/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.4.1",k=function(e,t){return new k.fn.init(e,t)},p=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function d(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},k.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t&&t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(p,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(d(Object(e))?k.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g.apply([],a)},guid:1,support:y}),"function"==typeof Symbol&&(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k="sizzle"+1*new Date,m=n.document,S=0,r=0,p=ue(),x=ue(),N=ue(),A=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",$=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",F=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp($),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+$),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ne=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(m.childNodes),m.childNodes),t[m.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&((e?e.ownerDocument||e:m)!==C&&T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!A[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&U.test(t)){(s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=k),o=(l=h(t)).length;while(o--)l[o]="#"+s+" "+xe(l[o]);c=l.join(","),f=ee.test(t)&&ye(e.parentNode)||e}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){A(t,!0)}finally{s===k&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[k]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:m;return r!==C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),m!==C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=k,!C.getElementsByName||!C.getElementsByName(k).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){a.appendChild(e).innerHTML="<a id='"+k+"'></a><select id='"+k+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+k+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+k+"+*").length||v.push(".#.+[+~]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",$)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e===C||e.ownerDocument===m&&y(m,e)?-1:t===C||t.ownerDocument===m&&y(m,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===C?-1:t===C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]===m?-1:s[r]===m?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if((e.ownerDocument||e)!==C&&T(e),d.matchesSelector&&E&&!A[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){A(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!==C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!==C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=p[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&p(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(F," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[S,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[S,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[k]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[k]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[S,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[k]||(e[k]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===S&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[k]&&(v=Ce(v)),y&&!y[k]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[k]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=N[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[k]?i.push(a):o.push(a);(a=N(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=S+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t===C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument===C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(S=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(S=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=k.split("").sort(D).join("")===k,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);k.find=h,k.expr=h.selectors,k.expr[":"]=k.expr.pseudos,k.uniqueSort=k.unique=h.uniqueSort,k.text=h.getText,k.isXMLDoc=h.isXML,k.contains=h.contains,k.escapeSelector=h.escape;var T=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&k(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},N=k.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var D=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?k.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?k.grep(e,function(e){return e===n!==r}):"string"!=typeof n?k.grep(e,function(e){return-1<i.call(n,e)!==r}):k.filter(n,e,r)}k.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?k.find.matchesSelector(r,e)?[r]:[]:k.find.matches(e,k.grep(t,function(e){return 1===e.nodeType}))},k.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(k(e).filter(function(){for(t=0;t<r;t++)if(k.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)k.find(e,i[t],n);return 1<r?k.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&N.test(e)?k(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(k.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:L.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof k?t[0]:t,k.merge(this,k.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),D.test(r[1])&&k.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(k):k.makeArray(e,this)}).prototype=k.fn,q=k(E);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}k.fn.extend({has:function(e){var t=k(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(k.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&k(e);if(!N.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&k.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?k.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(k(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(k.uniqueSort(k.merge(this.get(),k(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),k.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return T(e,"parentNode")},parentsUntil:function(e,t,n){return T(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return T(e,"nextSibling")},prevAll:function(e){return T(e,"previousSibling")},nextUntil:function(e,t,n){return T(e,"nextSibling",n)},prevUntil:function(e,t,n){return T(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return"undefined"!=typeof e.contentDocument?e.contentDocument:(A(e,"template")&&(e=e.content||e),k.merge([],e.childNodes))}},function(r,i){k.fn[r]=function(e,t){var n=k.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=k.filter(t,n)),1<this.length&&(O[r]||k.uniqueSort(n),H.test(r)&&n.reverse()),this.pushStack(n)}});var R=/[^\x20\t\r\n\f]+/g;function M(e){return e}function I(e){throw e}function W(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}k.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},k.each(e.match(R)||[],function(e,t){n[t]=!0}),n):k.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){k.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return k.each(arguments,function(e,t){var n;while(-1<(n=k.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<k.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},k.extend({Deferred:function(e){var o=[["notify","progress",k.Callbacks("memory"),k.Callbacks("memory"),2],["resolve","done",k.Callbacks("once memory"),k.Callbacks("once memory"),0,"resolved"],["reject","fail",k.Callbacks("once memory"),k.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return k.Deferred(function(r){k.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,M,s),l(u,o,I,s)):(u++,t.call(e,l(u,o,M,s),l(u,o,I,s),l(u,o,M,o.notifyWith))):(a!==M&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){k.Deferred.exceptionHook&&k.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==I&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(k.Deferred.getStackHook&&(t.stackTrace=k.Deferred.getStackHook()),C.setTimeout(t))}}return k.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:M,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:M)),o[2][3].add(l(0,e,m(n)?n:I))}).promise()},promise:function(e){return null!=e?k.extend(e,a):a}},s={};return k.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=k.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(W(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)W(i[t],a(t),o.reject);return o.promise()}});var $=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;k.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&$.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},k.readyException=function(e){C.setTimeout(function(){throw e})};var F=k.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),k.ready()}k.fn.ready=function(e){return F.then(e)["catch"](function(e){k.readyException(e)}),this},k.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--k.readyWait:k.isReady)||(k.isReady=!0)!==e&&0<--k.readyWait||F.resolveWith(E,[k])}}),k.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(k.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var _=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)_(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(k(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},z=/^-ms-/,U=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function V(e){return e.replace(z,"ms-").replace(U,X)}var G=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Y(){this.expando=k.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(e){var t=e[this.expando];return t||(t={},G(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[V(t)]=n;else for(r in t)i[V(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][V(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(V):(t=V(t))in r?[t]:t.match(R)||[]).length;while(n--)delete r[t[n]]}(void 0===t||k.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!k.isEmptyObject(t)}};var Q=new Y,J=new Y,K=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function ee(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Z,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:K.test(i)?JSON.parse(i):i)}catch(e){}J.set(e,t,n)}else n=void 0;return n}k.extend({hasData:function(e){return J.hasData(e)||Q.hasData(e)},data:function(e,t,n){return J.access(e,t,n)},removeData:function(e,t){J.remove(e,t)},_data:function(e,t,n){return Q.access(e,t,n)},_removeData:function(e,t){Q.remove(e,t)}}),k.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=J.get(o),1===o.nodeType&&!Q.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=V(r.slice(5)),ee(o,r,i[r]));Q.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){J.set(this,n)}):_(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=J.get(o,n))?t:void 0!==(t=ee(o,n))?t:void 0;this.each(function(){J.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){J.remove(this,e)})}}),k.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Q.get(e,t),n&&(!r||Array.isArray(n)?r=Q.access(e,t,k.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=k.queue(e,t),r=n.length,i=n.shift(),o=k._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){k.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Q.get(e,n)||Q.access(e,n,{empty:k.Callbacks("once memory").add(function(){Q.remove(e,[t+"queue",n])})})}}),k.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?k.queue(this[0],t):void 0===n?this:this.each(function(){var e=k.queue(this,t,n);k._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&k.dequeue(this,t)})},dequeue:function(e){return this.each(function(){k.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=k.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Q.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var te=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ne=new RegExp("^(?:([+-])=|)("+te+")([a-z%]*)$","i"),re=["Top","Right","Bottom","Left"],ie=E.documentElement,oe=function(e){return k.contains(e.ownerDocument,e)},ae={composed:!0};ie.getRootNode&&(oe=function(e){return k.contains(e.ownerDocument,e)||e.getRootNode(ae)===e.ownerDocument});var se=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&oe(e)&&"none"===k.css(e,"display")},ue=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function le(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return k.css(e,t,"")},u=s(),l=n&&n[3]||(k.cssNumber[t]?"":"px"),c=e.nodeType&&(k.cssNumber[t]||"px"!==l&&+u)&&ne.exec(k.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)k.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,k.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ce={};function fe(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Q.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&se(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ce[s])||(o=a.body.appendChild(a.createElement(s)),u=k.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ce[s]=u)))):"none"!==n&&(l[c]="none",Q.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}k.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){se(this)?k(this).show():k(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?k.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Q.set(e[n],"globalEval",!t||Q.get(t[n],"globalEval"))}ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;var me,xe,be=/<|&#?\w+;/;function we(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))k.merge(p,o.nodeType?[o]:o);else if(be.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+k.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;k.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<k.inArray(o,r))i&&i.push(o);else if(l=oe(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}me=E.createDocumentFragment().appendChild(E.createElement("div")),(xe=E.createElement("input")).setAttribute("type","radio"),xe.setAttribute("checked","checked"),xe.setAttribute("name","t"),me.appendChild(xe),y.checkClone=me.cloneNode(!0).cloneNode(!0).lastChild.checked,me.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!me.cloneNode(!0).lastChild.defaultValue;var Te=/^key/,Ce=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke(){return!0}function Se(){return!1}function Ne(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ae(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ae(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Se;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return k().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=k.guid++)),e.each(function(){k.event.add(this,t,i,r,n)})}function De(e,i,o){o?(Q.set(e,i,!1),k.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Q.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(k.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Q.set(this,i,r),t=o(this,i),this[i](),r!==(n=Q.get(this,i))||t?Q.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Q.set(this,i,{value:k.event.trigger(k.extend(r[0],k.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Q.get(e,i)&&k.event.add(e,i,ke)}k.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.get(t);if(v){n.handler&&(n=(o=n).handler,i=o.selector),i&&k.find.matchesSelector(ie,i),n.guid||(n.guid=k.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof k&&k.event.triggered!==e.type?k.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(R)||[""]).length;while(l--)d=g=(s=Ee.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=k.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=k.event.special[d]||{},c=k.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&k.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),k.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.hasData(e)&&Q.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(R)||[""]).length;while(l--)if(d=g=(s=Ee.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=k.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||k.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)k.event.remove(e,d+t[l],n,r,!0);k.isEmptyObject(u)&&Q.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=k.event.fix(e),u=new Array(arguments.length),l=(Q.get(this,"events")||{})[s.type]||[],c=k.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){a=k.event.handlers.call(this,s,l),t=0;while((i=a[t++])&&!s.isPropagationStopped()){s.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!s.isImmediatePropagationStopped())s.rnamespace&&!1!==o.namespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((k.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<k(i,this).index(l):k.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(k.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[k.expando]?e:new k.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click",ke),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Q.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},k.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},k.Event=function(e,t){if(!(this instanceof k.Event))return new k.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?ke:Se,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&k.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[k.expando]=!0},k.Event.prototype={constructor:k.Event,isDefaultPrevented:Se,isPropagationStopped:Se,isImmediatePropagationStopped:Se,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=ke,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=ke,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=ke,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},k.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Te.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ce.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},k.event.addProp),k.each({focus:"focusin",blur:"focusout"},function(e,t){k.event.special[e]={setup:function(){return De(this,e,Ne),!1},trigger:function(){return De(this,e),!0},delegateType:t}}),k.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){k.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||k.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),k.fn.extend({on:function(e,t,n,r){return Ae(this,e,t,n,r)},one:function(e,t,n,r){return Ae(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,k(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Se),this.each(function(){k.event.remove(this,e,n,t)})}});var je=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,qe=/<script|<style|<link/i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Oe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&k(e).children("tbody")[0]||e}function Pe(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Re(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Me(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Q.hasData(e)&&(o=Q.access(e),a=Q.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)k.event.add(t,i,l[i][n]);J.hasData(e)&&(s=J.access(e),u=k.extend({},s),J.set(t,u))}}function Ie(n,r,i,o){r=g.apply([],r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Le.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Ie(t,r,i,o)});if(f&&(t=(e=we(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=k.map(ve(e,"script"),Pe)).length;c<f;c++)u=e,c!==p&&(u=k.clone(u,!0,!0),s&&k.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,k.map(a,Re),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Q.access(u,"globalEval")&&k.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?k._evalUrl&&!u.noModule&&k._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")}):b(u.textContent.replace(He,""),u,l))}return n}function We(e,t,n){for(var r,i=t?k.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||k.cleanData(ve(r)),r.parentNode&&(n&&oe(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}k.extend({htmlPrefilter:function(e){return e.replace(je,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=oe(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||k.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Me(o[r],a[r]);else Me(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=k.event.special,o=0;void 0!==(n=e[o]);o++)if(G(n)){if(t=n[Q.expando]){if(t.events)for(r in t.events)i[r]?k.event.remove(n,r):k.removeEvent(n,r,t.handle);n[Q.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),k.fn.extend({detach:function(e){return We(this,e,!0)},remove:function(e){return We(this,e)},text:function(e){return _(this,function(e){return void 0===e?k.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Ie(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Oe(this,e).appendChild(e)})},prepend:function(){return Ie(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Oe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(k.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return k.clone(this,e,t)})},html:function(e){return _(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!qe.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=k.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(k.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Ie(this,arguments,function(e){var t=this.parentNode;k.inArray(this,n)<0&&(k.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),k.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){k.fn[e]=function(e){for(var t,n=[],r=k(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),k(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var $e=new RegExp("^("+te+")(?!px)[a-z%]+$","i"),Fe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Be=new RegExp(re.join("|"),"i");function _e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Fe(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||oe(e)||(a=k.style(e,t)),!y.pixelBoxStyles()&&$e.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function ze(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(u){s.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",ie.appendChild(s).appendChild(u);var e=C.getComputedStyle(u);n="1%"!==e.top,a=12===t(e.marginLeft),u.style.right="60%",o=36===t(e.right),r=36===t(e.width),u.style.position="absolute",i=12===t(u.offsetWidth/3),ie.removeChild(s),u=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s=E.createElement("div"),u=E.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,k.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),a},scrollboxSize:function(){return e(),i}}))}();var Ue=["Webkit","Moz","ms"],Xe=E.createElement("div").style,Ve={};function Ge(e){var t=k.cssProps[e]||Ve[e];return t||(e in Xe?e:Ve[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;while(n--)if((e=Ue[n]+t)in Xe)return e}(e)||e)}var Ye=/^(none|table(?!-c[ea]).+)/,Qe=/^--/,Je={position:"absolute",visibility:"hidden",display:"block"},Ke={letterSpacing:"0",fontWeight:"400"};function Ze(e,t,n){var r=ne.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function et(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=k.css(e,n+re[a],!0,i)),r?("content"===n&&(u-=k.css(e,"padding"+re[a],!0,i)),"margin"!==n&&(u-=k.css(e,"border"+re[a]+"Width",!0,i))):(u+=k.css(e,"padding"+re[a],!0,i),"padding"!==n?u+=k.css(e,"border"+re[a]+"Width",!0,i):s+=k.css(e,"border"+re[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function tt(e,t,n){var r=Fe(e),i=(!y.boxSizingReliable()||n)&&"border-box"===k.css(e,"boxSizing",!1,r),o=i,a=_e(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if($e.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||"auto"===a||!parseFloat(a)&&"inline"===k.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===k.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+et(e,t,n||(i?"border":"content"),o,r,a)+"px"}function nt(e,t,n,r,i){return new nt.prototype.init(e,t,n,r,i)}k.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=_e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=V(t),u=Qe.test(t),l=e.style;if(u||(t=Ge(s)),a=k.cssHooks[t]||k.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=ne.exec(n))&&i[1]&&(n=le(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(k.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=V(t);return Qe.test(t)||(t=Ge(s)),(a=k.cssHooks[t]||k.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=_e(e,t,r)),"normal"===i&&t in Ke&&(i=Ke[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),k.each(["height","width"],function(e,u){k.cssHooks[u]={get:function(e,t,n){if(t)return!Ye.test(k.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?tt(e,u,n):ue(e,Je,function(){return tt(e,u,n)})},set:function(e,t,n){var r,i=Fe(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===k.css(e,"boxSizing",!1,i),s=n?et(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-et(e,u,"border",!1,i)-.5)),s&&(r=ne.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=k.css(e,u)),Ze(0,t,s)}}}),k.cssHooks.marginLeft=ze(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(_e(e,"marginLeft"))||e.getBoundingClientRect().left-ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),k.each({margin:"",padding:"",border:"Width"},function(i,o){k.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+re[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(k.cssHooks[i+o].set=Ze)}),k.fn.extend({css:function(e,t){return _(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Fe(e),i=t.length;a<i;a++)o[t[a]]=k.css(e,t[a],!1,r);return o}return void 0!==n?k.style(e,t,n):k.css(e,t)},e,t,1<arguments.length)}}),((k.Tween=nt).prototype={constructor:nt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||k.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(k.cssNumber[n]?"":"px")},cur:function(){var e=nt.propHooks[this.prop];return e&&e.get?e.get(this):nt.propHooks._default.get(this)},run:function(e){var t,n=nt.propHooks[this.prop];return this.options.duration?this.pos=t=k.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):nt.propHooks._default.set(this),this}}).init.prototype=nt.prototype,(nt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=k.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){k.fx.step[e.prop]?k.fx.step[e.prop](e):1!==e.elem.nodeType||!k.cssHooks[e.prop]&&null==e.elem.style[Ge(e.prop)]?e.elem[e.prop]=e.now:k.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=nt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},k.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},k.fx=nt.prototype.init,k.fx.step={};var rt,it,ot,at,st=/^(?:toggle|show|hide)$/,ut=/queueHooks$/;function lt(){it&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(lt):C.setTimeout(lt,k.fx.interval),k.fx.tick())}function ct(){return C.setTimeout(function(){rt=void 0}),rt=Date.now()}function ft(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=re[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function pt(e,t,n){for(var r,i=(dt.tweeners[t]||[]).concat(dt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function dt(o,e,t){var n,a,r=0,i=dt.prefilters.length,s=k.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=rt||ct(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:k.extend({},e),opts:k.extend(!0,{specialEasing:{},easing:k.easing._default},t),originalProperties:e,originalOptions:t,startTime:rt||ct(),duration:t.duration,tweens:[],createTween:function(e,t){var n=k.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=V(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=k.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=dt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(k._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return k.map(c,pt,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),k.fx.timer(k.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}k.Animation=k.extend(dt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return le(n.elem,e,ne.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(R);for(var n,r=0,i=e.length;r<i;r++)n=e[r],dt.tweeners[n]=dt.tweeners[n]||[],dt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&se(e),v=Q.get(e,"fxshow");for(r in n.queue||(null==(a=k._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,k.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],st.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||k.style(e,r)}if((u=!k.isEmptyObject(t))||!k.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Q.get(e,"display")),"none"===(c=k.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=k.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===k.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Q.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&fe([e],!0),p.done(function(){for(r in g||fe([e]),Q.remove(e,"fxshow"),d)k.style(e,r,d[r])})),u=pt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?dt.prefilters.unshift(e):dt.prefilters.push(e)}}),k.speed=function(e,t,n){var r=e&&"object"==typeof e?k.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return k.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in k.fx.speeds?r.duration=k.fx.speeds[r.duration]:r.duration=k.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&k.dequeue(this,r.queue)},r},k.fn.extend({fadeTo:function(e,t,n,r){return this.filter(se).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=k.isEmptyObject(t),o=k.speed(e,n,r),a=function(){var e=dt(this,k.extend({},t),o);(i||Q.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&!1!==i&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=k.timers,r=Q.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&ut.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||k.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Q.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=k.timers,o=n?n.length:0;for(t.finish=!0,k.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),k.each(["toggle","show","hide"],function(e,r){var i=k.fn[r];k.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(ft(r,!0),e,t,n)}}),k.each({slideDown:ft("show"),slideUp:ft("hide"),slideToggle:ft("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){k.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),k.timers=[],k.fx.tick=function(){var e,t=0,n=k.timers;for(rt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||k.fx.stop(),rt=void 0},k.fx.timer=function(e){k.timers.push(e),k.fx.start()},k.fx.interval=13,k.fx.start=function(){it||(it=!0,lt())},k.fx.stop=function(){it=null},k.fx.speeds={slow:600,fast:200,_default:400},k.fn.delay=function(r,e){return r=k.fx&&k.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},ot=E.createElement("input"),at=E.createElement("select").appendChild(E.createElement("option")),ot.type="checkbox",y.checkOn=""!==ot.value,y.optSelected=at.selected,(ot=E.createElement("input")).value="t",ot.type="radio",y.radioValue="t"===ot.value;var ht,gt=k.expr.attrHandle;k.fn.extend({attr:function(e,t){return _(this,k.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){k.removeAttr(this,e)})}}),k.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?k.prop(e,t,n):(1===o&&k.isXMLDoc(e)||(i=k.attrHooks[t.toLowerCase()]||(k.expr.match.bool.test(t)?ht:void 0)),void 0!==n?null===n?void k.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=k.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(R);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ht={set:function(e,t,n){return!1===t?k.removeAttr(e,n):e.setAttribute(n,n),n}},k.each(k.expr.match.bool.source.match(/\w+/g),function(e,t){var a=gt[t]||k.find.attr;gt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=gt[o],gt[o]=r,r=null!=a(e,t,n)?o:null,gt[o]=i),r}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;function mt(e){return(e.match(R)||[]).join(" ")}function xt(e){return e.getAttribute&&e.getAttribute("class")||""}function bt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(R)||[]}k.fn.extend({prop:function(e,t){return _(this,k.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[k.propFix[e]||e]})}}),k.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&k.isXMLDoc(e)||(t=k.propFix[t]||t,i=k.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=k.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(k.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),k.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){k.propFix[this.toLowerCase()]=this}),k.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).addClass(t.call(this,e,xt(this)))});if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).removeClass(t.call(this,e,xt(this)))});if(!arguments.length)return this.attr("class","");if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){k(this).toggleClass(i.call(this,e,xt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=k(this),r=bt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=xt(this))&&Q.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Q.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+mt(xt(n))+" ").indexOf(t))return!0;return!1}});var wt=/\r/g;k.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,k(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=k.map(t,function(e){return null==e?"":e+""})),(r=k.valHooks[this.type]||k.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=k.valHooks[t.type]||k.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(wt,""):null==e?"":e:void 0}}),k.extend({valHooks:{option:{get:function(e){var t=k.find.attr(e,"value");return null!=t?t:mt(k.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=k(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=k.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<k.inArray(k.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),k.each(["radio","checkbox"],function(){k.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<k.inArray(k(e).val(),t)}},y.checkOn||(k.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var Tt=/^(?:focusinfocus|focusoutblur)$/,Ct=function(e){e.stopPropagation()};k.extend(k.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!Tt.test(d+k.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[k.expando]?e:new k.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:k.makeArray(t,[e]),c=k.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,Tt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Q.get(o,"events")||{})[e.type]&&Q.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&G(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!G(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),k.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Ct),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Ct),k.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=k.extend(new k.Event,n,{type:e,isSimulated:!0});k.event.trigger(r,null,t)}}),k.fn.extend({trigger:function(e,t){return this.each(function(){k.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return k.event.trigger(e,t,n,!0)}}),y.focusin||k.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){k.event.simulate(r,e.target,k.event.fix(e))};k.event.special[r]={setup:function(){var e=this.ownerDocument||this,t=Q.access(e,r);t||e.addEventListener(n,i,!0),Q.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this,t=Q.access(e,r)-1;t?Q.access(e,r,t):(e.removeEventListener(n,i,!0),Q.remove(e,r))}}});var Et=C.location,kt=Date.now(),St=/\?/;k.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||k.error("Invalid XML: "+e),t};var Nt=/\[\]$/,At=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;function qt(n,e,r,i){var t;if(Array.isArray(e))k.each(e,function(e,t){r||Nt.test(n)?i(n,t):qt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)qt(n+"["+t+"]",e[t],r,i)}k.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!k.isPlainObject(e))k.each(e,function(){i(this.name,this.value)});else for(n in e)qt(n,e[n],t,i);return r.join("&")},k.fn.extend({serialize:function(){return k.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=k.prop(this,"elements");return e?k.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!k(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=k(this).val();return null==n?null:Array.isArray(n)?k.map(n,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:n.replace(At,"\r\n")}}).get()}});var Lt=/%20/g,Ht=/#.*$/,Ot=/([?&])_=[^&]*/,Pt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Rt=/^(?:GET|HEAD)$/,Mt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Ft=E.createElement("a");function Bt(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(R)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function _t(t,i,o,a){var s={},u=t===Wt;function l(e){var r;return s[e]=!0,k.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function zt(e,t){var n,r,i=k.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&k.extend(!0,e,r),e}Ft.href=Et.href,k.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":k.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,k.ajaxSettings),t):zt(k.ajaxSettings,e)},ajaxPrefilter:Bt(It),ajaxTransport:Bt(Wt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=k.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?k(y):k.event,x=k.Deferred(),b=k.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Pt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace(Mt,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(R)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Ft.protocol+"//"+Ft.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=k.param(v.data,v.traditional)),_t(It,v,t,T),h)return T;for(i in(g=k.event&&v.global)&&0==k.active++&&k.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Rt.test(v.type),f=v.url.replace(Ht,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Lt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(St.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Ot,"$1"),o=(St.test(f)?"&":"?")+"_="+kt+++o),v.url=f+o),v.ifModified&&(k.lastModified[f]&&T.setRequestHeader("If-Modified-Since",k.lastModified[f]),k.etag[f]&&T.setRequestHeader("If-None-Match",k.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+$t+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=_t(Wt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(k.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(k.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--k.active||k.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return k.get(e,t,n,"json")},getScript:function(e,t){return k.get(e,void 0,t,"script")}}),k.each(["get","post"],function(e,i){k[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),k.ajax(k.extend({url:e,type:i,dataType:r,data:t,success:n},k.isPlainObject(e)&&e))}}),k._evalUrl=function(e,t){return k.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){k.globalEval(e,t)}})},k.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=k(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){k(this).wrapInner(n.call(this,e))}):this.each(function(){var e=k(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){k(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){k(this).replaceWith(this.childNodes)}),this}}),k.expr.pseudos.hidden=function(e){return!k.expr.pseudos.visible(e)},k.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},k.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Ut={0:200,1223:204},Xt=k.ajaxSettings.xhr();y.cors=!!Xt&&"withCredentials"in Xt,y.ajax=Xt=!!Xt,k.ajaxTransport(function(i){var o,a;if(y.cors||Xt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Ut[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),k.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),k.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return k.globalEval(e),e}}}),k.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),k.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=k("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Vt,Gt=[],Yt=/(=)\?(?=&|$)|\?\?/;k.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Gt.pop()||k.expando+"_"+kt++;return this[e]=!0,e}}),k.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Yt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Yt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Yt,"$1"+r):!1!==e.jsonp&&(e.url+=(St.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||k.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?k(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Gt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Vt=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Vt.childNodes.length),k.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=D.exec(e))?[t.createElement(i[1])]:(i=we([e],t,o),o&&o.length&&k(o).remove(),k.merge([],i.childNodes)));var r,i,o},k.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=mt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&k.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?k("<div>").append(k.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},k.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){k.fn[t]=function(e){return this.on(t,e)}}),k.expr.pseudos.animated=function(t){return k.grep(k.timers,function(e){return t===e.elem}).length},k.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=k.css(e,"position"),c=k(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=k.css(e,"top"),u=k.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,k.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},k.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){k.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===k.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===k.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=k(e).offset()).top+=k.css(e,"borderTopWidth",!0),i.left+=k.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-k.css(r,"marginTop",!0),left:t.left-i.left-k.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===k.css(e,"position"))e=e.offsetParent;return e||ie})}}),k.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;k.fn[t]=function(e){return _(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),k.each(["top","left"],function(e,n){k.cssHooks[n]=ze(y.pixelPosition,function(e,t){if(t)return t=_e(e,n),$e.test(t)?k(e).position()[n]+"px":t})}),k.each({Height:"height",Width:"width"},function(a,s){k.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){k.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return _(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?k.css(e,t,i):k.style(e,t,n,i)},s,n?e:void 0,n)}})}),k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){k.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}}),k.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),k.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),k.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||k.guid++,i},k.holdReady=function(e){e?k.readyWait++:k.ready(!0)},k.isArray=Array.isArray,k.parseJSON=JSON.parse,k.nodeName=A,k.isFunction=m,k.isWindow=x,k.camelCase=V,k.type=w,k.now=Date.now,k.isNumeric=function(e){var t=k.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return k});var Qt=C.jQuery,Jt=C.$;return k.noConflict=function(e){return C.$===k&&(C.$=Jt),e&&C.jQuery===k&&(C.jQuery=Qt),k},e||(C.jQuery=C.$=k),k});
/*!
* Bootstrap v4.3.1 (https://getbootstrap.com/)
* Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
*/
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("jquery")):"function"==typeof define&&define.amd?define(["exports","jquery"],e):e((t=t||self).bootstrap={},t.jQuery)}(this,function(t,p){"use strict";function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function s(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}function l(o){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},e=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(e=e.concat(Object.getOwnPropertySymbols(r).filter(function(t){return Object.getOwnPropertyDescriptor(r,t).enumerable}))),e.forEach(function(t){var e,n,i;e=o,i=r[n=t],n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i})}return o}p=p&&p.hasOwnProperty("default")?p.default:p;var e="transitionend";function n(t){var e=this,n=!1;return p(this).one(m.TRANSITION_END,function(){n=!0}),setTimeout(function(){n||m.triggerTransitionEnd(e)},t),this}var m={TRANSITION_END:"bsTransitionEnd",getUID:function(t){for(;t+=~~(1e6*Math.random()),document.getElementById(t););return t},getSelectorFromElement:function(t){var e=t.getAttribute("data-target");if(!e||"#"===e){var n=t.getAttribute("href");e=n&&"#"!==n?n.trim():""}try{return document.querySelector(e)?e:null}catch(t){return null}},getTransitionDurationFromElement:function(t){if(!t)return 0;var e=p(t).css("transition-duration"),n=p(t).css("transition-delay"),i=parseFloat(e),o=parseFloat(n);return i||o?(e=e.split(",")[0],n=n.split(",")[0],1e3*(parseFloat(e)+parseFloat(n))):0},reflow:function(t){return t.offsetHeight},triggerTransitionEnd:function(t){p(t).trigger(e)},supportsTransitionEnd:function(){return Boolean(e)},isElement:function(t){return(t[0]||t).nodeType},typeCheckConfig:function(t,e,n){for(var i in n)if(Object.prototype.hasOwnProperty.call(n,i)){var o=n[i],r=e[i],s=r&&m.isElement(r)?"element":(a=r,{}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase());if(!new RegExp(o).test(s))throw new Error(t.toUpperCase()+': Option "'+i+'" provided type "'+s+'" but expected type "'+o+'".')}var a},findShadowRoot:function(t){if(!document.documentElement.attachShadow)return null;if("function"!=typeof t.getRootNode)return t instanceof ShadowRoot?t:t.parentNode?m.findShadowRoot(t.parentNode):null;var e=t.getRootNode();return e instanceof ShadowRoot?e:null}};p.fn.emulateTransitionEnd=n,p.event.special[m.TRANSITION_END]={bindType:e,delegateType:e,handle:function(t){if(p(t.target).is(this))return t.handleObj.handler.apply(this,arguments)}};var o="alert",r="bs.alert",a="."+r,c=p.fn[o],h={CLOSE:"close"+a,CLOSED:"closed"+a,CLICK_DATA_API:"click"+a+".data-api"},u="alert",f="fade",d="show",g=function(){function i(t){this._element=t}var t=i.prototype;return t.close=function(t){var e=this._element;t&&(e=this._getRootElement(t)),this._triggerCloseEvent(e).isDefaultPrevented()||this._removeElement(e)},t.dispose=function(){p.removeData(this._element,r),this._element=null},t._getRootElement=function(t){var e=m.getSelectorFromElement(t),n=!1;return e&&(n=document.querySelector(e)),n||(n=p(t).closest("."+u)[0]),n},t._triggerCloseEvent=function(t){var e=p.Event(h.CLOSE);return p(t).trigger(e),e},t._removeElement=function(e){var n=this;if(p(e).removeClass(d),p(e).hasClass(f)){var t=m.getTransitionDurationFromElement(e);p(e).one(m.TRANSITION_END,function(t){return n._destroyElement(e,t)}).emulateTransitionEnd(t)}else this._destroyElement(e)},t._destroyElement=function(t){p(t).detach().trigger(h.CLOSED).remove()},i._jQueryInterface=function(n){return this.each(function(){var t=p(this),e=t.data(r);e||(e=new i(this),t.data(r,e)),"close"===n&&e[n](this)})},i._handleDismiss=function(e){return function(t){t&&t.preventDefault(),e.close(this)}},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}}]),i}();p(document).on(h.CLICK_DATA_API,'[data-dismiss="alert"]',g._handleDismiss(new g)),p.fn[o]=g._jQueryInterface,p.fn[o].Constructor=g,p.fn[o].noConflict=function(){return p.fn[o]=c,g._jQueryInterface};var _="button",v="bs.button",y="."+v,E=".data-api",b=p.fn[_],w="active",C="btn",T="focus",S='[data-toggle^="button"]',D='[data-toggle="buttons"]',I='input:not([type="hidden"])',A=".active",O=".btn",N={CLICK_DATA_API:"click"+y+E,FOCUS_BLUR_DATA_API:"focus"+y+E+" blur"+y+E},k=function(){function n(t){this._element=t}var t=n.prototype;return t.toggle=function(){var t=!0,e=!0,n=p(this._element).closest(D)[0];if(n){var i=this._element.querySelector(I);if(i){if("radio"===i.type)if(i.checked&&this._element.classList.contains(w))t=!1;else{var o=n.querySelector(A);o&&p(o).removeClass(w)}if(t){if(i.hasAttribute("disabled")||n.hasAttribute("disabled")||i.classList.contains("disabled")||n.classList.contains("disabled"))return;i.checked=!this._element.classList.contains(w),p(i).trigger("change")}i.focus(),e=!1}}e&&this._element.setAttribute("aria-pressed",!this._element.classList.contains(w)),t&&p(this._element).toggleClass(w)},t.dispose=function(){p.removeData(this._element,v),this._element=null},n._jQueryInterface=function(e){return this.each(function(){var t=p(this).data(v);t||(t=new n(this),p(this).data(v,t)),"toggle"===e&&t[e]()})},s(n,null,[{key:"VERSION",get:function(){return"4.3.1"}}]),n}();p(document).on(N.CLICK_DATA_API,S,function(t){t.preventDefault();var e=t.target;p(e).hasClass(C)||(e=p(e).closest(O)),k._jQueryInterface.call(p(e),"toggle")}).on(N.FOCUS_BLUR_DATA_API,S,function(t){var e=p(t.target).closest(O)[0];p(e).toggleClass(T,/^focus(in)?$/.test(t.type))}),p.fn[_]=k._jQueryInterface,p.fn[_].Constructor=k,p.fn[_].noConflict=function(){return p.fn[_]=b,k._jQueryInterface};var L="carousel",x="bs.carousel",P="."+x,H=".data-api",j=p.fn[L],R={interval:5e3,keyboard:!0,slide:!1,pause:"hover",wrap:!0,touch:!0},F={interval:"(number|boolean)",keyboard:"boolean",slide:"(boolean|string)",pause:"(string|boolean)",wrap:"boolean",touch:"boolean"},M="next",W="prev",U="left",B="right",q={SLIDE:"slide"+P,SLID:"slid"+P,KEYDOWN:"keydown"+P,MOUSEENTER:"mouseenter"+P,MOUSELEAVE:"mouseleave"+P,TOUCHSTART:"touchstart"+P,TOUCHMOVE:"touchmove"+P,TOUCHEND:"touchend"+P,POINTERDOWN:"pointerdown"+P,POINTERUP:"pointerup"+P,DRAG_START:"dragstart"+P,LOAD_DATA_API:"load"+P+H,CLICK_DATA_API:"click"+P+H},K="carousel",Q="active",V="slide",Y="carousel-item-right",z="carousel-item-left",X="carousel-item-next",G="carousel-item-prev",$="pointer-event",J=".active",Z=".active.carousel-item",tt=".carousel-item",et=".carousel-item img",nt=".carousel-item-next, .carousel-item-prev",it=".carousel-indicators",ot="[data-slide], [data-slide-to]",rt='[data-ride="carousel"]',st={TOUCH:"touch",PEN:"pen"},at=function(){function r(t,e){this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this.touchStartX=0,this.touchDeltaX=0,this._config=this._getConfig(e),this._element=t,this._indicatorsElement=this._element.querySelector(it),this._touchSupported="ontouchstart"in document.documentElement||0<navigator.maxTouchPoints,this._pointerEvent=Boolean(window.PointerEvent||window.MSPointerEvent),this._addEventListeners()}var t=r.prototype;return t.next=function(){this._isSliding||this._slide(M)},t.nextWhenVisible=function(){!document.hidden&&p(this._element).is(":visible")&&"hidden"!==p(this._element).css("visibility")&&this.next()},t.prev=function(){this._isSliding||this._slide(W)},t.pause=function(t){t||(this._isPaused=!0),this._element.querySelector(nt)&&(m.triggerTransitionEnd(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null},t.cycle=function(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config.interval&&!this._isPaused&&(this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))},t.to=function(t){var e=this;this._activeElement=this._element.querySelector(Z);var n=this._getItemIndex(this._activeElement);if(!(t>this._items.length-1||t<0))if(this._isSliding)p(this._element).one(q.SLID,function(){return e.to(t)});else{if(n===t)return this.pause(),void this.cycle();var i=n<t?M:W;this._slide(i,this._items[t])}},t.dispose=function(){p(this._element).off(P),p.removeData(this._element,x),this._items=null,this._config=null,this._element=null,this._interval=null,this._isPaused=null,this._isSliding=null,this._activeElement=null,this._indicatorsElement=null},t._getConfig=function(t){return t=l({},R,t),m.typeCheckConfig(L,t,F),t},t._handleSwipe=function(){var t=Math.abs(this.touchDeltaX);if(!(t<=40)){var e=t/this.touchDeltaX;0<e&&this.prev(),e<0&&this.next()}},t._addEventListeners=function(){var e=this;this._config.keyboard&&p(this._element).on(q.KEYDOWN,function(t){return e._keydown(t)}),"hover"===this._config.pause&&p(this._element).on(q.MOUSEENTER,function(t){return e.pause(t)}).on(q.MOUSELEAVE,function(t){return e.cycle(t)}),this._config.touch&&this._addTouchEventListeners()},t._addTouchEventListeners=function(){var n=this;if(this._touchSupported){var e=function(t){n._pointerEvent&&st[t.originalEvent.pointerType.toUpperCase()]?n.touchStartX=t.originalEvent.clientX:n._pointerEvent||(n.touchStartX=t.originalEvent.touches[0].clientX)},i=function(t){n._pointerEvent&&st[t.originalEvent.pointerType.toUpperCase()]&&(n.touchDeltaX=t.originalEvent.clientX-n.touchStartX),n._handleSwipe(),"hover"===n._config.pause&&(n.pause(),n.touchTimeout&&clearTimeout(n.touchTimeout),n.touchTimeout=setTimeout(function(t){return n.cycle(t)},500+n._config.interval))};p(this._element.querySelectorAll(et)).on(q.DRAG_START,function(t){return t.preventDefault()}),this._pointerEvent?(p(this._element).on(q.POINTERDOWN,function(t){return e(t)}),p(this._element).on(q.POINTERUP,function(t){return i(t)}),this._element.classList.add($)):(p(this._element).on(q.TOUCHSTART,function(t){return e(t)}),p(this._element).on(q.TOUCHMOVE,function(t){var e;(e=t).originalEvent.touches&&1<e.originalEvent.touches.length?n.touchDeltaX=0:n.touchDeltaX=e.originalEvent.touches[0].clientX-n.touchStartX}),p(this._element).on(q.TOUCHEND,function(t){return i(t)}))}},t._keydown=function(t){if(!/input|textarea/i.test(t.target.tagName))switch(t.which){case 37:t.preventDefault(),this.prev();break;case 39:t.preventDefault(),this.next()}},t._getItemIndex=function(t){return this._items=t&&t.parentNode?[].slice.call(t.parentNode.querySelectorAll(tt)):[],this._items.indexOf(t)},t._getItemByDirection=function(t,e){var n=t===M,i=t===W,o=this._getItemIndex(e),r=this._items.length-1;if((i&&0===o||n&&o===r)&&!this._config.wrap)return e;var s=(o+(t===W?-1:1))%this._items.length;return-1===s?this._items[this._items.length-1]:this._items[s]},t._triggerSlideEvent=function(t,e){var n=this._getItemIndex(t),i=this._getItemIndex(this._element.querySelector(Z)),o=p.Event(q.SLIDE,{relatedTarget:t,direction:e,from:i,to:n});return p(this._element).trigger(o),o},t._setActiveIndicatorElement=function(t){if(this._indicatorsElement){var e=[].slice.call(this._indicatorsElement.querySelectorAll(J));p(e).removeClass(Q);var n=this._indicatorsElement.children[this._getItemIndex(t)];n&&p(n).addClass(Q)}},t._slide=function(t,e){var n,i,o,r=this,s=this._element.querySelector(Z),a=this._getItemIndex(s),l=e||s&&this._getItemByDirection(t,s),c=this._getItemIndex(l),h=Boolean(this._interval);if(o=t===M?(n=z,i=X,U):(n=Y,i=G,B),l&&p(l).hasClass(Q))this._isSliding=!1;else if(!this._triggerSlideEvent(l,o).isDefaultPrevented()&&s&&l){this._isSliding=!0,h&&this.pause(),this._setActiveIndicatorElement(l);var u=p.Event(q.SLID,{relatedTarget:l,direction:o,from:a,to:c});if(p(this._element).hasClass(V)){p(l).addClass(i),m.reflow(l),p(s).addClass(n),p(l).addClass(n);var f=parseInt(l.getAttribute("data-interval"),10);this._config.interval=f?(this._config.defaultInterval=this._config.defaultInterval||this._config.interval,f):this._config.defaultInterval||this._config.interval;var d=m.getTransitionDurationFromElement(s);p(s).one(m.TRANSITION_END,function(){p(l).removeClass(n+" "+i).addClass(Q),p(s).removeClass(Q+" "+i+" "+n),r._isSliding=!1,setTimeout(function(){return p(r._element).trigger(u)},0)}).emulateTransitionEnd(d)}else p(s).removeClass(Q),p(l).addClass(Q),this._isSliding=!1,p(this._element).trigger(u);h&&this.cycle()}},r._jQueryInterface=function(i){return this.each(function(){var t=p(this).data(x),e=l({},R,p(this).data());"object"==typeof i&&(e=l({},e,i));var n="string"==typeof i?i:e.slide;if(t||(t=new r(this,e),p(this).data(x,t)),"number"==typeof i)t.to(i);else if("string"==typeof n){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}else e.interval&&e.ride&&(t.pause(),t.cycle())})},r._dataApiClickHandler=function(t){var e=m.getSelectorFromElement(this);if(e){var n=p(e)[0];if(n&&p(n).hasClass(K)){var i=l({},p(n).data(),p(this).data()),o=this.getAttribute("data-slide-to");o&&(i.interval=!1),r._jQueryInterface.call(p(n),i),o&&p(n).data(x).to(o),t.preventDefault()}}},s(r,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return R}}]),r}();p(document).on(q.CLICK_DATA_API,ot,at._dataApiClickHandler),p(window).on(q.LOAD_DATA_API,function(){for(var t=[].slice.call(document.querySelectorAll(rt)),e=0,n=t.length;e<n;e++){var i=p(t[e]);at._jQueryInterface.call(i,i.data())}}),p.fn[L]=at._jQueryInterface,p.fn[L].Constructor=at,p.fn[L].noConflict=function(){return p.fn[L]=j,at._jQueryInterface};var lt="collapse",ct="bs.collapse",ht="."+ct,ut=p.fn[lt],ft={toggle:!0,parent:""},dt={toggle:"boolean",parent:"(string|element)"},pt={SHOW:"show"+ht,SHOWN:"shown"+ht,HIDE:"hide"+ht,HIDDEN:"hidden"+ht,CLICK_DATA_API:"click"+ht+".data-api"},mt="show",gt="collapse",_t="collapsing",vt="collapsed",yt="width",Et="height",bt=".show, .collapsing",wt='[data-toggle="collapse"]',Ct=function(){function a(e,t){this._isTransitioning=!1,this._element=e,this._config=this._getConfig(t),this._triggerArray=[].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#'+e.id+'"],[data-toggle="collapse"][data-target="#'+e.id+'"]'));for(var n=[].slice.call(document.querySelectorAll(wt)),i=0,o=n.length;i<o;i++){var r=n[i],s=m.getSelectorFromElement(r),a=[].slice.call(document.querySelectorAll(s)).filter(function(t){return t===e});null!==s&&0<a.length&&(this._selector=s,this._triggerArray.push(r))}this._parent=this._config.parent?this._getParent():null,this._config.parent||this._addAriaAndCollapsedClass(this._element,this._triggerArray),this._config.toggle&&this.toggle()}var t=a.prototype;return t.toggle=function(){p(this._element).hasClass(mt)?this.hide():this.show()},t.show=function(){var t,e,n=this;if(!this._isTransitioning&&!p(this._element).hasClass(mt)&&(this._parent&&0===(t=[].slice.call(this._parent.querySelectorAll(bt)).filter(function(t){return"string"==typeof n._config.parent?t.getAttribute("data-parent")===n._config.parent:t.classList.contains(gt)})).length&&(t=null),!(t&&(e=p(t).not(this._selector).data(ct))&&e._isTransitioning))){var i=p.Event(pt.SHOW);if(p(this._element).trigger(i),!i.isDefaultPrevented()){t&&(a._jQueryInterface.call(p(t).not(this._selector),"hide"),e||p(t).data(ct,null));var o=this._getDimension();p(this._element).removeClass(gt).addClass(_t),this._element.style[o]=0,this._triggerArray.length&&p(this._triggerArray).removeClass(vt).attr("aria-expanded",!0),this.setTransitioning(!0);var r="scroll"+(o[0].toUpperCase()+o.slice(1)),s=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,function(){p(n._element).removeClass(_t).addClass(gt).addClass(mt),n._element.style[o]="",n.setTransitioning(!1),p(n._element).trigger(pt.SHOWN)}).emulateTransitionEnd(s),this._element.style[o]=this._element[r]+"px"}}},t.hide=function(){var t=this;if(!this._isTransitioning&&p(this._element).hasClass(mt)){var e=p.Event(pt.HIDE);if(p(this._element).trigger(e),!e.isDefaultPrevented()){var n=this._getDimension();this._element.style[n]=this._element.getBoundingClientRect()[n]+"px",m.reflow(this._element),p(this._element).addClass(_t).removeClass(gt).removeClass(mt);var i=this._triggerArray.length;if(0<i)for(var o=0;o<i;o++){var r=this._triggerArray[o],s=m.getSelectorFromElement(r);if(null!==s)p([].slice.call(document.querySelectorAll(s))).hasClass(mt)||p(r).addClass(vt).attr("aria-expanded",!1)}this.setTransitioning(!0);this._element.style[n]="";var a=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,function(){t.setTransitioning(!1),p(t._element).removeClass(_t).addClass(gt).trigger(pt.HIDDEN)}).emulateTransitionEnd(a)}}},t.setTransitioning=function(t){this._isTransitioning=t},t.dispose=function(){p.removeData(this._element,ct),this._config=null,this._parent=null,this._element=null,this._triggerArray=null,this._isTransitioning=null},t._getConfig=function(t){return(t=l({},ft,t)).toggle=Boolean(t.toggle),m.typeCheckConfig(lt,t,dt),t},t._getDimension=function(){return p(this._element).hasClass(yt)?yt:Et},t._getParent=function(){var t,n=this;m.isElement(this._config.parent)?(t=this._config.parent,"undefined"!=typeof this._config.parent.jquery&&(t=this._config.parent[0])):t=document.querySelector(this._config.parent);var e='[data-toggle="collapse"][data-parent="'+this._config.parent+'"]',i=[].slice.call(t.querySelectorAll(e));return p(i).each(function(t,e){n._addAriaAndCollapsedClass(a._getTargetFromElement(e),[e])}),t},t._addAriaAndCollapsedClass=function(t,e){var n=p(t).hasClass(mt);e.length&&p(e).toggleClass(vt,!n).attr("aria-expanded",n)},a._getTargetFromElement=function(t){var e=m.getSelectorFromElement(t);return e?document.querySelector(e):null},a._jQueryInterface=function(i){return this.each(function(){var t=p(this),e=t.data(ct),n=l({},ft,t.data(),"object"==typeof i&&i?i:{});if(!e&&n.toggle&&/show|hide/.test(i)&&(n.toggle=!1),e||(e=new a(this,n),t.data(ct,e)),"string"==typeof i){if("undefined"==typeof e[i])throw new TypeError('No method named "'+i+'"');e[i]()}})},s(a,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return ft}}]),a}();p(document).on(pt.CLICK_DATA_API,wt,function(t){"A"===t.currentTarget.tagName&&t.preventDefault();var n=p(this),e=m.getSelectorFromElement(this),i=[].slice.call(document.querySelectorAll(e));p(i).each(function(){var t=p(this),e=t.data(ct)?"toggle":n.data();Ct._jQueryInterface.call(t,e)})}),p.fn[lt]=Ct._jQueryInterface,p.fn[lt].Constructor=Ct,p.fn[lt].noConflict=function(){return p.fn[lt]=ut,Ct._jQueryInterface};for(var Tt="undefined"!=typeof window&&"undefined"!=typeof document,St=["Edge","Trident","Firefox"],Dt=0,It=0;It<St.length;It+=1)if(Tt&&0<=navigator.userAgent.indexOf(St[It])){Dt=1;break}var At=Tt&&window.Promise?function(t){var e=!1;return function(){e||(e=!0,window.Promise.resolve().then(function(){e=!1,t()}))}}:function(t){var e=!1;return function(){e||(e=!0,setTimeout(function(){e=!1,t()},Dt))}};function Ot(t){return t&&"[object Function]"==={}.toString.call(t)}function Nt(t,e){if(1!==t.nodeType)return[];var n=t.ownerDocument.defaultView.getComputedStyle(t,null);return e?n[e]:n}function kt(t){return"HTML"===t.nodeName?t:t.parentNode||t.host}function Lt(t){if(!t)return document.body;switch(t.nodeName){case"HTML":case"BODY":return t.ownerDocument.body;case"#document":return t.body}var e=Nt(t),n=e.overflow,i=e.overflowX,o=e.overflowY;return/(auto|scroll|overlay)/.test(n+o+i)?t:Lt(kt(t))}var xt=Tt&&!(!window.MSInputMethodContext||!document.documentMode),Pt=Tt&&/MSIE 10/.test(navigator.userAgent);function Ht(t){return 11===t?xt:10===t?Pt:xt||Pt}function jt(t){if(!t)return document.documentElement;for(var e=Ht(10)?document.body:null,n=t.offsetParent||null;n===e&&t.nextElementSibling;)n=(t=t.nextElementSibling).offsetParent;var i=n&&n.nodeName;return i&&"BODY"!==i&&"HTML"!==i?-1!==["TH","TD","TABLE"].indexOf(n.nodeName)&&"static"===Nt(n,"position")?jt(n):n:t?t.ownerDocument.documentElement:document.documentElement}function Rt(t){return null!==t.parentNode?Rt(t.parentNode):t}function Ft(t,e){if(!(t&&t.nodeType&&e&&e.nodeType))return document.documentElement;var n=t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_FOLLOWING,i=n?t:e,o=n?e:t,r=document.createRange();r.setStart(i,0),r.setEnd(o,0);var s,a,l=r.commonAncestorContainer;if(t!==l&&e!==l||i.contains(o))return"BODY"===(a=(s=l).nodeName)||"HTML"!==a&&jt(s.firstElementChild)!==s?jt(l):l;var c=Rt(t);return c.host?Ft(c.host,e):Ft(t,Rt(e).host)}function Mt(t){var e="top"===(1<arguments.length&&void 0!==arguments[1]?arguments[1]:"top")?"scrollTop":"scrollLeft",n=t.nodeName;if("BODY"!==n&&"HTML"!==n)return t[e];var i=t.ownerDocument.documentElement;return(t.ownerDocument.scrollingElement||i)[e]}function Wt(t,e){var n="x"===e?"Left":"Top",i="Left"===n?"Right":"Bottom";return parseFloat(t["border"+n+"Width"],10)+parseFloat(t["border"+i+"Width"],10)}function Ut(t,e,n,i){return Math.max(e["offset"+t],e["scroll"+t],n["client"+t],n["offset"+t],n["scroll"+t],Ht(10)?parseInt(n["offset"+t])+parseInt(i["margin"+("Height"===t?"Top":"Left")])+parseInt(i["margin"+("Height"===t?"Bottom":"Right")]):0)}function Bt(t){var e=t.body,n=t.documentElement,i=Ht(10)&&getComputedStyle(n);return{height:Ut("Height",e,n,i),width:Ut("Width",e,n,i)}}var qt=function(){function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}}(),Kt=function(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t},Qt=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t};function Vt(t){return Qt({},t,{right:t.left+t.width,bottom:t.top+t.height})}function Yt(t){var e={};try{if(Ht(10)){e=t.getBoundingClientRect();var n=Mt(t,"top"),i=Mt(t,"left");e.top+=n,e.left+=i,e.bottom+=n,e.right+=i}else e=t.getBoundingClientRect()}catch(t){}var o={left:e.left,top:e.top,width:e.right-e.left,height:e.bottom-e.top},r="HTML"===t.nodeName?Bt(t.ownerDocument):{},s=r.width||t.clientWidth||o.right-o.left,a=r.height||t.clientHeight||o.bottom-o.top,l=t.offsetWidth-s,c=t.offsetHeight-a;if(l||c){var h=Nt(t);l-=Wt(h,"x"),c-=Wt(h,"y"),o.width-=l,o.height-=c}return Vt(o)}function zt(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=Ht(10),o="HTML"===e.nodeName,r=Yt(t),s=Yt(e),a=Lt(t),l=Nt(e),c=parseFloat(l.borderTopWidth,10),h=parseFloat(l.borderLeftWidth,10);n&&o&&(s.top=Math.max(s.top,0),s.left=Math.max(s.left,0));var u=Vt({top:r.top-s.top-c,left:r.left-s.left-h,width:r.width,height:r.height});if(u.marginTop=0,u.marginLeft=0,!i&&o){var f=parseFloat(l.marginTop,10),d=parseFloat(l.marginLeft,10);u.top-=c-f,u.bottom-=c-f,u.left-=h-d,u.right-=h-d,u.marginTop=f,u.marginLeft=d}return(i&&!n?e.contains(a):e===a&&"BODY"!==a.nodeName)&&(u=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=Mt(e,"top"),o=Mt(e,"left"),r=n?-1:1;return t.top+=i*r,t.bottom+=i*r,t.left+=o*r,t.right+=o*r,t}(u,e)),u}function Xt(t){if(!t||!t.parentElement||Ht())return document.documentElement;for(var e=t.parentElement;e&&"none"===Nt(e,"transform");)e=e.parentElement;return e||document.documentElement}function Gt(t,e,n,i){var o=4<arguments.length&&void 0!==arguments[4]&&arguments[4],r={top:0,left:0},s=o?Xt(t):Ft(t,e);if("viewport"===i)r=function(t){var e=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n=t.ownerDocument.documentElement,i=zt(t,n),o=Math.max(n.clientWidth,window.innerWidth||0),r=Math.max(n.clientHeight,window.innerHeight||0),s=e?0:Mt(n),a=e?0:Mt(n,"left");return Vt({top:s-i.top+i.marginTop,left:a-i.left+i.marginLeft,width:o,height:r})}(s,o);else{var a=void 0;"scrollParent"===i?"BODY"===(a=Lt(kt(e))).nodeName&&(a=t.ownerDocument.documentElement):a="window"===i?t.ownerDocument.documentElement:i;var l=zt(a,s,o);if("HTML"!==a.nodeName||function t(e){var n=e.nodeName;if("BODY"===n||"HTML"===n)return!1;if("fixed"===Nt(e,"position"))return!0;var i=kt(e);return!!i&&t(i)}(s))r=l;else{var c=Bt(t.ownerDocument),h=c.height,u=c.width;r.top+=l.top-l.marginTop,r.bottom=h+l.top,r.left+=l.left-l.marginLeft,r.right=u+l.left}}var f="number"==typeof(n=n||0);return r.left+=f?n:n.left||0,r.top+=f?n:n.top||0,r.right-=f?n:n.right||0,r.bottom-=f?n:n.bottom||0,r}function $t(t,e,i,n,o){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===t.indexOf("auto"))return t;var s=Gt(i,n,r,o),a={top:{width:s.width,height:e.top-s.top},right:{width:s.right-e.right,height:s.height},bottom:{width:s.width,height:s.bottom-e.bottom},left:{width:e.left-s.left,height:s.height}},l=Object.keys(a).map(function(t){return Qt({key:t},a[t],{area:(e=a[t],e.width*e.height)});var e}).sort(function(t,e){return e.area-t.area}),c=l.filter(function(t){var e=t.width,n=t.height;return e>=i.clientWidth&&n>=i.clientHeight}),h=0<c.length?c[0].key:l[0].key,u=t.split("-")[1];return h+(u?"-"+u:"")}function Jt(t,e,n){var i=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return zt(n,i?Xt(e):Ft(e,n),i)}function Zt(t){var e=t.ownerDocument.defaultView.getComputedStyle(t),n=parseFloat(e.marginTop||0)+parseFloat(e.marginBottom||0),i=parseFloat(e.marginLeft||0)+parseFloat(e.marginRight||0);return{width:t.offsetWidth+i,height:t.offsetHeight+n}}function te(t){var e={left:"right",right:"left",bottom:"top",top:"bottom"};return t.replace(/left|right|bottom|top/g,function(t){return e[t]})}function ee(t,e,n){n=n.split("-")[0];var i=Zt(t),o={width:i.width,height:i.height},r=-1!==["right","left"].indexOf(n),s=r?"top":"left",a=r?"left":"top",l=r?"height":"width",c=r?"width":"height";return o[s]=e[s]+e[l]/2-i[l]/2,o[a]=n===a?e[a]-i[c]:e[te(a)],o}function ne(t,e){return Array.prototype.find?t.find(e):t.filter(e)[0]}function ie(t,n,e){return(void 0===e?t:t.slice(0,function(t,e,n){if(Array.prototype.findIndex)return t.findIndex(function(t){return t[e]===n});var i=ne(t,function(t){return t[e]===n});return t.indexOf(i)}(t,"name",e))).forEach(function(t){t.function&&console.warn("`modifier.function` is deprecated, use `modifier.fn`!");var e=t.function||t.fn;t.enabled&&Ot(e)&&(n.offsets.popper=Vt(n.offsets.popper),n.offsets.reference=Vt(n.offsets.reference),n=e(n,t))}),n}function oe(t,n){return t.some(function(t){var e=t.name;return t.enabled&&e===n})}function re(t){for(var e=[!1,"ms","Webkit","Moz","O"],n=t.charAt(0).toUpperCase()+t.slice(1),i=0;i<e.length;i++){var o=e[i],r=o?""+o+n:t;if("undefined"!=typeof document.body.style[r])return r}return null}function se(t){var e=t.ownerDocument;return e?e.defaultView:window}function ae(t,e,n,i){n.updateBound=i,se(t).addEventListener("resize",n.updateBound,{passive:!0});var o=Lt(t);return function t(e,n,i,o){var r="BODY"===e.nodeName,s=r?e.ownerDocument.defaultView:e;s.addEventListener(n,i,{passive:!0}),r||t(Lt(s.parentNode),n,i,o),o.push(s)}(o,"scroll",n.updateBound,n.scrollParents),n.scrollElement=o,n.eventsEnabled=!0,n}function le(){var t,e;this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=(t=this.reference,e=this.state,se(t).removeEventListener("resize",e.updateBound),e.scrollParents.forEach(function(t){t.removeEventListener("scroll",e.updateBound)}),e.updateBound=null,e.scrollParents=[],e.scrollElement=null,e.eventsEnabled=!1,e))}function ce(t){return""!==t&&!isNaN(parseFloat(t))&&isFinite(t)}function he(n,i){Object.keys(i).forEach(function(t){var e="";-1!==["width","height","top","right","bottom","left"].indexOf(t)&&ce(i[t])&&(e="px"),n.style[t]=i[t]+e})}var ue=Tt&&/Firefox/i.test(navigator.userAgent);function fe(t,e,n){var i=ne(t,function(t){return t.name===e}),o=!!i&&t.some(function(t){return t.name===n&&t.enabled&&t.order<i.order});if(!o){var r="`"+e+"`",s="`"+n+"`";console.warn(s+" modifier is required by "+r+" modifier in order to work, be sure to include it before "+r+"!")}return o}var de=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],pe=de.slice(3);function me(t){var e=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n=pe.indexOf(t),i=pe.slice(n+1).concat(pe.slice(0,n));return e?i.reverse():i}var ge="flip",_e="clockwise",ve="counterclockwise";function ye(t,o,r,e){var s=[0,0],a=-1!==["right","left"].indexOf(e),n=t.split(/(\+|\-)/).map(function(t){return t.trim()}),i=n.indexOf(ne(n,function(t){return-1!==t.search(/,|\s/)}));n[i]&&-1===n[i].indexOf(",")&&console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");var l=/\s*,\s*|\s+/,c=-1!==i?[n.slice(0,i).concat([n[i].split(l)[0]]),[n[i].split(l)[1]].concat(n.slice(i+1))]:[n];return(c=c.map(function(t,e){var n=(1===e?!a:a)?"height":"width",i=!1;return t.reduce(function(t,e){return""===t[t.length-1]&&-1!==["+","-"].indexOf(e)?(t[t.length-1]=e,i=!0,t):i?(t[t.length-1]+=e,i=!1,t):t.concat(e)},[]).map(function(t){return function(t,e,n,i){var o=t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+o[1],s=o[2];if(!r)return t;if(0!==s.indexOf("%"))return"vh"!==s&&"vw"!==s?r:("vh"===s?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0))/100*r;var a=void 0;switch(s){case"%p":a=n;break;case"%":case"%r":default:a=i}return Vt(a)[e]/100*r}(t,n,o,r)})})).forEach(function(n,i){n.forEach(function(t,e){ce(t)&&(s[i]+=t*("-"===n[e-1]?-1:1))})}),s}var Ee={placement:"bottom",positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(t){var e=t.placement,n=e.split("-")[0],i=e.split("-")[1];if(i){var o=t.offsets,r=o.reference,s=o.popper,a=-1!==["bottom","top"].indexOf(n),l=a?"left":"top",c=a?"width":"height",h={start:Kt({},l,r[l]),end:Kt({},l,r[l]+r[c]-s[c])};t.offsets.popper=Qt({},s,h[i])}return t}},offset:{order:200,enabled:!0,fn:function(t,e){var n=e.offset,i=t.placement,o=t.offsets,r=o.popper,s=o.reference,a=i.split("-")[0],l=void 0;return l=ce(+n)?[+n,0]:ye(n,r,s,a),"left"===a?(r.top+=l[0],r.left-=l[1]):"right"===a?(r.top+=l[0],r.left+=l[1]):"top"===a?(r.left+=l[0],r.top-=l[1]):"bottom"===a&&(r.left+=l[0],r.top+=l[1]),t.popper=r,t},offset:0},preventOverflow:{order:300,enabled:!0,fn:function(t,i){var e=i.boundariesElement||jt(t.instance.popper);t.instance.reference===e&&(e=jt(e));var n=re("transform"),o=t.instance.popper.style,r=o.top,s=o.left,a=o[n];o.top="",o.left="",o[n]="";var l=Gt(t.instance.popper,t.instance.reference,i.padding,e,t.positionFixed);o.top=r,o.left=s,o[n]=a,i.boundaries=l;var c=i.priority,h=t.offsets.popper,u={primary:function(t){var e=h[t];return h[t]<l[t]&&!i.escapeWithReference&&(e=Math.max(h[t],l[t])),Kt({},t,e)},secondary:function(t){var e="right"===t?"left":"top",n=h[e];return h[t]>l[t]&&!i.escapeWithReference&&(n=Math.min(h[e],l[t]-("right"===t?h.width:h.height))),Kt({},e,n)}};return c.forEach(function(t){var e=-1!==["left","top"].indexOf(t)?"primary":"secondary";h=Qt({},h,u[e](t))}),t.offsets.popper=h,t},priority:["left","right","top","bottom"],padding:5,boundariesElement:"scrollParent"},keepTogether:{order:400,enabled:!0,fn:function(t){var e=t.offsets,n=e.popper,i=e.reference,o=t.placement.split("-")[0],r=Math.floor,s=-1!==["top","bottom"].indexOf(o),a=s?"right":"bottom",l=s?"left":"top",c=s?"width":"height";return n[a]<r(i[l])&&(t.offsets.popper[l]=r(i[l])-n[c]),n[l]>r(i[a])&&(t.offsets.popper[l]=r(i[a])),t}},arrow:{order:500,enabled:!0,fn:function(t,e){var n;if(!fe(t.instance.modifiers,"arrow","keepTogether"))return t;var i=e.element;if("string"==typeof i){if(!(i=t.instance.popper.querySelector(i)))return t}else if(!t.instance.popper.contains(i))return console.warn("WARNING: `arrow.element` must be child of its popper element!"),t;var o=t.placement.split("-")[0],r=t.offsets,s=r.popper,a=r.reference,l=-1!==["left","right"].indexOf(o),c=l?"height":"width",h=l?"Top":"Left",u=h.toLowerCase(),f=l?"left":"top",d=l?"bottom":"right",p=Zt(i)[c];a[d]-p<s[u]&&(t.offsets.popper[u]-=s[u]-(a[d]-p)),a[u]+p>s[d]&&(t.offsets.popper[u]+=a[u]+p-s[d]),t.offsets.popper=Vt(t.offsets.popper);var m=a[u]+a[c]/2-p/2,g=Nt(t.instance.popper),_=parseFloat(g["margin"+h],10),v=parseFloat(g["border"+h+"Width"],10),y=m-t.offsets.popper[u]-_-v;return y=Math.max(Math.min(s[c]-p,y),0),t.arrowElement=i,t.offsets.arrow=(Kt(n={},u,Math.round(y)),Kt(n,f,""),n),t},element:"[x-arrow]"},flip:{order:600,enabled:!0,fn:function(p,m){if(oe(p.instance.modifiers,"inner"))return p;if(p.flipped&&p.placement===p.originalPlacement)return p;var g=Gt(p.instance.popper,p.instance.reference,m.padding,m.boundariesElement,p.positionFixed),_=p.placement.split("-")[0],v=te(_),y=p.placement.split("-")[1]||"",E=[];switch(m.behavior){case ge:E=[_,v];break;case _e:E=me(_);break;case ve:E=me(_,!0);break;default:E=m.behavior}return E.forEach(function(t,e){if(_!==t||E.length===e+1)return p;_=p.placement.split("-")[0],v=te(_);var n,i=p.offsets.popper,o=p.offsets.reference,r=Math.floor,s="left"===_&&r(i.right)>r(o.left)||"right"===_&&r(i.left)<r(o.right)||"top"===_&&r(i.bottom)>r(o.top)||"bottom"===_&&r(i.top)<r(o.bottom),a=r(i.left)<r(g.left),l=r(i.right)>r(g.right),c=r(i.top)<r(g.top),h=r(i.bottom)>r(g.bottom),u="left"===_&&a||"right"===_&&l||"top"===_&&c||"bottom"===_&&h,f=-1!==["top","bottom"].indexOf(_),d=!!m.flipVariations&&(f&&"start"===y&&a||f&&"end"===y&&l||!f&&"start"===y&&c||!f&&"end"===y&&h);(s||u||d)&&(p.flipped=!0,(s||u)&&(_=E[e+1]),d&&(y="end"===(n=y)?"start":"start"===n?"end":n),p.placement=_+(y?"-"+y:""),p.offsets.popper=Qt({},p.offsets.popper,ee(p.instance.popper,p.offsets.reference,p.placement)),p=ie(p.instance.modifiers,p,"flip"))}),p},behavior:"flip",padding:5,boundariesElement:"viewport"},inner:{order:700,enabled:!1,fn:function(t){var e=t.placement,n=e.split("-")[0],i=t.offsets,o=i.popper,r=i.reference,s=-1!==["left","right"].indexOf(n),a=-1===["top","left"].indexOf(n);return o[s?"left":"top"]=r[n]-(a?o[s?"width":"height"]:0),t.placement=te(e),t.offsets.popper=Vt(o),t}},hide:{order:800,enabled:!0,fn:function(t){if(!fe(t.instance.modifiers,"hide","preventOverflow"))return t;var e=t.offsets.reference,n=ne(t.instance.modifiers,function(t){return"preventOverflow"===t.name}).boundaries;if(e.bottom<n.top||e.left>n.right||e.top>n.bottom||e.right<n.left){if(!0===t.hide)return t;t.hide=!0,t.attributes["x-out-of-boundaries"]=""}else{if(!1===t.hide)return t;t.hide=!1,t.attributes["x-out-of-boundaries"]=!1}return t}},computeStyle:{order:850,enabled:!0,fn:function(t,e){var n=e.x,i=e.y,o=t.offsets.popper,r=ne(t.instance.modifiers,function(t){return"applyStyle"===t.name}).gpuAcceleration;void 0!==r&&console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");var s,a,l,c,h,u,f,d,p,m,g,_,v,y,E=void 0!==r?r:e.gpuAcceleration,b=jt(t.instance.popper),w=Yt(b),C={position:o.position},T=(s=t,a=window.devicePixelRatio<2||!ue,l=s.offsets,c=l.popper,h=l.reference,u=Math.round,f=Math.floor,d=function(t){return t},p=u(h.width),m=u(c.width),g=-1!==["left","right"].indexOf(s.placement),_=-1!==s.placement.indexOf("-"),y=a?u:d,{left:(v=a?g||_||p%2==m%2?u:f:d)(p%2==1&&m%2==1&&!_&&a?c.left-1:c.left),top:y(c.top),bottom:y(c.bottom),right:v(c.right)}),S="bottom"===n?"top":"bottom",D="right"===i?"left":"right",I=re("transform"),A=void 0,O=void 0;if(O="bottom"===S?"HTML"===b.nodeName?-b.clientHeight+T.bottom:-w.height+T.bottom:T.top,A="right"===D?"HTML"===b.nodeName?-b.clientWidth+T.right:-w.width+T.right:T.left,E&&I)C[I]="translate3d("+A+"px, "+O+"px, 0)",C[S]=0,C[D]=0,C.willChange="transform";else{var N="bottom"===S?-1:1,k="right"===D?-1:1;C[S]=O*N,C[D]=A*k,C.willChange=S+", "+D}var L={"x-placement":t.placement};return t.attributes=Qt({},L,t.attributes),t.styles=Qt({},C,t.styles),t.arrowStyles=Qt({},t.offsets.arrow,t.arrowStyles),t},gpuAcceleration:!0,x:"bottom",y:"right"},applyStyle:{order:900,enabled:!0,fn:function(t){var e,n;return he(t.instance.popper,t.styles),e=t.instance.popper,n=t.attributes,Object.keys(n).forEach(function(t){!1!==n[t]?e.setAttribute(t,n[t]):e.removeAttribute(t)}),t.arrowElement&&Object.keys(t.arrowStyles).length&&he(t.arrowElement,t.arrowStyles),t},onLoad:function(t,e,n,i,o){var r=Jt(o,e,t,n.positionFixed),s=$t(n.placement,r,e,t,n.modifiers.flip.boundariesElement,n.modifiers.flip.padding);return e.setAttribute("x-placement",s),he(e,{position:n.positionFixed?"fixed":"absolute"}),n},gpuAcceleration:void 0}}},be=function(){function r(t,e){var n=this,i=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,r),this.scheduleUpdate=function(){return requestAnimationFrame(n.update)},this.update=At(this.update.bind(this)),this.options=Qt({},r.Defaults,i),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=t&&t.jquery?t[0]:t,this.popper=e&&e.jquery?e[0]:e,this.options.modifiers={},Object.keys(Qt({},r.Defaults.modifiers,i.modifiers)).forEach(function(t){n.options.modifiers[t]=Qt({},r.Defaults.modifiers[t]||{},i.modifiers?i.modifiers[t]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(t){return Qt({name:t},n.options.modifiers[t])}).sort(function(t,e){return t.order-e.order}),this.modifiers.forEach(function(t){t.enabled&&Ot(t.onLoad)&&t.onLoad(n.reference,n.popper,n.options,t,n.state)}),this.update();var o=this.options.eventsEnabled;o&&this.enableEventListeners(),this.state.eventsEnabled=o}return qt(r,[{key:"update",value:function(){return function(){if(!this.state.isDestroyed){var t={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};t.offsets.reference=Jt(this.state,this.popper,this.reference,this.options.positionFixed),t.placement=$t(this.options.placement,t.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),t.originalPlacement=t.placement,t.positionFixed=this.options.positionFixed,t.offsets.popper=ee(this.popper,t.offsets.reference,t.placement),t.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",t=ie(this.modifiers,t),this.state.isCreated?this.options.onUpdate(t):(this.state.isCreated=!0,this.options.onCreate(t))}}.call(this)}},{key:"destroy",value:function(){return function(){return this.state.isDestroyed=!0,oe(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[re("transform")]=""),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}.call(this)}},{key:"enableEventListeners",value:function(){return function(){this.state.eventsEnabled||(this.state=ae(this.reference,this.options,this.state,this.scheduleUpdate))}.call(this)}},{key:"disableEventListeners",value:function(){return le.call(this)}}]),r}();be.Utils=("undefined"!=typeof window?window:global).PopperUtils,be.placements=de,be.Defaults=Ee;var we="dropdown",Ce="bs.dropdown",Te="."+Ce,Se=".data-api",De=p.fn[we],Ie=new RegExp("38|40|27"),Ae={HIDE:"hide"+Te,HIDDEN:"hidden"+Te,SHOW:"show"+Te,SHOWN:"shown"+Te,CLICK:"click"+Te,CLICK_DATA_API:"click"+Te+Se,KEYDOWN_DATA_API:"keydown"+Te+Se,KEYUP_DATA_API:"keyup"+Te+Se},Oe="disabled",Ne="show",ke="dropup",Le="dropright",xe="dropleft",Pe="dropdown-menu-right",He="position-static",je='[data-toggle="dropdown"]',Re=".dropdown form",Fe=".dropdown-menu",Me=".navbar-nav",We=".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",Ue="top-start",Be="top-end",qe="bottom-start",Ke="bottom-end",Qe="right-start",Ve="left-start",Ye={offset:0,flip:!0,boundary:"scrollParent",reference:"toggle",display:"dynamic"},ze={offset:"(number|string|function)",flip:"boolean",boundary:"(string|element)",reference:"(string|element)",display:"string"},Xe=function(){function c(t,e){this._element=t,this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._addEventListeners()}var t=c.prototype;return t.toggle=function(){if(!this._element.disabled&&!p(this._element).hasClass(Oe)){var t=c._getParentFromElement(this._element),e=p(this._menu).hasClass(Ne);if(c._clearMenus(),!e){var n={relatedTarget:this._element},i=p.Event(Ae.SHOW,n);if(p(t).trigger(i),!i.isDefaultPrevented()){if(!this._inNavbar){if("undefined"==typeof be)throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");var o=this._element;"parent"===this._config.reference?o=t:m.isElement(this._config.reference)&&(o=this._config.reference,"undefined"!=typeof this._config.reference.jquery&&(o=this._config.reference[0])),"scrollParent"!==this._config.boundary&&p(t).addClass(He),this._popper=new be(o,this._menu,this._getPopperConfig())}"ontouchstart"in document.documentElement&&0===p(t).closest(Me).length&&p(document.body).children().on("mouseover",null,p.noop),this._element.focus(),this._element.setAttribute("aria-expanded",!0),p(this._menu).toggleClass(Ne),p(t).toggleClass(Ne).trigger(p.Event(Ae.SHOWN,n))}}}},t.show=function(){if(!(this._element.disabled||p(this._element).hasClass(Oe)||p(this._menu).hasClass(Ne))){var t={relatedTarget:this._element},e=p.Event(Ae.SHOW,t),n=c._getParentFromElement(this._element);p(n).trigger(e),e.isDefaultPrevented()||(p(this._menu).toggleClass(Ne),p(n).toggleClass(Ne).trigger(p.Event(Ae.SHOWN,t)))}},t.hide=function(){if(!this._element.disabled&&!p(this._element).hasClass(Oe)&&p(this._menu).hasClass(Ne)){var t={relatedTarget:this._element},e=p.Event(Ae.HIDE,t),n=c._getParentFromElement(this._element);p(n).trigger(e),e.isDefaultPrevented()||(p(this._menu).toggleClass(Ne),p(n).toggleClass(Ne).trigger(p.Event(Ae.HIDDEN,t)))}},t.dispose=function(){p.removeData(this._element,Ce),p(this._element).off(Te),this._element=null,(this._menu=null)!==this._popper&&(this._popper.destroy(),this._popper=null)},t.update=function(){this._inNavbar=this._detectNavbar(),null!==this._popper&&this._popper.scheduleUpdate()},t._addEventListeners=function(){var e=this;p(this._element).on(Ae.CLICK,function(t){t.preventDefault(),t.stopPropagation(),e.toggle()})},t._getConfig=function(t){return t=l({},this.constructor.Default,p(this._element).data(),t),m.typeCheckConfig(we,t,this.constructor.DefaultType),t},t._getMenuElement=function(){if(!this._menu){var t=c._getParentFromElement(this._element);t&&(this._menu=t.querySelector(Fe))}return this._menu},t._getPlacement=function(){var t=p(this._element.parentNode),e=qe;return t.hasClass(ke)?(e=Ue,p(this._menu).hasClass(Pe)&&(e=Be)):t.hasClass(Le)?e=Qe:t.hasClass(xe)?e=Ve:p(this._menu).hasClass(Pe)&&(e=Ke),e},t._detectNavbar=function(){return 0<p(this._element).closest(".navbar").length},t._getOffset=function(){var e=this,t={};return"function"==typeof this._config.offset?t.fn=function(t){return t.offsets=l({},t.offsets,e._config.offset(t.offsets,e._element)||{}),t}:t.offset=this._config.offset,t},t._getPopperConfig=function(){var t={placement:this._getPlacement(),modifiers:{offset:this._getOffset(),flip:{enabled:this._config.flip},preventOverflow:{boundariesElement:this._config.boundary}}};return"static"===this._config.display&&(t.modifiers.applyStyle={enabled:!1}),t},c._jQueryInterface=function(e){return this.each(function(){var t=p(this).data(Ce);if(t||(t=new c(this,"object"==typeof e?e:null),p(this).data(Ce,t)),"string"==typeof e){if("undefined"==typeof t[e])throw new TypeError('No method named "'+e+'"');t[e]()}})},c._clearMenus=function(t){if(!t||3!==t.which&&("keyup"!==t.type||9===t.which))for(var e=[].slice.call(document.querySelectorAll(je)),n=0,i=e.length;n<i;n++){var o=c._getParentFromElement(e[n]),r=p(e[n]).data(Ce),s={relatedTarget:e[n]};if(t&&"click"===t.type&&(s.clickEvent=t),r){var a=r._menu;if(p(o).hasClass(Ne)&&!(t&&("click"===t.type&&/input|textarea/i.test(t.target.tagName)||"keyup"===t.type&&9===t.which)&&p.contains(o,t.target))){var l=p.Event(Ae.HIDE,s);p(o).trigger(l),l.isDefaultPrevented()||("ontouchstart"in document.documentElement&&p(document.body).children().off("mouseover",null,p.noop),e[n].setAttribute("aria-expanded","false"),p(a).removeClass(Ne),p(o).removeClass(Ne).trigger(p.Event(Ae.HIDDEN,s)))}}}},c._getParentFromElement=function(t){var e,n=m.getSelectorFromElement(t);return n&&(e=document.querySelector(n)),e||t.parentNode},c._dataApiKeydownHandler=function(t){if((/input|textarea/i.test(t.target.tagName)?!(32===t.which||27!==t.which&&(40!==t.which&&38!==t.which||p(t.target).closest(Fe).length)):Ie.test(t.which))&&(t.preventDefault(),t.stopPropagation(),!this.disabled&&!p(this).hasClass(Oe))){var e=c._getParentFromElement(this),n=p(e).hasClass(Ne);if(n&&(!n||27!==t.which&&32!==t.which)){var i=[].slice.call(e.querySelectorAll(We));if(0!==i.length){var o=i.indexOf(t.target);38===t.which&&0<o&&o--,40===t.which&&o<i.length-1&&o++,o<0&&(o=0),i[o].focus()}}else{if(27===t.which){var r=e.querySelector(je);p(r).trigger("focus")}p(this).trigger("click")}}},s(c,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return Ye}},{key:"DefaultType",get:function(){return ze}}]),c}();p(document).on(Ae.KEYDOWN_DATA_API,je,Xe._dataApiKeydownHandler).on(Ae.KEYDOWN_DATA_API,Fe,Xe._dataApiKeydownHandler).on(Ae.CLICK_DATA_API+" "+Ae.KEYUP_DATA_API,Xe._clearMenus).on(Ae.CLICK_DATA_API,je,function(t){t.preventDefault(),t.stopPropagation(),Xe._jQueryInterface.call(p(this),"toggle")}).on(Ae.CLICK_DATA_API,Re,function(t){t.stopPropagation()}),p.fn[we]=Xe._jQueryInterface,p.fn[we].Constructor=Xe,p.fn[we].noConflict=function(){return p.fn[we]=De,Xe._jQueryInterface};var Ge="modal",$e="bs.modal",Je="."+$e,Ze=p.fn[Ge],tn={backdrop:!0,keyboard:!0,focus:!0,show:!0},en={backdrop:"(boolean|string)",keyboard:"boolean",focus:"boolean",show:"boolean"},nn={HIDE:"hide"+Je,HIDDEN:"hidden"+Je,SHOW:"show"+Je,SHOWN:"shown"+Je,FOCUSIN:"focusin"+Je,RESIZE:"resize"+Je,CLICK_DISMISS:"click.dismiss"+Je,KEYDOWN_DISMISS:"keydown.dismiss"+Je,MOUSEUP_DISMISS:"mouseup.dismiss"+Je,MOUSEDOWN_DISMISS:"mousedown.dismiss"+Je,CLICK_DATA_API:"click"+Je+".data-api"},on="modal-dialog-scrollable",rn="modal-scrollbar-measure",sn="modal-backdrop",an="modal-open",ln="fade",cn="show",hn=".modal-dialog",un=".modal-body",fn='[data-toggle="modal"]',dn='[data-dismiss="modal"]',pn=".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",mn=".sticky-top",gn=function(){function o(t,e){this._config=this._getConfig(e),this._element=t,this._dialog=t.querySelector(hn),this._backdrop=null,this._isShown=!1,this._isBodyOverflowing=!1,this._ignoreBackdropClick=!1,this._isTransitioning=!1,this._scrollbarWidth=0}var t=o.prototype;return t.toggle=function(t){return this._isShown?this.hide():this.show(t)},t.show=function(t){var e=this;if(!this._isShown&&!this._isTransitioning){p(this._element).hasClass(ln)&&(this._isTransitioning=!0);var n=p.Event(nn.SHOW,{relatedTarget:t});p(this._element).trigger(n),this._isShown||n.isDefaultPrevented()||(this._isShown=!0,this._checkScrollbar(),this._setScrollbar(),this._adjustDialog(),this._setEscapeEvent(),this._setResizeEvent(),p(this._element).on(nn.CLICK_DISMISS,dn,function(t){return e.hide(t)}),p(this._dialog).on(nn.MOUSEDOWN_DISMISS,function(){p(e._element).one(nn.MOUSEUP_DISMISS,function(t){p(t.target).is(e._element)&&(e._ignoreBackdropClick=!0)})}),this._showBackdrop(function(){return e._showElement(t)}))}},t.hide=function(t){var e=this;if(t&&t.preventDefault(),this._isShown&&!this._isTransitioning){var n=p.Event(nn.HIDE);if(p(this._element).trigger(n),this._isShown&&!n.isDefaultPrevented()){this._isShown=!1;var i=p(this._element).hasClass(ln);if(i&&(this._isTransitioning=!0),this._setEscapeEvent(),this._setResizeEvent(),p(document).off(nn.FOCUSIN),p(this._element).removeClass(cn),p(this._element).off(nn.CLICK_DISMISS),p(this._dialog).off(nn.MOUSEDOWN_DISMISS),i){var o=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,function(t){return e._hideModal(t)}).emulateTransitionEnd(o)}else this._hideModal()}}},t.dispose=function(){[window,this._element,this._dialog].forEach(function(t){return p(t).off(Je)}),p(document).off(nn.FOCUSIN),p.removeData(this._element,$e),this._config=null,this._element=null,this._dialog=null,this._backdrop=null,this._isShown=null,this._isBodyOverflowing=null,this._ignoreBackdropClick=null,this._isTransitioning=null,this._scrollbarWidth=null},t.handleUpdate=function(){this._adjustDialog()},t._getConfig=function(t){return t=l({},tn,t),m.typeCheckConfig(Ge,t,en),t},t._showElement=function(t){var e=this,n=p(this._element).hasClass(ln);this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE||document.body.appendChild(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.setAttribute("aria-modal",!0),p(this._dialog).hasClass(on)?this._dialog.querySelector(un).scrollTop=0:this._element.scrollTop=0,n&&m.reflow(this._element),p(this._element).addClass(cn),this._config.focus&&this._enforceFocus();var i=p.Event(nn.SHOWN,{relatedTarget:t}),o=function(){e._config.focus&&e._element.focus(),e._isTransitioning=!1,p(e._element).trigger(i)};if(n){var r=m.getTransitionDurationFromElement(this._dialog);p(this._dialog).one(m.TRANSITION_END,o).emulateTransitionEnd(r)}else o()},t._enforceFocus=function(){var e=this;p(document).off(nn.FOCUSIN).on(nn.FOCUSIN,function(t){document!==t.target&&e._element!==t.target&&0===p(e._element).has(t.target).length&&e._element.focus()})},t._setEscapeEvent=function(){var e=this;this._isShown&&this._config.keyboard?p(this._element).on(nn.KEYDOWN_DISMISS,function(t){27===t.which&&(t.preventDefault(),e.hide())}):this._isShown||p(this._element).off(nn.KEYDOWN_DISMISS)},t._setResizeEvent=function(){var e=this;this._isShown?p(window).on(nn.RESIZE,function(t){return e.handleUpdate(t)}):p(window).off(nn.RESIZE)},t._hideModal=function(){var t=this;this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._element.removeAttribute("aria-modal"),this._isTransitioning=!1,this._showBackdrop(function(){p(document.body).removeClass(an),t._resetAdjustments(),t._resetScrollbar(),p(t._element).trigger(nn.HIDDEN)})},t._removeBackdrop=function(){this._backdrop&&(p(this._backdrop).remove(),this._backdrop=null)},t._showBackdrop=function(t){var e=this,n=p(this._element).hasClass(ln)?ln:"";if(this._isShown&&this._config.backdrop){if(this._backdrop=document.createElement("div"),this._backdrop.className=sn,n&&this._backdrop.classList.add(n),p(this._backdrop).appendTo(document.body),p(this._element).on(nn.CLICK_DISMISS,function(t){e._ignoreBackdropClick?e._ignoreBackdropClick=!1:t.target===t.currentTarget&&("static"===e._config.backdrop?e._element.focus():e.hide())}),n&&m.reflow(this._backdrop),p(this._backdrop).addClass(cn),!t)return;if(!n)return void t();var i=m.getTransitionDurationFromElement(this._backdrop);p(this._backdrop).one(m.TRANSITION_END,t).emulateTransitionEnd(i)}else if(!this._isShown&&this._backdrop){p(this._backdrop).removeClass(cn);var o=function(){e._removeBackdrop(),t&&t()};if(p(this._element).hasClass(ln)){var r=m.getTransitionDurationFromElement(this._backdrop);p(this._backdrop).one(m.TRANSITION_END,o).emulateTransitionEnd(r)}else o()}else t&&t()},t._adjustDialog=function(){var t=this._element.scrollHeight>document.documentElement.clientHeight;!this._isBodyOverflowing&&t&&(this._element.style.paddingLeft=this._scrollbarWidth+"px"),this._isBodyOverflowing&&!t&&(this._element.style.paddingRight=this._scrollbarWidth+"px")},t._resetAdjustments=function(){this._element.style.paddingLeft="",this._element.style.paddingRight=""},t._checkScrollbar=function(){var t=document.body.getBoundingClientRect();this._isBodyOverflowing=t.left+t.right<window.innerWidth,this._scrollbarWidth=this._getScrollbarWidth()},t._setScrollbar=function(){var o=this;if(this._isBodyOverflowing){var t=[].slice.call(document.querySelectorAll(pn)),e=[].slice.call(document.querySelectorAll(mn));p(t).each(function(t,e){var n=e.style.paddingRight,i=p(e).css("padding-right");p(e).data("padding-right",n).css("padding-right",parseFloat(i)+o._scrollbarWidth+"px")}),p(e).each(function(t,e){var n=e.style.marginRight,i=p(e).css("margin-right");p(e).data("margin-right",n).css("margin-right",parseFloat(i)-o._scrollbarWidth+"px")});var n=document.body.style.paddingRight,i=p(document.body).css("padding-right");p(document.body).data("padding-right",n).css("padding-right",parseFloat(i)+this._scrollbarWidth+"px")}p(document.body).addClass(an)},t._resetScrollbar=function(){var t=[].slice.call(document.querySelectorAll(pn));p(t).each(function(t,e){var n=p(e).data("padding-right");p(e).removeData("padding-right"),e.style.paddingRight=n||""});var e=[].slice.call(document.querySelectorAll(""+mn));p(e).each(function(t,e){var n=p(e).data("margin-right");"undefined"!=typeof n&&p(e).css("margin-right",n).removeData("margin-right")});var n=p(document.body).data("padding-right");p(document.body).removeData("padding-right"),document.body.style.paddingRight=n||""},t._getScrollbarWidth=function(){var t=document.createElement("div");t.className=rn,document.body.appendChild(t);var e=t.getBoundingClientRect().width-t.clientWidth;return document.body.removeChild(t),e},o._jQueryInterface=function(n,i){return this.each(function(){var t=p(this).data($e),e=l({},tn,p(this).data(),"object"==typeof n&&n?n:{});if(t||(t=new o(this,e),p(this).data($e,t)),"string"==typeof n){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n](i)}else e.show&&t.show(i)})},s(o,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return tn}}]),o}();p(document).on(nn.CLICK_DATA_API,fn,function(t){var e,n=this,i=m.getSelectorFromElement(this);i&&(e=document.querySelector(i));var o=p(e).data($e)?"toggle":l({},p(e).data(),p(this).data());"A"!==this.tagName&&"AREA"!==this.tagName||t.preventDefault();var r=p(e).one(nn.SHOW,function(t){t.isDefaultPrevented()||r.one(nn.HIDDEN,function(){p(n).is(":visible")&&n.focus()})});gn._jQueryInterface.call(p(e),o,this)}),p.fn[Ge]=gn._jQueryInterface,p.fn[Ge].Constructor=gn,p.fn[Ge].noConflict=function(){return p.fn[Ge]=Ze,gn._jQueryInterface};var _n=["background","cite","href","itemtype","longdesc","poster","src","xlink:href"],vn={"*":["class","dir","id","lang","role",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]},yn=/^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,En=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;function bn(t,s,e){if(0===t.length)return t;if(e&&"function"==typeof e)return e(t);for(var n=(new window.DOMParser).parseFromString(t,"text/html"),a=Object.keys(s),l=[].slice.call(n.body.querySelectorAll("*")),i=function(t,e){var n=l[t],i=n.nodeName.toLowerCase();if(-1===a.indexOf(n.nodeName.toLowerCase()))return n.parentNode.removeChild(n),"continue";var o=[].slice.call(n.attributes),r=[].concat(s["*"]||[],s[i]||[]);o.forEach(function(t){(function(t,e){var n=t.nodeName.toLowerCase();if(-1!==e.indexOf(n))return-1===_n.indexOf(n)||Boolean(t.nodeValue.match(yn)||t.nodeValue.match(En));for(var i=e.filter(function(t){return t instanceof RegExp}),o=0,r=i.length;o<r;o++)if(n.match(i[o]))return!0;return!1})(t,r)||n.removeAttribute(t.nodeName)})},o=0,r=l.length;o<r;o++)i(o);return n.body.innerHTML}var wn="tooltip",Cn="bs.tooltip",Tn="."+Cn,Sn=p.fn[wn],Dn="bs-tooltip",In=new RegExp("(^|\\s)"+Dn+"\\S+","g"),An=["sanitize","whiteList","sanitizeFn"],On={animation:"boolean",template:"string",title:"(string|element|function)",trigger:"string",delay:"(number|object)",html:"boolean",selector:"(string|boolean)",placement:"(string|function)",offset:"(number|string|function)",container:"(string|element|boolean)",fallbackPlacement:"(string|array)",boundary:"(string|element)",sanitize:"boolean",sanitizeFn:"(null|function)",whiteList:"object"},Nn={AUTO:"auto",TOP:"top",RIGHT:"right",BOTTOM:"bottom",LEFT:"left"},kn={animation:!0,template:'<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,selector:!1,placement:"top",offset:0,container:!1,fallbackPlacement:"flip",boundary:"scrollParent",sanitize:!0,sanitizeFn:null,whiteList:vn},Ln="show",xn="out",Pn={HIDE:"hide"+Tn,HIDDEN:"hidden"+Tn,SHOW:"show"+Tn,SHOWN:"shown"+Tn,INSERTED:"inserted"+Tn,CLICK:"click"+Tn,FOCUSIN:"focusin"+Tn,FOCUSOUT:"focusout"+Tn,MOUSEENTER:"mouseenter"+Tn,MOUSELEAVE:"mouseleave"+Tn},Hn="fade",jn="show",Rn=".tooltip-inner",Fn=".arrow",Mn="hover",Wn="focus",Un="click",Bn="manual",qn=function(){function i(t,e){if("undefined"==typeof be)throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");this._isEnabled=!0,this._timeout=0,this._hoverState="",this._activeTrigger={},this._popper=null,this.element=t,this.config=this._getConfig(e),this.tip=null,this._setListeners()}var t=i.prototype;return t.enable=function(){this._isEnabled=!0},t.disable=function(){this._isEnabled=!1},t.toggleEnabled=function(){this._isEnabled=!this._isEnabled},t.toggle=function(t){if(this._isEnabled)if(t){var e=this.constructor.DATA_KEY,n=p(t.currentTarget).data(e);n||(n=new this.constructor(t.currentTarget,this._getDelegateConfig()),p(t.currentTarget).data(e,n)),n._activeTrigger.click=!n._activeTrigger.click,n._isWithActiveTrigger()?n._enter(null,n):n._leave(null,n)}else{if(p(this.getTipElement()).hasClass(jn))return void this._leave(null,this);this._enter(null,this)}},t.dispose=function(){clearTimeout(this._timeout),p.removeData(this.element,this.constructor.DATA_KEY),p(this.element).off(this.constructor.EVENT_KEY),p(this.element).closest(".modal").off("hide.bs.modal"),this.tip&&p(this.tip).remove(),this._isEnabled=null,this._timeout=null,this._hoverState=null,(this._activeTrigger=null)!==this._popper&&this._popper.destroy(),this._popper=null,this.element=null,this.config=null,this.tip=null},t.show=function(){var e=this;if("none"===p(this.element).css("display"))throw new Error("Please use show on visible elements");var t=p.Event(this.constructor.Event.SHOW);if(this.isWithContent()&&this._isEnabled){p(this.element).trigger(t);var n=m.findShadowRoot(this.element),i=p.contains(null!==n?n:this.element.ownerDocument.documentElement,this.element);if(t.isDefaultPrevented()||!i)return;var o=this.getTipElement(),r=m.getUID(this.constructor.NAME);o.setAttribute("id",r),this.element.setAttribute("aria-describedby",r),this.setContent(),this.config.animation&&p(o).addClass(Hn);var s="function"==typeof this.config.placement?this.config.placement.call(this,o,this.element):this.config.placement,a=this._getAttachment(s);this.addAttachmentClass(a);var l=this._getContainer();p(o).data(this.constructor.DATA_KEY,this),p.contains(this.element.ownerDocument.documentElement,this.tip)||p(o).appendTo(l),p(this.element).trigger(this.constructor.Event.INSERTED),this._popper=new be(this.element,o,{placement:a,modifiers:{offset:this._getOffset(),flip:{behavior:this.config.fallbackPlacement},arrow:{element:Fn},preventOverflow:{boundariesElement:this.config.boundary}},onCreate:function(t){t.originalPlacement!==t.placement&&e._handlePopperPlacementChange(t)},onUpdate:function(t){return e._handlePopperPlacementChange(t)}}),p(o).addClass(jn),"ontouchstart"in document.documentElement&&p(document.body).children().on("mouseover",null,p.noop);var c=function(){e.config.animation&&e._fixTransition();var t=e._hoverState;e._hoverState=null,p(e.element).trigger(e.constructor.Event.SHOWN),t===xn&&e._leave(null,e)};if(p(this.tip).hasClass(Hn)){var h=m.getTransitionDurationFromElement(this.tip);p(this.tip).one(m.TRANSITION_END,c).emulateTransitionEnd(h)}else c()}},t.hide=function(t){var e=this,n=this.getTipElement(),i=p.Event(this.constructor.Event.HIDE),o=function(){e._hoverState!==Ln&&n.parentNode&&n.parentNode.removeChild(n),e._cleanTipClass(),e.element.removeAttribute("aria-describedby"),p(e.element).trigger(e.constructor.Event.HIDDEN),null!==e._popper&&e._popper.destroy(),t&&t()};if(p(this.element).trigger(i),!i.isDefaultPrevented()){if(p(n).removeClass(jn),"ontouchstart"in document.documentElement&&p(document.body).children().off("mouseover",null,p.noop),this._activeTrigger[Un]=!1,this._activeTrigger[Wn]=!1,this._activeTrigger[Mn]=!1,p(this.tip).hasClass(Hn)){var r=m.getTransitionDurationFromElement(n);p(n).one(m.TRANSITION_END,o).emulateTransitionEnd(r)}else o();this._hoverState=""}},t.update=function(){null!==this._popper&&this._popper.scheduleUpdate()},t.isWithContent=function(){return Boolean(this.getTitle())},t.addAttachmentClass=function(t){p(this.getTipElement()).addClass(Dn+"-"+t)},t.getTipElement=function(){return this.tip=this.tip||p(this.config.template)[0],this.tip},t.setContent=function(){var t=this.getTipElement();this.setElementContent(p(t.querySelectorAll(Rn)),this.getTitle()),p(t).removeClass(Hn+" "+jn)},t.setElementContent=function(t,e){"object"!=typeof e||!e.nodeType&&!e.jquery?this.config.html?(this.config.sanitize&&(e=bn(e,this.config.whiteList,this.config.sanitizeFn)),t.html(e)):t.text(e):this.config.html?p(e).parent().is(t)||t.empty().append(e):t.text(p(e).text())},t.getTitle=function(){var t=this.element.getAttribute("data-original-title");return t||(t="function"==typeof this.config.title?this.config.title.call(this.element):this.config.title),t},t._getOffset=function(){var e=this,t={};return"function"==typeof this.config.offset?t.fn=function(t){return t.offsets=l({},t.offsets,e.config.offset(t.offsets,e.element)||{}),t}:t.offset=this.config.offset,t},t._getContainer=function(){return!1===this.config.container?document.body:m.isElement(this.config.container)?p(this.config.container):p(document).find(this.config.container)},t._getAttachment=function(t){return Nn[t.toUpperCase()]},t._setListeners=function(){var i=this;this.config.trigger.split(" ").forEach(function(t){if("click"===t)p(i.element).on(i.constructor.Event.CLICK,i.config.selector,function(t){return i.toggle(t)});else if(t!==Bn){var e=t===Mn?i.constructor.Event.MOUSEENTER:i.constructor.Event.FOCUSIN,n=t===Mn?i.constructor.Event.MOUSELEAVE:i.constructor.Event.FOCUSOUT;p(i.element).on(e,i.config.selector,function(t){return i._enter(t)}).on(n,i.config.selector,function(t){return i._leave(t)})}}),p(this.element).closest(".modal").on("hide.bs.modal",function(){i.element&&i.hide()}),this.config.selector?this.config=l({},this.config,{trigger:"manual",selector:""}):this._fixTitle()},t._fixTitle=function(){var t=typeof this.element.getAttribute("data-original-title");(this.element.getAttribute("title")||"string"!==t)&&(this.element.setAttribute("data-original-title",this.element.getAttribute("title")||""),this.element.setAttribute("title",""))},t._enter=function(t,e){var n=this.constructor.DATA_KEY;(e=e||p(t.currentTarget).data(n))||(e=new this.constructor(t.currentTarget,this._getDelegateConfig()),p(t.currentTarget).data(n,e)),t&&(e._activeTrigger["focusin"===t.type?Wn:Mn]=!0),p(e.getTipElement()).hasClass(jn)||e._hoverState===Ln?e._hoverState=Ln:(clearTimeout(e._timeout),e._hoverState=Ln,e.config.delay&&e.config.delay.show?e._timeout=setTimeout(function(){e._hoverState===Ln&&e.show()},e.config.delay.show):e.show())},t._leave=function(t,e){var n=this.constructor.DATA_KEY;(e=e||p(t.currentTarget).data(n))||(e=new this.constructor(t.currentTarget,this._getDelegateConfig()),p(t.currentTarget).data(n,e)),t&&(e._activeTrigger["focusout"===t.type?Wn:Mn]=!1),e._isWithActiveTrigger()||(clearTimeout(e._timeout),e._hoverState=xn,e.config.delay&&e.config.delay.hide?e._timeout=setTimeout(function(){e._hoverState===xn&&e.hide()},e.config.delay.hide):e.hide())},t._isWithActiveTrigger=function(){for(var t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1},t._getConfig=function(t){var e=p(this.element).data();return Object.keys(e).forEach(function(t){-1!==An.indexOf(t)&&delete e[t]}),"number"==typeof(t=l({},this.constructor.Default,e,"object"==typeof t&&t?t:{})).delay&&(t.delay={show:t.delay,hide:t.delay}),"number"==typeof t.title&&(t.title=t.title.toString()),"number"==typeof t.content&&(t.content=t.content.toString()),m.typeCheckConfig(wn,t,this.constructor.DefaultType),t.sanitize&&(t.template=bn(t.template,t.whiteList,t.sanitizeFn)),t},t._getDelegateConfig=function(){var t={};if(this.config)for(var e in this.config)this.constructor.Default[e]!==this.config[e]&&(t[e]=this.config[e]);return t},t._cleanTipClass=function(){var t=p(this.getTipElement()),e=t.attr("class").match(In);null!==e&&e.length&&t.removeClass(e.join(""))},t._handlePopperPlacementChange=function(t){var e=t.instance;this.tip=e.popper,this._cleanTipClass(),this.addAttachmentClass(this._getAttachment(t.placement))},t._fixTransition=function(){var t=this.getTipElement(),e=this.config.animation;null===t.getAttribute("x-placement")&&(p(t).removeClass(Hn),this.config.animation=!1,this.hide(),this.show(),this.config.animation=e)},i._jQueryInterface=function(n){return this.each(function(){var t=p(this).data(Cn),e="object"==typeof n&&n;if((t||!/dispose|hide/.test(n))&&(t||(t=new i(this,e),p(this).data(Cn,t)),"string"==typeof n)){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}})},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return kn}},{key:"NAME",get:function(){return wn}},{key:"DATA_KEY",get:function(){return Cn}},{key:"Event",get:function(){return Pn}},{key:"EVENT_KEY",get:function(){return Tn}},{key:"DefaultType",get:function(){return On}}]),i}();p.fn[wn]=qn._jQueryInterface,p.fn[wn].Constructor=qn,p.fn[wn].noConflict=function(){return p.fn[wn]=Sn,qn._jQueryInterface};var Kn="popover",Qn="bs.popover",Vn="."+Qn,Yn=p.fn[Kn],zn="bs-popover",Xn=new RegExp("(^|\\s)"+zn+"\\S+","g"),Gn=l({},qn.Default,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'}),$n=l({},qn.DefaultType,{content:"(string|element|function)"}),Jn="fade",Zn="show",ti=".popover-header",ei=".popover-body",ni={HIDE:"hide"+Vn,HIDDEN:"hidden"+Vn,SHOW:"show"+Vn,SHOWN:"shown"+Vn,INSERTED:"inserted"+Vn,CLICK:"click"+Vn,FOCUSIN:"focusin"+Vn,FOCUSOUT:"focusout"+Vn,MOUSEENTER:"mouseenter"+Vn,MOUSELEAVE:"mouseleave"+Vn},ii=function(t){var e,n;function i(){return t.apply(this,arguments)||this}n=t,(e=i).prototype=Object.create(n.prototype),(e.prototype.constructor=e).__proto__=n;var o=i.prototype;return o.isWithContent=function(){return this.getTitle()||this._getContent()},o.addAttachmentClass=function(t){p(this.getTipElement()).addClass(zn+"-"+t)},o.getTipElement=function(){return this.tip=this.tip||p(this.config.template)[0],this.tip},o.setContent=function(){var t=p(this.getTipElement());this.setElementContent(t.find(ti),this.getTitle());var e=this._getContent();"function"==typeof e&&(e=e.call(this.element)),this.setElementContent(t.find(ei),e),t.removeClass(Jn+" "+Zn)},o._getContent=function(){return this.element.getAttribute("data-content")||this.config.content},o._cleanTipClass=function(){var t=p(this.getTipElement()),e=t.attr("class").match(Xn);null!==e&&0<e.length&&t.removeClass(e.join(""))},i._jQueryInterface=function(n){return this.each(function(){var t=p(this).data(Qn),e="object"==typeof n?n:null;if((t||!/dispose|hide/.test(n))&&(t||(t=new i(this,e),p(this).data(Qn,t)),"string"==typeof n)){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}})},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return Gn}},{key:"NAME",get:function(){return Kn}},{key:"DATA_KEY",get:function(){return Qn}},{key:"Event",get:function(){return ni}},{key:"EVENT_KEY",get:function(){return Vn}},{key:"DefaultType",get:function(){return $n}}]),i}(qn);p.fn[Kn]=ii._jQueryInterface,p.fn[Kn].Constructor=ii,p.fn[Kn].noConflict=function(){return p.fn[Kn]=Yn,ii._jQueryInterface};var oi="scrollspy",ri="bs.scrollspy",si="."+ri,ai=p.fn[oi],li={offset:10,method:"auto",target:""},ci={offset:"number",method:"string",target:"(string|element)"},hi={ACTIVATE:"activate"+si,SCROLL:"scroll"+si,LOAD_DATA_API:"load"+si+".data-api"},ui="dropdown-item",fi="active",di='[data-spy="scroll"]',pi=".nav, .list-group",mi=".nav-link",gi=".nav-item",_i=".list-group-item",vi=".dropdown",yi=".dropdown-item",Ei=".dropdown-toggle",bi="offset",wi="position",Ci=function(){function n(t,e){var n=this;this._element=t,this._scrollElement="BODY"===t.tagName?window:t,this._config=this._getConfig(e),this._selector=this._config.target+" "+mi+","+this._config.target+" "+_i+","+this._config.target+" "+yi,this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,p(this._scrollElement).on(hi.SCROLL,function(t){return n._process(t)}),this.refresh(),this._process()}var t=n.prototype;return t.refresh=function(){var e=this,t=this._scrollElement===this._scrollElement.window?bi:wi,o="auto"===this._config.method?t:this._config.method,r=o===wi?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight(),[].slice.call(document.querySelectorAll(this._selector)).map(function(t){var e,n=m.getSelectorFromElement(t);if(n&&(e=document.querySelector(n)),e){var i=e.getBoundingClientRect();if(i.width||i.height)return[p(e)[o]().top+r,n]}return null}).filter(function(t){return t}).sort(function(t,e){return t[0]-e[0]}).forEach(function(t){e._offsets.push(t[0]),e._targets.push(t[1])})},t.dispose=function(){p.removeData(this._element,ri),p(this._scrollElement).off(si),this._element=null,this._scrollElement=null,this._config=null,this._selector=null,this._offsets=null,this._targets=null,this._activeTarget=null,this._scrollHeight=null},t._getConfig=function(t){if("string"!=typeof(t=l({},li,"object"==typeof t&&t?t:{})).target){var e=p(t.target).attr("id");e||(e=m.getUID(oi),p(t.target).attr("id",e)),t.target="#"+e}return m.typeCheckConfig(oi,t,ci),t},t._getScrollTop=function(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop},t._getScrollHeight=function(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)},t._getOffsetHeight=function(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height},t._process=function(){var t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),n=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),n<=t){var i=this._targets[this._targets.length-1];this._activeTarget!==i&&this._activate(i)}else{if(this._activeTarget&&t<this._offsets[0]&&0<this._offsets[0])return this._activeTarget=null,void this._clear();for(var o=this._offsets.length;o--;){this._activeTarget!==this._targets[o]&&t>=this._offsets[o]&&("undefined"==typeof this._offsets[o+1]||t<this._offsets[o+1])&&this._activate(this._targets[o])}}},t._activate=function(e){this._activeTarget=e,this._clear();var t=this._selector.split(",").map(function(t){return t+'[data-target="'+e+'"],'+t+'[href="'+e+'"]'}),n=p([].slice.call(document.querySelectorAll(t.join(","))));n.hasClass(ui)?(n.closest(vi).find(Ei).addClass(fi),n.addClass(fi)):(n.addClass(fi),n.parents(pi).prev(mi+", "+_i).addClass(fi),n.parents(pi).prev(gi).children(mi).addClass(fi)),p(this._scrollElement).trigger(hi.ACTIVATE,{relatedTarget:e})},t._clear=function(){[].slice.call(document.querySelectorAll(this._selector)).filter(function(t){return t.classList.contains(fi)}).forEach(function(t){return t.classList.remove(fi)})},n._jQueryInterface=function(e){return this.each(function(){var t=p(this).data(ri);if(t||(t=new n(this,"object"==typeof e&&e),p(this).data(ri,t)),"string"==typeof e){if("undefined"==typeof t[e])throw new TypeError('No method named "'+e+'"');t[e]()}})},s(n,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return li}}]),n}();p(window).on(hi.LOAD_DATA_API,function(){for(var t=[].slice.call(document.querySelectorAll(di)),e=t.length;e--;){var n=p(t[e]);Ci._jQueryInterface.call(n,n.data())}}),p.fn[oi]=Ci._jQueryInterface,p.fn[oi].Constructor=Ci,p.fn[oi].noConflict=function(){return p.fn[oi]=ai,Ci._jQueryInterface};var Ti="bs.tab",Si="."+Ti,Di=p.fn.tab,Ii={HIDE:"hide"+Si,HIDDEN:"hidden"+Si,SHOW:"show"+Si,SHOWN:"shown"+Si,CLICK_DATA_API:"click"+Si+".data-api"},Ai="dropdown-menu",Oi="active",Ni="disabled",ki="fade",Li="show",xi=".dropdown",Pi=".nav, .list-group",Hi=".active",ji="> li > .active",Ri='[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',Fi=".dropdown-toggle",Mi="> .dropdown-menu .active",Wi=function(){function i(t){this._element=t}var t=i.prototype;return t.show=function(){var n=this;if(!(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&p(this._element).hasClass(Oi)||p(this._element).hasClass(Ni))){var t,i,e=p(this._element).closest(Pi)[0],o=m.getSelectorFromElement(this._element);if(e){var r="UL"===e.nodeName||"OL"===e.nodeName?ji:Hi;i=(i=p.makeArray(p(e).find(r)))[i.length-1]}var s=p.Event(Ii.HIDE,{relatedTarget:this._element}),a=p.Event(Ii.SHOW,{relatedTarget:i});if(i&&p(i).trigger(s),p(this._element).trigger(a),!a.isDefaultPrevented()&&!s.isDefaultPrevented()){o&&(t=document.querySelector(o)),this._activate(this._element,e);var l=function(){var t=p.Event(Ii.HIDDEN,{relatedTarget:n._element}),e=p.Event(Ii.SHOWN,{relatedTarget:i});p(i).trigger(t),p(n._element).trigger(e)};t?this._activate(t,t.parentNode,l):l()}}},t.dispose=function(){p.removeData(this._element,Ti),this._element=null},t._activate=function(t,e,n){var i=this,o=(!e||"UL"!==e.nodeName&&"OL"!==e.nodeName?p(e).children(Hi):p(e).find(ji))[0],r=n&&o&&p(o).hasClass(ki),s=function(){return i._transitionComplete(t,o,n)};if(o&&r){var a=m.getTransitionDurationFromElement(o);p(o).removeClass(Li).one(m.TRANSITION_END,s).emulateTransitionEnd(a)}else s()},t._transitionComplete=function(t,e,n){if(e){p(e).removeClass(Oi);var i=p(e.parentNode).find(Mi)[0];i&&p(i).removeClass(Oi),"tab"===e.getAttribute("role")&&e.setAttribute("aria-selected",!1)}if(p(t).addClass(Oi),"tab"===t.getAttribute("role")&&t.setAttribute("aria-selected",!0),m.reflow(t),t.classList.contains(ki)&&t.classList.add(Li),t.parentNode&&p(t.parentNode).hasClass(Ai)){var o=p(t).closest(xi)[0];if(o){var r=[].slice.call(o.querySelectorAll(Fi));p(r).addClass(Oi)}t.setAttribute("aria-expanded",!0)}n&&n()},i._jQueryInterface=function(n){return this.each(function(){var t=p(this),e=t.data(Ti);if(e||(e=new i(this),t.data(Ti,e)),"string"==typeof n){if("undefined"==typeof e[n])throw new TypeError('No method named "'+n+'"');e[n]()}})},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}}]),i}();p(document).on(Ii.CLICK_DATA_API,Ri,function(t){t.preventDefault(),Wi._jQueryInterface.call(p(this),"show")}),p.fn.tab=Wi._jQueryInterface,p.fn.tab.Constructor=Wi,p.fn.tab.noConflict=function(){return p.fn.tab=Di,Wi._jQueryInterface};var Ui="toast",Bi="bs.toast",qi="."+Bi,Ki=p.fn[Ui],Qi={CLICK_DISMISS:"click.dismiss"+qi,HIDE:"hide"+qi,HIDDEN:"hidden"+qi,SHOW:"show"+qi,SHOWN:"shown"+qi},Vi="fade",Yi="hide",zi="show",Xi="showing",Gi={animation:"boolean",autohide:"boolean",delay:"number"},$i={animation:!0,autohide:!0,delay:500},Ji='[data-dismiss="toast"]',Zi=function(){function i(t,e){this._element=t,this._config=this._getConfig(e),this._timeout=null,this._setListeners()}var t=i.prototype;return t.show=function(){var t=this;p(this._element).trigger(Qi.SHOW),this._config.animation&&this._element.classList.add(Vi);var e=function(){t._element.classList.remove(Xi),t._element.classList.add(zi),p(t._element).trigger(Qi.SHOWN),t._config.autohide&&t.hide()};if(this._element.classList.remove(Yi),this._element.classList.add(Xi),this._config.animation){var n=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,e).emulateTransitionEnd(n)}else e()},t.hide=function(t){var e=this;this._element.classList.contains(zi)&&(p(this._element).trigger(Qi.HIDE),t?this._close():this._timeout=setTimeout(function(){e._close()},this._config.delay))},t.dispose=function(){clearTimeout(this._timeout),this._timeout=null,this._element.classList.contains(zi)&&this._element.classList.remove(zi),p(this._element).off(Qi.CLICK_DISMISS),p.removeData(this._element,Bi),this._element=null,this._config=null},t._getConfig=function(t){return t=l({},$i,p(this._element).data(),"object"==typeof t&&t?t:{}),m.typeCheckConfig(Ui,t,this.constructor.DefaultType),t},t._setListeners=function(){var t=this;p(this._element).on(Qi.CLICK_DISMISS,Ji,function(){return t.hide(!0)})},t._close=function(){var t=this,e=function(){t._element.classList.add(Yi),p(t._element).trigger(Qi.HIDDEN)};if(this._element.classList.remove(zi),this._config.animation){var n=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,e).emulateTransitionEnd(n)}else e()},i._jQueryInterface=function(n){return this.each(function(){var t=p(this),e=t.data(Bi);if(e||(e=new i(this,"object"==typeof n&&n),t.data(Bi,e)),"string"==typeof n){if("undefined"==typeof e[n])throw new TypeError('No method named "'+n+'"');e[n](this)}})},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"DefaultType",get:function(){return Gi}},{key:"Default",get:function(){return $i}}]),i}();p.fn[Ui]=Zi._jQueryInterface,p.fn[Ui].Constructor=Zi,p.fn[Ui].noConflict=function(){return p.fn[Ui]=Ki,Zi._jQueryInterface},function(){if("undefined"==typeof p)throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");var t=p.fn.jquery.split(" ")[0].split(".");if(t[0]<2&&t[1]<9||1===t[0]&&9===t[1]&&t[2]<1||4<=t[0])throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")}(),t.Util=m,t.Alert=g,t.Button=k,t.Carousel=at,t.Collapse=Ct,t.Dropdown=Xe,t.Modal=gn,t.Popover=ii,t.Scrollspy=Ci,t.Tab=Wi,t.Toast=Zi,t.Tooltip=qn,Object.defineProperty(t,"__esModule",{value:!0})});
(function(factory){if(typeof define==="function"&&define.amd){define(["jquery"],function($){return factory($)})}else if(typeof module==="object"&&typeof module.exports==="object"){exports=factory(require("jquery"))}else{factory(jQuery)}})(function($){$.easing.jswing=$.easing.swing;var pow=Math.pow,sqrt=Math.sqrt,sin=Math.sin,cos=Math.cos,PI=Math.PI,c1=1.70158,c2=c1*1.525,c3=c1+1,c4=2*PI/3,c5=2*PI/4.5;function bounceOut(x){var n1=7.5625,d1=2.75;if(x<1/d1){return n1*x*x}else if(x<2/d1){return n1*(x-=1.5/d1)*x+.75}else if(x<2.5/d1){return n1*(x-=2.25/d1)*x+.9375}else{return n1*(x-=2.625/d1)*x+.984375}}$.extend($.easing,{def:"easeOutQuad",swing:function(x){return $.easing[$.easing.def](x)},easeInQuad:function(x){return x*x},easeOutQuad:function(x){return 1-(1-x)*(1-x)},easeInOutQuad:function(x){return x<.5?2*x*x:1-pow(-2*x+2,2)/2},easeInCubic:function(x){return x*x*x},easeOutCubic:function(x){return 1-pow(1-x,3)},easeInOutCubic:function(x){return x<.5?4*x*x*x:1-pow(-2*x+2,3)/2},easeInQuart:function(x){return x*x*x*x},easeOutQuart:function(x){return 1-pow(1-x,4)},easeInOutQuart:function(x){return x<.5?8*x*x*x*x:1-pow(-2*x+2,4)/2},easeInQuint:function(x){return x*x*x*x*x},easeOutQuint:function(x){return 1-pow(1-x,5)},easeInOutQuint:function(x){return x<.5?16*x*x*x*x*x:1-pow(-2*x+2,5)/2},easeInSine:function(x){return 1-cos(x*PI/2)},easeOutSine:function(x){return sin(x*PI/2)},easeInOutSine:function(x){return-(cos(PI*x)-1)/2},easeInExpo:function(x){return x===0?0:pow(2,10*x-10)},easeOutExpo:function(x){return x===1?1:1-pow(2,-10*x)},easeInOutExpo:function(x){return x===0?0:x===1?1:x<.5?pow(2,20*x-10)/2:(2-pow(2,-20*x+10))/2},easeInCirc:function(x){return 1-sqrt(1-pow(x,2))},easeOutCirc:function(x){return sqrt(1-pow(x-1,2))},easeInOutCirc:function(x){return x<.5?(1-sqrt(1-pow(2*x,2)))/2:(sqrt(1-pow(-2*x+2,2))+1)/2},easeInElastic:function(x){return x===0?0:x===1?1:-pow(2,10*x-10)*sin((x*10-10.75)*c4)},easeOutElastic:function(x){return x===0?0:x===1?1:pow(2,-10*x)*sin((x*10-.75)*c4)+1},easeInOutElastic:function(x){return x===0?0:x===1?1:x<.5?-(pow(2,20*x-10)*sin((20*x-11.125)*c5))/2:pow(2,-20*x+10)*sin((20*x-11.125)*c5)/2+1},easeInBack:function(x){return c3*x*x*x-c1*x*x},easeOutBack:function(x){return 1+c3*pow(x-1,3)+c1*pow(x-1,2)},easeInOutBack:function(x){return x<.5?pow(2*x,2)*((c2+1)*2*x-c2)/2:(pow(2*x-2,2)*((c2+1)*(x*2-2)+c2)+2)/2},easeInBounce:function(x){return 1-bounceOut(1-x)},easeOutBounce:bounceOut,easeInOutBounce:function(x){return x<.5?(1-bounceOut(1-2*x))/2:(1+bounceOut(2*x-1))/2}})});
/* jqBootstrapValidation
* A plugin for automating validation on Twitter Bootstrap formatted forms. * * v1.3.6 *
* License: MIT <http://opensource.org/licenses/mit-license.php> - see LICENSE file
*
* http://ReactiveRaven.github.com/jqBootstrapValidation/
*/ (function( $ ){ var createdElements = []; var defaults = { options: { prependExistingHelpBlock: false,
sniffHtml: true, // sniff for 'required', 'maxlength', etc
preventSubmit: true, // stop the form submit event from firing if validation fails
submitError: false, // function called if there is an error when trying to submit
submitSuccess: false, // function called just before a successful submit event is sent to the server
semanticallyStrict: false, // set to true to tidy up generated HTML output
autoAdd: { helpBlocks: true }, filter: function () {
// return $(this).is(":visible"); // only validate elements you can see
return true; // validate everything
} }, methods: { init : function( options ) { var settings = $.extend(true, {}, defaults); settings.options = $.extend(true, settings.options, options); var $siblingElements = this; var uniqueForms = $.unique( $siblingElements.map( function () { return $(this).parents("form")[0]; }).toArray() ); $(uniqueForms).bind("submit", function (e) { var $form = $(this); var warningsFound = 0; var $inputs = $form.find("input,textarea,select").not("[type=submit],[type=image]").filter(settings.options.filter); $inputs.trigger("submit.validation").trigger("validationLostFocus.validation"); $inputs.each(function (i, el) { var $this = $(el), $controlGroup = $this.parents(".control-group").first(); if ( $controlGroup.hasClass("warning") ) { $controlGroup.removeClass("warning").addClass("error"); warningsFound++; } }); $inputs.trigger("validationLostFocus.validation"); if (warningsFound) { if (settings.options.preventSubmit) { e.preventDefault(); } $form.addClass("error"); if ($.isFunction(settings.options.submitError)) { settings.options.submitError($form, e, $inputs.jqBootstrapValidation("collectErrors", true)); } } else { $form.removeClass("error"); if ($.isFunction(settings.options.submitSuccess)) { settings.options.submitSuccess($form, e); } } }); return this.each(function(){
// Get references to everything we're interested in
var $this = $(this), $controlGroup = $this.parents(".control-group").first(), $helpBlock = $controlGroup.find(".help-block").first(), $form = $this.parents("form").first(), validatorNames = [];
// create message container if not exists
if (!$helpBlock.length && settings.options.autoAdd && settings.options.autoAdd.helpBlocks) { $helpBlock = $('<div class="help-block" />'); $controlGroup.find('.controls').append($helpBlock); createdElements.push($helpBlock[0]); }
// =============================================================
// SNIFF HTML FOR VALIDATORS
// =============================================================
// *snort sniff snuffle*
if (settings.options.sniffHtml) { var message = "";
// ---------------------------------------------------------
// PATTERN
// ---------------------------------------------------------
if ($this.attr("pattern") !== undefined) { message = "Not in the expected format<!-- data-validation-pattern-message to override -->"; if ($this.data("validationPatternMessage")) { message = $this.data("validationPatternMessage"); } $this.data("validationPatternMessage", message); $this.data("validationPatternRegex", $this.attr("pattern")); }
// ---------------------------------------------------------
// MAX
// ---------------------------------------------------------
if ($this.attr("max") !== undefined || $this.attr("aria-valuemax") !== undefined) { var max = ($this.attr("max") !== undefined ? $this.attr("max") : $this.attr("aria-valuemax")); message = "Too high: Maximum of '" + max + "'<!-- data-validation-max-message to override -->"; if ($this.data("validationMaxMessage")) { message = $this.data("validationMaxMessage"); } $this.data("validationMaxMessage", message); $this.data("validationMaxMax", max); }
// ---------------------------------------------------------
// MIN
// ---------------------------------------------------------
if ($this.attr("min") !== undefined || $this.attr("aria-valuemin") !== undefined) { var min = ($this.attr("min") !== undefined ? $this.attr("min") : $this.attr("aria-valuemin")); message = "Too low: Minimum of '" + min + "'<!-- data-validation-min-message to override -->"; if ($this.data("validationMinMessage")) { message = $this.data("validationMinMessage"); } $this.data("validationMinMessage", message); $this.data("validationMinMin", min); }
// ---------------------------------------------------------
// MAXLENGTH
// ---------------------------------------------------------
if ($this.attr("maxlength") !== undefined) { message = "Too long: Maximum of '" + $this.attr("maxlength") + "' characters<!-- data-validation-maxlength-message to override -->"; if ($this.data("validationMaxlengthMessage")) { message = $this.data("validationMaxlengthMessage"); } $this.data("validationMaxlengthMessage", message); $this.data("validationMaxlengthMaxlength", $this.attr("maxlength")); }
// ---------------------------------------------------------
// MINLENGTH
// ---------------------------------------------------------
if ($this.attr("minlength") !== undefined) { message = "Too short: Minimum of '" + $this.attr("minlength") + "' characters<!-- data-validation-minlength-message to override -->"; if ($this.data("validationMinlengthMessage")) { message = $this.data("validationMinlengthMessage"); } $this.data("validationMinlengthMessage", message); $this.data("validationMinlengthMinlength", $this.attr("minlength")); }
// ---------------------------------------------------------
// REQUIRED
// ---------------------------------------------------------
if ($this.attr("required") !== undefined || $this.attr("aria-required") !== undefined) { message = settings.builtInValidators.required.message; if ($this.data("validationRequiredMessage")) { message = $this.data("validationRequiredMessage"); } $this.data("validationRequiredMessage", message); }
// ---------------------------------------------------------
// NUMBER
// ---------------------------------------------------------
if ($this.attr("type") !== undefined && $this.attr("type").toLowerCase() === "number") { message = settings.builtInValidators.number.message; if ($this.data("validationNumberMessage")) { message = $this.data("validationNumberMessage"); } $this.data("validationNumberMessage", message); }
// ---------------------------------------------------------
// EMAIL
// ---------------------------------------------------------
if ($this.attr("type") !== undefined && $this.attr("type").toLowerCase() === "email") { message = "Not a valid email address<!-- data-validator-validemail-message to override -->"; if ($this.data("validationValidemailMessage")) { message = $this.data("validationValidemailMessage"); } else if ($this.data("validationEmailMessage")) { message = $this.data("validationEmailMessage"); } $this.data("validationValidemailMessage", message); }
// ---------------------------------------------------------
// MINCHECKED
// ---------------------------------------------------------
if ($this.attr("minchecked") !== undefined) { message = "Not enough options checked; Minimum of '" + $this.attr("minchecked") + "' required<!-- data-validation-minchecked-message to override -->"; if ($this.data("validationMincheckedMessage")) { message = $this.data("validationMincheckedMessage"); } $this.data("validationMincheckedMessage", message); $this.data("validationMincheckedMinchecked", $this.attr("minchecked")); }
// ---------------------------------------------------------
// MAXCHECKED
// ---------------------------------------------------------
if ($this.attr("maxchecked") !== undefined) { message = "Too many options checked; Maximum of '" + $this.attr("maxchecked") + "' required<!-- data-validation-maxchecked-message to override -->"; if ($this.data("validationMaxcheckedMessage")) { message = $this.data("validationMaxcheckedMessage"); } $this.data("validationMaxcheckedMessage", message); $this.data("validationMaxcheckedMaxchecked", $this.attr("maxchecked")); } }
// =============================================================
// COLLECT VALIDATOR NAMES
// =============================================================
// Get named validators
if ($this.data("validation") !== undefined) { validatorNames = $this.data("validation").split(","); }
// Get extra ones defined on the element's data attributes
$.each($this.data(), function (i, el) { var parts = i.replace(/([A-Z])/g, ",$1").split(","); if (parts[0] === "validation" && parts[1]) { validatorNames.push(parts[1]); } });
// =============================================================
// NORMALISE VALIDATOR NAMES
// =============================================================
var validatorNamesToInspect = validatorNames; var newValidatorNamesToInspect = [];
do // repeatedly expand 'shortcut' validators into their real validators
{
// Uppercase only the first letter of each name
$.each(validatorNames, function (i, el) { validatorNames[i] = formatValidatorName(el); });
// Remove duplicate validator names
validatorNames = $.unique(validatorNames);
// Pull out the new validator names from each shortcut
newValidatorNamesToInspect = []; $.each(validatorNamesToInspect, function(i, el) { if ($this.data("validation" + el + "Shortcut") !== undefined) {
// Are these custom validators?
// Pull them out!
$.each($this.data("validation" + el + "Shortcut").split(","), function(i2, el2) { newValidatorNamesToInspect.push(el2); }); } else if (settings.builtInValidators[el.toLowerCase()]) {
// Is this a recognised built-in?
// Pull it out!
var validator = settings.builtInValidators[el.toLowerCase()]; if (validator.type.toLowerCase() === "shortcut") { $.each(validator.shortcut.split(","), function (i, el) { el = formatValidatorName(el); newValidatorNamesToInspect.push(el); validatorNames.push(el); }); } } }); validatorNamesToInspect = newValidatorNamesToInspect; } while (validatorNamesToInspect.length > 0)
// =============================================================
// SET UP VALIDATOR ARRAYS
// =============================================================
var validators = {}; $.each(validatorNames, function (i, el) {
// Set up the 'override' message
var message = $this.data("validation" + el + "Message"); var hasOverrideMessage = (message !== undefined); var foundValidator = false; message = ( message ? message : "'" + el + "' validation failed <!-- Add attribute 'data-validation-" + el.toLowerCase() + "-message' to input to change this message -->" ) ; $.each( settings.validatorTypes, function (validatorType, validatorTemplate) { if (validators[validatorType] === undefined) { validators[validatorType] = []; } if (!foundValidator && $this.data("validation" + el + formatValidatorName(validatorTemplate.name)) !== undefined) { validators[validatorType].push( $.extend( true, { name: formatValidatorName(validatorTemplate.name), message: message }, validatorTemplate.init($this, el) ) ); foundValidator = true; } } ); if (!foundValidator && settings.builtInValidators[el.toLowerCase()]) { var validator = $.extend(true, {}, settings.builtInValidators[el.toLowerCase()]); if (hasOverrideMessage) { validator.message = message; } var validatorType = validator.type.toLowerCase(); if (validatorType === "shortcut") { foundValidator = true; } else { $.each( settings.validatorTypes, function (validatorTemplateType, validatorTemplate) { if (validators[validatorTemplateType] === undefined) { validators[validatorTemplateType] = []; } if (!foundValidator && validatorType === validatorTemplateType.toLowerCase()) { $this.data("validation" + el + formatValidatorName(validatorTemplate.name), validator[validatorTemplate.name.toLowerCase()]); validators[validatorType].push( $.extend( validator, validatorTemplate.init($this, el) ) ); foundValidator = true; } } ); } } if (! foundValidator) { $.error("Cannot find validation info for '" + el + "'"); } });
// =============================================================
// STORE FALLBACK VALUES
// =============================================================
$helpBlock.data( "original-contents", ( $helpBlock.data("original-contents") ? $helpBlock.data("original-contents") : $helpBlock.html() ) ); $helpBlock.data( "original-role", ( $helpBlock.data("original-role") ? $helpBlock.data("original-role") : $helpBlock.attr("role") ) ); $controlGroup.data( "original-classes", ( $controlGroup.data("original-clases") ? $controlGroup.data("original-classes") : $controlGroup.attr("class") ) ); $this.data( "original-aria-invalid", ( $this.data("original-aria-invalid") ? $this.data("original-aria-invalid") : $this.attr("aria-invalid") ) );
// =============================================================
// VALIDATION
// =============================================================
$this.bind( "validation.validation", function (event, params) { var value = getValue($this);
// Get a list of the errors to apply
var errorsFound = []; $.each(validators, function (validatorType, validatorTypeArray) { if (value || value.length || (params && params.includeEmpty) || (!!settings.validatorTypes[validatorType].blockSubmit && params && !!params.submitting)) { $.each(validatorTypeArray, function (i, validator) { if (settings.validatorTypes[validatorType].validate($this, value, validator)) { errorsFound.push(validator.message); } }); } }); return errorsFound; } ); $this.bind( "getValidators.validation", function () { return validators; } );
// =============================================================
// WATCH FOR CHANGES
// =============================================================
$this.bind( "submit.validation", function () { return $this.triggerHandler("change.validation", {submitting: true}); } ); $this.bind( [ "keyup", "focus", "blur", "click", "keydown", "keypress", "change" ].join(".validation ") + ".validation", function (e, params) { var value = getValue($this); var errorsFound = []; $controlGroup.find("input,textarea,select").each(function (i, el) { var oldCount = errorsFound.length; $.each($(el).triggerHandler("validation.validation", params), function (j, message) { errorsFound.push(message); }); if (errorsFound.length > oldCount) { $(el).attr("aria-invalid", "true"); } else { var original = $this.data("original-aria-invalid"); $(el).attr("aria-invalid", (original !== undefined ? original : false)); } }); $form.find("input,select,textarea").not($this).not("[name=\"" + $this.attr("name") + "\"]").trigger("validationLostFocus.validation"); errorsFound = $.unique(errorsFound.sort());
// Were there any errors?
if (errorsFound.length) {
// Better flag it up as a warning.
$controlGroup.removeClass("success error").addClass("warning");
// How many errors did we find?
if (settings.options.semanticallyStrict && errorsFound.length === 1) {
// Only one? Being strict? Just output it.
$helpBlock.html(errorsFound[0] + ( settings.options.prependExistingHelpBlock ? $helpBlock.data("original-contents") : "" )); } else {
// Multiple? Being sloppy? Glue them together into an UL.
$helpBlock.html("<ul role=\"alert\"><li>" + errorsFound.join("</li><li>") + "</li></ul>" + ( settings.options.prependExistingHelpBlock ? $helpBlock.data("original-contents") : "" )); } } else { $controlGroup.removeClass("warning error success"); if (value.length > 0) { $controlGroup.addClass("success"); } $helpBlock.html($helpBlock.data("original-contents")); } if (e.type === "blur") { $controlGroup.removeClass("success"); } } ); $this.bind("validationLostFocus.validation", function () { $controlGroup.removeClass("success"); }); }); }, destroy : function( ) { return this.each( function() { var $this = $(this), $controlGroup = $this.parents(".control-group").first(), $helpBlock = $controlGroup.find(".help-block").first();
// remove our events
$this.unbind('.validation'); // events are namespaced.
// reset help text
$helpBlock.html($helpBlock.data("original-contents"));
// reset classes
$controlGroup.attr("class", $controlGroup.data("original-classes"));
// reset aria
$this.attr("aria-invalid", $this.data("original-aria-invalid"));
// reset role
$helpBlock.attr("role", $this.data("original-role"));
// remove all elements we created
if (createdElements.indexOf($helpBlock[0]) > -1) { $helpBlock.remove(); } } ); }, collectErrors : function(includeEmpty) { var errorMessages = {}; this.each(function (i, el) { var $el = $(el); var name = $el.attr("name"); var errors = $el.triggerHandler("validation.validation", {includeEmpty: true}); errorMessages[name] = $.extend(true, errors, errorMessages[name]); }); $.each(errorMessages, function (i, el) { if (el.length === 0) { delete errorMessages[i]; } }); return errorMessages; }, hasErrors: function() { var errorMessages = []; this.each(function (i, el) { errorMessages = errorMessages.concat( $(el).triggerHandler("getValidators.validation") ? $(el).triggerHandler("validation.validation", {submitting: true}) : [] ); }); return (errorMessages.length > 0); }, override : function (newDefaults) { defaults = $.extend(true, defaults, newDefaults); } }, validatorTypes: { callback: { name: "callback", init: function ($this, name) { return { validatorName: name, callback: $this.data("validation" + name + "Callback"), lastValue: $this.val(), lastValid: true, lastFinished: true }; }, validate: function ($this, value, validator) { if (validator.lastValue === value && validator.lastFinished) { return !validator.lastValid; } if (validator.lastFinished === true) { validator.lastValue = value; validator.lastValid = true; validator.lastFinished = false; var rrjqbvValidator = validator; var rrjqbvThis = $this; executeFunctionByName( validator.callback, window, $this, value, function (data) { if (rrjqbvValidator.lastValue === data.value) { rrjqbvValidator.lastValid = data.valid; if (data.message) { rrjqbvValidator.message = data.message; } rrjqbvValidator.lastFinished = true; rrjqbvThis.data("validation" + rrjqbvValidator.validatorName + "Message", rrjqbvValidator.message);
// Timeout is set to avoid problems with the events being considered 'already fired'
setTimeout(function () { rrjqbvThis.trigger("change.validation");
}, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
} } ); } return false; } }, ajax: { name: "ajax", init: function ($this, name) { return { validatorName: name, url: $this.data("validation" + name + "Ajax"), lastValue: $this.val(), lastValid: true, lastFinished: true }; }, validate: function ($this, value, validator) { if (""+validator.lastValue === ""+value && validator.lastFinished === true) { return validator.lastValid === false; } if (validator.lastFinished === true) { validator.lastValue = value; validator.lastValid = true; validator.lastFinished = false; $.ajax({ url: validator.url, data: "value=" + value + "&field=" + $this.attr("name"), dataType: "json", success: function (data) { if (""+validator.lastValue === ""+data.value) { validator.lastValid = !!(data.valid); if (data.message) { validator.message = data.message; } validator.lastFinished = true; $this.data("validation" + validator.validatorName + "Message", validator.message);
// Timeout is set to avoid problems with the events being considered 'already fired'
setTimeout(function () { $this.trigger("change.validation");
}, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
} }, failure: function () { validator.lastValid = true; validator.message = "ajax call failed"; validator.lastFinished = true; $this.data("validation" + validator.validatorName + "Message", validator.message);
// Timeout is set to avoid problems with the events being considered 'already fired'
setTimeout(function () { $this.trigger("change.validation");
}, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
} }); } return false; } }, regex: { name: "regex", init: function ($this, name) { return {regex: regexFromString($this.data("validation" + name + "Regex"))}; }, validate: function ($this, value, validator) { return (!validator.regex.test(value) && ! validator.negative) || (validator.regex.test(value) && validator.negative); } }, required: { name: "required", init: function ($this, name) { return {}; }, validate: function ($this, value, validator) { return !!(value.length === 0 && ! validator.negative) || !!(value.length > 0 && validator.negative); }, blockSubmit: true }, match: { name: "match", init: function ($this, name) { var element = $this.parents("form").first().find("[name=\"" + $this.data("validation" + name + "Match") + "\"]").first(); element.bind("validation.validation", function () { $this.trigger("change.validation", {submitting: true}); }); return {"element": element}; }, validate: function ($this, value, validator) { return (value !== validator.element.val() && ! validator.negative) || (value === validator.element.val() && validator.negative); }, blockSubmit: true }, max: { name: "max", init: function ($this, name) { return {max: $this.data("validation" + name + "Max")}; }, validate: function ($this, value, validator) { return (parseFloat(value, 10) > parseFloat(validator.max, 10) && ! validator.negative) || (parseFloat(value, 10) <= parseFloat(validator.max, 10) && validator.negative); } }, min: { name: "min", init: function ($this, name) { return {min: $this.data("validation" + name + "Min")}; }, validate: function ($this, value, validator) { return (parseFloat(value) < parseFloat(validator.min) && ! validator.negative) || (parseFloat(value) >= parseFloat(validator.min) && validator.negative); } }, maxlength: { name: "maxlength", init: function ($this, name) { return {maxlength: $this.data("validation" + name + "Maxlength")}; }, validate: function ($this, value, validator) { return ((value.length > validator.maxlength) && ! validator.negative) || ((value.length <= validator.maxlength) && validator.negative); } }, minlength: { name: "minlength", init: function ($this, name) { return {minlength: $this.data("validation" + name + "Minlength")}; }, validate: function ($this, value, validator) { return ((value.length < validator.minlength) && ! validator.negative) || ((value.length >= validator.minlength) && validator.negative); } }, maxchecked: { name: "maxchecked", init: function ($this, name) { var elements = $this.parents("form").first().find("[name=\"" + $this.attr("name") + "\"]"); elements.bind("click.validation", function () { $this.trigger("change.validation", {includeEmpty: true}); }); return {maxchecked: $this.data("validation" + name + "Maxchecked"), elements: elements}; }, validate: function ($this, value, validator) { return (validator.elements.filter(":checked").length > validator.maxchecked && ! validator.negative) || (validator.elements.filter(":checked").length <= validator.maxchecked && validator.negative); }, blockSubmit: true }, minchecked: { name: "minchecked", init: function ($this, name) { var elements = $this.parents("form").first().find("[name=\"" + $this.attr("name") + "\"]"); elements.bind("click.validation", function () { $this.trigger("change.validation", {includeEmpty: true}); }); return {minchecked: $this.data("validation" + name + "Minchecked"), elements: elements}; }, validate: function ($this, value, validator) { return (validator.elements.filter(":checked").length < validator.minchecked && ! validator.negative) || (validator.elements.filter(":checked").length >= validator.minchecked && validator.negative); }, blockSubmit: true } }, builtInValidators: { email: { name: "Email", type: "shortcut", shortcut: "validemail" }, validemail: { name: "Validemail", type: "regex", regex: "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\.[A-Za-z]{2,4}", message: "Not a valid email address<!-- data-validator-validemail-message to override -->" }, passwordagain: { name: "Passwordagain", type: "match", match: "password", message: "Does not match the given password<!-- data-validator-paswordagain-message to override -->" }, positive: { name: "Positive", type: "shortcut", shortcut: "number,positivenumber" }, negative: { name: "Negative", type: "shortcut", shortcut: "number,negativenumber" }, number: { name: "Number", type: "regex", regex: "([+-]?\\\d+(\\\.\\\d*)?([eE][+-]?[0-9]+)?)?", message: "Must be a number<!-- data-validator-number-message to override -->" }, integer: { name: "Integer", type: "regex", regex: "[+-]?\\\d+", message: "No decimal places allowed<!-- data-validator-integer-message to override -->" }, positivenumber: { name: "Positivenumber", type: "min", min: 0, message: "Must be a positive number<!-- data-validator-positivenumber-message to override -->" }, negativenumber: { name: "Negativenumber", type: "max", max: 0, message: "Must be a negative number<!-- data-validator-negativenumber-message to override -->" }, required: { name: "Required", type: "required", message: "This is required<!-- data-validator-required-message to override -->" }, checkone: { name: "Checkone", type: "minchecked", minchecked: 1, message: "Check at least one option<!-- data-validation-checkone-message to override -->" } } }; var formatValidatorName = function (name) { return name .toLowerCase() .replace( /(^|\s)([a-z])/g , function(m,p1,p2) { return p1+p2.toUpperCase(); } ) ; }; var getValue = function ($this) {
// Extract the value we're talking about
var value = $this.val(); var type = $this.attr("type"); if (type === "checkbox") { value = ($this.is(":checked") ? value : ""); } if (type === "radio") { value = ($('input[name="' + $this.attr("name") + '"]:checked').length > 0 ? value : ""); } return value; }; function regexFromString(inputstring) { return new RegExp("^" + inputstring + "$"); }
/**
* Thanks to Jason Bunting via StackOverflow.com *
* http://stackoverflow.com/questions/359788/how-to-execute-a-javascript-function-when-i-have-its-name-as-a-string#answer-359910
* Short link: http://tinyurl.com/executeFunctionByName
**/
function executeFunctionByName(functionName, context /*, args*/) {
var args = Array.prototype.slice.call(arguments).splice(2); var namespaces = functionName.split("."); var func = namespaces.pop(); for(var i = 0; i < namespaces.length; i++) { context = context[namespaces[i]]; } return context[func].apply(this, args); } $.fn.jqBootstrapValidation = function( method ) { if ( defaults.methods[method] ) { return defaults.methods[method].apply( this, Array.prototype.slice.call( arguments, 1 )); } else if ( typeof method === 'object' || ! method ) { return defaults.methods.init.apply( this, arguments ); } else { $.error( 'Method ' + method + ' does not exist on jQuery.jqBootstrapValidation' ); return null; } }; $.jqBootstrapValidation = function (options) { $(":input").not("[type=image],[type=submit]").jqBootstrapValidation.apply(this,arguments); }; })( jQuery ); $(function() { $("#contactForm input,#contactForm textarea").jqBootstrapValidation({ preventSubmit: true, submitError: function($form, event, errors) {
// additional error messages or events
}, submitSuccess: function($form, event) {
event.preventDefault(); // prevent default submit behaviour
// get values from FORM
var name = $("input#name").val(); var email = $("input#email").val(); var phone = $("input#phone").val(); var message = $("textarea#message").val();
var firstName = name; // For Success/Failure Message
// Check for white space in name for Success/Fail message
if (firstName.indexOf(' ') >= 0) { firstName = name.split(' ').slice(0, -1).join(' '); } $this = $("#sendMessageButton");
$this.prop("disabled", true); // Disable submit button until AJAX call is complete to prevent duplicate messages
$.ajax({
url: "https://contactme.saltos.org/php/contact_me.php",
type: "POST", data: { name: name, phone: phone, email: email, message: message }, cache: false, success: function() {
// Success message
$('#success').html("<div class='alert alert-success'>"); $('#success > .alert-success').html("<button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;") .append("</button>"); $('#success > .alert-success') .append("<strong>"+$("#contactForm").attr("data-validation-ok-message")+"</strong>"); $('#success > .alert-success') .append('</div>');
//clear all fields
$('#contactForm').trigger("reset"); }, error: function() {
// Fail message
$('#success').html("<div class='alert alert-danger'>"); $('#success > .alert-danger').html("<button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;") .append("</button>"); $('#success > .alert-danger').append("<strong>"+$("#contactForm").attr("data-validation-ko-message")+"</strong>"); $('#success > .alert-danger').append('</div>');
//clear all fields
$('#contactForm').trigger("reset"); }, complete: function() { setTimeout(function() {
$this.prop("disabled", false); // Re-enable submit button when AJAX call is complete
}, 1000); } }); }, filter: function() { return $(this).is(":visible"); }, }); $("a[data-toggle=\"tab\"]").click(function(e) { e.preventDefault(); $(this).tab("show"); }); });
/*When clicking on Full hide fail/success boxes */
$('#name').focus(function() { $('#success').html(''); }); (function($) {
"use strict"; // Start of use strict
// Smooth scrolling using jQuery easing
$('a.js-scroll-trigger[href*="#"]:not([href="#"])').click(function() {
if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
var target = $(this.hash); target = target.length ? target : $('[name=' + this.hash.slice(1) + ']'); if (target.length) { $('html, body').animate({ scrollTop: (target.offset().top - 71) }, 1000, "easeInOutExpo"); return false; } } });
// Scroll to top button appear
$(document).scroll(function() { var scrollDistance = $(this).scrollTop(); if (scrollDistance > 100) { $('.scroll-to-top').fadeIn(); } else { $('.scroll-to-top').fadeOut(); } });
// Closes responsive menu when a scroll trigger link is clicked
$('.js-scroll-trigger').click(function() { $('.navbar-collapse').collapse('hide'); });
// Activate scrollspy to add active class to navbar items on scroll
$('body').scrollspy({ target: '#mainNav', offset: 80 });
// Collapse Navbar
var navbarCollapse = function() { if ($("#mainNav").offset().top > 100) { $("#mainNav").addClass("navbar-shrink"); } else { $("#mainNav").removeClass("navbar-shrink"); } };
// Collapse now if page is not at top
navbarCollapse();
// Collapse the navbar when page is scrolled
$(window).scroll(navbarCollapse);
// Floating label headings for the contact form
$(function() { $("body").on("input propertychange", ".floating-label-form-group", function(e) { $(this).toggleClass("floating-label-form-group-with-value", !!$(e.target).val()); }).on("focus", ".floating-label-form-group", function() { $(this).addClass("floating-label-form-group-with-focus"); }).on("blur", ".floating-label-form-group", function() { $(this).removeClass("floating-label-form-group-with-focus"); }); });
})(jQuery); // End of use strict
(function(d){"function"===typeof define&&define.amd?define(["jquery"],d):"object"===typeof exports?module.exports=d(require("jquery")):d(jQuery)})(function(d){function l(b){return f.raw?b:encodeURIComponent(b)}function m(b,e){var a;if(f.raw)a=b;else a:{var c=b;0===c.indexOf('"')&&(c=c.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,"\\"));try{c=decodeURIComponent(c.replace(j," "));a=f.json?JSON.parse(c):c;break a}catch(h){}a=void 0}return d.isFunction(e)?e(a):a}var j=/\+/g,f=d.cookie=function(b,e,
a){if(1<arguments.length&&!d.isFunction(e)){a=d.extend({},f.defaults,a);if("number"===typeof a.expires){var c=a.expires,h=a.expires=new Date;h.setMilliseconds(h.getMilliseconds()+864E5*c)}return document.cookie=[l(b),"=",l(f.json?JSON.stringify(e):""+e),a.expires?"; expires="+a.expires.toUTCString():"",a.path?"; path="+a.path:"",a.domain?"; domain="+a.domain:"",a.secure?"; secure":""].join("")}for(var c=b?void 0:{},h=document.cookie?document.cookie.split("; "):[],k=0,j=h.length;k<j;k++){var g=h[k].split("="),
i;i=g.shift();i=f.raw?i:decodeURIComponent(i);g=g.join("=");if(b===i){c=m(g,e);break}if(!b&&void 0!==(g=m(g)))c[i]=g}return c};f.defaults={};d.removeCookie=function(b,e){d.cookie(b,"",d.extend({},e,{expires:-1}));return!d.cookie(b)}});
"use strict"; $(function() { var colores={ "template":{ ".divider-custom .divider-custom-line":{ "background-color":"#123456", "border-color":"#123456", }, ".divider-custom .divider-custom-icon i":{ "color":"#123456", }, ".divider-custom.divider-light .divider-custom-line":{ "background-color":"#345678", "border-color":"#345678", }, ".divider-custom.divider-light .divider-custom-icon i":{ "color":"#345678", }, ".bg-primary":{ "background-color":"#234567!important", }, ".text-primary":{ "color":"#234567", }, ".btn-primary":{ "color":"#345678", "background-color":"#234567", "border-color":"#234567", }, ".btn-primary:hover":{ "color":"#ffffff", "background-color":"#123456", "border-color":"#123456", }, ".masthead.text-white":{ "color":"#345678!important", }, "#about .text-white":{ "color":"#345678!important", }, ".bg-secondary":{ "background-color":"#123456!important", }, ".text-secondary":{ "color":"#123456!important", }, "#portfolio .portfolio-item-caption":{ "background-color":"rgba(50,100,150,.9)", }, "#portfolio img":{ "background-color":"#234567", }, ".portfolio-modal img":{ "background-color":"#234567", }, ".portfolio-modal .close":{ "color":"#123456", }, ".portfolio-modal a":{ "color":"#123456", "text-decoration":"underline", }, ".portfolio-modal a:hover":{ "text-decoration":"none", }, ".footer":{ "color":"#345678", "background-color":"#234567", }, ".copyright":{ "background-color":"#123456", }, ".copyright a":{ "color":"#ffffff", "text-decoration":"underline", }, ".copyright a:hover":{ "text-decoration":"none", }, ".btn-outline-light":{ "color":"#345678", "border-color":"#345678", }, ".btn-outline-light:hover":{ "color":"#234567", "background-color":"#345678", "border-color":"#345678", }, "#mainNav .nav-link.active":{ "background-color":"#234567!important", "color":"#345678!important", }, "#mainNav .nav-link:hover":{ "background-color":"#234567", "color":"#345678!important", }, "#mainNav button":{ "color":"#345678!important", }, "#mainNav button:hover":{ "background-color":"#345678!important", "color":"#234567!important", } } }; var counter=0; var nombre=["original","blue","green","red","yellow"]; var color1=["2c3e50","1a3561","144321","5d1a15","644b02"]; var color2=["1abc9c","4285f4","34a853","ea4335","fbbc05"]; var color3=[]; var color4=["ffffff","ffffff","ffffff","ffffff","000000"]; var color5=["15997f","4285f4","2f994c","ea4335","cc9904"]; for(var k in nombre) { var color=nombre[k]; colores[color]={}; color3[k]=parseInt(color1[k].substr(0,2),16)+","+parseInt(color1[k].substr(2,2),16)+","+parseInt(color1[k].substr(4,2),16); for(var i in colores["template"]) { colores[color][i]={}; for(var j in colores["template"][i]) { colores[color][i][j]=colores["template"][i][j].replace("123456",color1[k]).replace("234567",color2[k]).replace("50,100,150",color3[k]).replace("345678",color4[k]); } } } $("body").on("color",function() { var color=nombre[counter]; for(var i in colores[color]) { for(var j in colores[color][i]) { $("body").append("<style>"+i+"{"+j+":"+colores[color][i][j]+"}</style>"); } } color=color2[counter]; $("meta[name='theme-color']").attr("content","#"+color); color=color5[counter]; $("#viewerContainer").attr("data-color",color); }); $("body").on("click",function(e) { if($(e.target).is("a")) return; if($(e.target).is("button")) return; if($(e.target).is("i")) return; if($(e.target).is("div.portfolio-item-caption")) return; if($(e.target).is("input")) return; if($(e.target).is("textarea")) return; counter=(counter+1)%nombre.length; $("body").trigger("color"); $("body").trigger("pdfjs"); $.cookie("color",counter,{expires:365,path:"/"}); }); counter=parseInt($.cookie("color"));
//~ if(isNaN(counter)) counter=Math.floor(Math.random()*nombre.length);
if(isNaN(counter)) counter=0; $("body").trigger("color"); $("body").trigger("pdfjs"); $.cookie("color",counter,{expires:365,path:"/"}); var lang=window.location.href.split("/").pop().split(".")[1]; $.cookie("lang",lang,{expires:365,path:"/"}); });
/**
* @licstart The following is the entire license notice for the * Javascript code in this page * * Copyright 2020 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *
* http://www.apache.org/licenses/LICENSE-2.0
* * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * Javascript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define("pdfjs-dist/build/pdf", [], factory); else if(typeof exports === 'object') exports["pdfjs-dist/build/pdf"] = factory(); else root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory(); })(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__w_pdfjs_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__w_pdfjs_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
/******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__w_pdfjs_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__w_pdfjs_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __w_pdfjs_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__w_pdfjs_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __w_pdfjs_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__w_pdfjs_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__w_pdfjs_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); Object.defineProperty(exports, "addLinkAttributes", { enumerable: true, get: function () { return _display_utils.addLinkAttributes; } }); Object.defineProperty(exports, "getFilenameFromUrl", { enumerable: true, get: function () { return _display_utils.getFilenameFromUrl; } }); Object.defineProperty(exports, "LinkTarget", { enumerable: true, get: function () { return _display_utils.LinkTarget; } }); Object.defineProperty(exports, "loadScript", { enumerable: true, get: function () { return _display_utils.loadScript; } }); Object.defineProperty(exports, "PDFDateString", { enumerable: true, get: function () { return _display_utils.PDFDateString; } }); Object.defineProperty(exports, "RenderingCancelledException", { enumerable: true, get: function () { return _display_utils.RenderingCancelledException; } }); Object.defineProperty(exports, "build", { enumerable: true, get: function () { return _api.build; } }); Object.defineProperty(exports, "getDocument", { enumerable: true, get: function () { return _api.getDocument; } }); Object.defineProperty(exports, "LoopbackPort", { enumerable: true, get: function () { return _api.LoopbackPort; } }); Object.defineProperty(exports, "PDFDataRangeTransport", { enumerable: true, get: function () { return _api.PDFDataRangeTransport; } }); Object.defineProperty(exports, "PDFWorker", { enumerable: true, get: function () { return _api.PDFWorker; } }); Object.defineProperty(exports, "version", { enumerable: true, get: function () { return _api.version; } }); Object.defineProperty(exports, "CMapCompressionType", { enumerable: true, get: function () { return _util.CMapCompressionType; } }); Object.defineProperty(exports, "createObjectURL", { enumerable: true, get: function () { return _util.createObjectURL; } }); Object.defineProperty(exports, "createPromiseCapability", { enumerable: true, get: function () { return _util.createPromiseCapability; } }); Object.defineProperty(exports, "createValidAbsoluteUrl", { enumerable: true, get: function () { return _util.createValidAbsoluteUrl; } }); Object.defineProperty(exports, "InvalidPDFException", { enumerable: true, get: function () { return _util.InvalidPDFException; } }); Object.defineProperty(exports, "MissingPDFException", { enumerable: true, get: function () { return _util.MissingPDFException; } }); Object.defineProperty(exports, "OPS", { enumerable: true, get: function () { return _util.OPS; } }); Object.defineProperty(exports, "PasswordResponses", { enumerable: true, get: function () { return _util.PasswordResponses; } }); Object.defineProperty(exports, "PermissionFlag", { enumerable: true, get: function () { return _util.PermissionFlag; } }); Object.defineProperty(exports, "removeNullCharacters", { enumerable: true, get: function () { return _util.removeNullCharacters; } }); Object.defineProperty(exports, "shadow", { enumerable: true, get: function () { return _util.shadow; } }); Object.defineProperty(exports, "UnexpectedResponseException", { enumerable: true, get: function () { return _util.UnexpectedResponseException; } }); Object.defineProperty(exports, "UNSUPPORTED_FEATURES", { enumerable: true, get: function () { return _util.UNSUPPORTED_FEATURES; } }); Object.defineProperty(exports, "Util", { enumerable: true, get: function () { return _util.Util; } }); Object.defineProperty(exports, "VerbosityLevel", { enumerable: true, get: function () { return _util.VerbosityLevel; } }); Object.defineProperty(exports, "AnnotationLayer", { enumerable: true, get: function () { return _annotation_layer.AnnotationLayer; } }); Object.defineProperty(exports, "apiCompatibilityParams", { enumerable: true, get: function () { return _api_compatibility.apiCompatibilityParams; } }); Object.defineProperty(exports, "GlobalWorkerOptions", { enumerable: true, get: function () { return _worker_options.GlobalWorkerOptions; } }); Object.defineProperty(exports, "renderTextLayer", { enumerable: true, get: function () { return _text_layer.renderTextLayer; } }); Object.defineProperty(exports, "SVGGraphics", { enumerable: true, get: function () { return _svg.SVGGraphics; } }); var _display_utils = __w_pdfjs_require__(1); var _api = __w_pdfjs_require__(5); var _util = __w_pdfjs_require__(2); var _annotation_layer = __w_pdfjs_require__(19); var _api_compatibility = __w_pdfjs_require__(9); var _worker_options = __w_pdfjs_require__(12); var _text_layer = __w_pdfjs_require__(20); var _svg = __w_pdfjs_require__(21); const pdfjsVersion = '2.6.347'; const pdfjsBuild = '3be9c65f0'; { const { isNodeJS } = __w_pdfjs_require__(4); if (isNodeJS) { const PDFNodeStream = __w_pdfjs_require__(22).PDFNodeStream; (0, _api.setPDFNetworkStreamFactory)(params => { return new PDFNodeStream(params); }); } else { const PDFNetworkStream = __w_pdfjs_require__(25).PDFNetworkStream; let PDFFetchStream; if ((0, _display_utils.isFetchSupported)()) { PDFFetchStream = __w_pdfjs_require__(26).PDFFetchStream; } (0, _api.setPDFNetworkStreamFactory)(params => { if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) { return new PDFFetchStream(params); } return new PDFNetworkStream(params); }); } }
/***/ }),
/* 1 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.addLinkAttributes = addLinkAttributes; exports.getFilenameFromUrl = getFilenameFromUrl; exports.isFetchSupported = isFetchSupported; exports.isValidFetchUrl = isValidFetchUrl; exports.loadScript = loadScript; exports.deprecated = deprecated;
exports.PDFDateString = exports.StatTimer = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.BaseCMapReaderFactory = exports.DOMCanvasFactory = exports.BaseCanvasFactory = exports.DEFAULT_LINK_REL = exports.LinkTarget = exports.RenderingCancelledException = exports.PageViewport = void 0;
var _util = __w_pdfjs_require__(2); const DEFAULT_LINK_REL = "noopener noreferrer nofollow"; exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
const SVG_NS = "http://www.w3.org/2000/svg";
class BaseCanvasFactory { constructor() { if (this.constructor === BaseCanvasFactory) { (0, _util.unreachable)("Cannot initialize BaseCanvasFactory."); } } create(width, height) { (0, _util.unreachable)("Abstract method `create` called."); } reset(canvasAndContext, width, height) { if (!canvasAndContext.canvas) { throw new Error("Canvas is not specified"); } if (width <= 0 || height <= 0) { throw new Error("Invalid canvas size"); } canvasAndContext.canvas.width = width; canvasAndContext.canvas.height = height; } destroy(canvasAndContext) { if (!canvasAndContext.canvas) { throw new Error("Canvas is not specified"); } canvasAndContext.canvas.width = 0; canvasAndContext.canvas.height = 0; canvasAndContext.canvas = null; canvasAndContext.context = null; } } exports.BaseCanvasFactory = BaseCanvasFactory; class DOMCanvasFactory extends BaseCanvasFactory { constructor({ ownerDocument = globalThis.document } = {}) { super(); this._document = ownerDocument; } create(width, height) { if (width <= 0 || height <= 0) { throw new Error("Invalid canvas size"); } const canvas = this._document.createElement("canvas"); const context = canvas.getContext("2d"); canvas.width = width; canvas.height = height; return { canvas, context }; } } exports.DOMCanvasFactory = DOMCanvasFactory; class BaseCMapReaderFactory { constructor({ baseUrl = null, isCompressed = false }) { if (this.constructor === BaseCMapReaderFactory) { (0, _util.unreachable)("Cannot initialize BaseCMapReaderFactory."); } this.baseUrl = baseUrl; this.isCompressed = isCompressed; } async fetch({ name }) { if (!this.baseUrl) { throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.'); } if (!name) { throw new Error("CMap name must be specified."); } const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : ""); const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE; return this._fetchData(url, compressionType).catch(reason => { throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`); }); } _fetchData(url, compressionType) { (0, _util.unreachable)("Abstract method `_fetchData` called."); } } exports.BaseCMapReaderFactory = BaseCMapReaderFactory; class DOMCMapReaderFactory extends BaseCMapReaderFactory { _fetchData(url, compressionType) { if (isFetchSupported() && isValidFetchUrl(url, document.baseURI)) { return fetch(url).then(async response => { if (!response.ok) { throw new Error(response.statusText); } let cMapData; if (this.isCompressed) { cMapData = new Uint8Array(await response.arrayBuffer()); } else { cMapData = (0, _util.stringToBytes)(await response.text()); } return { cMapData, compressionType }; }); } return new Promise((resolve, reject) => { const request = new XMLHttpRequest(); request.open("GET", url, true); if (this.isCompressed) { request.responseType = "arraybuffer"; } request.onreadystatechange = () => { if (request.readyState !== XMLHttpRequest.DONE) { return; } if (request.status === 200 || request.status === 0) { let cMapData; if (this.isCompressed && request.response) { cMapData = new Uint8Array(request.response); } else if (!this.isCompressed && request.responseText) { cMapData = (0, _util.stringToBytes)(request.responseText); } if (cMapData) { resolve({ cMapData, compressionType }); return; } } reject(new Error(request.statusText)); }; request.send(null); }); } } exports.DOMCMapReaderFactory = DOMCMapReaderFactory; class DOMSVGFactory { create(width, height) { (0, _util.assert)(width > 0 && height > 0, "Invalid SVG dimensions"); const svg = document.createElementNS(SVG_NS, "svg:svg"); svg.setAttribute("version", "1.1"); svg.setAttribute("width", width + "px"); svg.setAttribute("height", height + "px"); svg.setAttribute("preserveAspectRatio", "none"); svg.setAttribute("viewBox", "0 0 " + width + " " + height); return svg; } createElement(type) { (0, _util.assert)(typeof type === "string", "Invalid SVG element type"); return document.createElementNS(SVG_NS, type); } } exports.DOMSVGFactory = DOMSVGFactory; class PageViewport { constructor({ viewBox, scale, rotation, offsetX = 0, offsetY = 0, dontFlip = false }) { this.viewBox = viewBox; this.scale = scale; this.rotation = rotation; this.offsetX = offsetX; this.offsetY = offsetY; const centerX = (viewBox[2] + viewBox[0]) / 2; const centerY = (viewBox[3] + viewBox[1]) / 2; let rotateA, rotateB, rotateC, rotateD; rotation = rotation % 360; rotation = rotation < 0 ? rotation + 360 : rotation; switch (rotation) { case 180: rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1; break; case 90: rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0; break; case 270: rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0; break; case 0: rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1; break; default: throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees."); } if (dontFlip) { rotateC = -rotateC; rotateD = -rotateD; } let offsetCanvasX, offsetCanvasY; let width, height; if (rotateA === 0) { offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX; offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY; width = Math.abs(viewBox[3] - viewBox[1]) * scale; height = Math.abs(viewBox[2] - viewBox[0]) * scale; } else { offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX; offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY; width = Math.abs(viewBox[2] - viewBox[0]) * scale; height = Math.abs(viewBox[3] - viewBox[1]) * scale; }
this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
this.width = width; this.height = height; } clone({ scale = this.scale, rotation = this.rotation, offsetX = this.offsetX, offsetY = this.offsetY, dontFlip = false } = {}) { return new PageViewport({ viewBox: this.viewBox.slice(), scale, rotation, offsetX, offsetY, dontFlip }); } convertToViewportPoint(x, y) { return _util.Util.applyTransform([x, y], this.transform); } convertToViewportRectangle(rect) { const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform); const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform); return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]]; } convertToPdfPoint(x, y) { return _util.Util.applyInverseTransform([x, y], this.transform); } } exports.PageViewport = PageViewport; class RenderingCancelledException extends _util.BaseException { constructor(msg, type) { super(msg); this.type = type; } } exports.RenderingCancelledException = RenderingCancelledException; const LinkTarget = { NONE: 0, SELF: 1, BLANK: 2, PARENT: 3, TOP: 4 }; exports.LinkTarget = LinkTarget; function addLinkAttributes(link, { url, target, rel, enabled = true } = {}) { (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.'); const urlNullRemoved = (0, _util.removeNullCharacters)(url); if (enabled) { link.href = link.title = urlNullRemoved; } else { link.href = ""; link.title = `Disabled: ${urlNullRemoved}`; link.onclick = () => { return false; }; } let targetStr = ""; switch (target) { case LinkTarget.NONE: break; case LinkTarget.SELF: targetStr = "_self"; break; case LinkTarget.BLANK: targetStr = "_blank"; break; case LinkTarget.PARENT: targetStr = "_parent"; break; case LinkTarget.TOP: targetStr = "_top"; break; } link.target = targetStr; link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL; } function getFilenameFromUrl(url) { const anchor = url.indexOf("#"); const query = url.indexOf("?"); const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length); return url.substring(url.lastIndexOf("/", end) + 1, end); } class StatTimer { constructor() { this.started = Object.create(null); this.times = []; } time(name) { if (name in this.started) { (0, _util.warn)(`Timer is already running for ${name}`); } this.started[name] = Date.now(); } timeEnd(name) { if (!(name in this.started)) { (0, _util.warn)(`Timer has not been started for ${name}`); } this.times.push({ name, start: this.started[name], end: Date.now() }); delete this.started[name]; } toString() { const outBuf = []; let longest = 0; for (const time of this.times) { const name = time.name; if (name.length > longest) { longest = name.length; } } for (const time of this.times) { const duration = time.end - time.start; outBuf.push(`${time.name.padEnd(longest)} ${duration}ms\n`); } return outBuf.join(""); } } exports.StatTimer = StatTimer; function isFetchSupported() { return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined"; } function isValidFetchUrl(url, baseUrl) { try { const { protocol } = baseUrl ? new URL(url, baseUrl) : new URL(url); return protocol === "http:" || protocol === "https:"; } catch (ex) { return false; } } function loadScript(src) { return new Promise((resolve, reject) => { const script = document.createElement("script"); script.src = src; script.onload = resolve; script.onerror = function () { reject(new Error(`Cannot load script at: ${script.src}`)); }; (document.head || document.documentElement).appendChild(script); }); } function deprecated(details) { console.log("Deprecated API usage: " + details); } let pdfDateStringRegex; class PDFDateString { static toDateObject(input) { if (!input || !(0, _util.isString)(input)) { return null; } if (!pdfDateStringRegex) { pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?"); } const matches = pdfDateStringRegex.exec(input); if (!matches) { return null; } const year = parseInt(matches[1], 10); let month = parseInt(matches[2], 10); month = month >= 1 && month <= 12 ? month - 1 : 0; let day = parseInt(matches[3], 10); day = day >= 1 && day <= 31 ? day : 1; let hour = parseInt(matches[4], 10); hour = hour >= 0 && hour <= 23 ? hour : 0; let minute = parseInt(matches[5], 10); minute = minute >= 0 && minute <= 59 ? minute : 0; let second = parseInt(matches[6], 10); second = second >= 0 && second <= 59 ? second : 0; const universalTimeRelation = matches[7] || "Z"; let offsetHour = parseInt(matches[8], 10); offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0; let offsetMinute = parseInt(matches[9], 10) || 0; offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0; if (universalTimeRelation === "-") { hour += offsetHour; minute += offsetMinute; } else if (universalTimeRelation === "+") { hour -= offsetHour; minute -= offsetMinute; } return new Date(Date.UTC(year, month, day, hour, minute, second)); } } exports.PDFDateString = PDFDateString;
/***/ }),
/* 2 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.arrayByteLength = arrayByteLength; exports.arraysToBytes = arraysToBytes; exports.assert = assert; exports.bytesToString = bytesToString; exports.createPromiseCapability = createPromiseCapability; exports.escapeString = escapeString; exports.getModificationDate = getModificationDate; exports.getVerbosityLevel = getVerbosityLevel; exports.info = info; exports.isArrayBuffer = isArrayBuffer; exports.isArrayEqual = isArrayEqual; exports.isBool = isBool; exports.isNum = isNum; exports.isString = isString; exports.isSameOrigin = isSameOrigin; exports.createValidAbsoluteUrl = createValidAbsoluteUrl; exports.removeNullCharacters = removeNullCharacters; exports.setVerbosityLevel = setVerbosityLevel; exports.shadow = shadow; exports.string32 = string32; exports.stringToBytes = stringToBytes; exports.stringToPDFString = stringToPDFString; exports.stringToUTF8String = stringToUTF8String; exports.utf8StringToString = utf8StringToString; exports.warn = warn; exports.unreachable = unreachable;
exports.IsEvalSupportedCached = exports.IsLittleEndianCached = exports.createObjectURL = exports.FormatError = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.MissingPDFException = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VerbosityLevel = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = exports.BaseException = void 0;
__w_pdfjs_require__(3); const IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]; exports.IDENTITY_MATRIX = IDENTITY_MATRIX; const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0]; exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX; const PermissionFlag = { PRINT: 0x04, MODIFY_CONTENTS: 0x08, COPY: 0x10, MODIFY_ANNOTATIONS: 0x20, FILL_INTERACTIVE_FORMS: 0x100, COPY_FOR_ACCESSIBILITY: 0x200, ASSEMBLE: 0x400, PRINT_HIGH_QUALITY: 0x800 }; exports.PermissionFlag = PermissionFlag; const TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; exports.TextRenderingMode = TextRenderingMode; const ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; exports.ImageKind = ImageKind; const AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }; exports.AnnotationType = AnnotationType; const AnnotationStateModelType = { MARKED: "Marked", REVIEW: "Review" }; exports.AnnotationStateModelType = AnnotationStateModelType; const AnnotationMarkedState = { MARKED: "Marked", UNMARKED: "Unmarked" }; exports.AnnotationMarkedState = AnnotationMarkedState; const AnnotationReviewState = { ACCEPTED: "Accepted", REJECTED: "Rejected", CANCELLED: "Cancelled", COMPLETED: "Completed", NONE: "None" }; exports.AnnotationReviewState = AnnotationReviewState; const AnnotationReplyType = { GROUP: "Group", REPLY: "R" }; exports.AnnotationReplyType = AnnotationReplyType; const AnnotationFlag = { INVISIBLE: 0x01, HIDDEN: 0x02, PRINT: 0x04, NOZOOM: 0x08, NOROTATE: 0x10, NOVIEW: 0x20, READONLY: 0x40, LOCKED: 0x80, TOGGLENOVIEW: 0x100, LOCKEDCONTENTS: 0x200 }; exports.AnnotationFlag = AnnotationFlag; const AnnotationFieldFlag = { READONLY: 0x0000001, REQUIRED: 0x0000002, NOEXPORT: 0x0000004, MULTILINE: 0x0001000, PASSWORD: 0x0002000, NOTOGGLETOOFF: 0x0004000, RADIO: 0x0008000, PUSHBUTTON: 0x0010000, COMBO: 0x0020000, EDIT: 0x0040000, SORT: 0x0080000, FILESELECT: 0x0100000, MULTISELECT: 0x0200000, DONOTSPELLCHECK: 0x0400000, DONOTSCROLL: 0x0800000, COMB: 0x1000000, RICHTEXT: 0x2000000, RADIOSINUNISON: 0x2000000, COMMITONSELCHANGE: 0x4000000 }; exports.AnnotationFieldFlag = AnnotationFieldFlag; const AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; exports.AnnotationBorderStyleType = AnnotationBorderStyleType; const StreamType = { UNKNOWN: "UNKNOWN", FLATE: "FLATE", LZW: "LZW", DCT: "DCT", JPX: "JPX", JBIG: "JBIG", A85: "A85", AHX: "AHX", CCF: "CCF", RLX: "RLX" }; exports.StreamType = StreamType; const FontType = { UNKNOWN: "UNKNOWN", TYPE1: "TYPE1", TYPE1C: "TYPE1C", CIDFONTTYPE0: "CIDFONTTYPE0", CIDFONTTYPE0C: "CIDFONTTYPE0C", TRUETYPE: "TRUETYPE", CIDFONTTYPE2: "CIDFONTTYPE2", TYPE3: "TYPE3", OPENTYPE: "OPENTYPE", TYPE0: "TYPE0", MMTYPE1: "MMTYPE1" }; exports.FontType = FontType; const VerbosityLevel = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }; exports.VerbosityLevel = VerbosityLevel; const CMapCompressionType = { NONE: 0, BINARY: 1, STREAM: 2 }; exports.CMapCompressionType = CMapCompressionType; const OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotations: 78, endAnnotations: 79, beginAnnotation: 80, endAnnotation: 81, paintJpegXObject: 82, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; exports.OPS = OPS; const UNSUPPORTED_FEATURES = { unknown: "unknown", forms: "forms", javaScript: "javaScript", smask: "smask", shadingPattern: "shadingPattern", font: "font", errorTilingPattern: "errorTilingPattern", errorExtGState: "errorExtGState", errorXObject: "errorXObject", errorFontLoadType3: "errorFontLoadType3", errorFontState: "errorFontState", errorFontMissing: "errorFontMissing", errorFontTranslate: "errorFontTranslate", errorColorSpace: "errorColorSpace", errorOperatorList: "errorOperatorList", errorFontToUnicode: "errorFontToUnicode", errorFontLoadNative: "errorFontLoadNative", errorFontGetPath: "errorFontGetPath", errorMarkedContent: "errorMarkedContent" }; exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES; const PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; exports.PasswordResponses = PasswordResponses; let verbosity = VerbosityLevel.WARNINGS; function setVerbosityLevel(level) { if (Number.isInteger(level)) { verbosity = level; } } function getVerbosityLevel() { return verbosity; } function info(msg) { if (verbosity >= VerbosityLevel.INFOS) { console.log(`Info: ${msg}`); } } function warn(msg) { if (verbosity >= VerbosityLevel.WARNINGS) { console.log(`Warning: ${msg}`); } } function unreachable(msg) { throw new Error(msg); } function assert(cond, msg) { if (!cond) { unreachable(msg); } } function isSameOrigin(baseUrl, otherUrl) { let base; try { base = new URL(baseUrl); if (!base.origin || base.origin === "null") { return false; } } catch (e) { return false; } const other = new URL(otherUrl, base); return base.origin === other.origin; } function _isValidProtocol(url) { if (!url) { return false; } switch (url.protocol) { case "http:": case "https:": case "ftp:": case "mailto:": case "tel:": return true; default: return false; } } function createValidAbsoluteUrl(url, baseUrl) { if (!url) { return null; } try { const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url); if (_isValidProtocol(absoluteUrl)) { return absoluteUrl; } } catch (ex) {} return null; } function shadow(obj, prop, value) { Object.defineProperty(obj, prop, { value, enumerable: true, configurable: true, writable: false }); return value; } const BaseException = function BaseExceptionClosure() { function BaseException(message) { if (this.constructor === BaseException) { unreachable("Cannot initialize BaseException."); } this.message = message; this.name = this.constructor.name; } BaseException.prototype = new Error(); BaseException.constructor = BaseException; return BaseException; }(); exports.BaseException = BaseException; class PasswordException extends BaseException { constructor(msg, code) { super(msg); this.code = code; } } exports.PasswordException = PasswordException; class UnknownErrorException extends BaseException { constructor(msg, details) { super(msg); this.details = details; } } exports.UnknownErrorException = UnknownErrorException; class InvalidPDFException extends BaseException {} exports.InvalidPDFException = InvalidPDFException; class MissingPDFException extends BaseException {} exports.MissingPDFException = MissingPDFException; class UnexpectedResponseException extends BaseException { constructor(msg, status) { super(msg); this.status = status; } } exports.UnexpectedResponseException = UnexpectedResponseException; class FormatError extends BaseException {} exports.FormatError = FormatError; class AbortException extends BaseException {} exports.AbortException = AbortException; const NullCharactersRegExp = /\x00/g; function removeNullCharacters(str) { if (typeof str !== "string") { warn("The argument for removeNullCharacters must be a string."); return str; } return str.replace(NullCharactersRegExp, ""); } function bytesToString(bytes) { assert(bytes !== null && typeof bytes === "object" && bytes.length !== undefined, "Invalid argument for bytesToString"); const length = bytes.length; const MAX_ARGUMENT_COUNT = 8192; if (length < MAX_ARGUMENT_COUNT) { return String.fromCharCode.apply(null, bytes); } const strBuf = []; for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) { const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length); const chunk = bytes.subarray(i, chunkEnd); strBuf.push(String.fromCharCode.apply(null, chunk)); } return strBuf.join(""); } function stringToBytes(str) { assert(typeof str === "string", "Invalid argument for stringToBytes"); const length = str.length; const bytes = new Uint8Array(length); for (let i = 0; i < length; ++i) { bytes[i] = str.charCodeAt(i) & 0xff; } return bytes; } function arrayByteLength(arr) { if (arr.length !== undefined) { return arr.length; } assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument."); return arr.byteLength; } function arraysToBytes(arr) { const length = arr.length; if (length === 1 && arr[0] instanceof Uint8Array) { return arr[0]; } let resultLength = 0; for (let i = 0; i < length; i++) { resultLength += arrayByteLength(arr[i]); } let pos = 0; const data = new Uint8Array(resultLength); for (let i = 0; i < length; i++) { let item = arr[i]; if (!(item instanceof Uint8Array)) { if (typeof item === "string") { item = stringToBytes(item); } else { item = new Uint8Array(item); } } const itemLength = item.byteLength; data.set(item, pos); pos += itemLength; } return data; } function string32(value) { return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff); } function isLittleEndian() { const buffer8 = new Uint8Array(4); buffer8[0] = 1; const view32 = new Uint32Array(buffer8.buffer, 0, 1); return view32[0] === 1; } const IsLittleEndianCached = { get value() { return shadow(this, "value", isLittleEndian()); } }; exports.IsLittleEndianCached = IsLittleEndianCached; function isEvalSupported() { try { new Function(""); return true; } catch (e) { return false; } } const IsEvalSupportedCached = { get value() { return shadow(this, "value", isEvalSupported()); } }; exports.IsEvalSupportedCached = IsEvalSupportedCached; const rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"]; class Util { static makeCssRgb(r, g, b) { rgbBuf[1] = r; rgbBuf[3] = g; rgbBuf[5] = b; return rgbBuf.join(""); } static transform(m1, m2) {
return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
} static applyTransform(p, m) { const xt = p[0] * m[0] + p[1] * m[2] + m[4]; const yt = p[0] * m[1] + p[1] * m[3] + m[5]; return [xt, yt]; } static applyInverseTransform(p, m) { const d = m[0] * m[3] - m[1] * m[2]; const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d; const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d; return [xt, yt]; } static getAxialAlignedBoundingBox(r, m) { const p1 = Util.applyTransform(r, m); const p2 = Util.applyTransform(r.slice(2, 4), m); const p3 = Util.applyTransform([r[0], r[3]], m); const p4 = Util.applyTransform([r[2], r[1]], m); return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])]; } static inverseTransform(m) { const d = m[0] * m[3] - m[1] * m[2]; return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d]; } static apply3dTransform(m, v) { return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]]; } static singularValueDecompose2dScale(m) { const transpose = [m[0], m[2], m[1], m[3]]; const a = m[0] * transpose[0] + m[1] * transpose[2]; const b = m[0] * transpose[1] + m[1] * transpose[3]; const c = m[2] * transpose[0] + m[3] * transpose[2]; const d = m[2] * transpose[1] + m[3] * transpose[3]; const first = (a + d) / 2; const second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2; const sx = first + second || 1; const sy = first - second || 1; return [Math.sqrt(sx), Math.sqrt(sy)]; } static normalizeRect(rect) { const r = rect.slice(0); if (rect[0] > rect[2]) { r[0] = rect[2]; r[2] = rect[0]; } if (rect[1] > rect[3]) { r[1] = rect[3]; r[3] = rect[1]; } return r; } static intersect(rect1, rect2) { function compare(a, b) { return a - b; } const orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare); const orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare); const result = []; rect1 = Util.normalizeRect(rect1); rect2 = Util.normalizeRect(rect2); if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) { result[0] = orderedX[1]; result[2] = orderedX[2]; } else { return null; } if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) { result[1] = orderedY[1]; result[3] = orderedY[2]; } else { return null; } return result; } } exports.Util = Util;
const PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];
function stringToPDFString(str) { const length = str.length, strBuf = []; if (str[0] === "\xFE" && str[1] === "\xFF") { for (let i = 2; i < length; i += 2) { strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1))); } } else if (str[0] === "\xFF" && str[1] === "\xFE") { for (let i = 2; i < length; i += 2) { strBuf.push(String.fromCharCode(str.charCodeAt(i + 1) << 8 | str.charCodeAt(i))); } } else { for (let i = 0; i < length; ++i) { const code = PDFStringTranslateTable[str.charCodeAt(i)]; strBuf.push(code ? String.fromCharCode(code) : str.charAt(i)); } } return strBuf.join(""); } function escapeString(str) { return str.replace(/([\(\)\\])/g, "\\$1"); } function stringToUTF8String(str) { return decodeURIComponent(escape(str)); } function utf8StringToString(str) { return unescape(encodeURIComponent(str)); } function isBool(v) { return typeof v === "boolean"; } function isNum(v) { return typeof v === "number"; } function isString(v) { return typeof v === "string"; } function isArrayBuffer(v) { return typeof v === "object" && v !== null && v.byteLength !== undefined; } function isArrayEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } return arr1.every(function (element, index) { return element === arr2[index]; }); } function getModificationDate(date = new Date(Date.now())) {
const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), (date.getUTCDate() + 1).toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
return buffer.join(""); } function createPromiseCapability() { const capability = Object.create(null); let isSettled = false; Object.defineProperty(capability, "settled", { get() { return isSettled; } }); capability.promise = new Promise(function (resolve, reject) { capability.resolve = function (data) { isSettled = true; resolve(data); }; capability.reject = function (reason) { isSettled = true; reject(reason); }; }); return capability; } const createObjectURL = function createObjectURLClosure() { const digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; return function createObjectURL(data, contentType, forceDataSchema = false) { if (!forceDataSchema && URL.createObjectURL) { const blob = new Blob([data], { type: contentType }); return URL.createObjectURL(blob); } let buffer = `data:${contentType};base64,`; for (let i = 0, ii = data.length; i < ii; i += 3) { const b1 = data[i] & 0xff; const b2 = data[i + 1] & 0xff; const b3 = data[i + 2] & 0xff; const d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4; const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64; const d4 = i + 2 < ii ? b3 & 0x3f : 64; buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4]; } return buffer; }; }(); exports.createObjectURL = createObjectURL;
/***/ }),
/* 3 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var _is_node = __w_pdfjs_require__(4); ;
/***/ }),
/* 4 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.isNodeJS = void 0; const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"); exports.isNodeJS = isNodeJS;
/***/ }),
/* 5 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.getDocument = getDocument; exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory; exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0; var _util = __w_pdfjs_require__(2); var _display_utils = __w_pdfjs_require__(1); var _font_loader = __w_pdfjs_require__(6); var _node_utils = __w_pdfjs_require__(7); var _annotation_storage = __w_pdfjs_require__(8); var _api_compatibility = __w_pdfjs_require__(9); var _canvas = __w_pdfjs_require__(10); var _worker_options = __w_pdfjs_require__(12); var _is_node = __w_pdfjs_require__(4); var _message_handler = __w_pdfjs_require__(13); var _metadata = __w_pdfjs_require__(14); var _optional_content_config = __w_pdfjs_require__(16); var _transport_stream = __w_pdfjs_require__(17); var _webgl = __w_pdfjs_require__(18); const DEFAULT_RANGE_CHUNK_SIZE = 65536; const RENDERING_CANCELLED_TIMEOUT = 100; const DefaultCanvasFactory = _is_node.isNodeJS ? _node_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory; const DefaultCMapReaderFactory = _is_node.isNodeJS ? _node_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory; let createPDFNetworkStream; function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) { createPDFNetworkStream = pdfNetworkStreamFactory; } function getDocument(src) { const task = new PDFDocumentLoadingTask(); let source; if (typeof src === "string") { source = { url: src }; } else if ((0, _util.isArrayBuffer)(src)) { source = { data: src }; } else if (src instanceof PDFDataRangeTransport) { source = { range: src }; } else { if (typeof src !== "object") { throw new Error("Invalid parameter in getDocument, " + "need either Uint8Array, string or a parameter object"); } if (!src.url && !src.data && !src.range) { throw new Error("Invalid parameter object: need either .data, .range or .url"); } source = src; } const params = Object.create(null); let rangeTransport = null, worker = null; for (const key in source) { if (key === "url" && typeof window !== "undefined") { params[key] = new URL(source[key], window.location).href; continue; } else if (key === "range") { rangeTransport = source[key]; continue; } else if (key === "worker") { worker = source[key]; continue; } else if (key === "data" && !(source[key] instanceof Uint8Array)) { const pdfBytes = source[key]; if (typeof pdfBytes === "string") { params[key] = (0, _util.stringToBytes)(pdfBytes); } else if (typeof pdfBytes === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) { params[key] = new Uint8Array(pdfBytes); } else if ((0, _util.isArrayBuffer)(pdfBytes)) { params[key] = new Uint8Array(pdfBytes); } else { throw new Error("Invalid PDF binary data: either typed array, " + "string or array-like object is expected in the " + "data property."); } continue; } params[key] = source[key]; } params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE; params.CMapReaderFactory = params.CMapReaderFactory || DefaultCMapReaderFactory; params.ignoreErrors = params.stopAtErrors !== true; params.fontExtraProperties = params.fontExtraProperties === true; params.pdfBug = params.pdfBug === true; if (!Number.isInteger(params.maxImageSize)) { params.maxImageSize = -1; } if (typeof params.isEvalSupported !== "boolean") { params.isEvalSupported = true; } if (typeof params.disableFontFace !== "boolean") { params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false; } if (typeof params.ownerDocument === "undefined") { params.ownerDocument = globalThis.document; } if (typeof params.disableRange !== "boolean") { params.disableRange = false; } if (typeof params.disableStream !== "boolean") { params.disableStream = false; } if (typeof params.disableAutoFetch !== "boolean") { params.disableAutoFetch = false; } (0, _util.setVerbosityLevel)(params.verbosity); if (!worker) { const workerParams = { verbosity: params.verbosity, port: _worker_options.GlobalWorkerOptions.workerPort }; worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams); task._worker = worker; } const docId = task.docId; worker.promise.then(function () { if (task.destroyed) { throw new Error("Loading aborted"); } const workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId); const networkStreamPromise = new Promise(function (resolve) { let networkStream; if (rangeTransport) { networkStream = new _transport_stream.PDFDataTransportStream({ length: params.length, initialData: params.initialData, progressiveDone: params.progressiveDone, disableRange: params.disableRange, disableStream: params.disableStream }, rangeTransport); } else if (!params.data) { networkStream = createPDFNetworkStream({ url: params.url, length: params.length, httpHeaders: params.httpHeaders, withCredentials: params.withCredentials, rangeChunkSize: params.rangeChunkSize, disableRange: params.disableRange, disableStream: params.disableStream }); } resolve(networkStream); }); return Promise.all([workerIdPromise, networkStreamPromise]).then(function ([workerId, networkStream]) { if (task.destroyed) { throw new Error("Loading aborted"); } const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port); messageHandler.postMessageTransfers = worker.postMessageTransfers; const transport = new WorkerTransport(messageHandler, task, networkStream, params); task._transport = transport; messageHandler.send("Ready", null); }); }).catch(task._capability.reject); return task; } function _fetchDocument(worker, source, pdfDataRangeTransport, docId) { if (worker.destroyed) { return Promise.reject(new Error("Worker was destroyed")); } if (pdfDataRangeTransport) { source.length = pdfDataRangeTransport.length; source.initialData = pdfDataRangeTransport.initialData; source.progressiveDone = pdfDataRangeTransport.progressiveDone; } return worker.messageHandler.sendWithPromise("GetDocRequest", { docId, apiVersion: '2.6.347', source: { data: source.data, url: source.url, password: source.password, disableAutoFetch: source.disableAutoFetch, rangeChunkSize: source.rangeChunkSize, length: source.length }, maxImageSize: source.maxImageSize, disableFontFace: source.disableFontFace, postMessageTransfers: worker.postMessageTransfers, docBaseUrl: source.docBaseUrl, ignoreErrors: source.ignoreErrors, isEvalSupported: source.isEvalSupported, fontExtraProperties: source.fontExtraProperties }).then(function (workerId) { if (worker.destroyed) { throw new Error("Worker was destroyed"); } return workerId; }); } const PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() { let nextDocumentId = 0; class PDFDocumentLoadingTask { constructor() { this._capability = (0, _util.createPromiseCapability)(); this._transport = null; this._worker = null; this.docId = "d" + nextDocumentId++; this.destroyed = false; this.onPassword = null; this.onProgress = null; this.onUnsupportedFeature = null; } get promise() { return this._capability.promise; } destroy() { this.destroyed = true; const transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy(); return transportDestroyed.then(() => { this._transport = null; if (this._worker) { this._worker.destroy(); this._worker = null; } }); } } return PDFDocumentLoadingTask; }(); class PDFDataRangeTransport { constructor(length, initialData, progressiveDone = false) { this.length = length; this.initialData = initialData; this.progressiveDone = progressiveDone; this._rangeListeners = []; this._progressListeners = []; this._progressiveReadListeners = []; this._progressiveDoneListeners = []; this._readyCapability = (0, _util.createPromiseCapability)(); } addRangeListener(listener) { this._rangeListeners.push(listener); } addProgressListener(listener) { this._progressListeners.push(listener); } addProgressiveReadListener(listener) { this._progressiveReadListeners.push(listener); } addProgressiveDoneListener(listener) { this._progressiveDoneListeners.push(listener); } onDataRange(begin, chunk) { for (const listener of this._rangeListeners) { listener(begin, chunk); } } onDataProgress(loaded, total) { this._readyCapability.promise.then(() => { for (const listener of this._progressListeners) { listener(loaded, total); } }); } onDataProgressiveRead(chunk) { this._readyCapability.promise.then(() => { for (const listener of this._progressiveReadListeners) { listener(chunk); } }); } onDataProgressiveDone() { this._readyCapability.promise.then(() => { for (const listener of this._progressiveDoneListeners) { listener(); } }); } transportReady() { this._readyCapability.resolve(); } requestDataRange(begin, end) { (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange"); } abort() {} } exports.PDFDataRangeTransport = PDFDataRangeTransport; class PDFDocumentProxy { constructor(pdfInfo, transport) { this._pdfInfo = pdfInfo; this._transport = transport; } get annotationStorage() { return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage()); } get numPages() { return this._pdfInfo.numPages; } get fingerprint() { return this._pdfInfo.fingerprint; } getPage(pageNumber) { return this._transport.getPage(pageNumber); } getPageIndex(ref) { return this._transport.getPageIndex(ref); } getDestinations() { return this._transport.getDestinations(); } getDestination(id) { return this._transport.getDestination(id); } getPageLabels() { return this._transport.getPageLabels(); } getPageLayout() { return this._transport.getPageLayout(); } getPageMode() { return this._transport.getPageMode(); } getViewerPreferences() { return this._transport.getViewerPreferences(); } getOpenAction() { return this._transport.getOpenAction(); } getAttachments() { return this._transport.getAttachments(); } getJavaScript() { return this._transport.getJavaScript(); } getOutline() { return this._transport.getOutline(); } getOptionalContentConfig() { return this._transport.getOptionalContentConfig(); } getPermissions() { return this._transport.getPermissions(); } getMetadata() { return this._transport.getMetadata(); } getData() { return this._transport.getData(); } getDownloadInfo() { return this._transport.downloadInfoCapability.promise; } getStats() { return this._transport.getStats(); } cleanup() { return this._transport.startCleanup(); } destroy() { return this.loadingTask.destroy(); } get loadingParams() { return this._transport.loadingParams; } get loadingTask() { return this._transport.loadingTask; } saveDocument(annotationStorage) { return this._transport.saveDocument(annotationStorage); } } exports.PDFDocumentProxy = PDFDocumentProxy; class PDFPageProxy { constructor(pageIndex, pageInfo, transport, ownerDocument, pdfBug = false) { this._pageIndex = pageIndex; this._pageInfo = pageInfo; this._ownerDocument = ownerDocument; this._transport = transport; this._stats = pdfBug ? new _display_utils.StatTimer() : null; this._pdfBug = pdfBug; this.commonObjs = transport.commonObjs; this.objs = new PDFObjects(); this.cleanupAfterRender = false; this.pendingCleanup = false; this._intentStates = new Map(); this.destroyed = false; } get pageNumber() { return this._pageIndex + 1; } get rotate() { return this._pageInfo.rotate; } get ref() { return this._pageInfo.ref; } get userUnit() { return this._pageInfo.userUnit; } get view() { return this._pageInfo.view; } getViewport({ scale, rotation = this.rotate, offsetX = 0, offsetY = 0, dontFlip = false } = {}) { return new _display_utils.PageViewport({ viewBox: this.view, scale, rotation, offsetX, offsetY, dontFlip }); } getAnnotations({ intent = null } = {}) { if (!this.annotationsPromise || this.annotationsIntent !== intent) { this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent); this.annotationsIntent = intent; } return this.annotationsPromise; } render({ canvasContext, viewport, intent = "display", enableWebGL = false, renderInteractiveForms = false, transform = null, imageLayer = null, canvasFactory = null, background = null, annotationStorage = null, optionalContentConfigPromise = null }) { if (this._stats) { this._stats.time("Overall"); } const renderingIntent = intent === "print" ? "print" : "display"; this.pendingCleanup = false; if (!optionalContentConfigPromise) { optionalContentConfigPromise = this._transport.getOptionalContentConfig(); } let intentState = this._intentStates.get(renderingIntent); if (!intentState) { intentState = Object.create(null); this._intentStates.set(renderingIntent, intentState); } if (intentState.streamReaderCancelTimeout) { clearTimeout(intentState.streamReaderCancelTimeout); intentState.streamReaderCancelTimeout = null; } const canvasFactoryInstance = canvasFactory || new DefaultCanvasFactory({ ownerDocument: this._ownerDocument }); const webGLContext = new _webgl.WebGLContext({ enable: enableWebGL }); if (!intentState.displayReadyCapability) { intentState.displayReadyCapability = (0, _util.createPromiseCapability)(); intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false }; if (this._stats) { this._stats.time("Page Request"); } this._pumpOperatorList({ pageIndex: this._pageIndex, intent: renderingIntent, renderInteractiveForms: renderInteractiveForms === true, annotationStorage: annotationStorage && annotationStorage.getAll() || null }); } const complete = error => { const i = intentState.renderTasks.indexOf(internalRenderTask); if (i >= 0) { intentState.renderTasks.splice(i, 1); } if (this.cleanupAfterRender || renderingIntent === "print") { this.pendingCleanup = true; } this._tryCleanup(); if (error) { internalRenderTask.capability.reject(error); this._abortOperatorList({ intentState, reason: error }); } else { internalRenderTask.capability.resolve(); } if (this._stats) { this._stats.timeEnd("Rendering"); this._stats.timeEnd("Overall"); } }; const internalRenderTask = new InternalRenderTask({ callback: complete, params: { canvasContext, viewport, transform, imageLayer, background }, objs: this.objs, commonObjs: this.commonObjs, operatorList: intentState.operatorList, pageIndex: this._pageIndex, canvasFactory: canvasFactoryInstance, webGLContext, useRequestAnimationFrame: renderingIntent !== "print", pdfBug: this._pdfBug }); if (!intentState.renderTasks) { intentState.renderTasks = []; } intentState.renderTasks.push(internalRenderTask); const renderTask = internalRenderTask.task; Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => { if (this.pendingCleanup) { complete(); return; } if (this._stats) { this._stats.time("Rendering"); } internalRenderTask.initializeGraphics({ transparency, optionalContentConfig }); internalRenderTask.operatorListChanged(); }).catch(complete); return renderTask; } getOperatorList() { function operatorListChanged() { if (intentState.operatorList.lastChunk) { intentState.opListReadCapability.resolve(intentState.operatorList); const i = intentState.renderTasks.indexOf(opListTask); if (i >= 0) { intentState.renderTasks.splice(i, 1); } } } const renderingIntent = "oplist"; let intentState = this._intentStates.get(renderingIntent); if (!intentState) { intentState = Object.create(null); this._intentStates.set(renderingIntent, intentState); } let opListTask; if (!intentState.opListReadCapability) { opListTask = Object.create(null); opListTask.operatorListChanged = operatorListChanged; intentState.opListReadCapability = (0, _util.createPromiseCapability)(); intentState.renderTasks = []; intentState.renderTasks.push(opListTask); intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false }; if (this._stats) { this._stats.time("Page Request"); } this._pumpOperatorList({ pageIndex: this._pageIndex, intent: renderingIntent }); } return intentState.opListReadCapability.promise; } streamTextContent({ normalizeWhitespace = false, disableCombineTextItems = false } = {}) { const TEXT_CONTENT_CHUNK_SIZE = 100; return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, normalizeWhitespace: normalizeWhitespace === true, combineTextItems: disableCombineTextItems !== true }, { highWaterMark: TEXT_CONTENT_CHUNK_SIZE, size(textContent) { return textContent.items.length; } }); } getTextContent(params = {}) { const readableStream = this.streamTextContent(params); return new Promise(function (resolve, reject) { function pump() { reader.read().then(function ({ value, done }) { if (done) { resolve(textContent); return; } Object.assign(textContent.styles, value.styles); textContent.items.push(...value.items); pump(); }, reject); } const reader = readableStream.getReader(); const textContent = { items: [], styles: Object.create(null) }; pump(); }); } _destroy() { this.destroyed = true; this._transport.pageCache[this._pageIndex] = null; const waitOn = []; for (const [intent, intentState] of this._intentStates) { this._abortOperatorList({ intentState, reason: new Error("Page was destroyed."), force: true }); if (intent === "oplist") { continue; } for (const internalRenderTask of intentState.renderTasks) { waitOn.push(internalRenderTask.completed); internalRenderTask.cancel(); } } this.objs.clear(); this.annotationsPromise = null; this.pendingCleanup = false; return Promise.all(waitOn); } cleanup(resetStats = false) { this.pendingCleanup = true; return this._tryCleanup(resetStats); } _tryCleanup(resetStats = false) { if (!this.pendingCleanup) { return false; } for (const { renderTasks, operatorList } of this._intentStates.values()) { if (renderTasks.length !== 0 || !operatorList.lastChunk) { return false; } } this._intentStates.clear(); this.objs.clear(); this.annotationsPromise = null; if (resetStats && this._stats) { this._stats = new _display_utils.StatTimer(); } this.pendingCleanup = false; return true; } _startRenderPage(transparency, intent) { const intentState = this._intentStates.get(intent); if (!intentState) { return; } if (this._stats) { this._stats.timeEnd("Page Request"); } if (intentState.displayReadyCapability) { intentState.displayReadyCapability.resolve(transparency); } } _renderPageChunk(operatorListChunk, intentState) { for (let i = 0, ii = operatorListChunk.length; i < ii; i++) { intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]); intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]); } intentState.operatorList.lastChunk = operatorListChunk.lastChunk; for (let i = 0; i < intentState.renderTasks.length; i++) { intentState.renderTasks[i].operatorListChanged(); } if (operatorListChunk.lastChunk) { this._tryCleanup(); } } _pumpOperatorList(args) { (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.'); const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args); const reader = readableStream.getReader(); const intentState = this._intentStates.get(args.intent); intentState.streamReader = reader; const pump = () => { reader.read().then(({ value, done }) => { if (done) { intentState.streamReader = null; return; } if (this._transport.destroyed) { return; } this._renderPageChunk(value, intentState); pump(); }, reason => { intentState.streamReader = null; if (this._transport.destroyed) { return; } if (intentState.operatorList) { intentState.operatorList.lastChunk = true; for (let i = 0; i < intentState.renderTasks.length; i++) { intentState.renderTasks[i].operatorListChanged(); } this._tryCleanup(); } if (intentState.displayReadyCapability) { intentState.displayReadyCapability.reject(reason); } else if (intentState.opListReadCapability) { intentState.opListReadCapability.reject(reason); } else { throw reason; } }); }; pump(); } _abortOperatorList({ intentState, reason, force = false }) { (0, _util.assert)(reason instanceof Error || typeof reason === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.'); if (!intentState.streamReader) { return; } if (!force) { if (intentState.renderTasks.length !== 0) { return; } if (reason instanceof _display_utils.RenderingCancelledException) { intentState.streamReaderCancelTimeout = setTimeout(() => { this._abortOperatorList({ intentState, reason, force: true }); intentState.streamReaderCancelTimeout = null; }, RENDERING_CANCELLED_TIMEOUT); return; } } intentState.streamReader.cancel(new _util.AbortException(reason && reason.message)); intentState.streamReader = null; if (this._transport.destroyed) { return; } for (const [intent, curIntentState] of this._intentStates) { if (curIntentState === intentState) { this._intentStates.delete(intent); break; } } this.cleanup(); } get stats() { return this._stats; } } exports.PDFPageProxy = PDFPageProxy; class LoopbackPort { constructor(defer = true) { this._listeners = []; this._defer = defer; this._deferred = Promise.resolve(undefined); } postMessage(obj, transfers) { function cloneValue(value) { if (typeof value !== "object" || value === null) { return value; } if (cloned.has(value)) { return cloned.get(value); } let buffer, result; if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) { const transferable = transfers && transfers.includes(buffer); if (transferable) { result = new value.constructor(buffer, value.byteOffset, value.byteLength); } else { result = new value.constructor(value); } cloned.set(value, result); return result; } result = Array.isArray(value) ? [] : {}; cloned.set(value, result); for (const i in value) { let desc, p = value; while (!(desc = Object.getOwnPropertyDescriptor(p, i))) { p = Object.getPrototypeOf(p); } if (typeof desc.value === "undefined") { continue; } if (typeof desc.value === "function") { if (value.hasOwnProperty && value.hasOwnProperty(i)) { throw new Error(`LoopbackPort.postMessage - cannot clone: ${value[i]}`); } continue; } result[i] = cloneValue(desc.value); } return result; } if (!this._defer) { this._listeners.forEach(listener => { listener.call(this, { data: obj }); }); return; } const cloned = new WeakMap(); const e = { data: cloneValue(obj) }; this._deferred.then(() => { this._listeners.forEach(listener => { listener.call(this, e); }); }); } addEventListener(name, listener) { this._listeners.push(listener); } removeEventListener(name, listener) { const i = this._listeners.indexOf(listener); this._listeners.splice(i, 1); } terminate() { this._listeners.length = 0; } } exports.LoopbackPort = LoopbackPort; const PDFWorker = function PDFWorkerClosure() { const pdfWorkerPorts = new WeakMap(); let isWorkerDisabled = false; let fallbackWorkerSrc; let nextFakeWorkerId = 0; let fakeWorkerCapability; if (_is_node.isNodeJS && typeof require === "function") { isWorkerDisabled = true; fallbackWorkerSrc = "./pdf.worker.js"; } else if (typeof document === "object" && "currentScript" in document) { const pdfjsFilePath = document.currentScript && document.currentScript.src; if (pdfjsFilePath) { fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"); } } function getWorkerSrc() { if (_worker_options.GlobalWorkerOptions.workerSrc) { return _worker_options.GlobalWorkerOptions.workerSrc; } if (typeof fallbackWorkerSrc !== "undefined") { if (!_is_node.isNodeJS) { (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'); } return fallbackWorkerSrc; } throw new Error('No "GlobalWorkerOptions.workerSrc" specified.'); } function getMainThreadWorkerMessageHandler() { let mainWorkerMessageHandler; try { mainWorkerMessageHandler = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler; } catch (ex) {} return mainWorkerMessageHandler || null; } function setupFakeWorkerGlobal() { if (fakeWorkerCapability) { return fakeWorkerCapability.promise; } fakeWorkerCapability = (0, _util.createPromiseCapability)(); const loader = async function () { const mainWorkerMessageHandler = getMainThreadWorkerMessageHandler(); if (mainWorkerMessageHandler) { return mainWorkerMessageHandler; } if (_is_node.isNodeJS && typeof require === "function") { const worker = eval("require")(getWorkerSrc()); return worker.WorkerMessageHandler; } await (0, _display_utils.loadScript)(getWorkerSrc()); return window.pdfjsWorker.WorkerMessageHandler; }; loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject); return fakeWorkerCapability.promise; } function createCDNWrapper(url) { const wrapper = "importScripts('" + url + "');"; return URL.createObjectURL(new Blob([wrapper])); } class PDFWorker { constructor({ name = null, port = null, verbosity = (0, _util.getVerbosityLevel)() } = {}) { if (port && pdfWorkerPorts.has(port)) { throw new Error("Cannot use more than one PDFWorker per port"); } this.name = name; this.destroyed = false; this.postMessageTransfers = true; this.verbosity = verbosity; this._readyCapability = (0, _util.createPromiseCapability)(); this._port = null; this._webWorker = null; this._messageHandler = null; if (port) { pdfWorkerPorts.set(port, this); this._initializeFromPort(port); return; } this._initialize(); } get promise() { return this._readyCapability.promise; } get port() { return this._port; } get messageHandler() { return this._messageHandler; } _initializeFromPort(port) { this._port = port; this._messageHandler = new _message_handler.MessageHandler("main", "worker", port); this._messageHandler.on("ready", function () {}); this._readyCapability.resolve(); } _initialize() { if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) { let workerSrc = getWorkerSrc(); try { if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) { workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href); } const worker = new Worker(workerSrc); const messageHandler = new _message_handler.MessageHandler("main", "worker", worker); const terminateEarly = () => { worker.removeEventListener("error", onWorkerError); messageHandler.destroy(); worker.terminate(); if (this.destroyed) { this._readyCapability.reject(new Error("Worker was destroyed")); } else { this._setupFakeWorker(); } }; const onWorkerError = () => { if (!this._webWorker) { terminateEarly(); } }; worker.addEventListener("error", onWorkerError); messageHandler.on("test", data => { worker.removeEventListener("error", onWorkerError); if (this.destroyed) { terminateEarly(); return; } if (data) { this._messageHandler = messageHandler; this._port = worker; this._webWorker = worker; if (!data.supportTransfers) { this.postMessageTransfers = false; } this._readyCapability.resolve(); messageHandler.send("configure", { verbosity: this.verbosity }); } else { this._setupFakeWorker(); messageHandler.destroy(); worker.terminate(); } }); messageHandler.on("ready", data => { worker.removeEventListener("error", onWorkerError); if (this.destroyed) { terminateEarly(); return; } try { sendTest(); } catch (e) { this._setupFakeWorker(); } }); const sendTest = () => { const testObj = new Uint8Array([this.postMessageTransfers ? 255 : 0]); try { messageHandler.send("test", testObj, [testObj.buffer]); } catch (ex) { (0, _util.warn)("Cannot use postMessage transfers."); testObj[0] = 0; messageHandler.send("test", testObj); } }; sendTest(); return; } catch (e) { (0, _util.info)("The worker has been disabled."); } } this._setupFakeWorker(); } _setupFakeWorker() { if (!isWorkerDisabled) { (0, _util.warn)("Setting up fake worker."); isWorkerDisabled = true; } setupFakeWorkerGlobal().then(WorkerMessageHandler => { if (this.destroyed) { this._readyCapability.reject(new Error("Worker was destroyed")); return; } const port = new LoopbackPort(); this._port = port; const id = "fake" + nextFakeWorkerId++; const workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port); WorkerMessageHandler.setup(workerHandler, port); const messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port); this._messageHandler = messageHandler; this._readyCapability.resolve(); messageHandler.send("configure", { verbosity: this.verbosity }); }).catch(reason => { this._readyCapability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`)); }); } destroy() { this.destroyed = true; if (this._webWorker) { this._webWorker.terminate(); this._webWorker = null; } pdfWorkerPorts.delete(this._port); this._port = null; if (this._messageHandler) { this._messageHandler.destroy(); this._messageHandler = null; } } static fromPort(params) { if (!params || !params.port) { throw new Error("PDFWorker.fromPort - invalid method signature."); } if (pdfWorkerPorts.has(params.port)) { return pdfWorkerPorts.get(params.port); } return new PDFWorker(params); } static getWorkerSrc() { return getWorkerSrc(); } } return PDFWorker; }(); exports.PDFWorker = PDFWorker; class WorkerTransport { constructor(messageHandler, loadingTask, networkStream, params) { this.messageHandler = messageHandler; this.loadingTask = loadingTask; this.commonObjs = new PDFObjects(); this.fontLoader = new _font_loader.FontLoader({ docId: loadingTask.docId, onUnsupportedFeature: this._onUnsupportedFeature.bind(this), ownerDocument: params.ownerDocument }); this._params = params; this.CMapReaderFactory = new params.CMapReaderFactory({ baseUrl: params.cMapUrl, isCompressed: params.cMapPacked }); this.destroyed = false; this.destroyCapability = null; this._passwordCapability = null; this._networkStream = networkStream; this._fullReader = null; this._lastProgress = null; this.pageCache = []; this.pagePromises = []; this.downloadInfoCapability = (0, _util.createPromiseCapability)(); this.setupMessageHandler(); } destroy() { if (this.destroyCapability) { return this.destroyCapability.promise; } this.destroyed = true; this.destroyCapability = (0, _util.createPromiseCapability)(); if (this._passwordCapability) { this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback")); } const waitOn = []; this.pageCache.forEach(function (page) { if (page) { waitOn.push(page._destroy()); } }); this.pageCache.length = 0; this.pagePromises.length = 0; const terminated = this.messageHandler.sendWithPromise("Terminate", null); waitOn.push(terminated); Promise.all(waitOn).then(() => { this.fontLoader.clear(); if (this._networkStream) { this._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")); } if (this.messageHandler) { this.messageHandler.destroy(); this.messageHandler = null; } this.destroyCapability.resolve(); }, this.destroyCapability.reject); return this.destroyCapability.promise; } setupMessageHandler() { const { messageHandler, loadingTask } = this; messageHandler.on("GetReader", (data, sink) => { (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."); this._fullReader = this._networkStream.getFullReader(); this._fullReader.onProgress = evt => { this._lastProgress = { loaded: evt.loaded, total: evt.total }; }; sink.onPull = () => { this._fullReader.read().then(function ({ value, done }) { if (done) { sink.close(); return; } (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer."); sink.enqueue(new Uint8Array(value), 1, [value]); }).catch(reason => { sink.error(reason); }); }; sink.onCancel = reason => { this._fullReader.cancel(reason); sink.ready.catch(readyReason => { if (this.destroyed) { return; } throw readyReason; }); }; }); messageHandler.on("ReaderHeadersReady", data => { const headersCapability = (0, _util.createPromiseCapability)(); const fullReader = this._fullReader; fullReader.headersReady.then(() => { if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) { if (this._lastProgress && loadingTask.onProgress) { loadingTask.onProgress(this._lastProgress); } fullReader.onProgress = evt => { if (loadingTask.onProgress) { loadingTask.onProgress({ loaded: evt.loaded, total: evt.total }); } }; } headersCapability.resolve({ isStreamingSupported: fullReader.isStreamingSupported, isRangeSupported: fullReader.isRangeSupported, contentLength: fullReader.contentLength }); }, headersCapability.reject); return headersCapability.promise; }); messageHandler.on("GetRangeReader", (data, sink) => { (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available."); const rangeReader = this._networkStream.getRangeReader(data.begin, data.end); if (!rangeReader) { sink.close(); return; } sink.onPull = () => { rangeReader.read().then(function ({ value, done }) { if (done) { sink.close(); return; } (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer."); sink.enqueue(new Uint8Array(value), 1, [value]); }).catch(reason => { sink.error(reason); }); }; sink.onCancel = reason => { rangeReader.cancel(reason); sink.ready.catch(readyReason => { if (this.destroyed) { return; } throw readyReason; }); }; }); messageHandler.on("GetDoc", ({ pdfInfo }) => { this._numPages = pdfInfo.numPages; loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this)); }); messageHandler.on("DocException", function (ex) { let reason; switch (ex.name) { case "PasswordException": reason = new _util.PasswordException(ex.message, ex.code); break; case "InvalidPDFException": reason = new _util.InvalidPDFException(ex.message); break; case "MissingPDFException": reason = new _util.MissingPDFException(ex.message); break; case "UnexpectedResponseException": reason = new _util.UnexpectedResponseException(ex.message, ex.status); break; case "UnknownErrorException": reason = new _util.UnknownErrorException(ex.message, ex.details); break; } if (!(reason instanceof Error)) { const msg = "DocException - expected a valid Error."; (0, _util.warn)(msg); } loadingTask._capability.reject(reason); }); messageHandler.on("PasswordRequest", exception => { this._passwordCapability = (0, _util.createPromiseCapability)(); if (loadingTask.onPassword) { const updatePassword = password => { this._passwordCapability.resolve({ password }); }; try { loadingTask.onPassword(updatePassword, exception.code); } catch (ex) { this._passwordCapability.reject(ex); } } else { this._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code)); } return this._passwordCapability.promise; }); messageHandler.on("DataLoaded", data => { if (loadingTask.onProgress) { loadingTask.onProgress({ loaded: data.length, total: data.length }); } this.downloadInfoCapability.resolve(data); }); messageHandler.on("StartRenderPage", data => { if (this.destroyed) { return; } const page = this.pageCache[data.pageIndex]; page._startRenderPage(data.transparency, data.intent); }); messageHandler.on("commonobj", data => { if (this.destroyed) { return; } const [id, type, exportedData] = data; if (this.commonObjs.has(id)) { return; } switch (type) { case "Font": const params = this._params; if ("error" in exportedData) { const exportedError = exportedData.error; (0, _util.warn)(`Error during font loading: ${exportedError}`); this.commonObjs.resolve(id, exportedError); break; } let fontRegistry = null; if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) { fontRegistry = { registerFont(font, url) { globalThis.FontInspector.fontAdded(font, url); } }; } const font = new _font_loader.FontFaceObject(exportedData, { isEvalSupported: params.isEvalSupported, disableFontFace: params.disableFontFace, ignoreErrors: params.ignoreErrors, onUnsupportedFeature: this._onUnsupportedFeature.bind(this), fontRegistry }); this.fontLoader.bind(font).catch(reason => { return messageHandler.sendWithPromise("FontFallback", { id }); }).finally(() => { if (!params.fontExtraProperties && font.data) { font.data = null; } this.commonObjs.resolve(id, font); }); break; case "FontPath": case "Image": this.commonObjs.resolve(id, exportedData); break; default: throw new Error(`Got unknown common object type ${type}`); } }); messageHandler.on("obj", data => { if (this.destroyed) { return undefined; } const [id, pageIndex, type, imageData] = data; const pageProxy = this.pageCache[pageIndex]; if (pageProxy.objs.has(id)) { return undefined; } switch (type) { case "Image": pageProxy.objs.resolve(id, imageData); const MAX_IMAGE_SIZE_TO_STORE = 8000000; if (imageData && "data" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) { pageProxy.cleanupAfterRender = true; } break; default: throw new Error(`Got unknown object type ${type}`); } return undefined; }); messageHandler.on("DocProgress", data => { if (this.destroyed) { return; } if (loadingTask.onProgress) { loadingTask.onProgress({ loaded: data.loaded, total: data.total }); } }); messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this)); messageHandler.on("FetchBuiltInCMap", (data, sink) => { if (this.destroyed) { sink.error(new Error("Worker was destroyed")); return; } let fetched = false; sink.onPull = () => { if (fetched) { sink.close(); return; } fetched = true; this.CMapReaderFactory.fetch(data).then(function (builtInCMap) { sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]); }).catch(function (reason) { sink.error(reason); }); }; }); } _onUnsupportedFeature({ featureId }) { if (this.destroyed) { return; } if (this.loadingTask.onUnsupportedFeature) { this.loadingTask.onUnsupportedFeature(featureId); } } getData() { return this.messageHandler.sendWithPromise("GetData", null); } getPage(pageNumber) { if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) { return Promise.reject(new Error("Invalid page request")); } const pageIndex = pageNumber - 1; if (pageIndex in this.pagePromises) { return this.pagePromises[pageIndex]; } const promise = this.messageHandler.sendWithPromise("GetPage", { pageIndex }).then(pageInfo => { if (this.destroyed) { throw new Error("Transport destroyed"); } const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.ownerDocument, this._params.pdfBug); this.pageCache[pageIndex] = page; return page; }); this.pagePromises[pageIndex] = promise; return promise; } getPageIndex(ref) { return this.messageHandler.sendWithPromise("GetPageIndex", { ref }).catch(function (reason) { return Promise.reject(new Error(reason)); }); } getAnnotations(pageIndex, intent) { return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex, intent }); } saveDocument(annotationStorage) { return this.messageHandler.sendWithPromise("SaveDocument", { numPages: this._numPages, annotationStorage: annotationStorage && annotationStorage.getAll() || null, filename: this._fullReader ? this._fullReader.filename : null }).finally(() => { if (annotationStorage) { annotationStorage.resetModified(); } }); } getDestinations() { return this.messageHandler.sendWithPromise("GetDestinations", null); } getDestination(id) { if (typeof id !== "string") { return Promise.reject(new Error("Invalid destination request.")); } return this.messageHandler.sendWithPromise("GetDestination", { id }); } getPageLabels() { return this.messageHandler.sendWithPromise("GetPageLabels", null); } getPageLayout() { return this.messageHandler.sendWithPromise("GetPageLayout", null); } getPageMode() { return this.messageHandler.sendWithPromise("GetPageMode", null); } getViewerPreferences() { return this.messageHandler.sendWithPromise("GetViewerPreferences", null); } getOpenAction() { return this.messageHandler.sendWithPromise("GetOpenAction", null); } getAttachments() { return this.messageHandler.sendWithPromise("GetAttachments", null); } getJavaScript() { return this.messageHandler.sendWithPromise("GetJavaScript", null); } getOutline() { return this.messageHandler.sendWithPromise("GetOutline", null); } getOptionalContentConfig() { return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(results => { return new _optional_content_config.OptionalContentConfig(results); }); } getPermissions() { return this.messageHandler.sendWithPromise("GetPermissions", null); } getMetadata() { return this.messageHandler.sendWithPromise("GetMetadata", null).then(results => { return { info: results[0], metadata: results[1] ? new _metadata.Metadata(results[1]) : null, contentDispositionFilename: this._fullReader ? this._fullReader.filename : null }; }); } getStats() { return this.messageHandler.sendWithPromise("GetStats", null); } startCleanup() { return this.messageHandler.sendWithPromise("Cleanup", null).then(() => { for (let i = 0, ii = this.pageCache.length; i < ii; i++) { const page = this.pageCache[i]; if (page) { const cleanupSuccessful = page.cleanup(); if (!cleanupSuccessful) { throw new Error(`startCleanup: Page ${i + 1} is currently rendering.`); } } } this.commonObjs.clear(); this.fontLoader.clear(); }); } get loadingParams() { const params = this._params; return (0, _util.shadow)(this, "loadingParams", { disableAutoFetch: params.disableAutoFetch, disableFontFace: params.disableFontFace }); } } class PDFObjects { constructor() { this._objs = Object.create(null); } _ensureObj(objId) { if (this._objs[objId]) { return this._objs[objId]; } return this._objs[objId] = { capability: (0, _util.createPromiseCapability)(), data: null, resolved: false }; } get(objId, callback = null) { if (callback) { this._ensureObj(objId).capability.promise.then(callback); return null; } const obj = this._objs[objId]; if (!obj || !obj.resolved) { throw new Error(`Requesting object that isn't resolved yet ${objId}.`); } return obj.data; } has(objId) { const obj = this._objs[objId]; return obj ? obj.resolved : false; } resolve(objId, data) { const obj = this._ensureObj(objId); obj.resolved = true; obj.data = data; obj.capability.resolve(data); } clear() { this._objs = Object.create(null); } } class RenderTask { constructor(internalRenderTask) { this._internalRenderTask = internalRenderTask; this.onContinue = null; } get promise() { return this._internalRenderTask.capability.promise; } cancel() { this._internalRenderTask.cancel(); } } const InternalRenderTask = function InternalRenderTaskClosure() { const canvasInRendering = new WeakSet(); class InternalRenderTask { constructor({ callback, params, objs, commonObjs, operatorList, pageIndex, canvasFactory, webGLContext, useRequestAnimationFrame = false, pdfBug = false }) { this.callback = callback; this.params = params; this.objs = objs; this.commonObjs = commonObjs; this.operatorListIdx = null; this.operatorList = operatorList; this._pageIndex = pageIndex; this.canvasFactory = canvasFactory; this.webGLContext = webGLContext; this._pdfBug = pdfBug; this.running = false; this.graphicsReadyCallback = null; this.graphicsReady = false; this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined"; this.cancelled = false; this.capability = (0, _util.createPromiseCapability)(); this.task = new RenderTask(this); this._continueBound = this._continue.bind(this); this._scheduleNextBound = this._scheduleNext.bind(this); this._nextBound = this._next.bind(this); this._canvas = params.canvasContext.canvas; } get completed() { return this.capability.promise.catch(function () {}); } initializeGraphics({ transparency = false, optionalContentConfig }) { if (this.cancelled) { return; } if (this._canvas) { if (canvasInRendering.has(this._canvas)) { throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed."); } canvasInRendering.add(this._canvas); } if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) { this.stepper = globalThis.StepperManager.create(this._pageIndex); this.stepper.init(this.operatorList); this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint(); } const { canvasContext, viewport, transform, imageLayer, background } = this.params; this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer, optionalContentConfig); this.gfx.beginDrawing({ transform, viewport, transparency, background }); this.operatorListIdx = 0; this.graphicsReady = true; if (this.graphicsReadyCallback) { this.graphicsReadyCallback(); } } cancel(error = null) { this.running = false; this.cancelled = true; if (this.gfx) { this.gfx.endDrawing(); } if (this._canvas) { canvasInRendering.delete(this._canvas); } this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, "canvas")); } operatorListChanged() { if (!this.graphicsReady) { if (!this.graphicsReadyCallback) { this.graphicsReadyCallback = this._continueBound; } return; } if (this.stepper) { this.stepper.updateOperatorList(this.operatorList); } if (this.running) { return; } this._continue(); } _continue() { this.running = true; if (this.cancelled) { return; } if (this.task.onContinue) { this.task.onContinue(this._scheduleNextBound); } else { this._scheduleNext(); } } _scheduleNext() { if (this._useRequestAnimationFrame) { window.requestAnimationFrame(() => { this._nextBound().catch(this.cancel.bind(this)); }); } else { Promise.resolve().then(this._nextBound).catch(this.cancel.bind(this)); } } async _next() { if (this.cancelled) { return; } this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper); if (this.operatorListIdx === this.operatorList.argsArray.length) { this.running = false; if (this.operatorList.lastChunk) { this.gfx.endDrawing(); if (this._canvas) { canvasInRendering.delete(this._canvas); } this.callback(); } } } } return InternalRenderTask; }(); const version = '2.6.347'; exports.version = version; const build = '3be9c65f0'; exports.build = build;
/***/ }),
/* 6 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.FontLoader = exports.FontFaceObject = void 0; var _util = __w_pdfjs_require__(2); class BaseFontLoader { constructor({ docId, onUnsupportedFeature, ownerDocument = globalThis.document }) { if (this.constructor === BaseFontLoader) { (0, _util.unreachable)("Cannot initialize BaseFontLoader."); } this.docId = docId; this._onUnsupportedFeature = onUnsupportedFeature; this._document = ownerDocument; this.nativeFontFaces = []; this.styleElement = null; } addNativeFontFace(nativeFontFace) { this.nativeFontFaces.push(nativeFontFace); this._document.fonts.add(nativeFontFace); } insertRule(rule) { let styleElement = this.styleElement; if (!styleElement) { styleElement = this.styleElement = this._document.createElement("style"); styleElement.id = `PDFJS_FONT_STYLE_TAG_${this.docId}`; this._document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement); } const styleSheet = styleElement.sheet; styleSheet.insertRule(rule, styleSheet.cssRules.length); } clear() { this.nativeFontFaces.forEach(nativeFontFace => { this._document.fonts.delete(nativeFontFace); }); this.nativeFontFaces.length = 0; if (this.styleElement) { this.styleElement.remove(); this.styleElement = null; } } async bind(font) { if (font.attached || font.missingFile) { return; } font.attached = true; if (this.isFontLoadingAPISupported) { const nativeFontFace = font.createNativeFontFace(); if (nativeFontFace) { this.addNativeFontFace(nativeFontFace); try { await nativeFontFace.loaded; } catch (ex) { this._onUnsupportedFeature({ featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative }); (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`); font.disableFontFace = true; throw ex; } } return; } const rule = font.createFontFaceRule(); if (rule) { this.insertRule(rule); if (this.isSyncFontLoadingSupported) { return; } await new Promise(resolve => { const request = this._queueLoadingCallback(resolve); this._prepareFontLoadEvent([rule], [font], request); }); } } _queueLoadingCallback(callback) { (0, _util.unreachable)("Abstract method `_queueLoadingCallback`."); } get isFontLoadingAPISupported() { const supported = typeof this._document !== "undefined" && !!this._document.fonts; return (0, _util.shadow)(this, "isFontLoadingAPISupported", supported); } get isSyncFontLoadingSupported() { (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`."); } get _loadTestFont() { (0, _util.unreachable)("Abstract method `_loadTestFont`."); } _prepareFontLoadEvent(rules, fontsToLoad, request) { (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`."); } } let FontLoader; exports.FontLoader = FontLoader; { exports.FontLoader = FontLoader = class GenericFontLoader extends BaseFontLoader { constructor(params) { super(params); this.loadingContext = { requests: [], nextRequestId: 0 }; this.loadTestFontId = 0; } get isSyncFontLoadingSupported() { let supported = false; if (typeof navigator === "undefined") { supported = true; } else { const m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent); if (m && m[1] >= 14) { supported = true; } } return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported); } _queueLoadingCallback(callback) { function completeRequest() { (0, _util.assert)(!request.done, "completeRequest() cannot be called twice."); request.done = true; while (context.requests.length > 0 && context.requests[0].done) { const otherRequest = context.requests.shift(); setTimeout(otherRequest.callback, 0); } } const context = this.loadingContext; const request = { id: `pdfjs-font-loading-${context.nextRequestId++}`, done: false, complete: completeRequest, callback }; context.requests.push(request); return request; } get _loadTestFont() { const getLoadTestFont = function () {
return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
}; return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont()); } _prepareFontLoadEvent(rules, fonts, request) { function int32(data, offset) { return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff; } function spliceString(s, offset, remove, insert) { const chunk1 = s.substring(0, offset); const chunk2 = s.substring(offset + remove); return chunk1 + insert + chunk2; } let i, ii; const canvas = this._document.createElement("canvas"); canvas.width = 1; canvas.height = 1; const ctx = canvas.getContext("2d"); let called = 0; function isFontReady(name, callback) { called++; if (called > 30) { (0, _util.warn)("Load test font never loaded."); callback(); return; } ctx.font = "30px " + name; ctx.fillText(".", 0, 20); const imageData = ctx.getImageData(0, 0, 1, 1); if (imageData.data[3] > 0) { callback(); return; } setTimeout(isFontReady.bind(null, name, callback)); } const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`; let data = this._loadTestFont; const COMMENT_OFFSET = 976; data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId); const CFF_CHECKSUM_OFFSET = 16; const XXXX_VALUE = 0x58585858; let checksum = int32(data, CFF_CHECKSUM_OFFSET); for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) { checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0; } if (i < loadTestFontId.length) { checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0; } data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum)); const url = `url(data:font/opentype;base64,${btoa(data)});`; const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`; this.insertRule(rule); const names = []; for (i = 0, ii = fonts.length; i < ii; i++) { names.push(fonts[i].loadedName); } names.push(loadTestFontId); const div = this._document.createElement("div"); div.style.visibility = "hidden"; div.style.width = div.style.height = "10px"; div.style.position = "absolute"; div.style.top = div.style.left = "0px"; for (i = 0, ii = names.length; i < ii; ++i) { const span = this._document.createElement("span"); span.textContent = "Hi"; span.style.fontFamily = names[i]; div.appendChild(span); } this._document.body.appendChild(div); isFontReady(loadTestFontId, () => { this._document.body.removeChild(div); request.complete(); }); } }; } class FontFaceObject { constructor(translatedData, { isEvalSupported = true, disableFontFace = false, ignoreErrors = false, onUnsupportedFeature = null, fontRegistry = null }) { this.compiledGlyphs = Object.create(null); for (const i in translatedData) { this[i] = translatedData[i]; } this.isEvalSupported = isEvalSupported !== false; this.disableFontFace = disableFontFace === true; this.ignoreErrors = ignoreErrors === true; this._onUnsupportedFeature = onUnsupportedFeature; this.fontRegistry = fontRegistry; } createNativeFontFace() { if (!this.data || this.disableFontFace) { return null; } const nativeFontFace = new FontFace(this.loadedName, this.data, {}); if (this.fontRegistry) { this.fontRegistry.registerFont(this); } return nativeFontFace; } createFontFaceRule() { if (!this.data || this.disableFontFace) { return null; } const data = (0, _util.bytesToString)(new Uint8Array(this.data)); const url = `url(data:${this.mimetype};base64,${btoa(data)});`; const rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`; if (this.fontRegistry) { this.fontRegistry.registerFont(this, url); } return rule; } getPathGenerator(objs, character) { if (this.compiledGlyphs[character] !== undefined) { return this.compiledGlyphs[character]; } let cmds, current; try { cmds = objs.get(this.loadedName + "_path_" + character); } catch (ex) { if (!this.ignoreErrors) { throw ex; } if (this._onUnsupportedFeature) { this._onUnsupportedFeature({ featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath }); } (0, _util.warn)(`getPathGenerator - ignoring character: "${ex}".`); return this.compiledGlyphs[character] = function (c, size) {}; } if (this.isEvalSupported && _util.IsEvalSupportedCached.value) { let args, js = ""; for (let i = 0, ii = cmds.length; i < ii; i++) { current = cmds[i]; if (current.args !== undefined) { args = current.args.join(","); } else { args = ""; } js += "c." + current.cmd + "(" + args + ");\n"; } return this.compiledGlyphs[character] = new Function("c", "size", js); } return this.compiledGlyphs[character] = function (c, size) { for (let i = 0, ii = cmds.length; i < ii; i++) { current = cmds[i]; if (current.cmd === "scale") { current.args = [size, -size]; } c[current.cmd].apply(c, current.args); } }; } } exports.FontFaceObject = FontFaceObject;
/***/ }),
/* 7 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.NodeCMapReaderFactory = exports.NodeCanvasFactory = void 0; var _display_utils = __w_pdfjs_require__(1); var _is_node = __w_pdfjs_require__(4); var _util = __w_pdfjs_require__(2); let NodeCanvasFactory = class { constructor() { (0, _util.unreachable)("Not implemented: NodeCanvasFactory"); } }; exports.NodeCanvasFactory = NodeCanvasFactory; let NodeCMapReaderFactory = class { constructor() { (0, _util.unreachable)("Not implemented: NodeCMapReaderFactory"); } }; exports.NodeCMapReaderFactory = NodeCMapReaderFactory; if (_is_node.isNodeJS) { exports.NodeCanvasFactory = NodeCanvasFactory = class extends _display_utils.BaseCanvasFactory { create(width, height) { if (width <= 0 || height <= 0) { throw new Error("Invalid canvas size"); } const Canvas = require("canvas"); const canvas = Canvas.createCanvas(width, height); return { canvas, context: canvas.getContext("2d") }; } }; exports.NodeCMapReaderFactory = NodeCMapReaderFactory = class extends _display_utils.BaseCMapReaderFactory { _fetchData(url, compressionType) { return new Promise((resolve, reject) => { const fs = require("fs"); fs.readFile(url, (error, data) => { if (error || !data) { reject(new Error(error)); return; } resolve({ cMapData: new Uint8Array(data), compressionType }); }); }); } }; }
/***/ }),
/* 8 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.AnnotationStorage = void 0; class AnnotationStorage { constructor() { this._storage = new Map(); this._modified = false; this.onSetModified = null; this.onResetModified = null; } getOrCreateValue(key, defaultValue) { if (this._storage.has(key)) { return this._storage.get(key); } this._storage.set(key, defaultValue); return defaultValue; } setValue(key, value) { if (this._storage.get(key) !== value) { this._setModified(); } this._storage.set(key, value); } getAll() { if (this._storage.size === 0) { return null; } return Object.fromEntries(this._storage); } get size() { return this._storage.size; } _setModified() { if (!this._modified) { this._modified = true; if (typeof this.onSetModified === "function") { this.onSetModified(); } } } resetModified() { if (this._modified) { this._modified = false; if (typeof this.onResetModified === "function") { this.onResetModified(); } } } } exports.AnnotationStorage = AnnotationStorage;
/***/ }),
/* 9 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.apiCompatibilityParams = void 0; var _is_node = __w_pdfjs_require__(4); const compatibilityParams = Object.create(null); { (function checkFontFace() { if (_is_node.isNodeJS) { compatibilityParams.disableFontFace = true; } })(); } const apiCompatibilityParams = Object.freeze(compatibilityParams); exports.apiCompatibilityParams = apiCompatibilityParams;
/***/ }),
/* 10 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.CanvasGraphics = void 0; var _util = __w_pdfjs_require__(2); var _pattern_helper = __w_pdfjs_require__(11); var MIN_FONT_SIZE = 16; var MAX_FONT_SIZE = 100; var MAX_GROUP_SIZE = 4096; var MIN_WIDTH_FACTOR = 0.65; var COMPILE_TYPE3_GLYPHS = true; var MAX_SIZE_TO_COMPILE = 1000; var FULL_CHUNK_HEIGHT = 16; function addContextCurrentTransform(ctx) { if (!ctx.mozCurrentTransform) { ctx._originalSave = ctx.save; ctx._originalRestore = ctx.restore; ctx._originalRotate = ctx.rotate; ctx._originalScale = ctx.scale; ctx._originalTranslate = ctx.translate; ctx._originalTransform = ctx.transform; ctx._originalSetTransform = ctx.setTransform; ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0]; ctx._transformStack = []; Object.defineProperty(ctx, "mozCurrentTransform", { get: function getCurrentTransform() { return this._transformMatrix; } }); Object.defineProperty(ctx, "mozCurrentTransformInverse", { get: function getCurrentTransformInverse() { var m = this._transformMatrix; var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5]; var ad_bc = a * d - b * c; var bc_ad = b * c - a * d; return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc]; } }); ctx.save = function ctxSave() { var old = this._transformMatrix; this._transformStack.push(old); this._transformMatrix = old.slice(0, 6); this._originalSave(); }; ctx.restore = function ctxRestore() { var prev = this._transformStack.pop(); if (prev) { this._transformMatrix = prev; this._originalRestore(); } }; ctx.translate = function ctxTranslate(x, y) { var m = this._transformMatrix; m[4] = m[0] * x + m[2] * y + m[4]; m[5] = m[1] * x + m[3] * y + m[5]; this._originalTranslate(x, y); }; ctx.scale = function ctxScale(x, y) { var m = this._transformMatrix; m[0] = m[0] * x; m[1] = m[1] * x; m[2] = m[2] * y; m[3] = m[3] * y; this._originalScale(x, y); }; ctx.transform = function ctxTransform(a, b, c, d, e, f) { var m = this._transformMatrix; this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]]; ctx._originalTransform(a, b, c, d, e, f); }; ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) { this._transformMatrix = [a, b, c, d, e, f]; ctx._originalSetTransform(a, b, c, d, e, f); }; ctx.rotate = function ctxRotate(angle) { var cosValue = Math.cos(angle); var sinValue = Math.sin(angle); var m = this._transformMatrix; this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]]; this._originalRotate(angle); }; } } var CachedCanvases = function CachedCanvasesClosure() { function CachedCanvases(canvasFactory) { this.canvasFactory = canvasFactory; this.cache = Object.create(null); } CachedCanvases.prototype = { getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) { var canvasEntry; if (this.cache[id] !== undefined) { canvasEntry = this.cache[id]; this.canvasFactory.reset(canvasEntry, width, height); canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0); } else { canvasEntry = this.canvasFactory.create(width, height); this.cache[id] = canvasEntry; } if (trackTransform) { addContextCurrentTransform(canvasEntry.context); } return canvasEntry; }, clear() { for (var id in this.cache) { var canvasEntry = this.cache[id]; this.canvasFactory.destroy(canvasEntry); delete this.cache[id]; } } }; return CachedCanvases; }(); function compileType3Glyph(imgData) { var POINT_TO_PROCESS_LIMIT = 1000; var width = imgData.width, height = imgData.height; var i, j, j0, width1 = width + 1; var points = new Uint8Array(width1 * (height + 1)); var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]); var lineSize = width + 7 & ~7, data0 = imgData.data; var data = new Uint8Array(lineSize * height), pos = 0, ii; for (i = 0, ii = data0.length; i < ii; i++) { var mask = 128, elem = data0[i]; while (mask > 0) { data[pos++] = elem & mask ? 0 : 255; mask >>= 1; } } var count = 0; pos = 0; if (data[pos] !== 0) { points[0] = 1; ++count; } for (j = 1; j < width; j++) { if (data[pos] !== data[pos + 1]) { points[j] = data[pos] ? 2 : 1; ++count; } pos++; } if (data[pos] !== 0) { points[j] = 2; ++count; } for (i = 1; i < height; i++) { pos = i * lineSize; j0 = i * width1; if (data[pos - lineSize] !== data[pos]) { points[j0] = data[pos] ? 1 : 8; ++count; } var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0); for (j = 1; j < width; j++) { sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0); if (POINT_TYPES[sum]) { points[j0 + j] = POINT_TYPES[sum]; ++count; } pos++; } if (data[pos - lineSize] !== data[pos]) { points[j0 + j] = data[pos] ? 2 : 4; ++count; } if (count > POINT_TO_PROCESS_LIMIT) { return null; } } pos = lineSize * (height - 1); j0 = i * width1; if (data[pos] !== 0) { points[j0] = 8; ++count; } for (j = 1; j < width; j++) { if (data[pos] !== data[pos + 1]) { points[j0 + j] = data[pos] ? 4 : 8; ++count; } pos++; } if (data[pos] !== 0) { points[j0 + j] = 4; ++count; } if (count > POINT_TO_PROCESS_LIMIT) { return null; } var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]); var outlines = []; for (i = 0; count && i <= height; i++) { var p = i * width1; var end = p + width; while (p < end && !points[p]) { p++; } if (p === end) { continue; } var coords = [p % width1, i]; var type = points[p], p0 = p, pp; do { var step = steps[type]; do { p += step; } while (!points[p]); pp = points[p]; if (pp !== 5 && pp !== 10) { type = pp; points[p] = 0; } else { type = pp & 0x33 * type >> 4; points[p] &= type >> 2 | type << 2; } coords.push(p % width1); coords.push(p / width1 | 0); if (!points[p]) { --count; } } while (p0 !== p); outlines.push(coords); --i; } var drawOutline = function (c) { c.save(); c.scale(1 / width, -1 / height); c.translate(0, -height); c.beginPath(); for (let k = 0, kk = outlines.length; k < kk; k++) { var o = outlines[k]; c.moveTo(o[0], o[1]); for (let l = 2, ll = o.length; l < ll; l += 2) { c.lineTo(o[l], o[l + 1]); } } c.fill(); c.beginPath(); c.restore(); }; return drawOutline; } var CanvasExtraState = function CanvasExtraStateClosure() { function CanvasExtraState() { this.alphaIsShape = false; this.fontSize = 0; this.fontSizeScale = 1; this.textMatrix = _util.IDENTITY_MATRIX; this.textMatrixScale = 1; this.fontMatrix = _util.FONT_IDENTITY_MATRIX; this.leading = 0; this.x = 0; this.y = 0; this.lineX = 0; this.lineY = 0; this.charSpacing = 0; this.wordSpacing = 0; this.textHScale = 1; this.textRenderingMode = _util.TextRenderingMode.FILL; this.textRise = 0; this.fillColor = "#000000"; this.strokeColor = "#000000"; this.patternFill = false; this.fillAlpha = 1; this.strokeAlpha = 1; this.lineWidth = 1; this.activeSMask = null; this.resumeSMaskCtx = null; this.transferMaps = null; } CanvasExtraState.prototype = { clone: function CanvasExtraState_clone() { return Object.create(this); }, setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) { this.x = x; this.y = y; } }; return CanvasExtraState; }(); var CanvasGraphics = function CanvasGraphicsClosure() { var EXECUTION_TIME = 15; var EXECUTION_STEPS = 10; function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer, optionalContentConfig) { this.ctx = canvasCtx; this.current = new CanvasExtraState(); this.stateStack = []; this.pendingClip = null; this.pendingEOFill = false; this.res = null; this.xobjs = null; this.commonObjs = commonObjs; this.objs = objs; this.canvasFactory = canvasFactory; this.webGLContext = webGLContext; this.imageLayer = imageLayer; this.groupStack = []; this.processingType3 = null; this.baseTransform = null; this.baseTransformStack = []; this.groupLevel = 0; this.smaskStack = []; this.smaskCounter = 0; this.tempSMask = null; this.contentVisible = true; this.markedContentStack = []; this.optionalContentConfig = optionalContentConfig; this.cachedCanvases = new CachedCanvases(this.canvasFactory); if (canvasCtx) { addContextCurrentTransform(canvasCtx); } this._cachedGetSinglePixelWidth = null; } function putBinaryImageData(ctx, imgData, transferMaps = null) { if (typeof ImageData !== "undefined" && imgData instanceof ImageData) { ctx.putImageData(imgData, 0, 0); return; } var height = imgData.height, width = imgData.width; var partialChunkHeight = height % FULL_CHUNK_HEIGHT; var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT; var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1; var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT); var srcPos = 0, destPos; var src = imgData.data; var dest = chunkImgData.data; var i, j, thisChunkHeight, elemsInThisChunk; let transferMapRed, transferMapGreen, transferMapBlue, transferMapGray; if (transferMaps) { switch (transferMaps.length) { case 1: transferMapRed = transferMaps[0]; transferMapGreen = transferMaps[0]; transferMapBlue = transferMaps[0]; transferMapGray = transferMaps[0]; break; case 4: transferMapRed = transferMaps[0]; transferMapGreen = transferMaps[1]; transferMapBlue = transferMaps[2]; transferMapGray = transferMaps[3]; break; } } if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) { var srcLength = src.byteLength; var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2); var dest32DataLength = dest32.length; var fullSrcDiff = width + 7 >> 3; var white = 0xffffffff; var black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff; if (transferMapGray) { if (transferMapGray[0] === 0xff && transferMapGray[0xff] === 0) { [white, black] = [black, white]; } } for (i = 0; i < totalChunks; i++) { thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight; destPos = 0; for (j = 0; j < thisChunkHeight; j++) { var srcDiff = srcLength - srcPos; let k = 0; var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7; var kEndUnrolled = kEnd & ~7; var mask = 0; var srcByte = 0; for (; k < kEndUnrolled; k += 8) { srcByte = src[srcPos++]; dest32[destPos++] = srcByte & 128 ? white : black; dest32[destPos++] = srcByte & 64 ? white : black; dest32[destPos++] = srcByte & 32 ? white : black; dest32[destPos++] = srcByte & 16 ? white : black; dest32[destPos++] = srcByte & 8 ? white : black; dest32[destPos++] = srcByte & 4 ? white : black; dest32[destPos++] = srcByte & 2 ? white : black; dest32[destPos++] = srcByte & 1 ? white : black; } for (; k < kEnd; k++) { if (mask === 0) { srcByte = src[srcPos++]; mask = 128; } dest32[destPos++] = srcByte & mask ? white : black; mask >>= 1; } } while (destPos < dest32DataLength) { dest32[destPos++] = 0; } ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) { const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue); j = 0; elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4; for (i = 0; i < fullChunks; i++) { dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk)); srcPos += elemsInThisChunk; if (hasTransferMaps) { for (let k = 0; k < elemsInThisChunk; k += 4) { if (transferMapRed) { dest[k + 0] = transferMapRed[dest[k + 0]]; } if (transferMapGreen) { dest[k + 1] = transferMapGreen[dest[k + 1]]; } if (transferMapBlue) { dest[k + 2] = transferMapBlue[dest[k + 2]]; } } } ctx.putImageData(chunkImgData, 0, j); j += FULL_CHUNK_HEIGHT; } if (i < totalChunks) { elemsInThisChunk = width * partialChunkHeight * 4; dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk)); if (hasTransferMaps) { for (let k = 0; k < elemsInThisChunk; k += 4) { if (transferMapRed) { dest[k + 0] = transferMapRed[dest[k + 0]]; } if (transferMapGreen) { dest[k + 1] = transferMapGreen[dest[k + 1]]; } if (transferMapBlue) { dest[k + 2] = transferMapBlue[dest[k + 2]]; } } } ctx.putImageData(chunkImgData, 0, j); } } else if (imgData.kind === _util.ImageKind.RGB_24BPP) { const hasTransferMaps = !!(transferMapRed || transferMapGreen || transferMapBlue); thisChunkHeight = FULL_CHUNK_HEIGHT; elemsInThisChunk = width * thisChunkHeight; for (i = 0; i < totalChunks; i++) { if (i >= fullChunks) { thisChunkHeight = partialChunkHeight; elemsInThisChunk = width * thisChunkHeight; } destPos = 0; for (j = elemsInThisChunk; j--;) { dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++]; dest[destPos++] = 255; } if (hasTransferMaps) { for (let k = 0; k < destPos; k += 4) { if (transferMapRed) { dest[k + 0] = transferMapRed[dest[k + 0]]; } if (transferMapGreen) { dest[k + 1] = transferMapGreen[dest[k + 1]]; } if (transferMapBlue) { dest[k + 2] = transferMapBlue[dest[k + 2]]; } } } ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } else { throw new Error(`bad image kind: ${imgData.kind}`); } } function putBinaryImageMask(ctx, imgData) { var height = imgData.height, width = imgData.width; var partialChunkHeight = height % FULL_CHUNK_HEIGHT; var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT; var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1; var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT); var srcPos = 0; var src = imgData.data; var dest = chunkImgData.data; for (var i = 0; i < totalChunks; i++) { var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight; var destPos = 3; for (var j = 0; j < thisChunkHeight; j++) { var mask = 0; for (var k = 0; k < width; k++) { if (!mask) { var elem = src[srcPos++]; mask = 128; } dest[destPos] = elem & mask ? 0 : 255; destPos += 4; mask >>= 1; } } ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } function copyCtxState(sourceCtx, destCtx) { var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"]; for (var i = 0, ii = properties.length; i < ii; i++) { var property = properties[i]; if (sourceCtx[property] !== undefined) { destCtx[property] = sourceCtx[property]; } } if (sourceCtx.setLineDash !== undefined) { destCtx.setLineDash(sourceCtx.getLineDash()); destCtx.lineDashOffset = sourceCtx.lineDashOffset; } } function resetCtxToDefault(ctx) { ctx.strokeStyle = "#000000"; ctx.fillStyle = "#000000"; ctx.fillRule = "nonzero"; ctx.globalAlpha = 1; ctx.lineWidth = 1; ctx.lineCap = "butt"; ctx.lineJoin = "miter"; ctx.miterLimit = 10; ctx.globalCompositeOperation = "source-over"; ctx.font = "10px sans-serif"; if (ctx.setLineDash !== undefined) { ctx.setLineDash([]); ctx.lineDashOffset = 0; } } function composeSMaskBackdrop(bytes, r0, g0, b0) { var length = bytes.length; for (var i = 3; i < length; i += 4) { var alpha = bytes[i]; if (alpha === 0) { bytes[i - 3] = r0; bytes[i - 2] = g0; bytes[i - 1] = b0; } else if (alpha < 255) { var alpha_ = 255 - alpha; bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8; bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8; bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8; } } } function composeSMaskAlpha(maskData, layerData, transferMap) { var length = maskData.length; var scale = 1 / 255; for (var i = 3; i < length; i += 4) { var alpha = transferMap ? transferMap[maskData[i]] : maskData[i]; layerData[i] = layerData[i] * alpha * scale | 0; } } function composeSMaskLuminosity(maskData, layerData, transferMap) { var length = maskData.length; for (var i = 3; i < length; i += 4) { var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28; layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16; } } function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) { var hasBackdrop = !!backdrop; var r0 = hasBackdrop ? backdrop[0] : 0; var g0 = hasBackdrop ? backdrop[1] : 0; var b0 = hasBackdrop ? backdrop[2] : 0; var composeFn; if (subtype === "Luminosity") { composeFn = composeSMaskLuminosity; } else { composeFn = composeSMaskAlpha; } var PIXELS_TO_PROCESS = 1048576; var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width)); for (var row = 0; row < height; row += chunkSize) { var chunkHeight = Math.min(chunkSize, height - row); var maskData = maskCtx.getImageData(0, row, width, chunkHeight); var layerData = layerCtx.getImageData(0, row, width, chunkHeight); if (hasBackdrop) { composeSMaskBackdrop(maskData.data, r0, g0, b0); } composeFn(maskData.data, layerData.data, transferMap); maskCtx.putImageData(layerData, 0, row); } } function composeSMask(ctx, smask, layerCtx, webGLContext) { var mask = smask.canvas; var maskCtx = smask.context; ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY); var backdrop = smask.backdrop || null; if (!smask.transferMap && webGLContext.isEnabled) { const composed = webGLContext.composeSMask({ layer: layerCtx.canvas, mask, properties: { subtype: smask.subtype, backdrop } }); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.drawImage(composed, smask.offsetX, smask.offsetY); return; } genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap); ctx.drawImage(mask, 0, 0); } var LINE_CAP_STYLES = ["butt", "round", "square"]; var LINE_JOIN_STYLES = ["miter", "round", "bevel"]; var NORMAL_CLIP = {}; var EO_CLIP = {}; CanvasGraphics.prototype = { beginDrawing({ transform, viewport, transparency = false, background = null }) { var width = this.ctx.canvas.width; var height = this.ctx.canvas.height; this.ctx.save(); this.ctx.fillStyle = background || "rgb(255, 255, 255)"; this.ctx.fillRect(0, 0, width, height); this.ctx.restore(); if (transparency) { var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true); this.compositeCtx = this.ctx; this.transparentCanvas = transparentCanvas.canvas; this.ctx = transparentCanvas.context; this.ctx.save(); this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform); } this.ctx.save(); resetCtxToDefault(this.ctx); if (transform) { this.ctx.transform.apply(this.ctx, transform); } this.ctx.transform.apply(this.ctx, viewport.transform); this.baseTransform = this.ctx.mozCurrentTransform.slice(); if (this.imageLayer) { this.imageLayer.beginLayout(); } }, executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) { var argsArray = operatorList.argsArray; var fnArray = operatorList.fnArray; var i = executionStartIdx || 0; var argsArrayLen = argsArray.length; if (argsArrayLen === i) { return i; } var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function"; var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0; var steps = 0; var commonObjs = this.commonObjs; var objs = this.objs; var fnId; while (true) { if (stepper !== undefined && i === stepper.nextBreakPoint) { stepper.breakIt(i, continueCallback); return i; } fnId = fnArray[i]; if (fnId !== _util.OPS.dependency) { this[fnId].apply(this, argsArray[i]); } else { for (const depObjId of argsArray[i]) { const objsPool = depObjId.startsWith("g_") ? commonObjs : objs; if (!objsPool.has(depObjId)) { objsPool.get(depObjId, continueCallback); return i; } } } i++; if (i === argsArrayLen) { return i; } if (chunkOperations && ++steps > EXECUTION_STEPS) { if (Date.now() > endTime) { continueCallback(); return i; } steps = 0; } } }, endDrawing: function CanvasGraphics_endDrawing() { if (this.current.activeSMask !== null) { this.endSMaskGroup(); } this.ctx.restore(); if (this.transparentCanvas) { this.ctx = this.compositeCtx; this.ctx.save(); this.ctx.setTransform(1, 0, 0, 1, 0, 0); this.ctx.drawImage(this.transparentCanvas, 0, 0); this.ctx.restore(); this.transparentCanvas = null; } this.cachedCanvases.clear(); this.webGLContext.clear(); if (this.imageLayer) { this.imageLayer.endLayout(); } }, setLineWidth: function CanvasGraphics_setLineWidth(width) { this.current.lineWidth = width; this.ctx.lineWidth = width; }, setLineCap: function CanvasGraphics_setLineCap(style) { this.ctx.lineCap = LINE_CAP_STYLES[style]; }, setLineJoin: function CanvasGraphics_setLineJoin(style) { this.ctx.lineJoin = LINE_JOIN_STYLES[style]; }, setMiterLimit: function CanvasGraphics_setMiterLimit(limit) { this.ctx.miterLimit = limit; }, setDash: function CanvasGraphics_setDash(dashArray, dashPhase) { var ctx = this.ctx; if (ctx.setLineDash !== undefined) { ctx.setLineDash(dashArray); ctx.lineDashOffset = dashPhase; } }, setRenderingIntent(intent) {}, setFlatness(flatness) {}, setGState: function CanvasGraphics_setGState(states) { for (var i = 0, ii = states.length; i < ii; i++) { var state = states[i]; var key = state[0]; var value = state[1]; switch (key) { case "LW": this.setLineWidth(value); break; case "LC": this.setLineCap(value); break; case "LJ": this.setLineJoin(value); break; case "ML": this.setMiterLimit(value); break; case "D": this.setDash(value[0], value[1]); break; case "RI": this.setRenderingIntent(value); break; case "FL": this.setFlatness(value); break; case "Font": this.setFont(value[0], value[1]); break; case "CA": this.current.strokeAlpha = state[1]; break; case "ca": this.current.fillAlpha = state[1]; this.ctx.globalAlpha = state[1]; break; case "BM": this.ctx.globalCompositeOperation = value; break; case "SMask": if (this.current.activeSMask) { if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) { this.suspendSMaskGroup(); } else { this.endSMaskGroup(); } } this.current.activeSMask = value ? this.tempSMask : null; if (this.current.activeSMask) { this.beginSMaskGroup(); } this.tempSMask = null; break; case "TR": this.current.transferMaps = value; } } }, beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() { var activeSMask = this.current.activeSMask; var drawnWidth = activeSMask.canvas.width; var drawnHeight = activeSMask.canvas.height; var cacheId = "smaskGroupAt" + this.groupLevel; var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true); var currentCtx = this.ctx; var currentTransform = currentCtx.mozCurrentTransform; this.ctx.save(); var groupCtx = scratchCanvas.context; groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY); groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY); groupCtx.transform.apply(groupCtx, currentTransform); activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse; copyCtxState(currentCtx, groupCtx); this.ctx = groupCtx; this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]); this.groupStack.push(currentCtx); this.groupLevel++; }, suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() { var groupCtx = this.ctx; this.groupLevel--; this.ctx = this.groupStack.pop(); composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext); this.ctx.restore(); this.ctx.save(); copyCtxState(groupCtx, this.ctx); this.current.resumeSMaskCtx = groupCtx; var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform); this.ctx.transform.apply(this.ctx, deltaTransform); groupCtx.save(); groupCtx.setTransform(1, 0, 0, 1, 0, 0); groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height); groupCtx.restore(); }, resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() { var groupCtx = this.current.resumeSMaskCtx; var currentCtx = this.ctx; this.ctx = groupCtx; this.groupStack.push(currentCtx); this.groupLevel++; }, endSMaskGroup: function CanvasGraphics_endSMaskGroup() { var groupCtx = this.ctx; this.groupLevel--; this.ctx = this.groupStack.pop(); composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext); this.ctx.restore(); copyCtxState(groupCtx, this.ctx); var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform); this.ctx.transform.apply(this.ctx, deltaTransform); }, save: function CanvasGraphics_save() { this.ctx.save(); var old = this.current; this.stateStack.push(old); this.current = old.clone(); this.current.resumeSMaskCtx = null; }, restore: function CanvasGraphics_restore() { if (this.current.resumeSMaskCtx) { this.resumeSMaskGroup(); } if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) { this.endSMaskGroup(); } if (this.stateStack.length !== 0) { this.current = this.stateStack.pop(); this.ctx.restore(); this.pendingClip = null; this._cachedGetSinglePixelWidth = null; } }, transform: function CanvasGraphics_transform(a, b, c, d, e, f) { this.ctx.transform(a, b, c, d, e, f); this._cachedGetSinglePixelWidth = null; }, constructPath: function CanvasGraphics_constructPath(ops, args) { var ctx = this.ctx; var current = this.current; var x = current.x, y = current.y; for (var i = 0, j = 0, ii = ops.length; i < ii; i++) { switch (ops[i] | 0) { case _util.OPS.rectangle: x = args[j++]; y = args[j++]; var width = args[j++]; var height = args[j++]; if (width === 0 && ctx.lineWidth < this.getSinglePixelWidth()) { width = this.getSinglePixelWidth(); } if (height === 0 && ctx.lineWidth < this.getSinglePixelWidth()) { height = this.getSinglePixelWidth(); } var xw = x + width; var yh = y + height; ctx.moveTo(x, y); ctx.lineTo(xw, y); ctx.lineTo(xw, yh); ctx.lineTo(x, yh); ctx.lineTo(x, y); ctx.closePath(); break; case _util.OPS.moveTo: x = args[j++]; y = args[j++]; ctx.moveTo(x, y); break; case _util.OPS.lineTo: x = args[j++]; y = args[j++]; ctx.lineTo(x, y); break; case _util.OPS.curveTo: x = args[j + 4]; y = args[j + 5]; ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y); j += 6; break; case _util.OPS.curveTo2: ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]); x = args[j + 2]; y = args[j + 3]; j += 4; break; case _util.OPS.curveTo3: x = args[j + 2]; y = args[j + 3]; ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y); j += 4; break; case _util.OPS.closePath: ctx.closePath(); break; } } current.setCurrentPoint(x, y); }, closePath: function CanvasGraphics_closePath() { this.ctx.closePath(); }, stroke: function CanvasGraphics_stroke(consumePath) { consumePath = typeof consumePath !== "undefined" ? consumePath : true; var ctx = this.ctx; var strokeColor = this.current.strokeColor; ctx.globalAlpha = this.current.strokeAlpha; if (this.contentVisible) { if (strokeColor && strokeColor.hasOwnProperty("type") && strokeColor.type === "Pattern") { ctx.save(); const transform = ctx.mozCurrentTransform; const scale = _util.Util.singularValueDecompose2dScale(transform)[0]; ctx.strokeStyle = strokeColor.getPattern(ctx, this); ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth * scale); ctx.stroke(); ctx.restore(); } else { ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth); ctx.stroke(); } } if (consumePath) { this.consumePath(); } ctx.globalAlpha = this.current.fillAlpha; }, closeStroke: function CanvasGraphics_closeStroke() { this.closePath(); this.stroke(); }, fill: function CanvasGraphics_fill(consumePath) { consumePath = typeof consumePath !== "undefined" ? consumePath : true; var ctx = this.ctx; var fillColor = this.current.fillColor; var isPatternFill = this.current.patternFill; var needRestore = false; if (isPatternFill) { ctx.save(); if (this.baseTransform) { ctx.setTransform.apply(ctx, this.baseTransform); } ctx.fillStyle = fillColor.getPattern(ctx, this); needRestore = true; } if (this.contentVisible) { if (this.pendingEOFill) { ctx.fill("evenodd"); this.pendingEOFill = false; } else { ctx.fill(); } } if (needRestore) { ctx.restore(); } if (consumePath) { this.consumePath(); } }, eoFill: function CanvasGraphics_eoFill() { this.pendingEOFill = true; this.fill(); }, fillStroke: function CanvasGraphics_fillStroke() { this.fill(false); this.stroke(false); this.consumePath(); }, eoFillStroke: function CanvasGraphics_eoFillStroke() { this.pendingEOFill = true; this.fillStroke(); }, closeFillStroke: function CanvasGraphics_closeFillStroke() { this.closePath(); this.fillStroke(); }, closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() { this.pendingEOFill = true; this.closePath(); this.fillStroke(); }, endPath: function CanvasGraphics_endPath() { this.consumePath(); }, clip: function CanvasGraphics_clip() { this.pendingClip = NORMAL_CLIP; }, eoClip: function CanvasGraphics_eoClip() { this.pendingClip = EO_CLIP; }, beginText: function CanvasGraphics_beginText() { this.current.textMatrix = _util.IDENTITY_MATRIX; this.current.textMatrixScale = 1; this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0; }, endText: function CanvasGraphics_endText() { var paths = this.pendingTextPaths; var ctx = this.ctx; if (paths === undefined) { ctx.beginPath(); return; } ctx.save(); ctx.beginPath(); for (var i = 0; i < paths.length; i++) { var path = paths[i]; ctx.setTransform.apply(ctx, path.transform); ctx.translate(path.x, path.y); path.addToPath(ctx, path.fontSize); } ctx.restore(); ctx.clip(); ctx.beginPath(); delete this.pendingTextPaths; }, setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) { this.current.charSpacing = spacing; }, setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) { this.current.wordSpacing = spacing; }, setHScale: function CanvasGraphics_setHScale(scale) { this.current.textHScale = scale / 100; }, setLeading: function CanvasGraphics_setLeading(leading) { this.current.leading = -leading; }, setFont: function CanvasGraphics_setFont(fontRefName, size) { var fontObj = this.commonObjs.get(fontRefName); var current = this.current; if (!fontObj) { throw new Error(`Can't find font for ${fontRefName}`); } current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX; if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) { (0, _util.warn)("Invalid font matrix for font " + fontRefName); } if (size < 0) { size = -size; current.fontDirection = -1; } else { current.fontDirection = 1; } this.current.font = fontObj; this.current.fontSize = size; if (fontObj.isType3Font) { return; } var name = fontObj.loadedName || "sans-serif"; let bold = "normal"; if (fontObj.black) { bold = "900"; } else if (fontObj.bold) { bold = "bold"; } var italic = fontObj.italic ? "italic" : "normal"; var typeface = `"${name}", ${fontObj.fallbackName}`; let browserFontSize = size; if (size < MIN_FONT_SIZE) { browserFontSize = MIN_FONT_SIZE; } else if (size > MAX_FONT_SIZE) { browserFontSize = MAX_FONT_SIZE; } this.current.fontSizeScale = size / browserFontSize; this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`; }, setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) { this.current.textRenderingMode = mode; }, setTextRise: function CanvasGraphics_setTextRise(rise) { this.current.textRise = rise; }, moveText: function CanvasGraphics_moveText(x, y) { this.current.x = this.current.lineX += x; this.current.y = this.current.lineY += y; }, setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) { this.setLeading(-y); this.moveText(x, y); }, setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) { this.current.textMatrix = [a, b, c, d, e, f]; this.current.textMatrixScale = Math.sqrt(a * a + b * b); this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0; }, nextLine: function CanvasGraphics_nextLine() { this.moveText(0, this.current.leading); }, paintChar(character, x, y, patternTransform) { var ctx = this.ctx; var current = this.current; var font = current.font; var textRenderingMode = current.textRenderingMode; var fontSize = current.fontSize / current.fontSizeScale; var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG); const patternFill = current.patternFill && !font.missingFile; var addToPath; if (font.disableFontFace || isAddToPathSet || patternFill) { addToPath = font.getPathGenerator(this.commonObjs, character); } if (font.disableFontFace || patternFill) { ctx.save(); ctx.translate(x, y); ctx.beginPath(); addToPath(ctx, fontSize); if (patternTransform) { ctx.setTransform.apply(ctx, patternTransform); } if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.fill(); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.stroke(); } ctx.restore(); } else { if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.fillText(character, x, y); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.strokeText(character, x, y); } } if (isAddToPathSet) { var paths = this.pendingTextPaths || (this.pendingTextPaths = []); paths.push({ transform: ctx.mozCurrentTransform, x, y, fontSize, addToPath }); } }, get isFontSubpixelAAEnabled() { const { context: ctx } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10); ctx.scale(1.5, 1); ctx.fillText("I", 0, 10); var data = ctx.getImageData(0, 0, 10, 10).data; var enabled = false; for (var i = 3; i < data.length; i += 4) { if (data[i] > 0 && data[i] < 255) { enabled = true; break; } } return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled); }, showText: function CanvasGraphics_showText(glyphs) { var current = this.current; var font = current.font; if (font.isType3Font) { return this.showType3Text(glyphs); } var fontSize = current.fontSize; if (fontSize === 0) { return undefined; } var ctx = this.ctx; var fontSizeScale = current.fontSizeScale; var charSpacing = current.charSpacing; var wordSpacing = current.wordSpacing; var fontDirection = current.fontDirection; var textHScale = current.textHScale * fontDirection; var glyphsLength = glyphs.length; var vertical = font.vertical; var spacingDir = vertical ? 1 : -1; var defaultVMetrics = font.defaultVMetrics; var widthAdvanceScale = fontSize * current.fontMatrix[0]; var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill; ctx.save(); let patternTransform; if (current.patternFill) { ctx.save(); const pattern = current.fillColor.getPattern(ctx, this); patternTransform = ctx.mozCurrentTransform; ctx.restore(); ctx.fillStyle = pattern; } ctx.transform.apply(ctx, current.textMatrix); ctx.translate(current.x, current.y + current.textRise); if (fontDirection > 0) { ctx.scale(textHScale, -1); } else { ctx.scale(textHScale, 1); } var lineWidth = current.lineWidth; var scale = current.textMatrixScale; if (scale === 0 || lineWidth === 0) { var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { this._cachedGetSinglePixelWidth = null; lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR; } } else { lineWidth /= scale; } if (fontSizeScale !== 1.0) { ctx.scale(fontSizeScale, fontSizeScale); lineWidth /= fontSizeScale; } ctx.lineWidth = lineWidth; var x = 0, i; for (i = 0; i < glyphsLength; ++i) { var glyph = glyphs[i]; if ((0, _util.isNum)(glyph)) { x += spacingDir * glyph * fontSize / 1000; continue; } var restoreNeeded = false; var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; var character = glyph.fontChar; var accent = glyph.accent; var scaledX, scaledY, scaledAccentX, scaledAccentY; var width = glyph.width; if (vertical) { var vmetric, vx, vy; vmetric = glyph.vmetric || defaultVMetrics; vx = glyph.vmetric ? vmetric[1] : width * 0.5; vx = -vx * widthAdvanceScale; vy = vmetric[2] * widthAdvanceScale; width = vmetric ? -vmetric[0] : width; scaledX = vx / fontSizeScale; scaledY = (x + vy) / fontSizeScale; } else { scaledX = x / fontSizeScale; scaledY = 0; } if (font.remeasure && width > 0) { var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale; if (width < measuredWidth && this.isFontSubpixelAAEnabled) { var characterScaleX = width / measuredWidth; restoreNeeded = true; ctx.save(); ctx.scale(characterScaleX, 1); scaledX /= characterScaleX; } else if (width !== measuredWidth) { scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale; } } if (this.contentVisible && (glyph.isInFont || font.missingFile)) { if (simpleFillText && !accent) { ctx.fillText(character, scaledX, scaledY); } else { this.paintChar(character, scaledX, scaledY, patternTransform); if (accent) { scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale; scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale; this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform); } } } var charWidth; if (vertical) { charWidth = width * widthAdvanceScale - spacing * fontDirection; } else { charWidth = width * widthAdvanceScale + spacing * fontDirection; } x += charWidth; if (restoreNeeded) { ctx.restore(); } } if (vertical) { current.y -= x; } else { current.x += x * textHScale; } ctx.restore(); }, showType3Text: function CanvasGraphics_showType3Text(glyphs) { var ctx = this.ctx; var current = this.current; var font = current.font; var fontSize = current.fontSize; var fontDirection = current.fontDirection; var spacingDir = font.vertical ? 1 : -1; var charSpacing = current.charSpacing; var wordSpacing = current.wordSpacing; var textHScale = current.textHScale * fontDirection; var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX; var glyphsLength = glyphs.length; var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE; var i, glyph, width, spacingLength; if (isTextInvisible || fontSize === 0) { return; } this._cachedGetSinglePixelWidth = null; ctx.save(); ctx.transform.apply(ctx, current.textMatrix); ctx.translate(current.x, current.y); ctx.scale(textHScale, fontDirection); for (i = 0; i < glyphsLength; ++i) { glyph = glyphs[i]; if ((0, _util.isNum)(glyph)) { spacingLength = spacingDir * glyph * fontSize / 1000; this.ctx.translate(spacingLength, 0); current.x += spacingLength * textHScale; continue; } var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; var operatorList = font.charProcOperatorList[glyph.operatorListId]; if (!operatorList) { (0, _util.warn)(`Type3 character "${glyph.operatorListId}" is not available.`); continue; } if (this.contentVisible) { this.processingType3 = glyph; this.save(); ctx.scale(fontSize, fontSize); ctx.transform.apply(ctx, fontMatrix); this.executeOperatorList(operatorList); this.restore(); } var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix); width = transformed[0] * fontSize + spacing; ctx.translate(width, 0); current.x += width * textHScale; } ctx.restore(); this.processingType3 = null; }, setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {}, setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) { this.ctx.rect(llx, lly, urx - llx, ury - lly); this.clip(); this.endPath(); }, getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) { var pattern; if (IR[0] === "TilingPattern") { var color = IR[1]; var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice(); var canvasGraphicsFactory = { createCanvasGraphics: ctx => { return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext); } }; pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform); } else { pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR); } return pattern; }, setStrokeColorN: function CanvasGraphics_setStrokeColorN() { this.current.strokeColor = this.getColorN_Pattern(arguments); }, setFillColorN: function CanvasGraphics_setFillColorN() { this.current.fillColor = this.getColorN_Pattern(arguments); this.current.patternFill = true; }, setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) { var color = _util.Util.makeCssRgb(r, g, b); this.ctx.strokeStyle = color; this.current.strokeColor = color; }, setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
/* BEGIN COLOR TRICK BY SANZ */
if(r==39 && g==128 && b==227) { r=pdfColor[0]; g=pdfColor[1]; b=pdfColor[2]; }
/* END COLOR TRICK BY SANZ */
var color = _util.Util.makeCssRgb(r, g, b); this.ctx.fillStyle = color; this.current.fillColor = color; this.current.patternFill = false; }, shadingFill: function CanvasGraphics_shadingFill(patternIR) { if (!this.contentVisible) { return; } var ctx = this.ctx; this.save(); var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR); ctx.fillStyle = pattern.getPattern(ctx, this, true); var inv = ctx.mozCurrentTransformInverse; if (inv) { var canvas = ctx.canvas; var width = canvas.width; var height = canvas.height; var bl = _util.Util.applyTransform([0, 0], inv); var br = _util.Util.applyTransform([0, height], inv); var ul = _util.Util.applyTransform([width, 0], inv); var ur = _util.Util.applyTransform([width, height], inv); var x0 = Math.min(bl[0], br[0], ul[0], ur[0]); var y0 = Math.min(bl[1], br[1], ul[1], ur[1]); var x1 = Math.max(bl[0], br[0], ul[0], ur[0]); var y1 = Math.max(bl[1], br[1], ul[1], ur[1]); this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0); } else { this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10); } this.restore(); }, beginInlineImage: function CanvasGraphics_beginInlineImage() { (0, _util.unreachable)("Should not call beginInlineImage"); }, beginImageData: function CanvasGraphics_beginImageData() { (0, _util.unreachable)("Should not call beginImageData"); }, paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) { if (!this.contentVisible) { return; } this.save(); this.baseTransformStack.push(this.baseTransform); if (Array.isArray(matrix) && matrix.length === 6) { this.transform.apply(this, matrix); } this.baseTransform = this.ctx.mozCurrentTransform; if (bbox) { var width = bbox[2] - bbox[0]; var height = bbox[3] - bbox[1]; this.ctx.rect(bbox[0], bbox[1], width, height); this.clip(); this.endPath(); } }, paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() { if (!this.contentVisible) { return; } this.restore(); this.baseTransform = this.baseTransformStack.pop(); }, beginGroup: function CanvasGraphics_beginGroup(group) { if (!this.contentVisible) { return; } this.save(); var currentCtx = this.ctx; if (!group.isolated) { (0, _util.info)("TODO: Support non-isolated groups."); } if (group.knockout) { (0, _util.warn)("Knockout groups not supported."); } var currentTransform = currentCtx.mozCurrentTransform; if (group.matrix) { currentCtx.transform.apply(currentCtx, group.matrix); } if (!group.bbox) { throw new Error("Bounding box is required."); } var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform); var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height]; bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0]; var offsetX = Math.floor(bounds[0]); var offsetY = Math.floor(bounds[1]); var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1); var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1); var scaleX = 1, scaleY = 1; if (drawnWidth > MAX_GROUP_SIZE) { scaleX = drawnWidth / MAX_GROUP_SIZE; drawnWidth = MAX_GROUP_SIZE; } if (drawnHeight > MAX_GROUP_SIZE) { scaleY = drawnHeight / MAX_GROUP_SIZE; drawnHeight = MAX_GROUP_SIZE; } var cacheId = "groupAt" + this.groupLevel; if (group.smask) { cacheId += "_smask_" + this.smaskCounter++ % 2; } var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true); var groupCtx = scratchCanvas.context; groupCtx.scale(1 / scaleX, 1 / scaleY); groupCtx.translate(-offsetX, -offsetY); groupCtx.transform.apply(groupCtx, currentTransform); if (group.smask) { this.smaskStack.push({ canvas: scratchCanvas.canvas, context: groupCtx, offsetX, offsetY, scaleX, scaleY, subtype: group.smask.subtype, backdrop: group.smask.backdrop, transferMap: group.smask.transferMap || null, startTransformInverse: null }); } else { currentCtx.setTransform(1, 0, 0, 1, 0, 0); currentCtx.translate(offsetX, offsetY); currentCtx.scale(scaleX, scaleY); } copyCtxState(currentCtx, groupCtx); this.ctx = groupCtx; this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]); this.groupStack.push(currentCtx); this.groupLevel++; this.current.activeSMask = null; }, endGroup: function CanvasGraphics_endGroup(group) { if (!this.contentVisible) { return; } this.groupLevel--; var groupCtx = this.ctx; this.ctx = this.groupStack.pop(); if (this.ctx.imageSmoothingEnabled !== undefined) { this.ctx.imageSmoothingEnabled = false; } else { this.ctx.mozImageSmoothingEnabled = false; } if (group.smask) { this.tempSMask = this.smaskStack.pop(); } else { this.ctx.drawImage(groupCtx.canvas, 0, 0); } this.restore(); }, beginAnnotations: function CanvasGraphics_beginAnnotations() { this.save(); if (this.baseTransform) { this.ctx.setTransform.apply(this.ctx, this.baseTransform); } }, endAnnotations: function CanvasGraphics_endAnnotations() { this.restore(); }, beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) { this.save(); resetCtxToDefault(this.ctx); this.current = new CanvasExtraState(); if (Array.isArray(rect) && rect.length === 4) { var width = rect[2] - rect[0]; var height = rect[3] - rect[1]; this.ctx.rect(rect[0], rect[1], width, height); this.clip(); this.endPath(); } this.transform.apply(this, transform); this.transform.apply(this, matrix); }, endAnnotation: function CanvasGraphics_endAnnotation() { this.restore(); }, paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) { if (!this.contentVisible) { return; } var ctx = this.ctx; var width = img.width, height = img.height; var fillColor = this.current.fillColor; var isPatternFill = this.current.patternFill; var glyph = this.processingType3; if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) { if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) { glyph.compiled = compileType3Glyph({ data: img.data, width, height }); } else { glyph.compiled = null; } } if (glyph && glyph.compiled) { glyph.compiled(ctx); return; } var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height); var maskCtx = maskCanvas.context; maskCtx.save(); putBinaryImageMask(maskCtx, img); maskCtx.globalCompositeOperation = "source-in"; maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor; maskCtx.fillRect(0, 0, width, height); maskCtx.restore(); this.paintInlineImageXObject(maskCanvas.canvas); }, paintImageMaskXObjectRepeat(imgData, scaleX, skewX = 0, skewY = 0, scaleY, positions) { if (!this.contentVisible) { return; } var width = imgData.width; var height = imgData.height; var fillColor = this.current.fillColor; var isPatternFill = this.current.patternFill; var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height); var maskCtx = maskCanvas.context; maskCtx.save(); putBinaryImageMask(maskCtx, imgData); maskCtx.globalCompositeOperation = "source-in"; maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor; maskCtx.fillRect(0, 0, width, height); maskCtx.restore(); var ctx = this.ctx; for (var i = 0, ii = positions.length; i < ii; i += 2) { ctx.save(); ctx.transform(scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]); ctx.scale(1, -1); ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1); ctx.restore(); } }, paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) { if (!this.contentVisible) { return; } var ctx = this.ctx; var fillColor = this.current.fillColor; var isPatternFill = this.current.patternFill; for (var i = 0, ii = images.length; i < ii; i++) { var image = images[i]; var width = image.width, height = image.height; var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height); var maskCtx = maskCanvas.context; maskCtx.save(); putBinaryImageMask(maskCtx, image); maskCtx.globalCompositeOperation = "source-in"; maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor; maskCtx.fillRect(0, 0, width, height); maskCtx.restore(); ctx.save(); ctx.transform.apply(ctx, image.transform); ctx.scale(1, -1); ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1); ctx.restore(); } }, paintImageXObject: function CanvasGraphics_paintImageXObject(objId) { if (!this.contentVisible) { return; } const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId); if (!imgData) { (0, _util.warn)("Dependent image isn't ready yet"); return; } this.paintInlineImageXObject(imgData); }, paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) { if (!this.contentVisible) { return; } const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId); if (!imgData) { (0, _util.warn)("Dependent image isn't ready yet"); return; } var width = imgData.width; var height = imgData.height; var map = []; for (var i = 0, ii = positions.length; i < ii; i += 2) { map.push({ transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]], x: 0, y: 0, w: width, h: height }); } this.paintInlineImageXObjectGroup(imgData, map); }, paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) { if (!this.contentVisible) { return; } var width = imgData.width; var height = imgData.height; var ctx = this.ctx; this.save(); ctx.scale(1 / width, -1 / height); var currentTransform = ctx.mozCurrentTransformInverse; var a = currentTransform[0], b = currentTransform[1]; var widthScale = Math.max(Math.sqrt(a * a + b * b), 1); var c = currentTransform[2], d = currentTransform[3]; var heightScale = Math.max(Math.sqrt(c * c + d * d), 1); var imgToPaint, tmpCanvas; if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) { imgToPaint = imgData; } else { tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height); var tmpCtx = tmpCanvas.context; putBinaryImageData(tmpCtx, imgData, this.current.transferMaps); imgToPaint = tmpCanvas.canvas; } var paintWidth = width, paintHeight = height; var tmpCanvasId = "prescale1"; while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) { var newWidth = paintWidth, newHeight = paintHeight; if (widthScale > 2 && paintWidth > 1) { newWidth = Math.ceil(paintWidth / 2); widthScale /= paintWidth / newWidth; } if (heightScale > 2 && paintHeight > 1) { newHeight = Math.ceil(paintHeight / 2); heightScale /= paintHeight / newHeight; } tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight); tmpCtx = tmpCanvas.context; tmpCtx.clearRect(0, 0, newWidth, newHeight); tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight); imgToPaint = tmpCanvas.canvas; paintWidth = newWidth; paintHeight = newHeight; tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1"; } ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height); if (this.imageLayer) { var position = this.getCanvasPosition(0, -height); this.imageLayer.appendImage({ imgData, left: position[0], top: position[1], width: width / currentTransform[0], height: height / currentTransform[3] }); } this.restore(); }, paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) { if (!this.contentVisible) { return; } var ctx = this.ctx; var w = imgData.width; var h = imgData.height; var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h); var tmpCtx = tmpCanvas.context; putBinaryImageData(tmpCtx, imgData, this.current.transferMaps); for (var i = 0, ii = map.length; i < ii; i++) { var entry = map[i]; ctx.save(); ctx.transform.apply(ctx, entry.transform); ctx.scale(1, -1); ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1); if (this.imageLayer) { var position = this.getCanvasPosition(entry.x, entry.y); this.imageLayer.appendImage({ imgData, left: position[0], top: position[1], width: w, height: h }); } ctx.restore(); } }, paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() { if (!this.contentVisible) { return; } this.ctx.fillRect(0, 0, 1, 1); }, markPoint: function CanvasGraphics_markPoint(tag) {}, markPointProps: function CanvasGraphics_markPointProps(tag, properties) {}, beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) { this.markedContentStack.push({ visible: true }); }, beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) { if (tag === "OC") { this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(properties) }); } else { this.markedContentStack.push({ visible: true }); } this.contentVisible = this.isContentVisible(); }, endMarkedContent: function CanvasGraphics_endMarkedContent() { this.markedContentStack.pop(); this.contentVisible = this.isContentVisible(); }, beginCompat: function CanvasGraphics_beginCompat() {}, endCompat: function CanvasGraphics_endCompat() {}, consumePath: function CanvasGraphics_consumePath() { var ctx = this.ctx; if (this.pendingClip) { if (this.pendingClip === EO_CLIP) { ctx.clip("evenodd"); } else { ctx.clip(); } this.pendingClip = null; } ctx.beginPath(); }, getSinglePixelWidth(scale) { if (this._cachedGetSinglePixelWidth === null) { const inverse = this.ctx.mozCurrentTransformInverse; this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3])); } return this._cachedGetSinglePixelWidth; }, getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) { var transform = this.ctx.mozCurrentTransform; return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]]; }, isContentVisible: function CanvasGraphics_isContentVisible() { for (let i = this.markedContentStack.length - 1; i >= 0; i--) { if (!this.markedContentStack[i].visible) { return false; } } return true; } }; for (var op in _util.OPS) { CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op]; } return CanvasGraphics; }(); exports.CanvasGraphics = CanvasGraphics;
/***/ }),
/* 11 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.getShadingPatternFromIR = getShadingPatternFromIR; exports.TilingPattern = void 0; var _util = __w_pdfjs_require__(2); var ShadingIRs = {}; function applyBoundingBox(ctx, bbox) { if (!bbox || typeof Path2D === "undefined") { return; } const width = bbox[2] - bbox[0]; const height = bbox[3] - bbox[1]; const region = new Path2D(); region.rect(bbox[0], bbox[1], width, height); ctx.clip(region); } ShadingIRs.RadialAxial = { fromIR: function RadialAxial_fromIR(raw) { var type = raw[1]; var bbox = raw[2]; var colorStops = raw[3]; var p0 = raw[4]; var p1 = raw[5]; var r0 = raw[6]; var r1 = raw[7]; return { type: "Pattern", getPattern: function RadialAxial_getPattern(ctx) { applyBoundingBox(ctx, bbox); var grad; if (type === "axial") { grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]); } else if (type === "radial") { grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1); } for (var i = 0, ii = colorStops.length; i < ii; ++i) { var c = colorStops[i]; grad.addColorStop(c[0], c[1]); } return grad; } }; } }; var createMeshCanvas = function createMeshCanvasClosure() { function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) { var coords = context.coords, colors = context.colors; var bytes = data.data, rowSize = data.width * 4; var tmp; if (coords[p1 + 1] > coords[p2 + 1]) { tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp; } if (coords[p2 + 1] > coords[p3 + 1]) { tmp = p2; p2 = p3; p3 = tmp; tmp = c2; c2 = c3; c3 = tmp; } if (coords[p1 + 1] > coords[p2 + 1]) { tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp; } var x1 = (coords[p1] + context.offsetX) * context.scaleX; var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY; var x2 = (coords[p2] + context.offsetX) * context.scaleX; var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY; var x3 = (coords[p3] + context.offsetX) * context.scaleX; var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY; if (y1 >= y3) { return; } var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2]; var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2]; var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2]; var minY = Math.round(y1), maxY = Math.round(y3); var xa, car, cag, cab; var xb, cbr, cbg, cbb; for (var y = minY; y <= maxY; y++) { if (y < y2) { let k; if (y < y1) { k = 0; } else if (y1 === y2) { k = 1; } else { k = (y1 - y) / (y1 - y2); } xa = x1 - (x1 - x2) * k; car = c1r - (c1r - c2r) * k; cag = c1g - (c1g - c2g) * k; cab = c1b - (c1b - c2b) * k; } else { let k; if (y > y3) { k = 1; } else if (y2 === y3) { k = 0; } else { k = (y2 - y) / (y2 - y3); } xa = x2 - (x2 - x3) * k; car = c2r - (c2r - c3r) * k; cag = c2g - (c2g - c3g) * k; cab = c2b - (c2b - c3b) * k; } let k; if (y < y1) { k = 0; } else if (y > y3) { k = 1; } else { k = (y1 - y) / (y1 - y3); } xb = x1 - (x1 - x3) * k; cbr = c1r - (c1r - c3r) * k; cbg = c1g - (c1g - c3g) * k; cbb = c1b - (c1b - c3b) * k; var x1_ = Math.round(Math.min(xa, xb)); var x2_ = Math.round(Math.max(xa, xb)); var j = rowSize * y + x1_ * 4; for (var x = x1_; x <= x2_; x++) { k = (xa - x) / (xa - xb); if (k < 0) { k = 0; } else if (k > 1) { k = 1; } bytes[j++] = car - (car - cbr) * k | 0; bytes[j++] = cag - (cag - cbg) * k | 0; bytes[j++] = cab - (cab - cbb) * k | 0; bytes[j++] = 255; } } } function drawFigure(data, figure, context) { var ps = figure.coords; var cs = figure.colors; var i, ii; switch (figure.type) { case "lattice": var verticesPerRow = figure.verticesPerRow; var rows = Math.floor(ps.length / verticesPerRow) - 1; var cols = verticesPerRow - 1; for (i = 0; i < rows; i++) { var q = i * verticesPerRow; for (var j = 0; j < cols; j++, q++) { drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]); drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]); } } break; case "triangles": for (i = 0, ii = ps.length; i < ii; i += 3) { drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]); } break; default: throw new Error("illegal figure"); } } function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) { var EXPECTED_SCALE = 1.1; var MAX_PATTERN_SIZE = 3000; var BORDER_SIZE = 2; var offsetX = Math.floor(bounds[0]); var offsetY = Math.floor(bounds[1]); var boundsWidth = Math.ceil(bounds[2]) - offsetX; var boundsHeight = Math.ceil(bounds[3]) - offsetY; var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE); var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE); var scaleX = boundsWidth / width; var scaleY = boundsHeight / height; var context = { coords, colors, offsetX: -offsetX, offsetY: -offsetY, scaleX: 1 / scaleX, scaleY: 1 / scaleY }; var paddedWidth = width + BORDER_SIZE * 2; var paddedHeight = height + BORDER_SIZE * 2; var canvas, tmpCanvas, i, ii; if (webGLContext.isEnabled) { canvas = webGLContext.drawFigures({ width, height, backgroundColor, figures, context }); tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false); tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE); canvas = tmpCanvas.canvas; } else { tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false); var tmpCtx = tmpCanvas.context; var data = tmpCtx.createImageData(width, height); if (backgroundColor) { var bytes = data.data; for (i = 0, ii = bytes.length; i < ii; i += 4) { bytes[i] = backgroundColor[0]; bytes[i + 1] = backgroundColor[1]; bytes[i + 2] = backgroundColor[2]; bytes[i + 3] = 255; } } for (i = 0; i < figures.length; i++) { drawFigure(data, figures[i], context); } tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE); canvas = tmpCanvas.canvas; } return { canvas, offsetX: offsetX - BORDER_SIZE * scaleX, offsetY: offsetY - BORDER_SIZE * scaleY, scaleX, scaleY }; } return createMeshCanvas; }(); ShadingIRs.Mesh = { fromIR: function Mesh_fromIR(raw) { var coords = raw[2]; var colors = raw[3]; var figures = raw[4]; var bounds = raw[5]; var matrix = raw[6]; var bbox = raw[7]; var background = raw[8]; return { type: "Pattern", getPattern: function Mesh_getPattern(ctx, owner, shadingFill) { applyBoundingBox(ctx, bbox); var scale; if (shadingFill) { scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform); } else { scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform); if (matrix) { var matrixScale = _util.Util.singularValueDecompose2dScale(matrix); scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]]; } } var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext); if (!shadingFill) { ctx.setTransform.apply(ctx, owner.baseTransform); if (matrix) { ctx.transform.apply(ctx, matrix); } } ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY); ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY); return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat"); } }; } }; ShadingIRs.Dummy = { fromIR: function Dummy_fromIR() { return { type: "Pattern", getPattern: function Dummy_fromIR_getPattern() { return "hotpink"; } }; } }; function getShadingPatternFromIR(raw) { var shadingIR = ShadingIRs[raw[0]]; if (!shadingIR) { throw new Error(`Unknown IR type: ${raw[0]}`); } return shadingIR.fromIR(raw); } var TilingPattern = function TilingPatternClosure() { var PaintType = { COLORED: 1, UNCOLORED: 2 }; var MAX_PATTERN_SIZE = 3000; function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) { this.operatorList = IR[2]; this.matrix = IR[3] || [1, 0, 0, 1, 0, 0]; this.bbox = IR[4]; this.xstep = IR[5]; this.ystep = IR[6]; this.paintType = IR[7]; this.tilingType = IR[8]; this.color = color; this.canvasGraphicsFactory = canvasGraphicsFactory; this.baseTransform = baseTransform; this.type = "Pattern"; this.ctx = ctx; } TilingPattern.prototype = { createPatternCanvas: function TilinPattern_createPatternCanvas(owner) { var operatorList = this.operatorList; var bbox = this.bbox; var xstep = this.xstep; var ystep = this.ystep; var paintType = this.paintType; var tilingType = this.tilingType; var color = this.color; var canvasGraphicsFactory = this.canvasGraphicsFactory; (0, _util.info)("TilingType: " + tilingType); var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3]; var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix); var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform); var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]]; var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]); var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]); var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true); var tmpCtx = tmpCanvas.context; var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx); graphics.groupLevel = owner.groupLevel; this.setFillAndStrokeStyleToContext(graphics, paintType, color); graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0); graphics.transform(1, 0, 0, 1, -x0, -y0); this.clipBbox(graphics, bbox, x0, y0, x1, y1); graphics.executeOperatorList(operatorList); this.ctx.transform(1, 0, 0, 1, x0, y0); this.ctx.scale(1 / dimx.scale, 1 / dimy.scale); return tmpCanvas.canvas; }, getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) { step = Math.abs(step); var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize); var size = Math.ceil(step * scale); if (size >= maxSize) { size = maxSize; } else { scale = size / step; } return { scale, size }; }, clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) { if (Array.isArray(bbox) && bbox.length === 4) { var bboxWidth = x1 - x0; var bboxHeight = y1 - y0; graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight); graphics.clip(); graphics.endPath(); } }, setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) { const context = graphics.ctx, current = graphics.current; switch (paintType) { case PaintType.COLORED: var ctx = this.ctx; context.fillStyle = ctx.fillStyle; context.strokeStyle = ctx.strokeStyle; current.fillColor = ctx.fillStyle; current.strokeColor = ctx.strokeStyle; break; case PaintType.UNCOLORED: var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]); context.fillStyle = cssColor; context.strokeStyle = cssColor; current.fillColor = cssColor; current.strokeColor = cssColor; break; default: throw new _util.FormatError(`Unsupported paint type: ${paintType}`); } }, getPattern: function TilingPattern_getPattern(ctx, owner) { ctx = this.ctx; ctx.setTransform.apply(ctx, this.baseTransform); ctx.transform.apply(ctx, this.matrix); var temporaryPatternCanvas = this.createPatternCanvas(owner); return ctx.createPattern(temporaryPatternCanvas, "repeat"); } }; return TilingPattern; }(); exports.TilingPattern = TilingPattern;
/***/ }),
/* 12 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.GlobalWorkerOptions = void 0; const GlobalWorkerOptions = Object.create(null); exports.GlobalWorkerOptions = GlobalWorkerOptions; GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort; GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;
/***/ }),
/* 13 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.MessageHandler = void 0; var _util = __w_pdfjs_require__(2); const CallbackKind = { UNKNOWN: 0, DATA: 1, ERROR: 2 }; const StreamKind = { UNKNOWN: 0, CANCEL: 1, CANCEL_COMPLETE: 2, CLOSE: 3, ENQUEUE: 4, ERROR: 5, PULL: 6, PULL_COMPLETE: 7, START_COMPLETE: 8 }; function wrapReason(reason) { if (typeof reason !== "object" || reason === null) { return reason; } switch (reason.name) { case "AbortException": return new _util.AbortException(reason.message); case "MissingPDFException": return new _util.MissingPDFException(reason.message); case "UnexpectedResponseException": return new _util.UnexpectedResponseException(reason.message, reason.status); case "UnknownErrorException": return new _util.UnknownErrorException(reason.message, reason.details); default: return new _util.UnknownErrorException(reason.message, reason.toString()); } } class MessageHandler { constructor(sourceName, targetName, comObj) { this.sourceName = sourceName; this.targetName = targetName; this.comObj = comObj; this.callbackId = 1; this.streamId = 1; this.postMessageTransfers = true; this.streamSinks = Object.create(null); this.streamControllers = Object.create(null); this.callbackCapabilities = Object.create(null); this.actionHandler = Object.create(null); this._onComObjOnMessage = event => { const data = event.data; if (data.targetName !== this.sourceName) { return; } if (data.stream) { this._processStreamMessage(data); return; } if (data.callback) { const callbackId = data.callbackId; const capability = this.callbackCapabilities[callbackId]; if (!capability) { throw new Error(`Cannot resolve callback ${callbackId}`); } delete this.callbackCapabilities[callbackId]; if (data.callback === CallbackKind.DATA) { capability.resolve(data.data); } else if (data.callback === CallbackKind.ERROR) { capability.reject(wrapReason(data.reason)); } else { throw new Error("Unexpected callback case"); } return; } const action = this.actionHandler[data.action]; if (!action) { throw new Error(`Unknown action from worker: ${data.action}`); } if (data.callbackId) { const cbSourceName = this.sourceName; const cbTargetName = data.sourceName; new Promise(function (resolve) { resolve(action(data.data)); }).then(function (result) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.DATA, callbackId: data.callbackId, data: result }); }, function (reason) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.ERROR, callbackId: data.callbackId, reason: wrapReason(reason) }); }); return; } if (data.streamId) { this._createStreamSink(data); return; } action(data.data); }; comObj.addEventListener("message", this._onComObjOnMessage); } on(actionName, handler) { const ah = this.actionHandler; if (ah[actionName]) { throw new Error(`There is already an actionName called "${actionName}"`); } ah[actionName] = handler; } send(actionName, data, transfers) { this._postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, data }, transfers); } sendWithPromise(actionName, data, transfers) { const callbackId = this.callbackId++; const capability = (0, _util.createPromiseCapability)(); this.callbackCapabilities[callbackId] = capability; try { this._postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, callbackId, data }, transfers); } catch (ex) { capability.reject(ex); } return capability.promise; } sendWithStream(actionName, data, queueingStrategy, transfers) { const streamId = this.streamId++; const sourceName = this.sourceName; const targetName = this.targetName; const comObj = this.comObj; return new ReadableStream({ start: controller => { const startCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId] = { controller, startCall: startCapability, pullCall: null, cancelCall: null, isClosed: false }; this._postMessage({ sourceName, targetName, action: actionName, streamId, data, desiredSize: controller.desiredSize }, transfers); return startCapability.promise; }, pull: controller => { const pullCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId].pullCall = pullCapability; comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL, streamId, desiredSize: controller.desiredSize }); return pullCapability.promise; }, cancel: reason => { (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason"); const cancelCapability = (0, _util.createPromiseCapability)(); this.streamControllers[streamId].cancelCall = cancelCapability; this.streamControllers[streamId].isClosed = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL, streamId, reason: wrapReason(reason) }); return cancelCapability.promise; } }, queueingStrategy); } _createStreamSink(data) { const self = this; const action = this.actionHandler[data.action]; const streamId = data.streamId; const sourceName = this.sourceName; const targetName = data.sourceName; const comObj = this.comObj; const streamSink = { enqueue(chunk, size = 1, transfers) { if (this.isCancelled) { return; } const lastDesiredSize = this.desiredSize; this.desiredSize -= size; if (lastDesiredSize > 0 && this.desiredSize <= 0) { this.sinkCapability = (0, _util.createPromiseCapability)(); this.ready = this.sinkCapability.promise; } self._postMessage({ sourceName, targetName, stream: StreamKind.ENQUEUE, streamId, chunk }, transfers); }, close() { if (this.isCancelled) { return; } this.isCancelled = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.CLOSE, streamId }); delete self.streamSinks[streamId]; }, error(reason) { (0, _util.assert)(reason instanceof Error, "error must have a valid reason"); if (this.isCancelled) { return; } this.isCancelled = true; comObj.postMessage({ sourceName, targetName, stream: StreamKind.ERROR, streamId, reason: wrapReason(reason) }); }, sinkCapability: (0, _util.createPromiseCapability)(), onPull: null, onCancel: null, isCancelled: false, desiredSize: data.desiredSize, ready: null }; streamSink.sinkCapability.resolve(); streamSink.ready = streamSink.sinkCapability.promise; this.streamSinks[streamId] = streamSink; new Promise(function (resolve) { resolve(action(data.data, streamSink)); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.START_COMPLETE, streamId, reason: wrapReason(reason) }); }); } _processStreamMessage(data) { const streamId = data.streamId; const sourceName = this.sourceName; const targetName = data.sourceName; const comObj = this.comObj; switch (data.stream) { case StreamKind.START_COMPLETE: if (data.success) { this.streamControllers[streamId].startCall.resolve(); } else { this.streamControllers[streamId].startCall.reject(wrapReason(data.reason)); } break; case StreamKind.PULL_COMPLETE: if (data.success) { this.streamControllers[streamId].pullCall.resolve(); } else { this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason)); } break; case StreamKind.PULL: if (!this.streamSinks[streamId]) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true }); break; } if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) { this.streamSinks[streamId].sinkCapability.resolve(); } this.streamSinks[streamId].desiredSize = data.desiredSize; const { onPull } = this.streamSinks[data.streamId]; new Promise(function (resolve) { resolve(onPull && onPull()); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.PULL_COMPLETE, streamId, reason: wrapReason(reason) }); }); break; case StreamKind.ENQUEUE: (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller"); if (this.streamControllers[streamId].isClosed) { break; } this.streamControllers[streamId].controller.enqueue(data.chunk); break; case StreamKind.CLOSE: (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller"); if (this.streamControllers[streamId].isClosed) { break; } this.streamControllers[streamId].isClosed = true; this.streamControllers[streamId].controller.close(); this._deleteStreamController(streamId); break; case StreamKind.ERROR: (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller"); this.streamControllers[streamId].controller.error(wrapReason(data.reason)); this._deleteStreamController(streamId); break; case StreamKind.CANCEL_COMPLETE: if (data.success) { this.streamControllers[streamId].cancelCall.resolve(); } else { this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason)); } this._deleteStreamController(streamId); break; case StreamKind.CANCEL: if (!this.streamSinks[streamId]) { break; } const { onCancel } = this.streamSinks[data.streamId]; new Promise(function (resolve) { resolve(onCancel && onCancel(wrapReason(data.reason))); }).then(function () { comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName, targetName, stream: StreamKind.CANCEL_COMPLETE, streamId, reason: wrapReason(reason) }); }); this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason)); this.streamSinks[streamId].isCancelled = true; delete this.streamSinks[streamId]; break; default: throw new Error("Unexpected stream case"); } } async _deleteStreamController(streamId) { await Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) { return capability && capability.promise; })); delete this.streamControllers[streamId]; } _postMessage(message, transfers) { if (transfers && this.postMessageTransfers) { this.comObj.postMessage(message, transfers); } else { this.comObj.postMessage(message); } } destroy() { this.comObj.removeEventListener("message", this._onComObjOnMessage); } } exports.MessageHandler = MessageHandler;
/***/ }),
/* 14 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.Metadata = void 0; var _util = __w_pdfjs_require__(2); var _xml_parser = __w_pdfjs_require__(15); class Metadata { constructor(data) { (0, _util.assert)(typeof data === "string", "Metadata: input is not a string"); data = this._repair(data); const parser = new _xml_parser.SimpleXMLParser(); const xmlDocument = parser.parseFromString(data); this._metadataMap = new Map(); if (xmlDocument) { this._parse(xmlDocument); } } _repair(data) { return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function (all, codes) { const bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) { return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1); }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) { switch (name) { case "amp": return "&"; case "apos": return "'"; case "gt": return ">"; case "lt": return "<"; case "quot": return '"'; } throw new Error(`_repair: ${name} isn't defined.`); }); let chars = ""; for (let i = 0, ii = bytes.length; i < ii; i += 2) { const code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1); if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) { chars += String.fromCharCode(code); } else { chars += "&#x" + (0x10000 + code).toString(16).substring(1) + ";"; } } return ">" + chars; }); } _parse(xmlDocument) { let rdf = xmlDocument.documentElement; if (rdf.nodeName.toLowerCase() !== "rdf:rdf") { rdf = rdf.firstChild; while (rdf && rdf.nodeName.toLowerCase() !== "rdf:rdf") { rdf = rdf.nextSibling; } } const nodeName = rdf ? rdf.nodeName.toLowerCase() : null; if (!rdf || nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) { return; } const children = rdf.childNodes; for (let i = 0, ii = children.length; i < ii; i++) { const desc = children[i]; if (desc.nodeName.toLowerCase() !== "rdf:description") { continue; } for (let j = 0, jj = desc.childNodes.length; j < jj; j++) { if (desc.childNodes[j].nodeName.toLowerCase() !== "#text") { const entry = desc.childNodes[j]; const name = entry.nodeName.toLowerCase(); this._metadataMap.set(name, entry.textContent.trim()); } } } } get(name) { return this._metadataMap.has(name) ? this._metadataMap.get(name) : null; } getAll() { return Object.fromEntries(this._metadataMap); } has(name) { return this._metadataMap.has(name); } } exports.Metadata = Metadata;
/***/ }),
/* 15 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.SimpleXMLParser = void 0; const XMLParserErrorCode = { NoError: 0, EndOfDocument: -1, UnterminatedCdat: -2, UnterminatedXmlDeclaration: -3, UnterminatedDoctypeDeclaration: -4, UnterminatedComment: -5, MalformedElement: -6, OutOfMemory: -7, UnterminatedAttributeValue: -8, UnterminatedElement: -9, ElementNeverBegun: -10 }; function isWhitespace(s, index) { const ch = s[index]; return ch === " " || ch === "\n" || ch === "\r" || ch === "\t"; } function isWhitespaceString(s) { for (let i = 0, ii = s.length; i < ii; i++) { if (!isWhitespace(s, i)) { return false; } } return true; } class XMLParserBase { _resolveEntities(s) { return s.replace(/&([^;]+);/g, (all, entity) => { if (entity.substring(0, 2) === "#x") { return String.fromCharCode(parseInt(entity.substring(2), 16)); } else if (entity.substring(0, 1) === "#") { return String.fromCharCode(parseInt(entity.substring(1), 10)); } switch (entity) { case "lt": return "<"; case "gt": return ">"; case "amp": return "&"; case "quot": return '"'; } return this.onResolveEntity(entity); }); } _parseContent(s, start) { const attributes = []; let pos = start; function skipWs() { while (pos < s.length && isWhitespace(s, pos)) { ++pos; } } while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") { ++pos; } const name = s.substring(start, pos); skipWs(); while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") { skipWs(); let attrName = "", attrValue = ""; while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") { attrName += s[pos]; ++pos; } skipWs(); if (s[pos] !== "=") { return null; } ++pos; skipWs(); const attrEndChar = s[pos]; if (attrEndChar !== '"' && attrEndChar !== "'") { return null; } const attrEndIndex = s.indexOf(attrEndChar, ++pos); if (attrEndIndex < 0) { return null; } attrValue = s.substring(pos, attrEndIndex); attributes.push({ name: attrName, value: this._resolveEntities(attrValue) }); pos = attrEndIndex + 1; skipWs(); } return { name, attributes, parsed: pos - start }; } _parseProcessingInstruction(s, start) { let pos = start; function skipWs() { while (pos < s.length && isWhitespace(s, pos)) { ++pos; } } while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") { ++pos; } const name = s.substring(start, pos); skipWs(); const attrStart = pos; while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) { ++pos; } const value = s.substring(attrStart, pos); return { name, value, parsed: pos - start }; } parseXml(s) { let i = 0; while (i < s.length) { const ch = s[i]; let j = i; if (ch === "<") { ++j; const ch2 = s[j]; let q; switch (ch2) { case "/": ++j; q = s.indexOf(">", j); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedElement); return; } this.onEndElement(s.substring(j, q)); j = q + 1; break; case "?": ++j; const pi = this._parseProcessingInstruction(s, j); if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") { this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration); return; } this.onPi(pi.name, pi.value); j += pi.parsed + 2; break; case "!": if (s.substring(j + 1, j + 3) === "--") { q = s.indexOf("-->", j + 3); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedComment); return; } this.onComment(s.substring(j + 3, q)); j = q + 3; } else if (s.substring(j + 1, j + 8) === "[CDATA[") { q = s.indexOf("]]>", j + 8); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedCdat); return; } this.onCdata(s.substring(j + 8, q)); j = q + 3; } else if (s.substring(j + 1, j + 8) === "DOCTYPE") { const q2 = s.indexOf("[", j + 8); let complexDoctype = false; q = s.indexOf(">", j + 8); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration); return; } if (q2 > 0 && q > q2) { q = s.indexOf("]>", j + 8); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration); return; } complexDoctype = true; } const doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0)); this.onDoctype(doctypeContent); j = q + (complexDoctype ? 2 : 1); } else { this.onError(XMLParserErrorCode.MalformedElement); return; } break; default: const content = this._parseContent(s, j); if (content === null) { this.onError(XMLParserErrorCode.MalformedElement); return; } let isClosed = false; if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") { isClosed = true; } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") { this.onError(XMLParserErrorCode.UnterminatedElement); return; } this.onBeginElement(content.name, content.attributes, isClosed); j += content.parsed + (isClosed ? 2 : 1); break; } } else { while (j < s.length && s[j] !== "<") { j++; } const text = s.substring(i, j); this.onText(this._resolveEntities(text)); } i = j; } } onResolveEntity(name) { return `&${name};`; } onPi(name, value) {} onComment(text) {} onCdata(text) {} onDoctype(doctypeContent) {} onText(text) {} onBeginElement(name, attributes, isEmpty) {} onEndElement(name) {} onError(code) {} } class SimpleDOMNode { constructor(nodeName, nodeValue) { this.nodeName = nodeName; this.nodeValue = nodeValue; Object.defineProperty(this, "parentNode", { value: null, writable: true }); } get firstChild() { return this.childNodes && this.childNodes[0]; } get nextSibling() { const childNodes = this.parentNode.childNodes; if (!childNodes) { return undefined; } const index = childNodes.indexOf(this); if (index === -1) { return undefined; } return childNodes[index + 1]; } get textContent() { if (!this.childNodes) { return this.nodeValue || ""; } return this.childNodes.map(function (child) { return child.textContent; }).join(""); } hasChildNodes() { return this.childNodes && this.childNodes.length > 0; } } class SimpleXMLParser extends XMLParserBase { constructor() { super(); this._currentFragment = null; this._stack = null; this._errorCode = XMLParserErrorCode.NoError; } parseFromString(data) { this._currentFragment = []; this._stack = []; this._errorCode = XMLParserErrorCode.NoError; this.parseXml(data); if (this._errorCode !== XMLParserErrorCode.NoError) { return undefined; } const [documentElement] = this._currentFragment; if (!documentElement) { return undefined; } return { documentElement }; } onResolveEntity(name) { switch (name) { case "apos": return "'"; } return super.onResolveEntity(name); } onText(text) { if (isWhitespaceString(text)) { return; } const node = new SimpleDOMNode("#text", text); this._currentFragment.push(node); } onCdata(text) { const node = new SimpleDOMNode("#text", text); this._currentFragment.push(node); } onBeginElement(name, attributes, isEmpty) { const node = new SimpleDOMNode(name); node.childNodes = []; this._currentFragment.push(node); if (isEmpty) { return; } this._stack.push(this._currentFragment); this._currentFragment = node.childNodes; } onEndElement(name) { this._currentFragment = this._stack.pop() || []; const lastElement = this._currentFragment[this._currentFragment.length - 1]; if (!lastElement) { return; } for (let i = 0, ii = lastElement.childNodes.length; i < ii; i++) { lastElement.childNodes[i].parentNode = lastElement; } } onError(code) { this._errorCode = code; } } exports.SimpleXMLParser = SimpleXMLParser;
/***/ }),
/* 16 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.OptionalContentConfig = void 0; var _util = __w_pdfjs_require__(2); class OptionalContentGroup { constructor(name, intent) { this.visible = true; this.name = name; this.intent = intent; } } class OptionalContentConfig { constructor(data) { this.name = null; this.creator = null; this._order = null; this._groups = new Map(); if (data === null) { return; } this.name = data.name; this.creator = data.creator; this._order = data.order; for (const group of data.groups) { this._groups.set(group.id, new OptionalContentGroup(group.name, group.intent)); } if (data.baseState === "OFF") { for (const group of this._groups) { group.visible = false; } } for (const on of data.on) { this._groups.get(on).visible = true; } for (const off of data.off) { this._groups.get(off).visible = false; } } isVisible(group) { if (group.type === "OCG") { if (!this._groups.has(group.id)) { (0, _util.warn)(`Optional content group not found: ${group.id}`); return true; } return this._groups.get(group.id).visible; } else if (group.type === "OCMD") { if (group.expression) { (0, _util.warn)("Visibility expression not supported yet."); } if (!group.policy || group.policy === "AnyOn") { for (const id of group.ids) { if (!this._groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return true; } if (this._groups.get(id).visible) { return true; } } return false; } else if (group.policy === "AllOn") { for (const id of group.ids) { if (!this._groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return true; } if (!this._groups.get(id).visible) { return false; } } return true; } else if (group.policy === "AnyOff") { for (const id of group.ids) { if (!this._groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return true; } if (!this._groups.get(id).visible) { return true; } } return false; } else if (group.policy === "AllOff") { for (const id of group.ids) { if (!this._groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return true; } if (this._groups.get(id).visible) { return false; } } return true; } (0, _util.warn)(`Unknown optional content policy ${group.policy}.`); return true; } (0, _util.warn)(`Unknown group type ${group.type}.`); return true; } setVisibility(id, visible = true) { if (!this._groups.has(id)) { (0, _util.warn)(`Optional content group not found: ${id}`); return; } this._groups.get(id).visible = !!visible; } getOrder() { if (!this._groups.size) { return null; } if (this._order) { return this._order.slice(); } return Array.from(this._groups.keys()); } getGroups() { if (!this._groups.size) { return null; } return Object.fromEntries(this._groups); } getGroup(id) { return this._groups.get(id) || null; } } exports.OptionalContentConfig = OptionalContentConfig;
/***/ }),
/* 17 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFDataTransportStream = void 0; var _util = __w_pdfjs_require__(2); class PDFDataTransportStream { constructor(params, pdfDataRangeTransport) { (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'); this._queuedChunks = []; this._progressiveDone = params.progressiveDone || false; const initialData = params.initialData; if (initialData && initialData.length > 0) { const buffer = new Uint8Array(initialData).buffer; this._queuedChunks.push(buffer); } this._pdfDataRangeTransport = pdfDataRangeTransport; this._isStreamingSupported = !params.disableStream; this._isRangeSupported = !params.disableRange; this._contentLength = params.length; this._fullRequestReader = null; this._rangeReaders = []; this._pdfDataRangeTransport.addRangeListener((begin, chunk) => { this._onReceiveData({ begin, chunk }); }); this._pdfDataRangeTransport.addProgressListener((loaded, total) => { this._onProgress({ loaded, total }); }); this._pdfDataRangeTransport.addProgressiveReadListener(chunk => { this._onReceiveData({ chunk }); }); this._pdfDataRangeTransport.addProgressiveDoneListener(() => { this._onProgressiveDone(); }); this._pdfDataRangeTransport.transportReady(); } _onReceiveData(args) { const buffer = new Uint8Array(args.chunk).buffer; if (args.begin === undefined) { if (this._fullRequestReader) { this._fullRequestReader._enqueue(buffer); } else { this._queuedChunks.push(buffer); } } else { const found = this._rangeReaders.some(function (rangeReader) { if (rangeReader._begin !== args.begin) { return false; } rangeReader._enqueue(buffer); return true; }); (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found."); } } get _progressiveDataLength() { return this._fullRequestReader ? this._fullRequestReader._loaded : 0; } _onProgress(evt) { if (evt.total === undefined) { const firstReader = this._rangeReaders[0]; if (firstReader && firstReader.onProgress) { firstReader.onProgress({ loaded: evt.loaded }); } } else { const fullReader = this._fullRequestReader; if (fullReader && fullReader.onProgress) { fullReader.onProgress({ loaded: evt.loaded, total: evt.total }); } } } _onProgressiveDone() { if (this._fullRequestReader) { this._fullRequestReader.progressiveDone(); } this._progressiveDone = true; } _removeRangeReader(reader) { const i = this._rangeReaders.indexOf(reader); if (i >= 0) { this._rangeReaders.splice(i, 1); } } getFullReader() { (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once."); const queuedChunks = this._queuedChunks; this._queuedChunks = null; return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone); } getRangeReader(begin, end) { if (end <= this._progressiveDataLength) { return null; } const reader = new PDFDataTransportStreamRangeReader(this, begin, end); this._pdfDataRangeTransport.requestDataRange(begin, end); this._rangeReaders.push(reader); return reader; } cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } const readers = this._rangeReaders.slice(0); readers.forEach(function (rangeReader) { rangeReader.cancel(reason); }); this._pdfDataRangeTransport.abort(); } } exports.PDFDataTransportStream = PDFDataTransportStream; class PDFDataTransportStreamReader { constructor(stream, queuedChunks, progressiveDone = false) { this._stream = stream; this._done = progressiveDone || false; this._filename = null; this._queuedChunks = queuedChunks || []; this._loaded = 0; for (const chunk of this._queuedChunks) { this._loaded += chunk.byteLength; } this._requests = []; this._headersReady = Promise.resolve(); stream._fullRequestReader = this; this.onProgress = null; } _enqueue(chunk) { if (this._done) { return; } if (this._requests.length > 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: chunk, done: false }); } else { this._queuedChunks.push(chunk); } this._loaded += chunk.byteLength; } get headersReady() { return this._headersReady; } get filename() { return this._filename; } get isRangeSupported() { return this._stream._isRangeSupported; } get isStreamingSupported() { return this._stream._isStreamingSupported; } get contentLength() { return this._stream._contentLength; } async read() { if (this._queuedChunks.length > 0) { const chunk = this._queuedChunks.shift(); return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; } progressiveDone() { if (this._done) { return; } this._done = true; } } class PDFDataTransportStreamRangeReader { constructor(stream, begin, end) { this._stream = stream; this._begin = begin; this._end = end; this._queuedChunk = null; this._requests = []; this._done = false; this.onProgress = null; } _enqueue(chunk) { if (this._done) { return; } if (this._requests.length === 0) { this._queuedChunk = chunk; } else { const requestsCapability = this._requests.shift(); requestsCapability.resolve({ value: chunk, done: false }); this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; } this._done = true; this._stream._removeRangeReader(this); } get isStreamingSupported() { return false; } async read() { if (this._queuedChunk) { const chunk = this._queuedChunk; this._queuedChunk = null; return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; this._stream._removeRangeReader(this); } }
/***/ }),
/* 18 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.WebGLContext = void 0; var _util = __w_pdfjs_require__(2); class WebGLContext { constructor({ enable = false }) { this._enabled = enable === true; } get isEnabled() { let enabled = this._enabled; if (enabled) { enabled = WebGLUtils.tryInitGL(); } return (0, _util.shadow)(this, "isEnabled", enabled); } composeSMask({ layer, mask, properties }) { return WebGLUtils.composeSMask(layer, mask, properties); } drawFigures({ width, height, backgroundColor, figures, context }) { return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context); } clear() { WebGLUtils.cleanup(); } } exports.WebGLContext = WebGLContext; var WebGLUtils = function WebGLUtilsClosure() { function loadShader(gl, code, shaderType) { var shader = gl.createShader(shaderType); gl.shaderSource(shader, code); gl.compileShader(shader); var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS); if (!compiled) { var errorMsg = gl.getShaderInfoLog(shader); throw new Error("Error during shader compilation: " + errorMsg); } return shader; } function createVertexShader(gl, code) { return loadShader(gl, code, gl.VERTEX_SHADER); } function createFragmentShader(gl, code) { return loadShader(gl, code, gl.FRAGMENT_SHADER); } function createProgram(gl, shaders) { var program = gl.createProgram(); for (var i = 0, ii = shaders.length; i < ii; ++i) { gl.attachShader(program, shaders[i]); } gl.linkProgram(program); var linked = gl.getProgramParameter(program, gl.LINK_STATUS); if (!linked) { var errorMsg = gl.getProgramInfoLog(program); throw new Error("Error during program linking: " + errorMsg); } return program; } function createTexture(gl, image, textureId) { gl.activeTexture(textureId); var texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); return texture; } var currentGL, currentCanvas; function generateGL() { if (currentGL) { return; } currentCanvas = document.createElement("canvas"); currentGL = currentCanvas.getContext("webgl", { premultipliedalpha: false }); } var smaskVertexShaderCode = "\ attribute vec2 a_position; \ attribute vec2 a_texCoord; \ \ uniform vec2 u_resolution; \ \ varying vec2 v_texCoord; \ \ void main() { \ vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0; \ gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); \ \ v_texCoord = a_texCoord; \ } "; var smaskFragmentShaderCode = "\ precision mediump float; \ \ uniform vec4 u_backdrop; \ uniform int u_subtype; \ uniform sampler2D u_image; \ uniform sampler2D u_mask; \ \ varying vec2 v_texCoord; \ \ void main() { \ vec4 imageColor = texture2D(u_image, v_texCoord); \ vec4 maskColor = texture2D(u_mask, v_texCoord); \ if (u_backdrop.a > 0.0) { \ maskColor.rgb = maskColor.rgb * maskColor.a + \ u_backdrop.rgb * (1.0 - maskColor.a); \ } \ float lum; \ if (u_subtype == 0) { \ lum = maskColor.a; \ } else { \ lum = maskColor.r * 0.3 + maskColor.g * 0.59 + \ maskColor.b * 0.11; \ } \ imageColor.a *= lum; \ imageColor.rgb *= imageColor.a; \ gl_FragColor = imageColor; \ } "; var smaskCache = null; function initSmaskGL() { var canvas, gl; generateGL(); canvas = currentCanvas; currentCanvas = null; gl = currentGL; currentGL = null; var vertexShader = createVertexShader(gl, smaskVertexShaderCode); var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode); var program = createProgram(gl, [vertexShader, fragmentShader]); gl.useProgram(program); var cache = {}; cache.gl = gl; cache.canvas = canvas; cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution"); cache.positionLocation = gl.getAttribLocation(program, "a_position"); cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop"); cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype"); var texCoordLocation = gl.getAttribLocation(program, "a_texCoord"); var texLayerLocation = gl.getUniformLocation(program, "u_image"); var texMaskLocation = gl.getUniformLocation(program, "u_mask"); var texCoordBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW); gl.enableVertexAttribArray(texCoordLocation); gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0); gl.uniform1i(texLayerLocation, 0); gl.uniform1i(texMaskLocation, 1); smaskCache = cache; } function composeSMask(layer, mask, properties) { var width = layer.width, height = layer.height; if (!smaskCache) { initSmaskGL(); } var cache = smaskCache, canvas = cache.canvas, gl = cache.gl; canvas.width = width; canvas.height = height; gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.uniform2f(cache.resolutionLocation, width, height); if (properties.backdrop) { gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1); } else { gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0); } gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0); var texture = createTexture(gl, layer, gl.TEXTURE0); var maskTexture = createTexture(gl, mask, gl.TEXTURE1); var buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW); gl.enableVertexAttribArray(cache.positionLocation); gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0); gl.clearColor(0, 0, 0, 0); gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, 6); gl.flush(); gl.deleteTexture(texture); gl.deleteTexture(maskTexture); gl.deleteBuffer(buffer); return canvas; } var figuresVertexShaderCode = "\ attribute vec2 a_position; \ attribute vec3 a_color; \ \ uniform vec2 u_resolution; \ uniform vec2 u_scale; \ uniform vec2 u_offset; \ \ varying vec4 v_color; \ \ void main() { \ vec2 position = (a_position + u_offset) * u_scale; \ vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0; \ gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); \ \ v_color = vec4(a_color / 255.0, 1.0); \ } "; var figuresFragmentShaderCode = "\ precision mediump float; \ \ varying vec4 v_color; \ \ void main() { \ gl_FragColor = v_color; \ } "; var figuresCache = null; function initFiguresGL() { var canvas, gl; generateGL(); canvas = currentCanvas; currentCanvas = null; gl = currentGL; currentGL = null; var vertexShader = createVertexShader(gl, figuresVertexShaderCode); var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode); var program = createProgram(gl, [vertexShader, fragmentShader]); gl.useProgram(program); var cache = {}; cache.gl = gl; cache.canvas = canvas; cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution"); cache.scaleLocation = gl.getUniformLocation(program, "u_scale"); cache.offsetLocation = gl.getUniformLocation(program, "u_offset"); cache.positionLocation = gl.getAttribLocation(program, "a_position"); cache.colorLocation = gl.getAttribLocation(program, "a_color"); figuresCache = cache; } function drawFigures(width, height, backgroundColor, figures, context) { if (!figuresCache) { initFiguresGL(); } var cache = figuresCache, canvas = cache.canvas, gl = cache.gl; canvas.width = width; canvas.height = height; gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.uniform2f(cache.resolutionLocation, width, height); var count = 0; var i, ii, rows; for (i = 0, ii = figures.length; i < ii; i++) { switch (figures[i].type) { case "lattice": rows = figures[i].coords.length / figures[i].verticesPerRow | 0; count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6; break; case "triangles": count += figures[i].coords.length; break; } } var coords = new Float32Array(count * 2); var colors = new Uint8Array(count * 3); var coordsMap = context.coords, colorsMap = context.colors; var pIndex = 0, cIndex = 0; for (i = 0, ii = figures.length; i < ii; i++) { var figure = figures[i], ps = figure.coords, cs = figure.colors; switch (figure.type) { case "lattice": var cols = figure.verticesPerRow; rows = ps.length / cols | 0; for (var row = 1; row < rows; row++) { var offset = row * cols + 1; for (var col = 1; col < cols; col++, offset++) { coords[pIndex] = coordsMap[ps[offset - cols - 1]]; coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1]; coords[pIndex + 2] = coordsMap[ps[offset - cols]]; coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1]; coords[pIndex + 4] = coordsMap[ps[offset - 1]]; coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1]; colors[cIndex] = colorsMap[cs[offset - cols - 1]]; colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1]; colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2]; colors[cIndex + 3] = colorsMap[cs[offset - cols]]; colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1]; colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2]; colors[cIndex + 6] = colorsMap[cs[offset - 1]]; colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1]; colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2]; coords[pIndex + 6] = coords[pIndex + 2]; coords[pIndex + 7] = coords[pIndex + 3]; coords[pIndex + 8] = coords[pIndex + 4]; coords[pIndex + 9] = coords[pIndex + 5]; coords[pIndex + 10] = coordsMap[ps[offset]]; coords[pIndex + 11] = coordsMap[ps[offset] + 1]; colors[cIndex + 9] = colors[cIndex + 3]; colors[cIndex + 10] = colors[cIndex + 4]; colors[cIndex + 11] = colors[cIndex + 5]; colors[cIndex + 12] = colors[cIndex + 6]; colors[cIndex + 13] = colors[cIndex + 7]; colors[cIndex + 14] = colors[cIndex + 8]; colors[cIndex + 15] = colorsMap[cs[offset]]; colors[cIndex + 16] = colorsMap[cs[offset] + 1]; colors[cIndex + 17] = colorsMap[cs[offset] + 2]; pIndex += 12; cIndex += 18; } } break; case "triangles": for (var j = 0, jj = ps.length; j < jj; j++) { coords[pIndex] = coordsMap[ps[j]]; coords[pIndex + 1] = coordsMap[ps[j] + 1]; colors[cIndex] = colorsMap[cs[j]]; colors[cIndex + 1] = colorsMap[cs[j] + 1]; colors[cIndex + 2] = colorsMap[cs[j] + 2]; pIndex += 2; cIndex += 3; } break; } } if (backgroundColor) { gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0); } else { gl.clearColor(0, 0, 0, 0); } gl.clear(gl.COLOR_BUFFER_BIT); var coordsBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer); gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW); gl.enableVertexAttribArray(cache.positionLocation); gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0); var colorsBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer); gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW); gl.enableVertexAttribArray(cache.colorLocation); gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0); gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY); gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY); gl.drawArrays(gl.TRIANGLES, 0, count); gl.flush(); gl.deleteBuffer(coordsBuffer); gl.deleteBuffer(colorsBuffer); return canvas; } return { tryInitGL() { try { generateGL(); return !!currentGL; } catch (ex) {} return false; }, composeSMask, drawFigures, cleanup() { if (smaskCache && smaskCache.canvas) { smaskCache.canvas.width = 0; smaskCache.canvas.height = 0; } if (figuresCache && figuresCache.canvas) { figuresCache.canvas.width = 0; figuresCache.canvas.height = 0; } smaskCache = null; figuresCache = null; } }; }();
/***/ }),
/* 19 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.AnnotationLayer = void 0; var _display_utils = __w_pdfjs_require__(1); var _util = __w_pdfjs_require__(2); var _annotation_storage = __w_pdfjs_require__(8); class AnnotationElementFactory { static create(parameters) { const subtype = parameters.data.annotationType; switch (subtype) { case _util.AnnotationType.LINK: return new LinkAnnotationElement(parameters); case _util.AnnotationType.TEXT: return new TextAnnotationElement(parameters); case _util.AnnotationType.WIDGET: const fieldType = parameters.data.fieldType; switch (fieldType) { case "Tx": return new TextWidgetAnnotationElement(parameters); case "Btn": if (parameters.data.radioButton) { return new RadioButtonWidgetAnnotationElement(parameters); } else if (parameters.data.checkBox) { return new CheckboxWidgetAnnotationElement(parameters); } return new PushButtonWidgetAnnotationElement(parameters); case "Ch": return new ChoiceWidgetAnnotationElement(parameters); } return new WidgetAnnotationElement(parameters); case _util.AnnotationType.POPUP: return new PopupAnnotationElement(parameters); case _util.AnnotationType.FREETEXT: return new FreeTextAnnotationElement(parameters); case _util.AnnotationType.LINE: return new LineAnnotationElement(parameters); case _util.AnnotationType.SQUARE: return new SquareAnnotationElement(parameters); case _util.AnnotationType.CIRCLE: return new CircleAnnotationElement(parameters); case _util.AnnotationType.POLYLINE: return new PolylineAnnotationElement(parameters); case _util.AnnotationType.CARET: return new CaretAnnotationElement(parameters); case _util.AnnotationType.INK: return new InkAnnotationElement(parameters); case _util.AnnotationType.POLYGON: return new PolygonAnnotationElement(parameters); case _util.AnnotationType.HIGHLIGHT: return new HighlightAnnotationElement(parameters); case _util.AnnotationType.UNDERLINE: return new UnderlineAnnotationElement(parameters); case _util.AnnotationType.SQUIGGLY: return new SquigglyAnnotationElement(parameters); case _util.AnnotationType.STRIKEOUT: return new StrikeOutAnnotationElement(parameters); case _util.AnnotationType.STAMP: return new StampAnnotationElement(parameters); case _util.AnnotationType.FILEATTACHMENT: return new FileAttachmentAnnotationElement(parameters); default: return new AnnotationElement(parameters); } } } class AnnotationElement { constructor(parameters, isRenderable = false, ignoreBorder = false) { this.isRenderable = isRenderable; this.data = parameters.data; this.layer = parameters.layer; this.page = parameters.page; this.viewport = parameters.viewport; this.linkService = parameters.linkService; this.downloadManager = parameters.downloadManager; this.imageResourcesPath = parameters.imageResourcesPath; this.renderInteractiveForms = parameters.renderInteractiveForms; this.svgFactory = parameters.svgFactory; this.annotationStorage = parameters.annotationStorage; if (isRenderable) { this.container = this._createContainer(ignoreBorder); } } _createContainer(ignoreBorder = false) { const data = this.data, page = this.page, viewport = this.viewport; const container = document.createElement("section"); let width = data.rect[2] - data.rect[0]; let height = data.rect[3] - data.rect[1]; container.setAttribute("data-annotation-id", data.id); const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]); container.style.transform = `matrix(${viewport.transform.join(",")})`; container.style.transformOrigin = `-${rect[0]}px -${rect[1]}px`; if (!ignoreBorder && data.borderStyle.width > 0) { container.style.borderWidth = `${data.borderStyle.width}px`; if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) { width = width - 2 * data.borderStyle.width; height = height - 2 * data.borderStyle.width; } const horizontalRadius = data.borderStyle.horizontalCornerRadius; const verticalRadius = data.borderStyle.verticalCornerRadius; if (horizontalRadius > 0 || verticalRadius > 0) { const radius = `${horizontalRadius}px / ${verticalRadius}px`; container.style.borderRadius = radius; } switch (data.borderStyle.style) { case _util.AnnotationBorderStyleType.SOLID: container.style.borderStyle = "solid"; break; case _util.AnnotationBorderStyleType.DASHED: container.style.borderStyle = "dashed"; break; case _util.AnnotationBorderStyleType.BEVELED: (0, _util.warn)("Unimplemented border style: beveled"); break; case _util.AnnotationBorderStyleType.INSET: (0, _util.warn)("Unimplemented border style: inset"); break; case _util.AnnotationBorderStyleType.UNDERLINE: container.style.borderBottomStyle = "solid"; break; default: break; } if (data.color) { container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0); } else { container.style.borderWidth = 0; } } container.style.left = `${rect[0]}px`; container.style.top = `${rect[1]}px`; container.style.width = `${width}px`; container.style.height = `${height}px`; return container; } _createPopup(container, trigger, data) { if (!trigger) { trigger = document.createElement("div"); trigger.style.height = container.style.height; trigger.style.width = container.style.width; container.appendChild(trigger); } const popupElement = new PopupElement({ container, trigger, color: data.color, title: data.title, modificationDate: data.modificationDate, contents: data.contents, hideWrapper: true }); const popup = popupElement.render(); popup.style.left = container.style.width; container.appendChild(popup); } render() { (0, _util.unreachable)("Abstract method `AnnotationElement.render` called"); } } class LinkAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action); super(parameters, isRenderable); } render() { this.container.className = "linkAnnotation"; const { data, linkService } = this; const link = document.createElement("a"); if (data.url) { (0, _display_utils.addLinkAttributes)(link, { url: data.url, target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget, rel: linkService.externalLinkRel, enabled: linkService.externalLinkEnabled }); } else if (data.action) { this._bindNamedAction(link, data.action); } else { this._bindLink(link, data.dest); } this.container.appendChild(link); return this.container; } _bindLink(link, destination) { link.href = this.linkService.getDestinationHash(destination); link.onclick = () => { if (destination) { this.linkService.navigateTo(destination); } return false; }; if (destination) { link.className = "internalLink"; } } _bindNamedAction(link, action) { link.href = this.linkService.getAnchorUrl(""); link.onclick = () => { this.linkService.executeNamedAction(action); return false; }; link.className = "internalLink"; } } class TextAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable); } render() { this.container.className = "textAnnotation"; const image = document.createElement("img"); image.style.height = this.container.style.height; image.style.width = this.container.style.width; image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg"; image.alt = "[{{type}} Annotation]"; image.dataset.l10nId = "text_annotation_type"; image.dataset.l10nArgs = JSON.stringify({ type: this.data.name }); if (!this.data.hasPopup) { this._createPopup(this.container, image, this.data); } this.container.appendChild(image); return this.container; } } class WidgetAnnotationElement extends AnnotationElement { render() { return this.container; } } class TextWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { const isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue; super(parameters, isRenderable); } render() { const TEXT_ALIGNMENT = ["left", "center", "right"]; const storage = this.annotationStorage; const id = this.data.id; this.container.className = "textWidgetAnnotation"; let element = null; if (this.renderInteractiveForms) { const textContent = storage.getOrCreateValue(id, this.data.fieldValue); if (this.data.multiLine) { element = document.createElement("textarea"); element.textContent = textContent; } else { element = document.createElement("input"); element.type = "text"; element.setAttribute("value", textContent); } element.addEventListener("input", function (event) { storage.setValue(id, event.target.value); }); element.disabled = this.data.readOnly; element.name = this.data.fieldName; if (this.data.maxLen !== null) { element.maxLength = this.data.maxLen; } if (this.data.comb) { const fieldWidth = this.data.rect[2] - this.data.rect[0]; const combWidth = fieldWidth / this.data.maxLen; element.classList.add("comb"); element.style.letterSpacing = `calc(${combWidth}px - 1ch)`; } } else { element = document.createElement("div"); element.textContent = this.data.fieldValue; element.style.verticalAlign = "middle"; element.style.display = "table-cell"; let font = null; if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) { font = this.page.commonObjs.get(this.data.fontRefName); } this._setTextStyle(element, font); } if (this.data.textAlignment !== null) { element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment]; } this.container.appendChild(element); return this.container; } _setTextStyle(element, font) { const style = element.style; style.fontSize = `${this.data.fontSize}px`; style.direction = this.data.fontDirection < 0 ? "rtl" : "ltr"; if (!font) { return; } let bold = "normal"; if (font.black) { bold = "900"; } else if (font.bold) { bold = "bold"; } style.fontWeight = bold; style.fontStyle = font.italic ? "italic" : "normal"; const fontFamily = font.loadedName ? `"${font.loadedName}", ` : ""; const fallbackName = font.fallbackName || "Helvetica, sans-serif"; style.fontFamily = fontFamily + fallbackName; } } class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, parameters.renderInteractiveForms); } render() { const storage = this.annotationStorage; const data = this.data; const id = data.id; const value = storage.getOrCreateValue(id, data.fieldValue && data.fieldValue !== "Off"); this.container.className = "buttonWidgetAnnotation checkBox"; const element = document.createElement("input"); element.disabled = data.readOnly; element.type = "checkbox"; element.name = this.data.fieldName; if (value) { element.setAttribute("checked", true); } element.addEventListener("change", function (event) { storage.setValue(id, event.target.checked); }); this.container.appendChild(element); return this.container; } } class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, parameters.renderInteractiveForms); } render() { this.container.className = "buttonWidgetAnnotation radioButton"; const storage = this.annotationStorage; const data = this.data; const id = data.id; const value = storage.getOrCreateValue(id, data.fieldValue === data.buttonValue); const element = document.createElement("input"); element.disabled = data.readOnly; element.type = "radio"; element.name = data.fieldName; if (value) { element.setAttribute("checked", true); } element.addEventListener("change", function (event) { const name = event.target.name; for (const radio of document.getElementsByName(name)) { if (radio !== event.target) { storage.setValue(radio.parentNode.getAttribute("data-annotation-id"), false); } } storage.setValue(id, event.target.checked); }); this.container.appendChild(element); return this.container; } } class PushButtonWidgetAnnotationElement extends LinkAnnotationElement { render() { const container = super.render(); container.className = "buttonWidgetAnnotation pushButton"; return container; } } class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement { constructor(parameters) { super(parameters, parameters.renderInteractiveForms); } render() { this.container.className = "choiceWidgetAnnotation"; const storage = this.annotationStorage; const id = this.data.id; storage.getOrCreateValue(id, this.data.fieldValue.length > 0 ? this.data.fieldValue[0] : null); const selectElement = document.createElement("select"); selectElement.disabled = this.data.readOnly; selectElement.name = this.data.fieldName; if (!this.data.combo) { selectElement.size = this.data.options.length; if (this.data.multiSelect) { selectElement.multiple = true; } } for (const option of this.data.options) { const optionElement = document.createElement("option"); optionElement.textContent = option.displayValue; optionElement.value = option.exportValue; if (this.data.fieldValue.includes(option.exportValue)) { optionElement.setAttribute("selected", true); } selectElement.appendChild(optionElement); } selectElement.addEventListener("input", function (event) { const options = event.target.options; const value = options[options.selectedIndex].value; storage.setValue(id, value); }); this.container.appendChild(selectElement); return this.container; } } class PopupAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.title || parameters.data.contents); super(parameters, isRenderable); } render() { const IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"]; this.container.className = "popupAnnotation"; if (IGNORE_TYPES.includes(this.data.parentType)) { return this.container; } const selector = `[data-annotation-id="${this.data.parentId}"]`; const parentElement = this.layer.querySelector(selector); if (!parentElement) { return this.container; } const popup = new PopupElement({ container: this.container, trigger: parentElement, color: this.data.color, title: this.data.title, modificationDate: this.data.modificationDate, contents: this.data.contents }); const parentLeft = parseFloat(parentElement.style.left); const parentWidth = parseFloat(parentElement.style.width); this.container.style.transformOrigin = `-${parentLeft + parentWidth}px -${parentElement.style.top}`; this.container.style.left = `${parentLeft + parentWidth}px`; this.container.appendChild(popup.render()); return this.container; } } class PopupElement { constructor(parameters) { this.container = parameters.container; this.trigger = parameters.trigger; this.color = parameters.color; this.title = parameters.title; this.modificationDate = parameters.modificationDate; this.contents = parameters.contents; this.hideWrapper = parameters.hideWrapper || false; this.pinned = false; } render() { const BACKGROUND_ENLIGHT = 0.7; const wrapper = document.createElement("div"); wrapper.className = "popupWrapper"; this.hideElement = this.hideWrapper ? wrapper : this.container; this.hideElement.setAttribute("hidden", true); const popup = document.createElement("div"); popup.className = "popup"; const color = this.color; if (color) { const r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0]; const g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1]; const b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2]; popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0); } const title = document.createElement("h1"); title.textContent = this.title; popup.appendChild(title); const dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate); if (dateObject) { const modificationDate = document.createElement("span"); modificationDate.textContent = "{{date}}, {{time}}"; modificationDate.dataset.l10nId = "annotation_date_string"; modificationDate.dataset.l10nArgs = JSON.stringify({ date: dateObject.toLocaleDateString(), time: dateObject.toLocaleTimeString() }); popup.appendChild(modificationDate); } const contents = this._formatContents(this.contents); popup.appendChild(contents); this.trigger.addEventListener("click", this._toggle.bind(this)); this.trigger.addEventListener("mouseover", this._show.bind(this, false)); this.trigger.addEventListener("mouseout", this._hide.bind(this, false)); popup.addEventListener("click", this._hide.bind(this, true)); wrapper.appendChild(popup); return wrapper; } _formatContents(contents) { const p = document.createElement("p"); const lines = contents.split(/(?:\r\n?|\n)/); for (let i = 0, ii = lines.length; i < ii; ++i) { const line = lines[i]; p.appendChild(document.createTextNode(line)); if (i < ii - 1) { p.appendChild(document.createElement("br")); } } return p; } _toggle() { if (this.pinned) { this._hide(true); } else { this._show(true); } } _show(pin = false) { if (pin) { this.pinned = true; } if (this.hideElement.hasAttribute("hidden")) { this.hideElement.removeAttribute("hidden"); this.container.style.zIndex += 1; } } _hide(unpin = true) { if (unpin) { this.pinned = false; } if (!this.hideElement.hasAttribute("hidden") && !this.pinned) { this.hideElement.setAttribute("hidden", true); this.container.style.zIndex -= 1; } } } class FreeTextAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "freeTextAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } } class LineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "lineAnnotation"; const data = this.data; const width = data.rect[2] - data.rect[0]; const height = data.rect[3] - data.rect[1]; const svg = this.svgFactory.create(width, height); const line = this.svgFactory.createElement("svg:line"); line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]); line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]); line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]); line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]); line.setAttribute("stroke-width", data.borderStyle.width || 1); line.setAttribute("stroke", "transparent"); svg.appendChild(line); this.container.append(svg); this._createPopup(this.container, line, data); return this.container; } } class SquareAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "squareAnnotation"; const data = this.data; const width = data.rect[2] - data.rect[0]; const height = data.rect[3] - data.rect[1]; const svg = this.svgFactory.create(width, height); const borderWidth = data.borderStyle.width; const square = this.svgFactory.createElement("svg:rect"); square.setAttribute("x", borderWidth / 2); square.setAttribute("y", borderWidth / 2); square.setAttribute("width", width - borderWidth); square.setAttribute("height", height - borderWidth); square.setAttribute("stroke-width", borderWidth || 1); square.setAttribute("stroke", "transparent"); square.setAttribute("fill", "none"); svg.appendChild(square); this.container.append(svg); this._createPopup(this.container, square, data); return this.container; } } class CircleAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "circleAnnotation"; const data = this.data; const width = data.rect[2] - data.rect[0]; const height = data.rect[3] - data.rect[1]; const svg = this.svgFactory.create(width, height); const borderWidth = data.borderStyle.width; const circle = this.svgFactory.createElement("svg:ellipse"); circle.setAttribute("cx", width / 2); circle.setAttribute("cy", height / 2); circle.setAttribute("rx", width / 2 - borderWidth / 2); circle.setAttribute("ry", height / 2 - borderWidth / 2); circle.setAttribute("stroke-width", borderWidth || 1); circle.setAttribute("stroke", "transparent"); circle.setAttribute("fill", "none"); svg.appendChild(circle); this.container.append(svg); this._createPopup(this.container, circle, data); return this.container; } } class PolylineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); this.containerClassName = "polylineAnnotation"; this.svgElementName = "svg:polyline"; } render() { this.container.className = this.containerClassName; const data = this.data; const width = data.rect[2] - data.rect[0]; const height = data.rect[3] - data.rect[1]; const svg = this.svgFactory.create(width, height); let points = []; for (const coordinate of data.vertices) { const x = coordinate.x - data.rect[0]; const y = data.rect[3] - coordinate.y; points.push(x + "," + y); } points = points.join(" "); const polyline = this.svgFactory.createElement(this.svgElementName); polyline.setAttribute("points", points); polyline.setAttribute("stroke-width", data.borderStyle.width || 1); polyline.setAttribute("stroke", "transparent"); polyline.setAttribute("fill", "none"); svg.appendChild(polyline); this.container.append(svg); this._createPopup(this.container, polyline, data); return this.container; } } class PolygonAnnotationElement extends PolylineAnnotationElement { constructor(parameters) { super(parameters); this.containerClassName = "polygonAnnotation"; this.svgElementName = "svg:polygon"; } } class CaretAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "caretAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } } class InkAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); this.containerClassName = "inkAnnotation"; this.svgElementName = "svg:polyline"; } render() { this.container.className = this.containerClassName; const data = this.data; const width = data.rect[2] - data.rect[0]; const height = data.rect[3] - data.rect[1]; const svg = this.svgFactory.create(width, height); for (const inkList of data.inkLists) { let points = []; for (const coordinate of inkList) { const x = coordinate.x - data.rect[0]; const y = data.rect[3] - coordinate.y; points.push(`${x},${y}`); } points = points.join(" "); const polyline = this.svgFactory.createElement(this.svgElementName); polyline.setAttribute("points", points); polyline.setAttribute("stroke-width", data.borderStyle.width || 1); polyline.setAttribute("stroke", "transparent"); polyline.setAttribute("fill", "none"); this._createPopup(this.container, polyline, data); svg.appendChild(polyline); } this.container.append(svg); return this.container; } } class HighlightAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "highlightAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } } class UnderlineAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "underlineAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } } class SquigglyAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "squigglyAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } } class StrikeOutAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "strikeoutAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } } class StampAnnotationElement extends AnnotationElement { constructor(parameters) { const isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); super(parameters, isRenderable, true); } render() { this.container.className = "stampAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } } class FileAttachmentAnnotationElement extends AnnotationElement { constructor(parameters) { super(parameters, true); const { filename, content } = this.data.file; this.filename = (0, _display_utils.getFilenameFromUrl)(filename); this.content = content; if (this.linkService.eventBus) { this.linkService.eventBus.dispatch("fileattachmentannotation", { source: this, id: (0, _util.stringToPDFString)(filename), filename, content }); } } render() { this.container.className = "fileAttachmentAnnotation"; const trigger = document.createElement("div"); trigger.style.height = this.container.style.height; trigger.style.width = this.container.style.width; trigger.addEventListener("dblclick", this._download.bind(this)); if (!this.data.hasPopup && (this.data.title || this.data.contents)) { this._createPopup(this.container, trigger, this.data); } this.container.appendChild(trigger); return this.container; } _download() { if (!this.downloadManager) { (0, _util.warn)("Download cannot be started due to unavailable download manager"); return; } this.downloadManager.downloadData(this.content, this.filename, ""); } } class AnnotationLayer { static render(parameters) { const sortedAnnotations = [], popupAnnotations = []; for (const data of parameters.annotations) { if (!data) { continue; } if (data.annotationType === _util.AnnotationType.POPUP) { popupAnnotations.push(data); continue; } sortedAnnotations.push(data); } if (popupAnnotations.length) { sortedAnnotations.push(...popupAnnotations); } for (const data of sortedAnnotations) { const element = AnnotationElementFactory.create({ data, layer: parameters.div, page: parameters.page, viewport: parameters.viewport, linkService: parameters.linkService, downloadManager: parameters.downloadManager, imageResourcesPath: parameters.imageResourcesPath || "", renderInteractiveForms: typeof parameters.renderInteractiveForms === "boolean" ? parameters.renderInteractiveForms : true, svgFactory: new _display_utils.DOMSVGFactory(), annotationStorage: parameters.annotationStorage || new _annotation_storage.AnnotationStorage() }); if (element.isRenderable) { parameters.div.appendChild(element.render()); } } } static update(parameters) { for (const data of parameters.annotations) { const element = parameters.div.querySelector(`[data-annotation-id="${data.id}"]`); if (element) { element.style.transform = `matrix(${parameters.viewport.transform.join(",")})`; } } parameters.div.removeAttribute("hidden"); } } exports.AnnotationLayer = AnnotationLayer;
/***/ }),
/* 20 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.renderTextLayer = void 0; var _util = __w_pdfjs_require__(2); var renderTextLayer = function renderTextLayerClosure() { var MAX_TEXT_DIVS_TO_RENDER = 100000; var NonWhitespaceRegexp = /\S/; function isAllWhitespace(str) { return !NonWhitespaceRegexp.test(str); } function appendText(task, geom, styles) { var textDiv = document.createElement("span"); var textDivProperties = { angle: 0, canvasWidth: 0, isWhitespace: false, originalTransform: null, paddingBottom: 0, paddingLeft: 0, paddingRight: 0, paddingTop: 0, scale: 1 }; task._textDivs.push(textDiv); if (isAllWhitespace(geom.str)) { textDivProperties.isWhitespace = true; task._textDivProperties.set(textDiv, textDivProperties); return; } var tx = _util.Util.transform(task._viewport.transform, geom.transform); var angle = Math.atan2(tx[1], tx[0]); var style = styles[geom.fontName]; if (style.vertical) { angle += Math.PI / 2; } var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]); var fontAscent = fontHeight; if (style.ascent) { fontAscent = style.ascent * fontAscent; } else if (style.descent) { fontAscent = (1 + style.descent) * fontAscent; } let left, top; if (angle === 0) { left = tx[4]; top = tx[5] - fontAscent; } else { left = tx[4] + fontAscent * Math.sin(angle); top = tx[5] - fontAscent * Math.cos(angle); } textDiv.style.left = `${left}px`; textDiv.style.top = `${top}px`; textDiv.style.fontSize = `${fontHeight}px`; textDiv.style.fontFamily = style.fontFamily; textDiv.textContent = geom.str; if (task._fontInspectorEnabled) { textDiv.dataset.fontName = geom.fontName; } if (angle !== 0) { textDivProperties.angle = angle * (180 / Math.PI); } let shouldScaleText = false; if (geom.str.length > 1) { shouldScaleText = true; } else if (geom.transform[0] !== geom.transform[3]) { const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]); if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) { shouldScaleText = true; } } if (shouldScaleText) { if (style.vertical) { textDivProperties.canvasWidth = geom.height * task._viewport.scale; } else { textDivProperties.canvasWidth = geom.width * task._viewport.scale; } } task._textDivProperties.set(textDiv, textDivProperties); if (task._textContentStream) { task._layoutText(textDiv); } if (task._enhanceTextSelection) { var angleCos = 1, angleSin = 0; if (angle !== 0) { angleCos = Math.cos(angle); angleSin = Math.sin(angle); } var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale; var divHeight = fontHeight; var m, b; if (angle !== 0) { m = [angleCos, angleSin, -angleSin, angleCos, left, top]; b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m); } else { b = [left, top, left + divWidth, top + divHeight]; } task._bounds.push({ left: b[0], top: b[1], right: b[2], bottom: b[3], div: textDiv, size: [divWidth, divHeight], m }); } } function render(task) { if (task._canceled) { return; } var textDivs = task._textDivs; var capability = task._capability; var textDivsLength = textDivs.length; if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) { task._renderingDone = true; capability.resolve(); return; } if (!task._textContentStream) { for (var i = 0; i < textDivsLength; i++) { task._layoutText(textDivs[i]); } } task._renderingDone = true; capability.resolve(); } function findPositiveMin(ts, offset, count) { let result = 0; for (let i = 0; i < count; i++) { const t = ts[offset++]; if (t > 0) { result = result ? Math.min(t, result) : t; } } return result; } function expand(task) { var bounds = task._bounds; var viewport = task._viewport; var expanded = expandBounds(viewport.width, viewport.height, bounds); for (var i = 0; i < expanded.length; i++) { var div = bounds[i].div; var divProperties = task._textDivProperties.get(div); if (divProperties.angle === 0) { divProperties.paddingLeft = bounds[i].left - expanded[i].left; divProperties.paddingTop = bounds[i].top - expanded[i].top; divProperties.paddingRight = expanded[i].right - bounds[i].right; divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom; task._textDivProperties.set(div, divProperties); continue; } var e = expanded[i], b = bounds[i]; var m = b.m, c = m[0], s = m[1]; var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size]; var ts = new Float64Array(64); points.forEach(function (p, j) { var t = _util.Util.applyTransform(p, m); ts[j + 0] = c && (e.left - t[0]) / c; ts[j + 4] = s && (e.top - t[1]) / s; ts[j + 8] = c && (e.right - t[0]) / c; ts[j + 12] = s && (e.bottom - t[1]) / s; ts[j + 16] = s && (e.left - t[0]) / -s; ts[j + 20] = c && (e.top - t[1]) / c; ts[j + 24] = s && (e.right - t[0]) / -s; ts[j + 28] = c && (e.bottom - t[1]) / c; ts[j + 32] = c && (e.left - t[0]) / -c; ts[j + 36] = s && (e.top - t[1]) / -s; ts[j + 40] = c && (e.right - t[0]) / -c; ts[j + 44] = s && (e.bottom - t[1]) / -s; ts[j + 48] = s && (e.left - t[0]) / s; ts[j + 52] = c && (e.top - t[1]) / -c; ts[j + 56] = s && (e.right - t[0]) / s; ts[j + 60] = c && (e.bottom - t[1]) / -c; }); var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s)); divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale; divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale; divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale; divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale; task._textDivProperties.set(div, divProperties); } } function expandBounds(width, height, boxes) { var bounds = boxes.map(function (box, i) { return { x1: box.left, y1: box.top, x2: box.right, y2: box.bottom, index: i, x1New: undefined, x2New: undefined }; }); expandBoundsLTR(width, bounds); var expanded = new Array(boxes.length); bounds.forEach(function (b) { var i = b.index; expanded[i] = { left: b.x1New, top: 0, right: b.x2New, bottom: 0 }; }); boxes.map(function (box, i) { var e = expanded[i], b = bounds[i]; b.x1 = box.top; b.y1 = width - e.right; b.x2 = box.bottom; b.y2 = width - e.left; b.index = i; b.x1New = undefined; b.x2New = undefined; }); expandBoundsLTR(height, bounds); bounds.forEach(function (b) { var i = b.index; expanded[i].top = b.x1New; expanded[i].bottom = b.x2New; }); return expanded; } function expandBoundsLTR(width, bounds) { bounds.sort(function (a, b) { return a.x1 - b.x1 || a.index - b.index; }); var fakeBoundary = { x1: -Infinity, y1: -Infinity, x2: 0, y2: Infinity, index: -1, x1New: 0, x2New: 0 }; var horizon = [{ start: -Infinity, end: Infinity, boundary: fakeBoundary }]; bounds.forEach(function (boundary) { var i = 0; while (i < horizon.length && horizon[i].end <= boundary.y1) { i++; } var j = horizon.length - 1; while (j >= 0 && horizon[j].start >= boundary.y2) { j--; } var horizonPart, affectedBoundary; var q, k, maxXNew = -Infinity; for (q = i; q <= j; q++) { horizonPart = horizon[q]; affectedBoundary = horizonPart.boundary; var xNew; if (affectedBoundary.x2 > boundary.x1) { xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1; } else if (affectedBoundary.x2New === undefined) { xNew = (affectedBoundary.x2 + boundary.x1) / 2; } else { xNew = affectedBoundary.x2New; } if (xNew > maxXNew) { maxXNew = xNew; } } boundary.x1New = maxXNew; for (q = i; q <= j; q++) { horizonPart = horizon[q]; affectedBoundary = horizonPart.boundary; if (affectedBoundary.x2New === undefined) { if (affectedBoundary.x2 > boundary.x1) { if (affectedBoundary.index > boundary.index) { affectedBoundary.x2New = affectedBoundary.x2; } } else { affectedBoundary.x2New = maxXNew; } } else if (affectedBoundary.x2New > maxXNew) { affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2); } } var changedHorizon = [], lastBoundary = null; for (q = i; q <= j; q++) { horizonPart = horizon[q]; affectedBoundary = horizonPart.boundary; var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary; if (lastBoundary === useBoundary) { changedHorizon[changedHorizon.length - 1].end = horizonPart.end; } else { changedHorizon.push({ start: horizonPart.start, end: horizonPart.end, boundary: useBoundary }); lastBoundary = useBoundary; } } if (horizon[i].start < boundary.y1) { changedHorizon[0].start = boundary.y1; changedHorizon.unshift({ start: horizon[i].start, end: boundary.y1, boundary: horizon[i].boundary }); } if (boundary.y2 < horizon[j].end) { changedHorizon[changedHorizon.length - 1].end = boundary.y2; changedHorizon.push({ start: boundary.y2, end: horizon[j].end, boundary: horizon[j].boundary }); } for (q = i; q <= j; q++) { horizonPart = horizon[q]; affectedBoundary = horizonPart.boundary; if (affectedBoundary.x2New !== undefined) { continue; } var used = false; for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) { used = horizon[k].boundary === affectedBoundary; } for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) { used = horizon[k].boundary === affectedBoundary; } for (k = 0; !used && k < changedHorizon.length; k++) { used = changedHorizon[k].boundary === affectedBoundary; } if (!used) { affectedBoundary.x2New = maxXNew; } } Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon)); }); horizon.forEach(function (horizonPart) { var affectedBoundary = horizonPart.boundary; if (affectedBoundary.x2New === undefined) { affectedBoundary.x2New = Math.max(width, affectedBoundary.x2); } }); } function TextLayerRenderTask({ textContent, textContentStream, container, viewport, textDivs, textContentItemsStr, enhanceTextSelection }) { this._textContent = textContent; this._textContentStream = textContentStream; this._container = container; this._document = container.ownerDocument; this._viewport = viewport; this._textDivs = textDivs || []; this._textContentItemsStr = textContentItemsStr || []; this._enhanceTextSelection = !!enhanceTextSelection; this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled); this._reader = null; this._layoutTextLastFontSize = null; this._layoutTextLastFontFamily = null; this._layoutTextCtx = null; this._textDivProperties = new WeakMap(); this._renderingDone = false; this._canceled = false; this._capability = (0, _util.createPromiseCapability)(); this._renderTimer = null; this._bounds = []; this._capability.promise.finally(() => { if (this._layoutTextCtx) { this._layoutTextCtx.canvas.width = 0; this._layoutTextCtx.canvas.height = 0; this._layoutTextCtx = null; } }).catch(() => {}); } TextLayerRenderTask.prototype = { get promise() { return this._capability.promise; }, cancel: function TextLayer_cancel() { this._canceled = true; if (this._reader) { this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")); this._reader = null; } if (this._renderTimer !== null) { clearTimeout(this._renderTimer); this._renderTimer = null; } this._capability.reject(new Error("TextLayer task cancelled.")); }, _processItems(items, styleCache) { for (let i = 0, len = items.length; i < len; i++) { this._textContentItemsStr.push(items[i].str); appendText(this, items[i], styleCache); } }, _layoutText(textDiv) { const textDivProperties = this._textDivProperties.get(textDiv); if (textDivProperties.isWhitespace) { return; } let transform = ""; if (textDivProperties.canvasWidth !== 0) { const { fontSize, fontFamily } = textDiv.style; if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) { this._layoutTextCtx.font = `${fontSize} ${fontFamily}`; this._layoutTextLastFontSize = fontSize; this._layoutTextLastFontFamily = fontFamily; } const { width } = this._layoutTextCtx.measureText(textDiv.textContent); if (width > 0) { textDivProperties.scale = textDivProperties.canvasWidth / width; transform = `scaleX(${textDivProperties.scale})`; } } if (textDivProperties.angle !== 0) { transform = `rotate(${textDivProperties.angle}deg) ${transform}`; } if (transform.length > 0) { if (this._enhanceTextSelection) { textDivProperties.originalTransform = transform; } textDiv.style.transform = transform; } this._textDivProperties.set(textDiv, textDivProperties); this._container.appendChild(textDiv); }, _render: function TextLayer_render(timeout) { const capability = (0, _util.createPromiseCapability)(); let styleCache = Object.create(null); const canvas = this._document.createElement("canvas"); canvas.mozOpaque = true; this._layoutTextCtx = canvas.getContext("2d", { alpha: false }); if (this._textContent) { const textItems = this._textContent.items; const textStyles = this._textContent.styles; this._processItems(textItems, textStyles); capability.resolve(); } else if (this._textContentStream) { const pump = () => { this._reader.read().then(({ value, done }) => { if (done) { capability.resolve(); return; } Object.assign(styleCache, value.styles); this._processItems(value.items, styleCache); pump(); }, capability.reject); }; this._reader = this._textContentStream.getReader(); pump(); } else { throw new Error('Neither "textContent" nor "textContentStream"' + " parameters specified."); } capability.promise.then(() => { styleCache = null; if (!timeout) { render(this); } else { this._renderTimer = setTimeout(() => { render(this); this._renderTimer = null; }, timeout); } }, this._capability.reject); }, expandTextDivs: function TextLayer_expandTextDivs(expandDivs) { if (!this._enhanceTextSelection || !this._renderingDone) { return; } if (this._bounds !== null) { expand(this); this._bounds = null; } const transformBuf = [], paddingBuf = []; for (var i = 0, ii = this._textDivs.length; i < ii; i++) { const div = this._textDivs[i]; const divProps = this._textDivProperties.get(div); if (divProps.isWhitespace) { continue; } if (expandDivs) { transformBuf.length = 0; paddingBuf.length = 0; if (divProps.originalTransform) { transformBuf.push(divProps.originalTransform); } if (divProps.paddingTop > 0) { paddingBuf.push(`${divProps.paddingTop}px`); transformBuf.push(`translateY(${-divProps.paddingTop}px)`); } else { paddingBuf.push(0); } if (divProps.paddingRight > 0) { paddingBuf.push(`${divProps.paddingRight / divProps.scale}px`); } else { paddingBuf.push(0); } if (divProps.paddingBottom > 0) { paddingBuf.push(`${divProps.paddingBottom}px`); } else { paddingBuf.push(0); } if (divProps.paddingLeft > 0) { paddingBuf.push(`${divProps.paddingLeft / divProps.scale}px`); transformBuf.push(`translateX(${-divProps.paddingLeft / divProps.scale}px)`); } else { paddingBuf.push(0); } div.style.padding = paddingBuf.join(" "); if (transformBuf.length) { div.style.transform = transformBuf.join(" "); } } else { div.style.padding = null; div.style.transform = divProps.originalTransform; } } } }; function renderTextLayer(renderParameters) { var task = new TextLayerRenderTask({ textContent: renderParameters.textContent, textContentStream: renderParameters.textContentStream, container: renderParameters.container, viewport: renderParameters.viewport, textDivs: renderParameters.textDivs, textContentItemsStr: renderParameters.textContentItemsStr, enhanceTextSelection: renderParameters.enhanceTextSelection }); task._render(renderParameters.timeout); return task; } return renderTextLayer; }(); exports.renderTextLayer = renderTextLayer;
/***/ }),
/* 21 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.SVGGraphics = void 0; var _util = __w_pdfjs_require__(2); var _display_utils = __w_pdfjs_require__(1); var _is_node = __w_pdfjs_require__(4); let SVGGraphics = function () { throw new Error("Not implemented: SVGGraphics"); }; exports.SVGGraphics = SVGGraphics; { const SVG_DEFAULTS = { fontStyle: "normal", fontWeight: "normal", fillColor: "#000000" };
const XML_NS = "http://www.w3.org/XML/1998/namespace";
const XLINK_NS = "http://www.w3.org/1999/xlink";
const LINE_CAP_STYLES = ["butt", "round", "square"]; const LINE_JOIN_STYLES = ["miter", "round", "bevel"]; const convertImgDataToPng = function () { const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]); const CHUNK_WRAPPER_SIZE = 12; const crcTable = new Int32Array(256); for (let i = 0; i < 256; i++) { let c = i; for (let h = 0; h < 8; h++) { if (c & 1) { c = 0xedb88320 ^ c >> 1 & 0x7fffffff; } else { c = c >> 1 & 0x7fffffff; } } crcTable[i] = c; } function crc32(data, start, end) { let crc = -1; for (let i = start; i < end; i++) { const a = (crc ^ data[i]) & 0xff; const b = crcTable[a]; crc = crc >>> 8 ^ b; } return crc ^ -1; } function writePngChunk(type, body, data, offset) { let p = offset; const len = body.length; data[p] = len >> 24 & 0xff; data[p + 1] = len >> 16 & 0xff; data[p + 2] = len >> 8 & 0xff; data[p + 3] = len & 0xff; p += 4; data[p] = type.charCodeAt(0) & 0xff; data[p + 1] = type.charCodeAt(1) & 0xff; data[p + 2] = type.charCodeAt(2) & 0xff; data[p + 3] = type.charCodeAt(3) & 0xff; p += 4; data.set(body, p); p += body.length; const crc = crc32(data, offset + 4, p); data[p] = crc >> 24 & 0xff; data[p + 1] = crc >> 16 & 0xff; data[p + 2] = crc >> 8 & 0xff; data[p + 3] = crc & 0xff; } function adler32(data, start, end) { let a = 1; let b = 0; for (let i = start; i < end; ++i) { a = (a + (data[i] & 0xff)) % 65521; b = (b + a) % 65521; } return b << 16 | a; } function deflateSync(literals) { if (!_is_node.isNodeJS) { return deflateSyncUncompressed(literals); } try { let input; if (parseInt(process.versions.node) >= 8) { input = literals; } else { input = Buffer.from(literals); } const output = require("zlib").deflateSync(input, { level: 9 }); return output instanceof Uint8Array ? output : new Uint8Array(output); } catch (e) { (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e); } return deflateSyncUncompressed(literals); } function deflateSyncUncompressed(literals) { let len = literals.length; const maxBlockLength = 0xffff; const deflateBlocks = Math.ceil(len / maxBlockLength); const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4); let pi = 0; idat[pi++] = 0x78; idat[pi++] = 0x9c; let pos = 0; while (len > maxBlockLength) { idat[pi++] = 0x00; idat[pi++] = 0xff; idat[pi++] = 0xff; idat[pi++] = 0x00; idat[pi++] = 0x00; idat.set(literals.subarray(pos, pos + maxBlockLength), pi); pi += maxBlockLength; pos += maxBlockLength; len -= maxBlockLength; } idat[pi++] = 0x01; idat[pi++] = len & 0xff; idat[pi++] = len >> 8 & 0xff; idat[pi++] = ~len & 0xffff & 0xff; idat[pi++] = (~len & 0xffff) >> 8 & 0xff; idat.set(literals.subarray(pos), pi); pi += literals.length - pos; const adler = adler32(literals, 0, literals.length); idat[pi++] = adler >> 24 & 0xff; idat[pi++] = adler >> 16 & 0xff; idat[pi++] = adler >> 8 & 0xff; idat[pi++] = adler & 0xff; return idat; } function encode(imgData, kind, forceDataSchema, isMask) { const width = imgData.width; const height = imgData.height; let bitDepth, colorType, lineSize; const bytes = imgData.data; switch (kind) { case _util.ImageKind.GRAYSCALE_1BPP: colorType = 0; bitDepth = 1; lineSize = width + 7 >> 3; break; case _util.ImageKind.RGB_24BPP: colorType = 2; bitDepth = 8; lineSize = width * 3; break; case _util.ImageKind.RGBA_32BPP: colorType = 6; bitDepth = 8; lineSize = width * 4; break; default: throw new Error("invalid format"); } const literals = new Uint8Array((1 + lineSize) * height); let offsetLiterals = 0, offsetBytes = 0; for (let y = 0; y < height; ++y) { literals[offsetLiterals++] = 0; literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals); offsetBytes += lineSize; offsetLiterals += lineSize; } if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) { offsetLiterals = 0; for (let y = 0; y < height; y++) { offsetLiterals++; for (let i = 0; i < lineSize; i++) { literals[offsetLiterals++] ^= 0xff; } } }
const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
const idat = deflateSync(literals); const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length; const data = new Uint8Array(pngLength); let offset = 0; data.set(PNG_HEADER, offset); offset += PNG_HEADER.length; writePngChunk("IHDR", ihdr, data, offset); offset += CHUNK_WRAPPER_SIZE + ihdr.length; writePngChunk("IDATA", idat, data, offset); offset += CHUNK_WRAPPER_SIZE + idat.length; writePngChunk("IEND", new Uint8Array(0), data, offset); return (0, _util.createObjectURL)(data, "image/png", forceDataSchema); } return function convertImgDataToPng(imgData, forceDataSchema, isMask) { const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind; return encode(imgData, kind, forceDataSchema, isMask); }; }(); class SVGExtraState { constructor() { this.fontSizeScale = 1; this.fontWeight = SVG_DEFAULTS.fontWeight; this.fontSize = 0; this.textMatrix = _util.IDENTITY_MATRIX; this.fontMatrix = _util.FONT_IDENTITY_MATRIX; this.leading = 0; this.textRenderingMode = _util.TextRenderingMode.FILL; this.textMatrixScale = 1; this.x = 0; this.y = 0; this.lineX = 0; this.lineY = 0; this.charSpacing = 0; this.wordSpacing = 0; this.textHScale = 1; this.textRise = 0; this.fillColor = SVG_DEFAULTS.fillColor; this.strokeColor = "#000000"; this.fillAlpha = 1; this.strokeAlpha = 1; this.lineWidth = 1; this.lineJoin = ""; this.lineCap = ""; this.miterLimit = 0; this.dashArray = []; this.dashPhase = 0; this.dependencies = []; this.activeClipUrl = null; this.clipGroup = null; this.maskId = ""; } clone() { return Object.create(this); } setCurrentPoint(x, y) { this.x = x; this.y = y; } } function opListToTree(opList) { let opTree = []; const tmp = []; for (const opListElement of opList) { if (opListElement.fn === "save") { opTree.push({ fnId: 92, fn: "group", items: [] }); tmp.push(opTree); opTree = opTree[opTree.length - 1].items; continue; } if (opListElement.fn === "restore") { opTree = tmp.pop(); } else { opTree.push(opListElement); } } return opTree; } function pf(value) { if (Number.isInteger(value)) { return value.toString(); } const s = value.toFixed(10); let i = s.length - 1; if (s[i] !== "0") { return s; } do { i--; } while (s[i] === "0"); return s.substring(0, s[i] === "." ? i : i + 1); } function pm(m) { if (m[4] === 0 && m[5] === 0) { if (m[1] === 0 && m[2] === 0) { if (m[0] === 1 && m[3] === 1) { return ""; } return `scale(${pf(m[0])} ${pf(m[3])})`; } if (m[0] === m[3] && m[1] === -m[2]) { const a = Math.acos(m[0]) * 180 / Math.PI; return `rotate(${pf(a)})`; } } else { if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) { return `translate(${pf(m[4])} ${pf(m[5])})`; } } return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`; } let clipCount = 0; let maskCount = 0; let shadingCount = 0; exports.SVGGraphics = SVGGraphics = class SVGGraphics { constructor(commonObjs, objs, forceDataSchema = false) { this.svgFactory = new _display_utils.DOMSVGFactory(); this.current = new SVGExtraState(); this.transformMatrix = _util.IDENTITY_MATRIX; this.transformStack = []; this.extraStack = []; this.commonObjs = commonObjs; this.objs = objs; this.pendingClip = null; this.pendingEOFill = false; this.embedFonts = false; this.embeddedFonts = Object.create(null); this.cssStyle = null; this.forceDataSchema = !!forceDataSchema; this._operatorIdMapping = []; for (const op in _util.OPS) { this._operatorIdMapping[_util.OPS[op]] = op; } } save() { this.transformStack.push(this.transformMatrix); const old = this.current; this.extraStack.push(old); this.current = old.clone(); } restore() { this.transformMatrix = this.transformStack.pop(); this.current = this.extraStack.pop(); this.pendingClip = null; this.tgrp = null; } group(items) { this.save(); this.executeOpTree(items); this.restore(); } loadDependencies(operatorList) { const fnArray = operatorList.fnArray; const argsArray = operatorList.argsArray; for (let i = 0, ii = fnArray.length; i < ii; i++) { if (fnArray[i] !== _util.OPS.dependency) { continue; } for (const obj of argsArray[i]) { const objsPool = obj.startsWith("g_") ? this.commonObjs : this.objs; const promise = new Promise(resolve => { objsPool.get(obj, resolve); }); this.current.dependencies.push(promise); } } return Promise.all(this.current.dependencies); } transform(a, b, c, d, e, f) { const transformMatrix = [a, b, c, d, e, f]; this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix); this.tgrp = null; } getSVG(operatorList, viewport) { this.viewport = viewport; const svgElement = this._initialize(viewport); return this.loadDependencies(operatorList).then(() => { this.transformMatrix = _util.IDENTITY_MATRIX; this.executeOpTree(this.convertOpList(operatorList)); return svgElement; }); } convertOpList(operatorList) { const operatorIdMapping = this._operatorIdMapping; const argsArray = operatorList.argsArray; const fnArray = operatorList.fnArray; const opList = []; for (let i = 0, ii = fnArray.length; i < ii; i++) { const fnId = fnArray[i]; opList.push({ fnId, fn: operatorIdMapping[fnId], args: argsArray[i] }); } return opListToTree(opList); } executeOpTree(opTree) { for (const opTreeElement of opTree) { const fn = opTreeElement.fn; const fnId = opTreeElement.fnId; const args = opTreeElement.args; switch (fnId | 0) { case _util.OPS.beginText: this.beginText(); break; case _util.OPS.dependency: break; case _util.OPS.setLeading: this.setLeading(args); break; case _util.OPS.setLeadingMoveText: this.setLeadingMoveText(args[0], args[1]); break; case _util.OPS.setFont: this.setFont(args); break; case _util.OPS.showText: this.showText(args[0]); break; case _util.OPS.showSpacedText: this.showText(args[0]); break; case _util.OPS.endText: this.endText(); break; case _util.OPS.moveText: this.moveText(args[0], args[1]); break; case _util.OPS.setCharSpacing: this.setCharSpacing(args[0]); break; case _util.OPS.setWordSpacing: this.setWordSpacing(args[0]); break; case _util.OPS.setHScale: this.setHScale(args[0]); break; case _util.OPS.setTextMatrix: this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]); break; case _util.OPS.setTextRise: this.setTextRise(args[0]); break; case _util.OPS.setTextRenderingMode: this.setTextRenderingMode(args[0]); break; case _util.OPS.setLineWidth: this.setLineWidth(args[0]); break; case _util.OPS.setLineJoin: this.setLineJoin(args[0]); break; case _util.OPS.setLineCap: this.setLineCap(args[0]); break; case _util.OPS.setMiterLimit: this.setMiterLimit(args[0]); break; case _util.OPS.setFillRGBColor: this.setFillRGBColor(args[0], args[1], args[2]); break; case _util.OPS.setStrokeRGBColor: this.setStrokeRGBColor(args[0], args[1], args[2]); break; case _util.OPS.setStrokeColorN: this.setStrokeColorN(args); break; case _util.OPS.setFillColorN: this.setFillColorN(args); break; case _util.OPS.shadingFill: this.shadingFill(args[0]); break; case _util.OPS.setDash: this.setDash(args[0], args[1]); break; case _util.OPS.setRenderingIntent: this.setRenderingIntent(args[0]); break; case _util.OPS.setFlatness: this.setFlatness(args[0]); break; case _util.OPS.setGState: this.setGState(args[0]); break; case _util.OPS.fill: this.fill(); break; case _util.OPS.eoFill: this.eoFill(); break; case _util.OPS.stroke: this.stroke(); break; case _util.OPS.fillStroke: this.fillStroke(); break; case _util.OPS.eoFillStroke: this.eoFillStroke(); break; case _util.OPS.clip: this.clip("nonzero"); break; case _util.OPS.eoClip: this.clip("evenodd"); break; case _util.OPS.paintSolidColorImageMask: this.paintSolidColorImageMask(); break; case _util.OPS.paintImageXObject: this.paintImageXObject(args[0]); break; case _util.OPS.paintInlineImageXObject: this.paintInlineImageXObject(args[0]); break; case _util.OPS.paintImageMaskXObject: this.paintImageMaskXObject(args[0]); break; case _util.OPS.paintFormXObjectBegin: this.paintFormXObjectBegin(args[0], args[1]); break; case _util.OPS.paintFormXObjectEnd: this.paintFormXObjectEnd(); break; case _util.OPS.closePath: this.closePath(); break; case _util.OPS.closeStroke: this.closeStroke(); break; case _util.OPS.closeFillStroke: this.closeFillStroke(); break; case _util.OPS.closeEOFillStroke: this.closeEOFillStroke(); break; case _util.OPS.nextLine: this.nextLine(); break; case _util.OPS.transform: this.transform(args[0], args[1], args[2], args[3], args[4], args[5]); break; case _util.OPS.constructPath: this.constructPath(args[0], args[1]); break; case _util.OPS.endPath: this.endPath(); break; case 92: this.group(opTreeElement.items); break; default: (0, _util.warn)(`Unimplemented operator ${fn}`); break; } } } setWordSpacing(wordSpacing) { this.current.wordSpacing = wordSpacing; } setCharSpacing(charSpacing) { this.current.charSpacing = charSpacing; } nextLine() { this.moveText(0, this.current.leading); } setTextMatrix(a, b, c, d, e, f) { const current = this.current; current.textMatrix = current.lineMatrix = [a, b, c, d, e, f]; current.textMatrixScale = Math.sqrt(a * a + b * b); current.x = current.lineX = 0; current.y = current.lineY = 0; current.xcoords = []; current.ycoords = []; current.tspan = this.svgFactory.createElement("svg:tspan"); current.tspan.setAttributeNS(null, "font-family", current.fontFamily); current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`); current.tspan.setAttributeNS(null, "y", pf(-current.y)); current.txtElement = this.svgFactory.createElement("svg:text"); current.txtElement.appendChild(current.tspan); } beginText() { const current = this.current; current.x = current.lineX = 0; current.y = current.lineY = 0; current.textMatrix = _util.IDENTITY_MATRIX; current.lineMatrix = _util.IDENTITY_MATRIX; current.textMatrixScale = 1; current.tspan = this.svgFactory.createElement("svg:tspan"); current.txtElement = this.svgFactory.createElement("svg:text"); current.txtgrp = this.svgFactory.createElement("svg:g"); current.xcoords = []; current.ycoords = []; } moveText(x, y) { const current = this.current; current.x = current.lineX += x; current.y = current.lineY += y; current.xcoords = []; current.ycoords = []; current.tspan = this.svgFactory.createElement("svg:tspan"); current.tspan.setAttributeNS(null, "font-family", current.fontFamily); current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`); current.tspan.setAttributeNS(null, "y", pf(-current.y)); } showText(glyphs) { const current = this.current; const font = current.font; const fontSize = current.fontSize; if (fontSize === 0) { return; } const fontSizeScale = current.fontSizeScale; const charSpacing = current.charSpacing; const wordSpacing = current.wordSpacing; const fontDirection = current.fontDirection; const textHScale = current.textHScale * fontDirection; const vertical = font.vertical; const spacingDir = vertical ? 1 : -1; const defaultVMetrics = font.defaultVMetrics; const widthAdvanceScale = fontSize * current.fontMatrix[0]; let x = 0; for (const glyph of glyphs) { if (glyph === null) { x += fontDirection * wordSpacing; continue; } else if ((0, _util.isNum)(glyph)) { x += spacingDir * glyph * fontSize / 1000; continue; } const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; const character = glyph.fontChar; let scaledX, scaledY; let width = glyph.width; if (vertical) { let vx; const vmetric = glyph.vmetric || defaultVMetrics; vx = glyph.vmetric ? vmetric[1] : width * 0.5; vx = -vx * widthAdvanceScale; const vy = vmetric[2] * widthAdvanceScale; width = vmetric ? -vmetric[0] : width; scaledX = vx / fontSizeScale; scaledY = (x + vy) / fontSizeScale; } else { scaledX = x / fontSizeScale; scaledY = 0; } if (glyph.isInFont || font.missingFile) { current.xcoords.push(current.x + scaledX); if (vertical) { current.ycoords.push(-current.y + scaledY); } current.tspan.textContent += character; } else {} let charWidth; if (vertical) { charWidth = width * widthAdvanceScale - spacing * fontDirection; } else { charWidth = width * widthAdvanceScale + spacing * fontDirection; } x += charWidth; } current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" ")); if (vertical) { current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" ")); } else { current.tspan.setAttributeNS(null, "y", pf(-current.y)); } if (vertical) { current.y -= x; } else { current.x += x * textHScale; } current.tspan.setAttributeNS(null, "font-family", current.fontFamily); current.tspan.setAttributeNS(null, "font-size", `${pf(current.fontSize)}px`); if (current.fontStyle !== SVG_DEFAULTS.fontStyle) { current.tspan.setAttributeNS(null, "font-style", current.fontStyle); } if (current.fontWeight !== SVG_DEFAULTS.fontWeight) { current.tspan.setAttributeNS(null, "font-weight", current.fontWeight); } const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { if (current.fillColor !== SVG_DEFAULTS.fillColor) { current.tspan.setAttributeNS(null, "fill", current.fillColor); } if (current.fillAlpha < 1) { current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha); } } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) { current.tspan.setAttributeNS(null, "fill", "transparent"); } else { current.tspan.setAttributeNS(null, "fill", "none"); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { const lineWidthScale = 1 / (current.textMatrixScale || 1); this._setStrokeAttributes(current.tspan, lineWidthScale); } let textMatrix = current.textMatrix; if (current.textRise !== 0) { textMatrix = textMatrix.slice(); textMatrix[5] += current.textRise; } current.txtElement.setAttributeNS(null, "transform", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`); current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve"); current.txtElement.appendChild(current.tspan); current.txtgrp.appendChild(current.txtElement); this._ensureTransformGroup().appendChild(current.txtElement); } setLeadingMoveText(x, y) { this.setLeading(-y); this.moveText(x, y); } addFontStyle(fontObj) { if (!fontObj.data) { throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.'); } if (!this.cssStyle) { this.cssStyle = this.svgFactory.createElement("svg:style"); this.cssStyle.setAttributeNS(null, "type", "text/css"); this.defs.appendChild(this.cssStyle); } const url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema); this.cssStyle.textContent += `@font-face { font-family: "${fontObj.loadedName}";` + ` src: url(${url}); }\n`; } setFont(details) { const current = this.current; const fontObj = this.commonObjs.get(details[0]); let size = details[1]; current.font = fontObj; if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) { this.addFontStyle(fontObj); this.embeddedFonts[fontObj.loadedName] = fontObj; } current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX; let bold = "normal"; if (fontObj.black) { bold = "900"; } else if (fontObj.bold) { bold = "bold"; } const italic = fontObj.italic ? "italic" : "normal"; if (size < 0) { size = -size; current.fontDirection = -1; } else { current.fontDirection = 1; } current.fontSize = size; current.fontFamily = fontObj.loadedName; current.fontWeight = bold; current.fontStyle = italic; current.tspan = this.svgFactory.createElement("svg:tspan"); current.tspan.setAttributeNS(null, "y", pf(-current.y)); current.xcoords = []; current.ycoords = []; } endText() { const current = this.current; if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) { current.element = current.txtElement; this.clip("nonzero"); this.endPath(); } } setLineWidth(width) { if (width > 0) { this.current.lineWidth = width; } } setLineCap(style) { this.current.lineCap = LINE_CAP_STYLES[style]; } setLineJoin(style) { this.current.lineJoin = LINE_JOIN_STYLES[style]; } setMiterLimit(limit) { this.current.miterLimit = limit; } setStrokeAlpha(strokeAlpha) { this.current.strokeAlpha = strokeAlpha; } setStrokeRGBColor(r, g, b) { this.current.strokeColor = _util.Util.makeCssRgb(r, g, b); } setFillAlpha(fillAlpha) { this.current.fillAlpha = fillAlpha; } setFillRGBColor(r, g, b) { this.current.fillColor = _util.Util.makeCssRgb(r, g, b); this.current.tspan = this.svgFactory.createElement("svg:tspan"); this.current.xcoords = []; this.current.ycoords = []; } setStrokeColorN(args) { this.current.strokeColor = this._makeColorN_Pattern(args); } setFillColorN(args) { this.current.fillColor = this._makeColorN_Pattern(args); } shadingFill(args) { const width = this.viewport.width; const height = this.viewport.height; const inv = _util.Util.inverseTransform(this.transformMatrix); const bl = _util.Util.applyTransform([0, 0], inv); const br = _util.Util.applyTransform([0, height], inv); const ul = _util.Util.applyTransform([width, 0], inv); const ur = _util.Util.applyTransform([width, height], inv); const x0 = Math.min(bl[0], br[0], ul[0], ur[0]); const y0 = Math.min(bl[1], br[1], ul[1], ur[1]); const x1 = Math.max(bl[0], br[0], ul[0], ur[0]); const y1 = Math.max(bl[1], br[1], ul[1], ur[1]); const rect = this.svgFactory.createElement("svg:rect"); rect.setAttributeNS(null, "x", x0); rect.setAttributeNS(null, "y", y0); rect.setAttributeNS(null, "width", x1 - x0); rect.setAttributeNS(null, "height", y1 - y0); rect.setAttributeNS(null, "fill", this._makeShadingPattern(args)); if (this.current.fillAlpha < 1) { rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha); } this._ensureTransformGroup().appendChild(rect); } _makeColorN_Pattern(args) { if (args[0] === "TilingPattern") { return this._makeTilingPattern(args); } return this._makeShadingPattern(args); } _makeTilingPattern(args) { const color = args[1]; const operatorList = args[2]; const matrix = args[3] || _util.IDENTITY_MATRIX; const [x0, y0, x1, y1] = args[4]; const xstep = args[5]; const ystep = args[6]; const paintType = args[7]; const tilingId = `shading${shadingCount++}`; const [tx0, ty0] = _util.Util.applyTransform([x0, y0], matrix); const [tx1, ty1] = _util.Util.applyTransform([x1, y1], matrix); const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix); const txstep = xstep * xscale; const tystep = ystep * yscale; const tiling = this.svgFactory.createElement("svg:pattern"); tiling.setAttributeNS(null, "id", tilingId); tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse"); tiling.setAttributeNS(null, "width", txstep); tiling.setAttributeNS(null, "height", tystep); tiling.setAttributeNS(null, "x", `${tx0}`); tiling.setAttributeNS(null, "y", `${ty0}`); const svg = this.svg; const transformMatrix = this.transformMatrix; const fillColor = this.current.fillColor; const strokeColor = this.current.strokeColor; const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0); this.svg = bbox; this.transformMatrix = matrix; if (paintType === 2) { const cssColor = _util.Util.makeCssRgb(...color); this.current.fillColor = cssColor; this.current.strokeColor = cssColor; } this.executeOpTree(this.convertOpList(operatorList)); this.svg = svg; this.transformMatrix = transformMatrix; this.current.fillColor = fillColor; this.current.strokeColor = strokeColor; tiling.appendChild(bbox.childNodes[0]); this.defs.appendChild(tiling); return `url(#${tilingId})`; } _makeShadingPattern(args) { switch (args[0]) { case "RadialAxial": const shadingId = `shading${shadingCount++}`; const colorStops = args[3]; let gradient; switch (args[1]) { case "axial": const point0 = args[4]; const point1 = args[5]; gradient = this.svgFactory.createElement("svg:linearGradient"); gradient.setAttributeNS(null, "id", shadingId); gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"); gradient.setAttributeNS(null, "x1", point0[0]); gradient.setAttributeNS(null, "y1", point0[1]); gradient.setAttributeNS(null, "x2", point1[0]); gradient.setAttributeNS(null, "y2", point1[1]); break; case "radial": const focalPoint = args[4]; const circlePoint = args[5]; const focalRadius = args[6]; const circleRadius = args[7]; gradient = this.svgFactory.createElement("svg:radialGradient"); gradient.setAttributeNS(null, "id", shadingId); gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"); gradient.setAttributeNS(null, "cx", circlePoint[0]); gradient.setAttributeNS(null, "cy", circlePoint[1]); gradient.setAttributeNS(null, "r", circleRadius); gradient.setAttributeNS(null, "fx", focalPoint[0]); gradient.setAttributeNS(null, "fy", focalPoint[1]); gradient.setAttributeNS(null, "fr", focalRadius); break; default: throw new Error(`Unknown RadialAxial type: ${args[1]}`); } for (const colorStop of colorStops) { const stop = this.svgFactory.createElement("svg:stop"); stop.setAttributeNS(null, "offset", colorStop[0]); stop.setAttributeNS(null, "stop-color", colorStop[1]); gradient.appendChild(stop); } this.defs.appendChild(gradient); return `url(#${shadingId})`; case "Mesh": (0, _util.warn)("Unimplemented pattern Mesh"); return null; case "Dummy": return "hotpink"; default: throw new Error(`Unknown IR type: ${args[0]}`); } } setDash(dashArray, dashPhase) { this.current.dashArray = dashArray; this.current.dashPhase = dashPhase; } constructPath(ops, args) { const current = this.current; let x = current.x, y = current.y; let d = []; let j = 0; for (const op of ops) { switch (op | 0) { case _util.OPS.rectangle: x = args[j++]; y = args[j++]; const width = args[j++]; const height = args[j++]; const xw = x + width; const yh = y + height; d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z"); break; case _util.OPS.moveTo: x = args[j++]; y = args[j++]; d.push("M", pf(x), pf(y)); break; case _util.OPS.lineTo: x = args[j++]; y = args[j++]; d.push("L", pf(x), pf(y)); break; case _util.OPS.curveTo: x = args[j + 4]; y = args[j + 5]; d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y)); j += 6; break; case _util.OPS.curveTo2: d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3])); x = args[j + 2]; y = args[j + 3]; j += 4; break; case _util.OPS.curveTo3: x = args[j + 2]; y = args[j + 3]; d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y)); j += 4; break; case _util.OPS.closePath: d.push("Z"); break; } } d = d.join(" "); if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) { d = current.path.getAttributeNS(null, "d") + d; } else { current.path = this.svgFactory.createElement("svg:path"); this._ensureTransformGroup().appendChild(current.path); } current.path.setAttributeNS(null, "d", d); current.path.setAttributeNS(null, "fill", "none"); current.element = current.path; current.setCurrentPoint(x, y); } endPath() { const current = this.current; current.path = null; if (!this.pendingClip) { return; } if (!current.element) { this.pendingClip = null; return; } const clipId = `clippath${clipCount++}`; const clipPath = this.svgFactory.createElement("svg:clipPath"); clipPath.setAttributeNS(null, "id", clipId); clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix)); const clipElement = current.element.cloneNode(true); if (this.pendingClip === "evenodd") { clipElement.setAttributeNS(null, "clip-rule", "evenodd"); } else { clipElement.setAttributeNS(null, "clip-rule", "nonzero"); } this.pendingClip = null; clipPath.appendChild(clipElement); this.defs.appendChild(clipPath); if (current.activeClipUrl) { current.clipGroup = null; this.extraStack.forEach(function (prev) { prev.clipGroup = null; }); clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl); } current.activeClipUrl = `url(#${clipId})`; this.tgrp = null; } clip(type) { this.pendingClip = type; } closePath() { const current = this.current; if (current.path) { const d = `${current.path.getAttributeNS(null, "d")}Z`; current.path.setAttributeNS(null, "d", d); } } setLeading(leading) { this.current.leading = -leading; } setTextRise(textRise) { this.current.textRise = textRise; } setTextRenderingMode(textRenderingMode) { this.current.textRenderingMode = textRenderingMode; } setHScale(scale) { this.current.textHScale = scale / 100; } setRenderingIntent(intent) {} setFlatness(flatness) {} setGState(states) { for (const [key, value] of states) { switch (key) { case "LW": this.setLineWidth(value); break; case "LC": this.setLineCap(value); break; case "LJ": this.setLineJoin(value); break; case "ML": this.setMiterLimit(value); break; case "D": this.setDash(value[0], value[1]); break; case "RI": this.setRenderingIntent(value); break; case "FL": this.setFlatness(value); break; case "Font": this.setFont(value); break; case "CA": this.setStrokeAlpha(value); break; case "ca": this.setFillAlpha(value); break; default: (0, _util.warn)(`Unimplemented graphic state operator ${key}`); break; } } } fill() { const current = this.current; if (current.element) { current.element.setAttributeNS(null, "fill", current.fillColor); current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha); this.endPath(); } } stroke() { const current = this.current; if (current.element) { this._setStrokeAttributes(current.element); current.element.setAttributeNS(null, "fill", "none"); this.endPath(); } } _setStrokeAttributes(element, lineWidthScale = 1) { const current = this.current; let dashArray = current.dashArray; if (lineWidthScale !== 1 && dashArray.length > 0) { dashArray = dashArray.map(function (value) { return lineWidthScale * value; }); } element.setAttributeNS(null, "stroke", current.strokeColor); element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha); element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit)); element.setAttributeNS(null, "stroke-linecap", current.lineCap); element.setAttributeNS(null, "stroke-linejoin", current.lineJoin); element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px"); element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" ")); element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px"); } eoFill() { if (this.current.element) { this.current.element.setAttributeNS(null, "fill-rule", "evenodd"); } this.fill(); } fillStroke() { this.stroke(); this.fill(); } eoFillStroke() { if (this.current.element) { this.current.element.setAttributeNS(null, "fill-rule", "evenodd"); } this.fillStroke(); } closeStroke() { this.closePath(); this.stroke(); } closeFillStroke() { this.closePath(); this.fillStroke(); } closeEOFillStroke() { this.closePath(); this.eoFillStroke(); } paintSolidColorImageMask() { const rect = this.svgFactory.createElement("svg:rect"); rect.setAttributeNS(null, "x", "0"); rect.setAttributeNS(null, "y", "0"); rect.setAttributeNS(null, "width", "1px"); rect.setAttributeNS(null, "height", "1px"); rect.setAttributeNS(null, "fill", this.current.fillColor); this._ensureTransformGroup().appendChild(rect); } paintImageXObject(objId) { const imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId); if (!imgData) { (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`); return; } this.paintInlineImageXObject(imgData); } paintInlineImageXObject(imgData, mask) { const width = imgData.width; const height = imgData.height; const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask); const cliprect = this.svgFactory.createElement("svg:rect"); cliprect.setAttributeNS(null, "x", "0"); cliprect.setAttributeNS(null, "y", "0"); cliprect.setAttributeNS(null, "width", pf(width)); cliprect.setAttributeNS(null, "height", pf(height)); this.current.element = cliprect; this.clip("nonzero"); const imgEl = this.svgFactory.createElement("svg:image"); imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc); imgEl.setAttributeNS(null, "x", "0"); imgEl.setAttributeNS(null, "y", pf(-height)); imgEl.setAttributeNS(null, "width", pf(width) + "px"); imgEl.setAttributeNS(null, "height", pf(height) + "px"); imgEl.setAttributeNS(null, "transform", `scale(${pf(1 / width)} ${pf(-1 / height)})`); if (mask) { mask.appendChild(imgEl); } else { this._ensureTransformGroup().appendChild(imgEl); } } paintImageMaskXObject(imgData) { const current = this.current; const width = imgData.width; const height = imgData.height; const fillColor = current.fillColor; current.maskId = `mask${maskCount++}`; const mask = this.svgFactory.createElement("svg:mask"); mask.setAttributeNS(null, "id", current.maskId); const rect = this.svgFactory.createElement("svg:rect"); rect.setAttributeNS(null, "x", "0"); rect.setAttributeNS(null, "y", "0"); rect.setAttributeNS(null, "width", pf(width)); rect.setAttributeNS(null, "height", pf(height)); rect.setAttributeNS(null, "fill", fillColor); rect.setAttributeNS(null, "mask", `url(#${current.maskId})`); this.defs.appendChild(mask); this._ensureTransformGroup().appendChild(rect); this.paintInlineImageXObject(imgData, mask); } paintFormXObjectBegin(matrix, bbox) { if (Array.isArray(matrix) && matrix.length === 6) { this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]); } if (bbox) { const width = bbox[2] - bbox[0]; const height = bbox[3] - bbox[1]; const cliprect = this.svgFactory.createElement("svg:rect"); cliprect.setAttributeNS(null, "x", bbox[0]); cliprect.setAttributeNS(null, "y", bbox[1]); cliprect.setAttributeNS(null, "width", pf(width)); cliprect.setAttributeNS(null, "height", pf(height)); this.current.element = cliprect; this.clip("nonzero"); this.endPath(); } } paintFormXObjectEnd() {} _initialize(viewport) { const svg = this.svgFactory.create(viewport.width, viewport.height); const definitions = this.svgFactory.createElement("svg:defs"); svg.appendChild(definitions); this.defs = definitions; const rootGroup = this.svgFactory.createElement("svg:g"); rootGroup.setAttributeNS(null, "transform", pm(viewport.transform)); svg.appendChild(rootGroup); this.svg = rootGroup; return svg; } _ensureClipGroup() { if (!this.current.clipGroup) { const clipGroup = this.svgFactory.createElement("svg:g"); clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl); this.svg.appendChild(clipGroup); this.current.clipGroup = clipGroup; } return this.current.clipGroup; } _ensureTransformGroup() { if (!this.tgrp) { this.tgrp = this.svgFactory.createElement("svg:g"); this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix)); if (this.current.activeClipUrl) { this._ensureClipGroup().appendChild(this.tgrp); } else { this.svg.appendChild(this.tgrp); } } return this.tgrp; } }; }
/***/ }),
/* 22 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFNodeStream = void 0; var _util = __w_pdfjs_require__(2); var _network_utils = __w_pdfjs_require__(23); ; const fs = require("fs"); const http = require("http"); const https = require("https"); const url = require("url");
const fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
function parseUrl(sourceUrl) { const parsedUrl = url.parse(sourceUrl); if (parsedUrl.protocol === "file:" || parsedUrl.host) { return parsedUrl; } if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
return url.parse(`file:///${sourceUrl}`);
} if (!parsedUrl.host) { parsedUrl.protocol = "file:"; } return parsedUrl; } class PDFNodeStream { constructor(source) { this.source = source; this.url = parseUrl(source.url); this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:"; this.isFsUrl = this.url.protocol === "file:"; this.httpHeaders = this.isHttp && source.httpHeaders || {}; this._fullRequestReader = null; this._rangeRequestReaders = []; } get _progressiveDataLength() { return this._fullRequestReader ? this._fullRequestReader._loaded : 0; } getFullReader() { (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."); this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this); return this._fullRequestReader; } getRangeReader(start, end) { if (end <= this._progressiveDataLength) { return null; } const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end); this._rangeRequestReaders.push(rangeReader); return rangeReader; } cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } const readers = this._rangeRequestReaders.slice(0); readers.forEach(function (reader) { reader.cancel(reason); }); } } exports.PDFNodeStream = PDFNodeStream; class BaseFullReader { constructor(stream) { this._url = stream.url; this._done = false; this._storedError = null; this.onProgress = null; const source = stream.source; this._contentLength = source.length; this._loaded = 0; this._filename = null; this._disableRange = source.disableRange || false; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize && !this._disableRange) { this._disableRange = true; } this._isStreamingSupported = !source.disableStream; this._isRangeSupported = !source.disableRange; this._readableStream = null; this._readCapability = (0, _util.createPromiseCapability)(); this._headersCapability = (0, _util.createPromiseCapability)(); } get headersReady() { return this._headersCapability.promise; } get filename() { return this._filename; } get contentLength() { return this._contentLength; } get isRangeSupported() { return this._isRangeSupported; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._readCapability.promise; if (this._done) { return { value: undefined, done: true }; } if (this._storedError) { throw this._storedError; } const chunk = this._readableStream.read(); if (chunk === null) { this._readCapability = (0, _util.createPromiseCapability)(); return this.read(); } this._loaded += chunk.length; if (this.onProgress) { this.onProgress({ loaded: this._loaded, total: this._contentLength }); } const buffer = new Uint8Array(chunk).buffer; return { value: buffer, done: false }; } cancel(reason) { if (!this._readableStream) { this._error(reason); return; } this._readableStream.destroy(reason); } _error(reason) { this._storedError = reason; this._readCapability.resolve(); } _setReadableStream(readableStream) { this._readableStream = readableStream; readableStream.on("readable", () => { this._readCapability.resolve(); }); readableStream.on("end", () => { readableStream.destroy(); this._done = true; this._readCapability.resolve(); }); readableStream.on("error", reason => { this._error(reason); }); if (!this._isStreamingSupported && this._isRangeSupported) { this._error(new _util.AbortException("streaming is disabled")); } if (this._storedError) { this._readableStream.destroy(this._storedError); } } } class BaseRangeReader { constructor(stream) { this._url = stream.url; this._done = false; this._storedError = null; this.onProgress = null; this._loaded = 0; this._readableStream = null; this._readCapability = (0, _util.createPromiseCapability)(); const source = stream.source; this._isStreamingSupported = !source.disableStream; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._readCapability.promise; if (this._done) { return { value: undefined, done: true }; } if (this._storedError) { throw this._storedError; } const chunk = this._readableStream.read(); if (chunk === null) { this._readCapability = (0, _util.createPromiseCapability)(); return this.read(); } this._loaded += chunk.length; if (this.onProgress) { this.onProgress({ loaded: this._loaded }); } const buffer = new Uint8Array(chunk).buffer; return { value: buffer, done: false }; } cancel(reason) { if (!this._readableStream) { this._error(reason); return; } this._readableStream.destroy(reason); } _error(reason) { this._storedError = reason; this._readCapability.resolve(); } _setReadableStream(readableStream) { this._readableStream = readableStream; readableStream.on("readable", () => { this._readCapability.resolve(); }); readableStream.on("end", () => { readableStream.destroy(); this._done = true; this._readCapability.resolve(); }); readableStream.on("error", reason => { this._error(reason); }); if (this._storedError) { this._readableStream.destroy(this._storedError); } } } function createRequestOptions(parsedUrl, headers) { return { protocol: parsedUrl.protocol, auth: parsedUrl.auth, host: parsedUrl.hostname, port: parsedUrl.port, path: parsedUrl.path, method: "GET", headers }; } class PDFNodeStreamFullReader extends BaseFullReader { constructor(stream) { super(stream); const handleResponse = response => { if (response.statusCode === 404) { const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`); this._storedError = error; this._headersCapability.reject(error); return; } this._headersCapability.resolve(); this._setReadableStream(response); const getResponseHeader = name => { return this._readableStream.headers[name.toLowerCase()]; }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = allowRangeRequests; this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); }; this._request = null; if (this._url.protocol === "http:") { this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse); } else { this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse); } this._request.on("error", reason => { this._storedError = reason; this._headersCapability.reject(reason); }); this._request.end(); } } class PDFNodeStreamRangeReader extends BaseRangeReader { constructor(stream, start, end) { super(stream); this._httpHeaders = {}; for (const property in stream.httpHeaders) { const value = stream.httpHeaders[property]; if (typeof value === "undefined") { continue; } this._httpHeaders[property] = value; } this._httpHeaders.Range = `bytes=${start}-${end - 1}`; const handleResponse = response => { if (response.statusCode === 404) { const error = new _util.MissingPDFException(`Missing PDF "${this._url}".`); this._storedError = error; return; } this._setReadableStream(response); }; this._request = null; if (this._url.protocol === "http:") { this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse); } else { this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse); } this._request.on("error", reason => { this._storedError = reason; }); this._request.end(); } } class PDFNodeStreamFsFullReader extends BaseFullReader { constructor(stream) { super(stream); let path = decodeURIComponent(this._url.path); if (fileUriRegex.test(this._url.href)) {
path = path.replace(/^\//, "");
} fs.lstat(path, (error, stat) => { if (error) { if (error.code === "ENOENT") { error = new _util.MissingPDFException(`Missing PDF "${path}".`); } this._storedError = error; this._headersCapability.reject(error); return; } this._contentLength = stat.size; this._setReadableStream(fs.createReadStream(path)); this._headersCapability.resolve(); }); } } class PDFNodeStreamFsRangeReader extends BaseRangeReader { constructor(stream, start, end) { super(stream); let path = decodeURIComponent(this._url.path); if (fileUriRegex.test(this._url.href)) {
path = path.replace(/^\//, "");
} this._setReadableStream(fs.createReadStream(path, { start, end: end - 1 })); } }
/***/ }),
/* 23 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.createResponseStatusError = createResponseStatusError; exports.extractFilenameFromHeader = extractFilenameFromHeader; exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities; exports.validateResponseStatus = validateResponseStatus; var _util = __w_pdfjs_require__(2); var _content_disposition = __w_pdfjs_require__(24); function validateRangeRequestCapabilities({ getResponseHeader, isHttp, rangeChunkSize, disableRange }) { (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero"); const returnValues = { allowRangeRequests: false, suggestedLength: undefined }; const length = parseInt(getResponseHeader("Content-Length"), 10); if (!Number.isInteger(length)) { return returnValues; } returnValues.suggestedLength = length; if (length <= 2 * rangeChunkSize) { return returnValues; } if (disableRange || !isHttp) { return returnValues; } if (getResponseHeader("Accept-Ranges") !== "bytes") { return returnValues; } const contentEncoding = getResponseHeader("Content-Encoding") || "identity"; if (contentEncoding !== "identity") { return returnValues; } returnValues.allowRangeRequests = true; return returnValues; } function extractFilenameFromHeader(getResponseHeader) { const contentDisposition = getResponseHeader("Content-Disposition"); if (contentDisposition) { let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition); if (filename.includes("%")) { try { filename = decodeURIComponent(filename); } catch (ex) {} } if (/\.pdf$/i.test(filename)) { return filename; } } return null; } function createResponseStatusError(status, url) { if (status === 404 || status === 0 && url.startsWith("file:")) { return new _util.MissingPDFException('Missing PDF "' + url + '".'); } return new _util.UnexpectedResponseException("Unexpected server response (" + status + ') while retrieving PDF "' + url + '".', status); } function validateResponseStatus(status) { return status === 200 || status === 206; }
/***/ }),
/* 24 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader; function getFilenameFromContentDispositionHeader(contentDisposition) { let needsEncodingFixup = true; let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition); if (tmp) { tmp = tmp[1]; let filename = rfc2616unquote(tmp); filename = unescape(filename); filename = rfc5987decode(filename); filename = rfc2047decode(filename); return fixupEncoding(filename); } tmp = rfc2231getparam(contentDisposition); if (tmp) { const filename = rfc2047decode(tmp); return fixupEncoding(filename); } tmp = toParamRegExp("filename", "i").exec(contentDisposition); if (tmp) { tmp = tmp[1]; let filename = rfc2616unquote(tmp); filename = rfc2047decode(filename); return fixupEncoding(filename); } function toParamRegExp(attributePattern, flags) { return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags); } function textdecode(encoding, value) { if (encoding) { if (!/^[\x00-\xFF]+$/.test(value)) { return value; } try { const decoder = new TextDecoder(encoding, { fatal: true }); const bytes = Array.from(value, function (ch) { return ch.charCodeAt(0) & 0xff; }); value = decoder.decode(new Uint8Array(bytes)); needsEncodingFixup = false; } catch (e) { if (/^utf-?8$/i.test(encoding)) { try { value = decodeURIComponent(escape(value)); needsEncodingFixup = false; } catch (err) {} } } } return value; } function fixupEncoding(value) { if (needsEncodingFixup && /[\x80-\xff]/.test(value)) { value = textdecode("utf-8", value); if (needsEncodingFixup) { value = textdecode("iso-8859-1", value); } } return value; } function rfc2231getparam(contentDispositionStr) { const matches = []; let match; const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig"); while ((match = iter.exec(contentDispositionStr)) !== null) { let [, n, quot, part] = match; n = parseInt(n, 10); if (n in matches) { if (n === 0) { break; } continue; } matches[n] = [quot, part]; } const parts = []; for (let n = 0; n < matches.length; ++n) { if (!(n in matches)) { break; } let [quot, part] = matches[n]; part = rfc2616unquote(part); if (quot) { part = unescape(part); if (n === 0) { part = rfc5987decode(part); } } parts.push(part); } return parts.join(""); } function rfc2616unquote(value) { if (value.startsWith('"')) { const parts = value.slice(1).split('\\"'); for (let i = 0; i < parts.length; ++i) { const quotindex = parts[i].indexOf('"'); if (quotindex !== -1) { parts[i] = parts[i].slice(0, quotindex); parts.length = i + 1; } parts[i] = parts[i].replace(/\\(.)/g, "$1"); } value = parts.join('"'); } return value; } function rfc5987decode(extvalue) { const encodingend = extvalue.indexOf("'"); if (encodingend === -1) { return extvalue; } const encoding = extvalue.slice(0, encodingend); const langvalue = extvalue.slice(encodingend + 1); const value = langvalue.replace(/^[^']*'/, ""); return textdecode(encoding, value); } function rfc2047decode(value) { if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) { return value; } return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) { if (encoding === "q" || encoding === "Q") { text = text.replace(/_/g, " "); text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) { return String.fromCharCode(parseInt(hex, 16)); }); return textdecode(charset, text); } try { text = atob(text); } catch (e) {} return textdecode(charset, text); }); } return ""; }
/***/ }),
/* 25 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFNetworkStream = void 0; var _util = __w_pdfjs_require__(2); var _network_utils = __w_pdfjs_require__(23); ; const OK_RESPONSE = 200; const PARTIAL_CONTENT_RESPONSE = 206; function getArrayBuffer(xhr) { const data = xhr.response; if (typeof data !== "string") { return data; } const array = (0, _util.stringToBytes)(data); return array.buffer; } class NetworkManager { constructor(url, args) { this.url = url; args = args || {}; this.isHttp = /^https?:/i.test(url); this.httpHeaders = this.isHttp && args.httpHeaders || {}; this.withCredentials = args.withCredentials || false; this.getXhr = args.getXhr || function NetworkManager_getXhr() { return new XMLHttpRequest(); }; this.currXhrId = 0; this.pendingRequests = Object.create(null); } requestRange(begin, end, listeners) { const args = { begin, end }; for (const prop in listeners) { args[prop] = listeners[prop]; } return this.request(args); } requestFull(listeners) { return this.request(listeners); } request(args) { const xhr = this.getXhr(); const xhrId = this.currXhrId++; const pendingRequest = this.pendingRequests[xhrId] = { xhr }; xhr.open("GET", this.url); xhr.withCredentials = this.withCredentials; for (const property in this.httpHeaders) { const value = this.httpHeaders[property]; if (typeof value === "undefined") { continue; } xhr.setRequestHeader(property, value); } if (this.isHttp && "begin" in args && "end" in args) { xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`); pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE; } else { pendingRequest.expectedStatus = OK_RESPONSE; } xhr.responseType = "arraybuffer"; if (args.onError) { xhr.onerror = function (evt) { args.onError(xhr.status); }; } xhr.onreadystatechange = this.onStateChange.bind(this, xhrId); xhr.onprogress = this.onProgress.bind(this, xhrId); pendingRequest.onHeadersReceived = args.onHeadersReceived; pendingRequest.onDone = args.onDone; pendingRequest.onError = args.onError; pendingRequest.onProgress = args.onProgress; xhr.send(null); return xhrId; } onProgress(xhrId, evt) { const pendingRequest = this.pendingRequests[xhrId]; if (!pendingRequest) { return; } if (pendingRequest.onProgress) { pendingRequest.onProgress(evt); } } onStateChange(xhrId, evt) { const pendingRequest = this.pendingRequests[xhrId]; if (!pendingRequest) { return; } const xhr = pendingRequest.xhr; if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) { pendingRequest.onHeadersReceived(); delete pendingRequest.onHeadersReceived; } if (xhr.readyState !== 4) { return; } if (!(xhrId in this.pendingRequests)) { return; } delete this.pendingRequests[xhrId]; if (xhr.status === 0 && this.isHttp) { if (pendingRequest.onError) { pendingRequest.onError(xhr.status); } return; } const xhrStatus = xhr.status || OK_RESPONSE; const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE; if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) { if (pendingRequest.onError) { pendingRequest.onError(xhr.status); } return; } const chunk = getArrayBuffer(xhr); if (xhrStatus === PARTIAL_CONTENT_RESPONSE) { const rangeHeader = xhr.getResponseHeader("Content-Range"); const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader); pendingRequest.onDone({ begin: parseInt(matches[1], 10), chunk }); } else if (chunk) { pendingRequest.onDone({ begin: 0, chunk }); } else if (pendingRequest.onError) { pendingRequest.onError(xhr.status); } } getRequestXhr(xhrId) { return this.pendingRequests[xhrId].xhr; } isPendingRequest(xhrId) { return xhrId in this.pendingRequests; } abortRequest(xhrId) { const xhr = this.pendingRequests[xhrId].xhr; delete this.pendingRequests[xhrId]; xhr.abort(); } } class PDFNetworkStream { constructor(source) { this._source = source; this._manager = new NetworkManager(source.url, { httpHeaders: source.httpHeaders, withCredentials: source.withCredentials }); this._rangeChunkSize = source.rangeChunkSize; this._fullRequestReader = null; this._rangeRequestReaders = []; } _onRangeRequestReaderClosed(reader) { const i = this._rangeRequestReaders.indexOf(reader); if (i >= 0) { this._rangeRequestReaders.splice(i, 1); } } getFullReader() { (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."); this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source); return this._fullRequestReader; } getRangeReader(begin, end) { const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end); reader.onClosed = this._onRangeRequestReaderClosed.bind(this); this._rangeRequestReaders.push(reader); return reader; } cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } const readers = this._rangeRequestReaders.slice(0); readers.forEach(function (reader) { reader.cancel(reason); }); } } exports.PDFNetworkStream = PDFNetworkStream; class PDFNetworkStreamFullRequestReader { constructor(manager, source) { this._manager = manager; const args = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = source.url; this._fullRequestId = manager.requestFull(args); this._headersReceivedCapability = (0, _util.createPromiseCapability)(); this._disableRange = source.disableRange || false; this._contentLength = source.length; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize && !this._disableRange) { this._disableRange = true; } this._isStreamingSupported = false; this._isRangeSupported = false; this._cachedChunks = []; this._requests = []; this._done = false; this._storedError = undefined; this._filename = null; this.onProgress = null; } _onHeadersReceived() { const fullRequestXhrId = this._fullRequestId; const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId); const getResponseHeader = name => { return fullRequestXhr.getResponseHeader(name); }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); if (allowRangeRequests) { this._isRangeSupported = true; } this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); if (this._isRangeSupported) { this._manager.abortRequest(fullRequestXhrId); } this._headersReceivedCapability.resolve(); } _onDone(args) { if (args) { if (this._requests.length > 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: args.chunk, done: false }); } else { this._cachedChunks.push(args.chunk); } } this._done = true; if (this._cachedChunks.length > 0) { return; } this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; } _onError(status) { const url = this._url; const exception = (0, _network_utils.createResponseStatusError)(status, url); this._storedError = exception; this._headersReceivedCapability.reject(exception); this._requests.forEach(function (requestCapability) { requestCapability.reject(exception); }); this._requests = []; this._cachedChunks = []; } _onProgress(data) { if (this.onProgress) { this.onProgress({ loaded: data.loaded, total: data.lengthComputable ? data.total : this._contentLength }); } } get filename() { return this._filename; } get isRangeSupported() { return this._isRangeSupported; } get isStreamingSupported() { return this._isStreamingSupported; } get contentLength() { return this._contentLength; } get headersReady() { return this._headersReceivedCapability.promise; } async read() { if (this._storedError) { throw this._storedError; } if (this._cachedChunks.length > 0) { const chunk = this._cachedChunks.shift(); return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; this._headersReceivedCapability.reject(reason); this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; if (this._manager.isPendingRequest(this._fullRequestId)) { this._manager.abortRequest(this._fullRequestId); } this._fullRequestReader = null; } } class PDFNetworkStreamRangeRequestReader { constructor(manager, begin, end) { this._manager = manager; const args = { onDone: this._onDone.bind(this), onProgress: this._onProgress.bind(this) }; this._requestId = manager.requestRange(begin, end, args); this._requests = []; this._queuedChunk = null; this._done = false; this.onProgress = null; this.onClosed = null; } _close() { if (this.onClosed) { this.onClosed(this); } } _onDone(data) { const chunk = data.chunk; if (this._requests.length > 0) { const requestCapability = this._requests.shift(); requestCapability.resolve({ value: chunk, done: false }); } else { this._queuedChunk = chunk; } this._done = true; this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; this._close(); } _onProgress(evt) { if (!this.isStreamingSupported && this.onProgress) { this.onProgress({ loaded: evt.loaded }); } } get isStreamingSupported() { return false; } async read() { if (this._queuedChunk !== null) { const chunk = this._queuedChunk; this._queuedChunk = null; return { value: chunk, done: false }; } if (this._done) { return { value: undefined, done: true }; } const requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return requestCapability.promise; } cancel(reason) { this._done = true; this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; if (this._manager.isPendingRequest(this._requestId)) { this._manager.abortRequest(this._requestId); } this._close(); } }
/***/ }),
/* 26 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFFetchStream = void 0; var _util = __w_pdfjs_require__(2); var _network_utils = __w_pdfjs_require__(23); ; function createFetchOptions(headers, withCredentials, abortController) { return { method: "GET", headers, signal: abortController && abortController.signal, mode: "cors", credentials: withCredentials ? "include" : "same-origin", redirect: "follow" }; } function createHeaders(httpHeaders) { const headers = new Headers(); for (const property in httpHeaders) { const value = httpHeaders[property]; if (typeof value === "undefined") { continue; } headers.append(property, value); } return headers; } class PDFFetchStream { constructor(source) { this.source = source; this.isHttp = /^https?:/i.test(source.url); this.httpHeaders = this.isHttp && source.httpHeaders || {}; this._fullRequestReader = null; this._rangeRequestReaders = []; } get _progressiveDataLength() { return this._fullRequestReader ? this._fullRequestReader._loaded : 0; } getFullReader() { (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."); this._fullRequestReader = new PDFFetchStreamReader(this); return this._fullRequestReader; } getRangeReader(begin, end) { if (end <= this._progressiveDataLength) { return null; } const reader = new PDFFetchStreamRangeReader(this, begin, end); this._rangeRequestReaders.push(reader); return reader; } cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } const readers = this._rangeRequestReaders.slice(0); readers.forEach(function (reader) { reader.cancel(reason); }); } } exports.PDFFetchStream = PDFFetchStream; class PDFFetchStreamReader { constructor(stream) { this._stream = stream; this._reader = null; this._loaded = 0; this._filename = null; const source = stream.source; this._withCredentials = source.withCredentials || false; this._contentLength = source.length; this._headersCapability = (0, _util.createPromiseCapability)(); this._disableRange = source.disableRange || false; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize && !this._disableRange) { this._disableRange = true; } if (typeof AbortController !== "undefined") { this._abortController = new AbortController(); } this._isStreamingSupported = !source.disableStream; this._isRangeSupported = !source.disableRange; this._headers = createHeaders(this._stream.httpHeaders); const url = source.url; fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => { if (!(0, _network_utils.validateResponseStatus)(response.status)) { throw (0, _network_utils.createResponseStatusError)(response.status, url); } this._reader = response.body.getReader(); this._headersCapability.resolve(); const getResponseHeader = name => { return response.headers.get(name); }; const { allowRangeRequests, suggestedLength } = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = allowRangeRequests; this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); if (!this._isStreamingSupported && this._isRangeSupported) { this.cancel(new _util.AbortException("Streaming is disabled.")); } }).catch(this._headersCapability.reject); this.onProgress = null; } get headersReady() { return this._headersCapability.promise; } get filename() { return this._filename; } get contentLength() { return this._contentLength; } get isRangeSupported() { return this._isRangeSupported; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._headersCapability.promise; const { value, done } = await this._reader.read(); if (done) { return { value, done }; } this._loaded += value.byteLength; if (this.onProgress) { this.onProgress({ loaded: this._loaded, total: this._contentLength }); } const buffer = new Uint8Array(value).buffer; return { value: buffer, done: false }; } cancel(reason) { if (this._reader) { this._reader.cancel(reason); } if (this._abortController) { this._abortController.abort(); } } } class PDFFetchStreamRangeReader { constructor(stream, begin, end) { this._stream = stream; this._reader = null; this._loaded = 0; const source = stream.source; this._withCredentials = source.withCredentials || false; this._readCapability = (0, _util.createPromiseCapability)(); this._isStreamingSupported = !source.disableStream; if (typeof AbortController !== "undefined") { this._abortController = new AbortController(); } this._headers = createHeaders(this._stream.httpHeaders); this._headers.append("Range", `bytes=${begin}-${end - 1}`); const url = source.url; fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => { if (!(0, _network_utils.validateResponseStatus)(response.status)) { throw (0, _network_utils.createResponseStatusError)(response.status, url); } this._readCapability.resolve(); this._reader = response.body.getReader(); }).catch(reason => { if (reason && reason.name === "AbortError") { return; } throw reason; }); this.onProgress = null; } get isStreamingSupported() { return this._isStreamingSupported; } async read() { await this._readCapability.promise; const { value, done } = await this._reader.read(); if (done) { return { value, done }; } this._loaded += value.byteLength; if (this.onProgress) { this.onProgress({ loaded: this._loaded }); } const buffer = new Uint8Array(value).buffer; return { value: buffer, done: false }; } cancel(reason) { if (this._reader) { this._reader.cancel(reason); } if (this._abortController) { this._abortController.abort(); } } }
/***/ })
/******/ ]);
});
//# sourceMappingURL=pdf.js.map
/**
* @licstart The following is the entire license notice for the * Javascript code in this page * * Copyright 2020 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *
* http://www.apache.org/licenses/LICENSE-2.0
* * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * Javascript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define("pdfjs-dist/web/pdf_viewer", [], factory); else if(typeof exports === 'object') exports["pdfjs-dist/web/pdf_viewer"] = factory(); else root["pdfjs-dist/web/pdf_viewer"] = root.pdfjsViewer = factory(); })(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__w_pdfjs_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__w_pdfjs_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
/******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__w_pdfjs_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__w_pdfjs_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __w_pdfjs_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__w_pdfjs_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __w_pdfjs_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__w_pdfjs_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__w_pdfjs_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); Object.defineProperty(exports, "AnnotationLayerBuilder", { enumerable: true, get: function () { return _annotation_layer_builder.AnnotationLayerBuilder; } }); Object.defineProperty(exports, "DefaultAnnotationLayerFactory", { enumerable: true, get: function () { return _annotation_layer_builder.DefaultAnnotationLayerFactory; } }); Object.defineProperty(exports, "DefaultTextLayerFactory", { enumerable: true, get: function () { return _text_layer_builder.DefaultTextLayerFactory; } }); Object.defineProperty(exports, "TextLayerBuilder", { enumerable: true, get: function () { return _text_layer_builder.TextLayerBuilder; } }); Object.defineProperty(exports, "EventBus", { enumerable: true, get: function () { return _ui_utils.EventBus; } }); Object.defineProperty(exports, "NullL10n", { enumerable: true, get: function () { return _ui_utils.NullL10n; } }); Object.defineProperty(exports, "ProgressBar", { enumerable: true, get: function () { return _ui_utils.ProgressBar; } }); Object.defineProperty(exports, "PDFLinkService", { enumerable: true, get: function () { return _pdf_link_service.PDFLinkService; } }); Object.defineProperty(exports, "SimpleLinkService", { enumerable: true, get: function () { return _pdf_link_service.SimpleLinkService; } }); Object.defineProperty(exports, "DownloadManager", { enumerable: true, get: function () { return _download_manager.DownloadManager; } }); Object.defineProperty(exports, "GenericL10n", { enumerable: true, get: function () { return _genericl10n.GenericL10n; } }); Object.defineProperty(exports, "PDFFindController", { enumerable: true, get: function () { return _pdf_find_controller.PDFFindController; } }); Object.defineProperty(exports, "PDFHistory", { enumerable: true, get: function () { return _pdf_history.PDFHistory; } }); Object.defineProperty(exports, "PDFPageView", { enumerable: true, get: function () { return _pdf_page_view.PDFPageView; } }); Object.defineProperty(exports, "PDFSinglePageViewer", { enumerable: true, get: function () { return _pdf_single_page_viewer.PDFSinglePageViewer; } }); Object.defineProperty(exports, "PDFViewer", { enumerable: true, get: function () { return _pdf_viewer.PDFViewer; } }); var _annotation_layer_builder = __w_pdfjs_require__(1); var _text_layer_builder = __w_pdfjs_require__(5); var _ui_utils = __w_pdfjs_require__(3); var _pdf_link_service = __w_pdfjs_require__(4); var _download_manager = __w_pdfjs_require__(6); var _genericl10n = __w_pdfjs_require__(8); var _pdf_find_controller = __w_pdfjs_require__(10); var _pdf_history = __w_pdfjs_require__(12); var _pdf_page_view = __w_pdfjs_require__(13); var _pdf_single_page_viewer = __w_pdfjs_require__(15); var _pdf_viewer = __w_pdfjs_require__(17); const pdfjsVersion = '2.6.347'; const pdfjsBuild = '3be9c65f0';
/***/ }),
/* 1 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.DefaultAnnotationLayerFactory = exports.AnnotationLayerBuilder = void 0; var _pdfjsLib = __w_pdfjs_require__(2); var _ui_utils = __w_pdfjs_require__(3); var _pdf_link_service = __w_pdfjs_require__(4); class AnnotationLayerBuilder { constructor({ pageDiv, pdfPage, linkService, downloadManager, annotationStorage = null, imageResourcesPath = "", renderInteractiveForms = true, l10n = _ui_utils.NullL10n }) { this.pageDiv = pageDiv; this.pdfPage = pdfPage; this.linkService = linkService; this.downloadManager = downloadManager; this.imageResourcesPath = imageResourcesPath; this.renderInteractiveForms = renderInteractiveForms; this.l10n = l10n; this.annotationStorage = annotationStorage; this.div = null; this._cancelled = false; } render(viewport, intent = "display") { return this.pdfPage.getAnnotations({ intent }).then(annotations => { if (this._cancelled) { return; } if (annotations.length === 0) { return; } const parameters = { viewport: viewport.clone({ dontFlip: true }), div: this.div, annotations, page: this.pdfPage, imageResourcesPath: this.imageResourcesPath, renderInteractiveForms: this.renderInteractiveForms, linkService: this.linkService, downloadManager: this.downloadManager, annotationStorage: this.annotationStorage }; if (this.div) { _pdfjsLib.AnnotationLayer.update(parameters); } else { this.div = document.createElement("div"); this.div.className = "annotationLayer"; this.pageDiv.appendChild(this.div); parameters.div = this.div; _pdfjsLib.AnnotationLayer.render(parameters); this.l10n.translate(this.div); } }); } cancel() { this._cancelled = true; } hide() { if (!this.div) { return; } this.div.setAttribute("hidden", "true"); } } exports.AnnotationLayerBuilder = AnnotationLayerBuilder; class DefaultAnnotationLayerFactory { createAnnotationLayerBuilder(pageDiv, pdfPage, annotationStorage = null, imageResourcesPath = "", renderInteractiveForms = true, l10n = _ui_utils.NullL10n) { return new AnnotationLayerBuilder({ pageDiv, pdfPage, imageResourcesPath, renderInteractiveForms, linkService: new _pdf_link_service.SimpleLinkService(), l10n, annotationStorage }); } } exports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;
/***/ }),
/* 2 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; let pdfjsLib; if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) { pdfjsLib = window["pdfjs-dist/build/pdf"]; } else { pdfjsLib = require("../build/pdf.js"); } module.exports = pdfjsLib;
/***/ }),
/* 3 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.isValidRotation = isValidRotation; exports.isValidScrollMode = isValidScrollMode; exports.isValidSpreadMode = isValidSpreadMode; exports.isPortraitOrientation = isPortraitOrientation; exports.clamp = clamp; exports.getPDFFileNameFromURL = getPDFFileNameFromURL; exports.noContextMenuHandler = noContextMenuHandler; exports.parseQueryString = parseQueryString; exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements; exports.getVisibleElements = getVisibleElements; exports.roundToDivide = roundToDivide; exports.getPageSizeInches = getPageSizeInches; exports.approximateFraction = approximateFraction; exports.getOutputScale = getOutputScale; exports.scrollIntoView = scrollIntoView; exports.watchScroll = watchScroll; exports.binarySearchFirstItem = binarySearchFirstItem; exports.normalizeWheelEventDirection = normalizeWheelEventDirection; exports.normalizeWheelEventDelta = normalizeWheelEventDelta; exports.waitOnEventOrTimeout = waitOnEventOrTimeout; exports.moveToEndOfArray = moveToEndOfArray;
exports.WaitOnType = exports.animationStarted = exports.ProgressBar = exports.EventBus = exports.NullL10n = exports.SpreadMode = exports.ScrollMode = exports.TextLayerMode = exports.RendererType = exports.PresentationModeState = exports.VERTICAL_PADDING = exports.SCROLLBAR_PADDING = exports.MAX_AUTO_SCALE = exports.UNKNOWN_SCALE = exports.MAX_SCALE = exports.MIN_SCALE = exports.DEFAULT_SCALE = exports.DEFAULT_SCALE_VALUE = exports.CSS_UNITS = exports.AutoPrintRegExp = void 0;
const CSS_UNITS = 96.0 / 72.0; exports.CSS_UNITS = CSS_UNITS; const DEFAULT_SCALE_VALUE = "auto"; exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE; const DEFAULT_SCALE = 1.0; exports.DEFAULT_SCALE = DEFAULT_SCALE; const MIN_SCALE = 0.1; exports.MIN_SCALE = MIN_SCALE; const MAX_SCALE = 10.0; exports.MAX_SCALE = MAX_SCALE; const UNKNOWN_SCALE = 0; exports.UNKNOWN_SCALE = UNKNOWN_SCALE; const MAX_AUTO_SCALE = 1.25; exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE; const SCROLLBAR_PADDING = 40; exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING; const VERTICAL_PADDING = 5; exports.VERTICAL_PADDING = VERTICAL_PADDING; const PresentationModeState = { UNKNOWN: 0, NORMAL: 1, CHANGING: 2, FULLSCREEN: 3 }; exports.PresentationModeState = PresentationModeState; const RendererType = { CANVAS: "canvas", SVG: "svg" }; exports.RendererType = RendererType; const TextLayerMode = { DISABLE: 0, ENABLE: 1, ENABLE_ENHANCE: 2 }; exports.TextLayerMode = TextLayerMode; const ScrollMode = { UNKNOWN: -1, VERTICAL: 0, HORIZONTAL: 1, WRAPPED: 2 }; exports.ScrollMode = ScrollMode; const SpreadMode = { UNKNOWN: -1, NONE: 0, ODD: 1, EVEN: 2 }; exports.SpreadMode = SpreadMode; const AutoPrintRegExp = /\bprint\s*\(/; exports.AutoPrintRegExp = AutoPrintRegExp; function formatL10nValue(text, args) { if (!args) { return text; } return text.replace(/\{\{\s*(\w+)\s*\}\}/g, (all, name) => { return name in args ? args[name] : "{{" + name + "}}"; }); } const NullL10n = { async getLanguage() { return "en-us"; }, async getDirection() { return "ltr"; }, async get(property, args, fallback) { return formatL10nValue(fallback, args); }, async translate(element) {} }; exports.NullL10n = NullL10n; function getOutputScale(ctx) { const devicePixelRatio = window.devicePixelRatio || 1; const backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1; const pixelRatio = devicePixelRatio / backingStoreRatio; return { sx: pixelRatio, sy: pixelRatio, scaled: pixelRatio !== 1 }; } function scrollIntoView(element, spot, skipOverflowHiddenElements = false) { let parent = element.offsetParent; if (!parent) { console.error("offsetParent is not set -- cannot scroll"); return; } let offsetY = element.offsetTop + element.clientTop; let offsetX = element.offsetLeft + element.clientLeft; while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === "hidden") { if (parent.dataset._scaleY) { offsetY /= parent.dataset._scaleY; offsetX /= parent.dataset._scaleX; } offsetY += parent.offsetTop; offsetX += parent.offsetLeft; parent = parent.offsetParent; if (!parent) { return; } } if (spot) { if (spot.top !== undefined) { offsetY += spot.top; } if (spot.left !== undefined) { offsetX += spot.left; parent.scrollLeft = offsetX; } } parent.scrollTop = offsetY; } function watchScroll(viewAreaElement, callback) { const debounceScroll = function (evt) { if (rAF) { return; } rAF = window.requestAnimationFrame(function viewAreaElementScrolled() { rAF = null; const currentX = viewAreaElement.scrollLeft; const lastX = state.lastX; if (currentX !== lastX) { state.right = currentX > lastX; } state.lastX = currentX; const currentY = viewAreaElement.scrollTop; const lastY = state.lastY; if (currentY !== lastY) { state.down = currentY > lastY; } state.lastY = currentY; callback(state); }); }; const state = { right: true, down: true, lastX: viewAreaElement.scrollLeft, lastY: viewAreaElement.scrollTop, _eventHandler: debounceScroll }; let rAF = null; viewAreaElement.addEventListener("scroll", debounceScroll, true); return state; } function parseQueryString(query) { const parts = query.split("&"); const params = Object.create(null); for (let i = 0, ii = parts.length; i < ii; ++i) { const param = parts[i].split("="); const key = param[0].toLowerCase(); const value = param.length > 1 ? param[1] : null; params[decodeURIComponent(key)] = decodeURIComponent(value); } return params; } function binarySearchFirstItem(items, condition) { let minIndex = 0; let maxIndex = items.length - 1; if (maxIndex < 0 || !condition(items[maxIndex])) { return items.length; } if (condition(items[minIndex])) { return minIndex; } while (minIndex < maxIndex) { const currentIndex = minIndex + maxIndex >> 1; const currentItem = items[currentIndex]; if (condition(currentItem)) { maxIndex = currentIndex; } else { minIndex = currentIndex + 1; } } return minIndex; } function approximateFraction(x) { if (Math.floor(x) === x) { return [x, 1]; } const xinv = 1 / x; const limit = 8; if (xinv > limit) { return [1, limit]; } else if (Math.floor(xinv) === xinv) { return [1, xinv]; } const x_ = x > 1 ? xinv : x; let a = 0, b = 1, c = 1, d = 1; while (true) { const p = a + c, q = b + d; if (q > limit) { break; } if (x_ <= p / q) { c = p; d = q; } else { a = p; b = q; } } let result; if (x_ - a / b < c / d - x_) { result = x_ === x ? [a, b] : [b, a]; } else { result = x_ === x ? [c, d] : [d, c]; } return result; } function roundToDivide(x, div) { const r = x % div; return r === 0 ? x : Math.round(x - r + div); } function getPageSizeInches({ view, userUnit, rotate }) { const [x1, y1, x2, y2] = view; const changeOrientation = rotate % 180 !== 0; const width = (x2 - x1) / 72 * userUnit; const height = (y2 - y1) / 72 * userUnit; return { width: changeOrientation ? height : width, height: changeOrientation ? width : height }; } function backtrackBeforeAllVisibleElements(index, views, top) { if (index < 2) { return index; } let elt = views[index].div; let pageTop = elt.offsetTop + elt.clientTop; if (pageTop >= top) { elt = views[index - 1].div; pageTop = elt.offsetTop + elt.clientTop; } for (let i = index - 2; i >= 0; --i) { elt = views[i].div; if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) { break; } index = i; } return index; } function getVisibleElements(scrollEl, views, sortByVisibility = false, horizontal = false) { const top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight; const left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth; function isElementBottomAfterViewTop(view) { const element = view.div; const elementBottom = element.offsetTop + element.clientTop + element.clientHeight; return elementBottom > top; } function isElementRightAfterViewLeft(view) { const element = view.div; const elementRight = element.offsetLeft + element.clientLeft + element.clientWidth; return elementRight > left; } const visible = [], numViews = views.length; let firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop); if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) { firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top); } let lastEdge = horizontal ? right : -1; for (let i = firstVisibleElementInd; i < numViews; i++) { const view = views[i], element = view.div; const currentWidth = element.offsetLeft + element.clientLeft; const currentHeight = element.offsetTop + element.clientTop; const viewWidth = element.clientWidth, viewHeight = element.clientHeight; const viewRight = currentWidth + viewWidth; const viewBottom = currentHeight + viewHeight; if (lastEdge === -1) { if (viewBottom >= bottom) { lastEdge = viewBottom; } } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) { break; } if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) { continue; } const hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom); const hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right); const percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0; visible.push({ id: view.id, x: currentWidth, y: currentHeight, view, percent }); } const first = visible[0], last = visible[visible.length - 1]; if (sortByVisibility) { visible.sort(function (a, b) { const pc = a.percent - b.percent; if (Math.abs(pc) > 0.001) { return -pc; } return a.id - b.id; }); } return { first, last, views: visible }; } function noContextMenuHandler(evt) { evt.preventDefault(); } function isDataSchema(url) { let i = 0; const ii = url.length; while (i < ii && url[i].trim() === "") { i++; } return url.substring(i, i + 5).toLowerCase() === "data:"; } function getPDFFileNameFromURL(url, defaultFilename = "document.pdf") { if (typeof url !== "string") { return defaultFilename; } if (isDataSchema(url)) { console.warn("getPDFFileNameFromURL: " + 'ignoring "data:" URL for performance reasons.'); return defaultFilename; } const reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/; const reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i; const splitURI = reURI.exec(url); let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]); if (suggestedFilename) { suggestedFilename = suggestedFilename[0]; if (suggestedFilename.includes("%")) { try { suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0]; } catch (ex) {} } } return suggestedFilename || defaultFilename; } function normalizeWheelEventDirection(evt) { let delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY); const angle = Math.atan2(evt.deltaY, evt.deltaX); if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) { delta = -delta; } return delta; } function normalizeWheelEventDelta(evt) { let delta = normalizeWheelEventDirection(evt); const MOUSE_DOM_DELTA_PIXEL_MODE = 0; const MOUSE_DOM_DELTA_LINE_MODE = 1; const MOUSE_PIXELS_PER_LINE = 30; const MOUSE_LINES_PER_PAGE = 30; if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) { delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE; } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) { delta /= MOUSE_LINES_PER_PAGE; } return delta; } function isValidRotation(angle) { return Number.isInteger(angle) && angle % 90 === 0; } function isValidScrollMode(mode) { return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN; } function isValidSpreadMode(mode) { return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN; } function isPortraitOrientation(size) { return size.width <= size.height; } const WaitOnType = { EVENT: "event", TIMEOUT: "timeout" }; exports.WaitOnType = WaitOnType; function waitOnEventOrTimeout({ target, name, delay = 0 }) { return new Promise(function (resolve, reject) { if (typeof target !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) { throw new Error("waitOnEventOrTimeout - invalid parameters."); } function handler(type) { if (target instanceof EventBus) { target._off(name, eventHandler); } else { target.removeEventListener(name, eventHandler); } if (timeout) { clearTimeout(timeout); } resolve(type); } const eventHandler = handler.bind(null, WaitOnType.EVENT); if (target instanceof EventBus) { target._on(name, eventHandler); } else { target.addEventListener(name, eventHandler); } const timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT); const timeout = setTimeout(timeoutHandler, delay); }); } const animationStarted = new Promise(function (resolve) { window.requestAnimationFrame(resolve); }); exports.animationStarted = animationStarted; function dispatchDOMEvent(eventName, args = null) { throw new Error("Not implemented: dispatchDOMEvent"); } class EventBus { constructor(options) { this._listeners = Object.create(null); } on(eventName, listener) { this._on(eventName, listener, { external: true }); } off(eventName, listener) { this._off(eventName, listener, { external: true }); } dispatch(eventName) { const eventListeners = this._listeners[eventName]; if (!eventListeners || eventListeners.length === 0) { return; } const args = Array.prototype.slice.call(arguments, 1); let externalListeners; eventListeners.slice(0).forEach(function ({ listener, external }) { if (external) { if (!externalListeners) { externalListeners = []; } externalListeners.push(listener); return; } listener.apply(null, args); }); if (externalListeners) { externalListeners.forEach(function (listener) { listener.apply(null, args); }); externalListeners = null; } } _on(eventName, listener, options = null) { let eventListeners = this._listeners[eventName]; if (!eventListeners) { this._listeners[eventName] = eventListeners = []; } eventListeners.push({ listener, external: (options && options.external) === true }); } _off(eventName, listener, options = null) { const eventListeners = this._listeners[eventName]; if (!eventListeners) { return; } for (let i = 0, ii = eventListeners.length; i < ii; i++) { if (eventListeners[i].listener === listener) { eventListeners.splice(i, 1); return; } } } } exports.EventBus = EventBus; function clamp(v, min, max) { return Math.min(Math.max(v, min), max); } class ProgressBar { constructor(id, { height, width, units } = {}) { this.visible = true; this.div = document.querySelector(id + " .progress"); this.bar = this.div.parentNode; this.height = height || 100; this.width = width || 100; this.units = units || "%"; this.div.style.height = this.height + this.units; this.percent = 0; } _updateBar() { if (this._indeterminate) { this.div.classList.add("indeterminate"); this.div.style.width = this.width + this.units; return; } this.div.classList.remove("indeterminate"); const progressSize = this.width * this._percent / 100; this.div.style.width = progressSize + this.units; } get percent() { return this._percent; } set percent(val) { this._indeterminate = isNaN(val); this._percent = clamp(val, 0, 100); this._updateBar(); } setWidth(viewer) { if (!viewer) { return; } const container = viewer.parentNode; const scrollbarWidth = container.offsetWidth - viewer.offsetWidth; if (scrollbarWidth > 0) { this.bar.style.width = `calc(100% - ${scrollbarWidth}px)`; } } hide() { if (!this.visible) { return; } this.visible = false; this.bar.classList.add("hidden"); document.body.classList.remove("loadingInProgress"); } show() { if (this.visible) { return; } this.visible = true; document.body.classList.add("loadingInProgress"); this.bar.classList.remove("hidden"); } } exports.ProgressBar = ProgressBar; function moveToEndOfArray(arr, condition) { const moved = [], len = arr.length; let write = 0; for (let read = 0; read < len; ++read) { if (condition(arr[read])) { moved.push(arr[read]); } else { arr[write] = arr[read]; ++write; } } for (let read = 0; write < len; ++read, ++write) { arr[write] = moved[read]; } }
/***/ }),
/* 4 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.SimpleLinkService = exports.PDFLinkService = void 0; var _ui_utils = __w_pdfjs_require__(3); class PDFLinkService { constructor({ eventBus, externalLinkTarget = null, externalLinkRel = null, externalLinkEnabled = true, ignoreDestinationZoom = false } = {}) { this.eventBus = eventBus; this.externalLinkTarget = externalLinkTarget; this.externalLinkRel = externalLinkRel; this.externalLinkEnabled = externalLinkEnabled; this._ignoreDestinationZoom = ignoreDestinationZoom; this.baseUrl = null; this.pdfDocument = null; this.pdfViewer = null; this.pdfHistory = null; this._pagesRefCache = null; } setDocument(pdfDocument, baseUrl = null) { this.baseUrl = baseUrl; this.pdfDocument = pdfDocument; this._pagesRefCache = Object.create(null); } setViewer(pdfViewer) { this.pdfViewer = pdfViewer; } setHistory(pdfHistory) { this.pdfHistory = pdfHistory; } get pagesCount() { return this.pdfDocument ? this.pdfDocument.numPages : 0; } get page() { return this.pdfViewer.currentPageNumber; } set page(value) { this.pdfViewer.currentPageNumber = value; } get rotation() { return this.pdfViewer.pagesRotation; } set rotation(value) { this.pdfViewer.pagesRotation = value; } navigateTo(dest) { const goToDestination = ({ namedDest, explicitDest }) => { const destRef = explicitDest[0]; let pageNumber; if (destRef instanceof Object) { pageNumber = this._cachedPageNumber(destRef); if (pageNumber === null) { this.pdfDocument.getPageIndex(destRef).then(pageIndex => { this.cachePageRef(pageIndex + 1, destRef); goToDestination({ namedDest, explicitDest }); }).catch(() => { console.error(`PDFLinkService.navigateTo: "${destRef}" is not ` + `a valid page reference, for dest="${dest}".`); }); return; } } else if (Number.isInteger(destRef)) { pageNumber = destRef + 1; } else { console.error(`PDFLinkService.navigateTo: "${destRef}" is not ` + `a valid destination reference, for dest="${dest}".`); return; } if (!pageNumber || pageNumber < 1 || pageNumber > this.pagesCount) { console.error(`PDFLinkService.navigateTo: "${pageNumber}" is not ` + `a valid page number, for dest="${dest}".`); return; } if (this.pdfHistory) { this.pdfHistory.pushCurrentPosition(); this.pdfHistory.push({ namedDest, explicitDest, pageNumber }); } this.pdfViewer.scrollPageIntoView({ pageNumber, destArray: explicitDest, ignoreDestinationZoom: this._ignoreDestinationZoom }); }; new Promise((resolve, reject) => { if (typeof dest === "string") { this.pdfDocument.getDestination(dest).then(destArray => { resolve({ namedDest: dest, explicitDest: destArray }); }); return; } resolve({ namedDest: "", explicitDest: dest }); }).then(data => { if (!Array.isArray(data.explicitDest)) { console.error(`PDFLinkService.navigateTo: "${data.explicitDest}" is` + ` not a valid destination array, for dest="${dest}".`); return; } goToDestination(data); }); } getDestinationHash(dest) { if (typeof dest === "string") { return this.getAnchorUrl("#" + escape(dest)); } if (Array.isArray(dest)) { const str = JSON.stringify(dest); return this.getAnchorUrl("#" + escape(str)); } return this.getAnchorUrl(""); } getAnchorUrl(anchor) { return (this.baseUrl || "") + anchor; } setHash(hash) { let pageNumber, dest; if (hash.includes("=")) { const params = (0, _ui_utils.parseQueryString)(hash); if ("search" in params) { this.eventBus.dispatch("findfromurlhash", { source: this, query: params.search.replace(/"/g, ""), phraseSearch: params.phrase === "true" }); } if ("page" in params) { pageNumber = params.page | 0 || 1; } if ("zoom" in params) { const zoomArgs = params.zoom.split(","); const zoomArg = zoomArgs[0]; const zoomArgNumber = parseFloat(zoomArg); if (!zoomArg.includes("Fit")) { dest = [null, { name: "XYZ" }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg]; } else { if (zoomArg === "Fit" || zoomArg === "FitB") { dest = [null, { name: zoomArg }]; } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") { dest = [null, { name: zoomArg }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null]; } else if (zoomArg === "FitR") { if (zoomArgs.length !== 5) { console.error('PDFLinkService.setHash: Not enough parameters for "FitR".'); } else { dest = [null, { name: zoomArg }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0]; } } else { console.error(`PDFLinkService.setHash: "${zoomArg}" is not ` + "a valid zoom value."); } } } if (dest) { this.pdfViewer.scrollPageIntoView({ pageNumber: pageNumber || this.page, destArray: dest, allowNegativeOffset: true }); } else if (pageNumber) { this.page = pageNumber; } if ("pagemode" in params) { this.eventBus.dispatch("pagemode", { source: this, mode: params.pagemode }); } if ("nameddest" in params) { this.navigateTo(params.nameddest); } } else { dest = unescape(hash); try { dest = JSON.parse(dest); if (!Array.isArray(dest)) { dest = dest.toString(); } } catch (ex) {} if (typeof dest === "string" || isValidExplicitDestination(dest)) { this.navigateTo(dest); return; } console.error(`PDFLinkService.setHash: "${unescape(hash)}" is not ` + "a valid destination."); } } executeNamedAction(action) { switch (action) { case "GoBack": if (this.pdfHistory) { this.pdfHistory.back(); } break; case "GoForward": if (this.pdfHistory) { this.pdfHistory.forward(); } break; case "NextPage": if (this.page < this.pagesCount) { this.page++; } break; case "PrevPage": if (this.page > 1) { this.page--; } break; case "LastPage": this.page = this.pagesCount; break; case "FirstPage": this.page = 1; break; default: break; } this.eventBus.dispatch("namedaction", { source: this, action }); } cachePageRef(pageNum, pageRef) { if (!pageRef) { return; } const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`; this._pagesRefCache[refStr] = pageNum; } _cachedPageNumber(pageRef) { const refStr = pageRef.gen === 0 ? `${pageRef.num}R` : `${pageRef.num}R${pageRef.gen}`; return this._pagesRefCache && this._pagesRefCache[refStr] || null; } isPageVisible(pageNumber) { return this.pdfViewer.isPageVisible(pageNumber); } } exports.PDFLinkService = PDFLinkService; function isValidExplicitDestination(dest) { if (!Array.isArray(dest)) { return false; } const destLength = dest.length; if (destLength < 2) { return false; } const page = dest[0]; if (!(typeof page === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) { return false; } const zoom = dest[1]; if (!(typeof zoom === "object" && typeof zoom.name === "string")) { return false; } let allowNull = true; switch (zoom.name) { case "XYZ": if (destLength !== 5) { return false; } break; case "Fit": case "FitB": return destLength === 2; case "FitH": case "FitBH": case "FitV": case "FitBV": if (destLength !== 3) { return false; } break; case "FitR": if (destLength !== 6) { return false; } allowNull = false; break; default: return false; } for (let i = 2; i < destLength; i++) { const param = dest[i]; if (!(typeof param === "number" || allowNull && param === null)) { return false; } } return true; } class SimpleLinkService { constructor() { this.externalLinkTarget = null; this.externalLinkRel = null; this.externalLinkEnabled = true; this._ignoreDestinationZoom = false; } get pagesCount() { return 0; } get page() { return 0; } set page(value) {} get rotation() { return 0; } set rotation(value) {} navigateTo(dest) {} getDestinationHash(dest) { return "#"; } getAnchorUrl(hash) { return "#"; } setHash(hash) {} executeNamedAction(action) {} cachePageRef(pageNum, pageRef) {} isPageVisible(pageNumber) { return true; } } exports.SimpleLinkService = SimpleLinkService;
/***/ }),
/* 5 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.DefaultTextLayerFactory = exports.TextLayerBuilder = void 0; var _pdfjsLib = __w_pdfjs_require__(2); const EXPAND_DIVS_TIMEOUT = 300; class TextLayerBuilder { constructor({ textLayerDiv, eventBus, pageIndex, viewport, findController = null, enhanceTextSelection = false }) { this.textLayerDiv = textLayerDiv; this.eventBus = eventBus; this.textContent = null; this.textContentItemsStr = []; this.textContentStream = null; this.renderingDone = false; this.pageIdx = pageIndex; this.pageNumber = this.pageIdx + 1; this.matches = []; this.viewport = viewport; this.textDivs = []; this.findController = findController; this.textLayerRenderTask = null; this.enhanceTextSelection = enhanceTextSelection; this._onUpdateTextLayerMatches = null; this._bindMouse(); } _finishRendering() { this.renderingDone = true; if (!this.enhanceTextSelection) { const endOfContent = document.createElement("div"); endOfContent.className = "endOfContent"; this.textLayerDiv.appendChild(endOfContent); } this.eventBus.dispatch("textlayerrendered", { source: this, pageNumber: this.pageNumber, numTextDivs: this.textDivs.length }); } render(timeout = 0) { if (!(this.textContent || this.textContentStream) || this.renderingDone) { return; } this.cancel(); this.textDivs = []; const textLayerFrag = document.createDocumentFragment(); this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({ textContent: this.textContent, textContentStream: this.textContentStream, container: textLayerFrag, viewport: this.viewport, textDivs: this.textDivs, textContentItemsStr: this.textContentItemsStr, timeout, enhanceTextSelection: this.enhanceTextSelection }); this.textLayerRenderTask.promise.then(() => { this.textLayerDiv.appendChild(textLayerFrag); this._finishRendering(); this._updateMatches(); }, function (reason) {}); if (!this._onUpdateTextLayerMatches) { this._onUpdateTextLayerMatches = evt => { if (evt.pageIndex === this.pageIdx || evt.pageIndex === -1) { this._updateMatches(); } }; this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches); } } cancel() { if (this.textLayerRenderTask) { this.textLayerRenderTask.cancel(); this.textLayerRenderTask = null; } if (this._onUpdateTextLayerMatches) { this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches); this._onUpdateTextLayerMatches = null; } } setTextContentStream(readableStream) { this.cancel(); this.textContentStream = readableStream; } setTextContent(textContent) { this.cancel(); this.textContent = textContent; } _convertMatches(matches, matchesLength) { if (!matches) { return []; } const { findController, textContentItemsStr } = this; let i = 0, iIndex = 0; const end = textContentItemsStr.length - 1; const queryLen = findController.state.query.length; const result = []; for (let m = 0, mm = matches.length; m < mm; m++) { let matchIdx = matches[m]; while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) { iIndex += textContentItemsStr[i].length; i++; } if (i === textContentItemsStr.length) { console.error("Could not find a matching mapping"); } const match = { begin: { divIdx: i, offset: matchIdx - iIndex } }; if (matchesLength) { matchIdx += matchesLength[m]; } else { matchIdx += queryLen; } while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) { iIndex += textContentItemsStr[i].length; i++; } match.end = { divIdx: i, offset: matchIdx - iIndex }; result.push(match); } return result; } _renderMatches(matches) { if (matches.length === 0) { return; } const { findController, pageIdx, textContentItemsStr, textDivs } = this; const isSelectedPage = pageIdx === findController.selected.pageIdx; const selectedMatchIdx = findController.selected.matchIdx; const highlightAll = findController.state.highlightAll; let prevEnd = null; const infinity = { divIdx: -1, offset: undefined }; function beginText(begin, className) { const divIdx = begin.divIdx; textDivs[divIdx].textContent = ""; appendTextToDiv(divIdx, 0, begin.offset, className); } function appendTextToDiv(divIdx, fromOffset, toOffset, className) { const div = textDivs[divIdx]; const content = textContentItemsStr[divIdx].substring(fromOffset, toOffset); const node = document.createTextNode(content); if (className) { const span = document.createElement("span"); span.className = className; span.appendChild(node); div.appendChild(span); return; } div.appendChild(node); } let i0 = selectedMatchIdx, i1 = i0 + 1; if (highlightAll) { i0 = 0; i1 = matches.length; } else if (!isSelectedPage) { return; } for (let i = i0; i < i1; i++) { const match = matches[i]; const begin = match.begin; const end = match.end; const isSelected = isSelectedPage && i === selectedMatchIdx; const highlightSuffix = isSelected ? " selected" : ""; if (isSelected) { findController.scrollMatchIntoView({ element: textDivs[begin.divIdx], pageIndex: pageIdx, matchIndex: selectedMatchIdx }); } if (!prevEnd || begin.divIdx !== prevEnd.divIdx) { if (prevEnd !== null) { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset); } beginText(begin); } else { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset); } if (begin.divIdx === end.divIdx) { appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix); } else { appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix); for (let n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) { textDivs[n0].className = "highlight middle" + highlightSuffix; } beginText(end, "highlight end" + highlightSuffix); } prevEnd = end; } if (prevEnd) { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset); } } _updateMatches() { if (!this.renderingDone) { return; } const { findController, matches, pageIdx, textContentItemsStr, textDivs } = this; let clearedUntilDivIdx = -1; for (let i = 0, ii = matches.length; i < ii; i++) { const match = matches[i]; const begin = Math.max(clearedUntilDivIdx, match.begin.divIdx); for (let n = begin, end = match.end.divIdx; n <= end; n++) { const div = textDivs[n]; div.textContent = textContentItemsStr[n]; div.className = ""; } clearedUntilDivIdx = match.end.divIdx + 1; } if (!findController || !findController.highlightMatches) { return; } const pageMatches = findController.pageMatches[pageIdx] || null; const pageMatchesLength = findController.pageMatchesLength[pageIdx] || null; this.matches = this._convertMatches(pageMatches, pageMatchesLength); this._renderMatches(this.matches); } _bindMouse() { const div = this.textLayerDiv; let expandDivsTimer = null; div.addEventListener("mousedown", evt => { if (this.enhanceTextSelection && this.textLayerRenderTask) { this.textLayerRenderTask.expandTextDivs(true); if (expandDivsTimer) { clearTimeout(expandDivsTimer); expandDivsTimer = null; } return; } const end = div.querySelector(".endOfContent"); if (!end) { return; } let adjustTop = evt.target !== div; adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none"; if (adjustTop) { const divBounds = div.getBoundingClientRect(); const r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height); end.style.top = (r * 100).toFixed(2) + "%"; } end.classList.add("active"); }); div.addEventListener("mouseup", () => { if (this.enhanceTextSelection && this.textLayerRenderTask) { expandDivsTimer = setTimeout(() => { if (this.textLayerRenderTask) { this.textLayerRenderTask.expandTextDivs(false); } expandDivsTimer = null; }, EXPAND_DIVS_TIMEOUT); return; } const end = div.querySelector(".endOfContent"); if (!end) { return; } end.style.top = ""; end.classList.remove("active"); }); } } exports.TextLayerBuilder = TextLayerBuilder; class DefaultTextLayerFactory { createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus) { return new TextLayerBuilder({ textLayerDiv, pageIndex, viewport, enhanceTextSelection, eventBus }); } } exports.DefaultTextLayerFactory = DefaultTextLayerFactory;
/***/ }),
/* 6 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.DownloadManager = void 0; var _pdfjsLib = __w_pdfjs_require__(2); var _viewer_compatibility = __w_pdfjs_require__(7); ; function download(blobUrl, filename) { const a = document.createElement("a"); if (!a.click) { throw new Error('DownloadManager: "a.click()" is not supported.'); } a.href = blobUrl; a.target = "_parent"; if ("download" in a) { a.download = filename; } (document.body || document.documentElement).appendChild(a); a.click(); a.remove(); } class DownloadManager { downloadUrl(url, filename) {
if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
return; } download(url + "#pdfjs.action=download", filename); } downloadData(data, filename, contentType) { if (navigator.msSaveBlob) { navigator.msSaveBlob(new Blob([data], { type: contentType }), filename); return; } const blobUrl = (0, _pdfjsLib.createObjectURL)(data, contentType, _viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL); download(blobUrl, filename); } download(blob, url, filename, sourceEventType = "download") { if (navigator.msSaveBlob) { if (!navigator.msSaveBlob(blob, filename)) { this.downloadUrl(url, filename); } return; } if (_viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL) { this.downloadUrl(url, filename); return; } const blobUrl = URL.createObjectURL(blob); download(blobUrl, filename); } } exports.DownloadManager = DownloadManager;
/***/ }),
/* 7 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.viewerCompatibilityParams = void 0; const compatibilityParams = Object.create(null); { const userAgent = typeof navigator !== "undefined" && navigator.userAgent || ""; const platform = typeof navigator !== "undefined" && navigator.platform || ""; const maxTouchPoints = typeof navigator !== "undefined" && navigator.maxTouchPoints || 1; const isAndroid = /Android/.test(userAgent); const isIE = /Trident/.test(userAgent); const isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1; const isIOSChrome = /CriOS/.test(userAgent); (function checkOnBlobSupport() { if (isIE || isIOSChrome) { compatibilityParams.disableCreateObjectURL = true; } })(); (function checkCanvasSizeLimitation() { if (isIOS || isAndroid) { compatibilityParams.maxCanvasPixels = 5242880; } })(); } const viewerCompatibilityParams = Object.freeze(compatibilityParams); exports.viewerCompatibilityParams = viewerCompatibilityParams;
/***/ }),
/* 8 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.GenericL10n = void 0; __w_pdfjs_require__(9); const webL10n = document.webL10n; class GenericL10n { constructor(lang) { this._lang = lang; this._ready = new Promise((resolve, reject) => { webL10n.setLanguage(lang, () => { resolve(webL10n); }); }); } async getLanguage() { const l10n = await this._ready; return l10n.getLanguage(); } async getDirection() { const l10n = await this._ready; return l10n.getDirection(); } async get(property, args, fallback) { const l10n = await this._ready; return l10n.get(property, args, fallback); } async translate(element) { const l10n = await this._ready; return l10n.translate(element); } } exports.GenericL10n = GenericL10n;
/***/ }),
/* 9 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; document.webL10n = function (window, document, undefined) { var gL10nData = {}; var gTextData = ''; var gTextProp = 'textContent'; var gLanguage = ''; var gMacros = {}; var gReadyState = 'loading'; var gAsyncResourceLoading = true; function getL10nResourceLinks() { return document.querySelectorAll('link[type="application/l10n"]'); } function getL10nDictionary() { var script = document.querySelector('script[type="application/l10n"]'); return script ? JSON.parse(script.innerHTML) : null; } function getTranslatableChildren(element) { return element ? element.querySelectorAll('*[data-l10n-id]') : []; } function getL10nAttributes(element) { if (!element) return {}; var l10nId = element.getAttribute('data-l10n-id'); var l10nArgs = element.getAttribute('data-l10n-args'); var args = {}; if (l10nArgs) { try { args = JSON.parse(l10nArgs); } catch (e) { console.warn('could not parse arguments for #' + l10nId); } } return { id: l10nId, args: args }; } function xhrLoadText(url, onSuccess, onFailure) { onSuccess = onSuccess || function _onSuccess(data) {}; onFailure = onFailure || function _onFailure() {}; var xhr = new XMLHttpRequest(); xhr.open('GET', url, gAsyncResourceLoading); if (xhr.overrideMimeType) { xhr.overrideMimeType('text/plain; charset=utf-8'); } xhr.onreadystatechange = function () { if (xhr.readyState == 4) { if (xhr.status == 200 || xhr.status === 0) { onSuccess(xhr.responseText); } else { onFailure(); } } }; xhr.onerror = onFailure; xhr.ontimeout = onFailure; try { xhr.send(null); } catch (e) { onFailure(); } } function parseResource(href, lang, successCallback, failureCallback) { var baseURL = href.replace(/[^\/]*$/, '') || './'; function evalString(text) { if (text.lastIndexOf('\\') < 0) return text;
return text.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\b/g, '\b').replace(/\\f/g, '\f').replace(/\\{/g, '{').replace(/\\}/g, '}').replace(/\\"/g, '"').replace(/\\'/g, "'");
} function parseProperties(text, parsedPropertiesCallback) { var dictionary = {}; var reBlank = /^\s*|\s*$/; var reComment = /^\s*#|^\s*$/; var reSection = /^\s*\[(.*)\]\s*$/; var reImport = /^\s*@import\s+url\((.*)\)\s*$/i; var reSplit = /^([^=\s]*)\s*=\s*(.+)$/; function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) { var entries = rawText.replace(reBlank, '').split(/[\r\n]+/); var currentLang = '*'; var genericLang = lang.split('-', 1)[0]; var skipLang = false; var match = ''; function nextEntry() { while (true) { if (!entries.length) { parsedRawLinesCallback(); return; } var line = entries.shift(); if (reComment.test(line)) continue; if (extendedSyntax) { match = reSection.exec(line); if (match) { currentLang = match[1].toLowerCase(); skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang; continue; } else if (skipLang) { continue; } match = reImport.exec(line); if (match) { loadImport(baseURL + match[1], nextEntry); return; } } var tmp = line.match(reSplit); if (tmp && tmp.length == 3) { dictionary[tmp[1]] = evalString(tmp[2]); } } } nextEntry(); } function loadImport(url, callback) { xhrLoadText(url, function (content) { parseRawLines(content, false, callback); }, function () { console.warn(url + ' not found.'); callback(); }); } parseRawLines(text, true, function () { parsedPropertiesCallback(dictionary); }); } xhrLoadText(href, function (response) { gTextData += response; parseProperties(response, function (data) { for (var key in data) { var id, prop, index = key.lastIndexOf('.'); if (index > 0) { id = key.substring(0, index); prop = key.substring(index + 1); } else { id = key; prop = gTextProp; } if (!gL10nData[id]) { gL10nData[id] = {}; } gL10nData[id][prop] = data[key]; } if (successCallback) { successCallback(); } }); }, failureCallback); } function loadLocale(lang, callback) { if (lang) { lang = lang.toLowerCase(); } callback = callback || function _callback() {}; clear(); gLanguage = lang; var langLinks = getL10nResourceLinks(); var langCount = langLinks.length; if (langCount === 0) { var dict = getL10nDictionary(); if (dict && dict.locales && dict.default_locale) { console.log('using the embedded JSON directory, early way out'); gL10nData = dict.locales[lang]; if (!gL10nData) { var defaultLocale = dict.default_locale.toLowerCase(); for (var anyCaseLang in dict.locales) { anyCaseLang = anyCaseLang.toLowerCase(); if (anyCaseLang === lang) { gL10nData = dict.locales[lang]; break; } else if (anyCaseLang === defaultLocale) { gL10nData = dict.locales[defaultLocale]; } } } callback(); } else { console.log('no resource to load, early way out'); } gReadyState = 'complete'; return; } var onResourceLoaded = null; var gResourceCount = 0; onResourceLoaded = function () { gResourceCount++; if (gResourceCount >= langCount) { callback(); gReadyState = 'complete'; } }; function L10nResourceLink(link) { var href = link.href; this.load = function (lang, callback) { parseResource(href, lang, callback, function () { console.warn(href + ' not found.'); console.warn('"' + lang + '" resource not found'); gLanguage = ''; callback(); }); }; } for (var i = 0; i < langCount; i++) { var resource = new L10nResourceLink(langLinks[i]); resource.load(lang, onResourceLoaded); } } function clear() { gL10nData = {}; gTextData = ''; gLanguage = ''; } function getPluralRules(lang) { var locales2rules = { 'af': 3, 'ak': 4, 'am': 4, 'ar': 1, 'asa': 3, 'az': 0, 'be': 11, 'bem': 3, 'bez': 3, 'bg': 3, 'bh': 4, 'bm': 0, 'bn': 3, 'bo': 0, 'br': 20, 'brx': 3, 'bs': 11, 'ca': 3, 'cgg': 3, 'chr': 3, 'cs': 12, 'cy': 17, 'da': 3, 'de': 3, 'dv': 3, 'dz': 0, 'ee': 3, 'el': 3, 'en': 3, 'eo': 3, 'es': 3, 'et': 3, 'eu': 3, 'fa': 0, 'ff': 5, 'fi': 3, 'fil': 4, 'fo': 3, 'fr': 5, 'fur': 3, 'fy': 3, 'ga': 8, 'gd': 24, 'gl': 3, 'gsw': 3, 'gu': 3, 'guw': 4, 'gv': 23, 'ha': 3, 'haw': 3, 'he': 2, 'hi': 4, 'hr': 11, 'hu': 0, 'id': 0, 'ig': 0, 'ii': 0, 'is': 3, 'it': 3, 'iu': 7, 'ja': 0, 'jmc': 3, 'jv': 0, 'ka': 0, 'kab': 5, 'kaj': 3, 'kcg': 3, 'kde': 0, 'kea': 0, 'kk': 3, 'kl': 3, 'km': 0, 'kn': 0, 'ko': 0, 'ksb': 3, 'ksh': 21, 'ku': 3, 'kw': 7, 'lag': 18, 'lb': 3, 'lg': 3, 'ln': 4, 'lo': 0, 'lt': 10, 'lv': 6, 'mas': 3, 'mg': 4, 'mk': 16, 'ml': 3, 'mn': 3, 'mo': 9, 'mr': 3, 'ms': 0, 'mt': 15, 'my': 0, 'nah': 3, 'naq': 7, 'nb': 3, 'nd': 3, 'ne': 3, 'nl': 3, 'nn': 3, 'no': 3, 'nr': 3, 'nso': 4, 'ny': 3, 'nyn': 3, 'om': 3, 'or': 3, 'pa': 3, 'pap': 3, 'pl': 13, 'ps': 3, 'pt': 3, 'rm': 3, 'ro': 9, 'rof': 3, 'ru': 11, 'rwk': 3, 'sah': 0, 'saq': 3, 'se': 7, 'seh': 3, 'ses': 0, 'sg': 0, 'sh': 11, 'shi': 19, 'sk': 12, 'sl': 14, 'sma': 7, 'smi': 7, 'smj': 7, 'smn': 7, 'sms': 7, 'sn': 3, 'so': 3, 'sq': 3, 'sr': 11, 'ss': 3, 'ssy': 3, 'st': 3, 'sv': 3, 'sw': 3, 'syr': 3, 'ta': 3, 'te': 3, 'teo': 3, 'th': 0, 'ti': 4, 'tig': 3, 'tk': 3, 'tl': 4, 'tn': 3, 'to': 0, 'tr': 0, 'ts': 3, 'tzm': 22, 'uk': 11, 'ur': 3, 've': 3, 'vi': 0, 'vun': 3, 'wa': 4, 'wae': 3, 'wo': 0, 'xh': 3, 'xog': 3, 'yo': 0, 'zh': 0, 'zu': 3 }; function isIn(n, list) { return list.indexOf(n) !== -1; } function isBetween(n, start, end) { return start <= n && n <= end; } var pluralRules = { '0': function (n) { return 'other'; }, '1': function (n) { if (isBetween(n % 100, 3, 10)) return 'few'; if (n === 0) return 'zero'; if (isBetween(n % 100, 11, 99)) return 'many'; if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '2': function (n) { if (n !== 0 && n % 10 === 0) return 'many'; if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '3': function (n) { if (n == 1) return 'one'; return 'other'; }, '4': function (n) { if (isBetween(n, 0, 1)) return 'one'; return 'other'; }, '5': function (n) { if (isBetween(n, 0, 2) && n != 2) return 'one'; return 'other'; }, '6': function (n) { if (n === 0) return 'zero'; if (n % 10 == 1 && n % 100 != 11) return 'one'; return 'other'; }, '7': function (n) { if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '8': function (n) { if (isBetween(n, 3, 6)) return 'few'; if (isBetween(n, 7, 10)) return 'many'; if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '9': function (n) { if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few'; if (n == 1) return 'one'; return 'other'; }, '10': function (n) { if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few'; if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one'; return 'other'; }, '11': function (n) { if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few'; if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many'; if (n % 10 == 1 && n % 100 != 11) return 'one'; return 'other'; }, '12': function (n) { if (isBetween(n, 2, 4)) return 'few'; if (n == 1) return 'one'; return 'other'; }, '13': function (n) { if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few'; if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many'; if (n == 1) return 'one'; return 'other'; }, '14': function (n) { if (isBetween(n % 100, 3, 4)) return 'few'; if (n % 100 == 2) return 'two'; if (n % 100 == 1) return 'one'; return 'other'; }, '15': function (n) { if (n === 0 || isBetween(n % 100, 2, 10)) return 'few'; if (isBetween(n % 100, 11, 19)) return 'many'; if (n == 1) return 'one'; return 'other'; }, '16': function (n) { if (n % 10 == 1 && n != 11) return 'one'; return 'other'; }, '17': function (n) { if (n == 3) return 'few'; if (n === 0) return 'zero'; if (n == 6) return 'many'; if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '18': function (n) { if (n === 0) return 'zero'; if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one'; return 'other'; }, '19': function (n) { if (isBetween(n, 2, 10)) return 'few'; if (isBetween(n, 0, 1)) return 'one'; return 'other'; }, '20': function (n) { if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few'; if (n % 1000000 === 0 && n !== 0) return 'many'; if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two'; if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one'; return 'other'; }, '21': function (n) { if (n === 0) return 'zero'; if (n == 1) return 'one'; return 'other'; }, '22': function (n) { if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one'; return 'other'; }, '23': function (n) { if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one'; return 'other'; }, '24': function (n) { if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few'; if (isIn(n, [2, 12])) return 'two'; if (isIn(n, [1, 11])) return 'one'; return 'other'; } }; var index = locales2rules[lang.replace(/-.*$/, '')]; if (!(index in pluralRules)) { console.warn('plural form unknown for [' + lang + ']'); return function () { return 'other'; }; } return pluralRules[index]; } gMacros.plural = function (str, param, key, prop) { var n = parseFloat(param); if (isNaN(n)) return str; if (prop != gTextProp) return str; if (!gMacros._pluralRules) { gMacros._pluralRules = getPluralRules(gLanguage); } var index = '[' + gMacros._pluralRules(n) + ']'; if (n === 0 && key + '[zero]' in gL10nData) { str = gL10nData[key + '[zero]'][prop]; } else if (n == 1 && key + '[one]' in gL10nData) { str = gL10nData[key + '[one]'][prop]; } else if (n == 2 && key + '[two]' in gL10nData) { str = gL10nData[key + '[two]'][prop]; } else if (key + index in gL10nData) { str = gL10nData[key + index][prop]; } else if (key + '[other]' in gL10nData) { str = gL10nData[key + '[other]'][prop]; } return str; }; function getL10nData(key, args, fallback) { var data = gL10nData[key]; if (!data) { console.warn('#' + key + ' is undefined.'); if (!fallback) { return null; } data = fallback; } var rv = {}; for (var prop in data) { var str = data[prop]; str = substIndexes(str, args, key, prop); str = substArguments(str, args, key); rv[prop] = str; } return rv; } function substIndexes(str, args, key, prop) { var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/; var reMatch = reIndex.exec(str); if (!reMatch || !reMatch.length) return str; var macroName = reMatch[1]; var paramName = reMatch[2]; var param; if (args && paramName in args) { param = args[paramName]; } else if (paramName in gL10nData) { param = gL10nData[paramName]; } if (macroName in gMacros) { var macro = gMacros[macroName]; str = macro(str, param, key, prop); } return str; } function substArguments(str, args, key) { var reArgs = /\{\{\s*(.+?)\s*\}\}/g; return str.replace(reArgs, function (matched_text, arg) { if (args && arg in args) { return args[arg]; } if (arg in gL10nData) { return gL10nData[arg]; } console.log('argument {{' + arg + '}} for #' + key + ' is undefined.'); return matched_text; }); } function translateElement(element) { var l10n = getL10nAttributes(element); if (!l10n.id) return; var data = getL10nData(l10n.id, l10n.args); if (!data) { console.warn('#' + l10n.id + ' is undefined.'); return; } if (data[gTextProp]) { if (getChildElementCount(element) === 0) { element[gTextProp] = data[gTextProp]; } else { var children = element.childNodes; var found = false; for (var i = 0, l = children.length; i < l; i++) { if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) { if (found) { children[i].nodeValue = ''; } else { children[i].nodeValue = data[gTextProp]; found = true; } } } if (!found) { var textNode = document.createTextNode(data[gTextProp]); element.insertBefore(textNode, element.firstChild); } } delete data[gTextProp]; } for (var k in data) { element[k] = data[k]; } } function getChildElementCount(element) { if (element.children) { return element.children.length; } if (typeof element.childElementCount !== 'undefined') { return element.childElementCount; } var count = 0; for (var i = 0; i < element.childNodes.length; i++) { count += element.nodeType === 1 ? 1 : 0; } return count; } function translateFragment(element) { element = element || document.documentElement; var children = getTranslatableChildren(element); var elementCount = children.length; for (var i = 0; i < elementCount; i++) { translateElement(children[i]); } translateElement(element); } return { get: function (key, args, fallbackString) { var index = key.lastIndexOf('.'); var prop = gTextProp; if (index > 0) { prop = key.substring(index + 1); key = key.substring(0, index); } var fallback; if (fallbackString) { fallback = {}; fallback[prop] = fallbackString; } var data = getL10nData(key, args, fallback); if (data && prop in data) { return data[prop]; } return '{{' + key + '}}'; }, getData: function () { return gL10nData; }, getText: function () { return gTextData; }, getLanguage: function () { return gLanguage; }, setLanguage: function (lang, callback) { loadLocale(lang, function () { if (callback) callback(); }); }, getDirection: function () { var rtlList = ['ar', 'he', 'fa', 'ps', 'ur']; var shortCode = gLanguage.split('-', 1)[0]; return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr'; }, translate: translateFragment, getReadyState: function () { return gReadyState; }, ready: function (callback) { if (!callback) { return; } else if (gReadyState == 'complete' || gReadyState == 'interactive') { window.setTimeout(function () { callback(); }); } else if (document.addEventListener) { document.addEventListener('localized', function once() { document.removeEventListener('localized', once); callback(); }); } } }; }(window, document);
/***/ }),
/* 10 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFFindController = exports.FindState = void 0; var _pdfjsLib = __w_pdfjs_require__(2); var _pdf_find_utils = __w_pdfjs_require__(11); var _ui_utils = __w_pdfjs_require__(3); const FindState = { FOUND: 0, NOT_FOUND: 1, WRAPPED: 2, PENDING: 3 }; exports.FindState = FindState; const FIND_TIMEOUT = 250; const MATCH_SCROLL_OFFSET_TOP = -50; const MATCH_SCROLL_OFFSET_LEFT = -400; const CHARACTERS_TO_NORMALIZE = { "\u2018": "'", "\u2019": "'", "\u201A": "'", "\u201B": "'", "\u201C": '"', "\u201D": '"', "\u201E": '"', "\u201F": '"', "\u00BC": "1/4", "\u00BD": "1/2", "\u00BE": "3/4" }; let normalizationRegex = null; function normalize(text) { if (!normalizationRegex) { const replace = Object.keys(CHARACTERS_TO_NORMALIZE).join(""); normalizationRegex = new RegExp(`[${replace}]`, "g"); } return text.replace(normalizationRegex, function (ch) { return CHARACTERS_TO_NORMALIZE[ch]; }); } class PDFFindController { constructor({ linkService, eventBus }) { this._linkService = linkService; this._eventBus = eventBus; this._reset(); eventBus._on("findbarclose", this._onFindBarClose.bind(this)); } get highlightMatches() { return this._highlightMatches; } get pageMatches() { return this._pageMatches; } get pageMatchesLength() { return this._pageMatchesLength; } get selected() { return this._selected; } get state() { return this._state; } setDocument(pdfDocument) { if (this._pdfDocument) { this._reset(); } if (!pdfDocument) { return; } this._pdfDocument = pdfDocument; this._firstPageCapability.resolve(); } executeCommand(cmd, state) { if (!state) { return; } const pdfDocument = this._pdfDocument; if (this._state === null || this._shouldDirtyMatch(cmd, state)) { this._dirtyMatch = true; } this._state = state; if (cmd !== "findhighlightallchange") { this._updateUIState(FindState.PENDING); } this._firstPageCapability.promise.then(() => { if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) { return; } this._extractText(); const findbarClosed = !this._highlightMatches; const pendingTimeout = !!this._findTimeout; if (this._findTimeout) { clearTimeout(this._findTimeout); this._findTimeout = null; } if (cmd === "find") { this._findTimeout = setTimeout(() => { this._nextMatch(); this._findTimeout = null; }, FIND_TIMEOUT); } else if (this._dirtyMatch) { this._nextMatch(); } else if (cmd === "findagain") { this._nextMatch(); if (findbarClosed && this._state.highlightAll) { this._updateAllPages(); } } else if (cmd === "findhighlightallchange") { if (pendingTimeout) { this._nextMatch(); } else { this._highlightMatches = true; } this._updateAllPages(); } else { this._nextMatch(); } }); } scrollMatchIntoView({ element = null, pageIndex = -1, matchIndex = -1 }) { if (!this._scrollMatches || !element) { return; } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) { return; } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) { return; } this._scrollMatches = false; const spot = { top: MATCH_SCROLL_OFFSET_TOP, left: MATCH_SCROLL_OFFSET_LEFT }; (0, _ui_utils.scrollIntoView)(element, spot, true); } _reset() { this._highlightMatches = false; this._scrollMatches = false; this._pdfDocument = null; this._pageMatches = []; this._pageMatchesLength = []; this._state = null; this._selected = { pageIdx: -1, matchIdx: -1 }; this._offset = { pageIdx: null, matchIdx: null, wrapped: false }; this._extractTextPromises = []; this._pageContents = []; this._matchesCountTotal = 0; this._pagesToSearch = null; this._pendingFindMatches = Object.create(null); this._resumePageIdx = null; this._dirtyMatch = false; clearTimeout(this._findTimeout); this._findTimeout = null; this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)(); } get _query() { if (this._state.query !== this._rawQuery) { this._rawQuery = this._state.query; this._normalizedQuery = normalize(this._state.query); } return this._normalizedQuery; } _shouldDirtyMatch(cmd, state) { if (state.query !== this._state.query) { return true; } switch (cmd) { case "findagain": const pageNumber = this._selected.pageIdx + 1; const linkService = this._linkService; if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) { return true; } return false; case "findhighlightallchange": return false; } return true; } _prepareMatches(matchesWithLength, matches, matchesLength) { function isSubTerm(currentIndex) { const currentElem = matchesWithLength[currentIndex]; const nextElem = matchesWithLength[currentIndex + 1]; if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) { currentElem.skipped = true; return true; } for (let i = currentIndex - 1; i >= 0; i--) { const prevElem = matchesWithLength[i]; if (prevElem.skipped) { continue; } if (prevElem.match + prevElem.matchLength < currentElem.match) { break; } if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) { currentElem.skipped = true; return true; } } return false; } matchesWithLength.sort(function (a, b) { return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match; }); for (let i = 0, len = matchesWithLength.length; i < len; i++) { if (isSubTerm(i)) { continue; } matches.push(matchesWithLength[i].match); matchesLength.push(matchesWithLength[i].matchLength); } } _isEntireWord(content, startIdx, length) { if (startIdx > 0) { const first = content.charCodeAt(startIdx); const limit = content.charCodeAt(startIdx - 1); if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) { return false; } } const endIdx = startIdx + length - 1; if (endIdx < content.length - 1) { const last = content.charCodeAt(endIdx); const limit = content.charCodeAt(endIdx + 1); if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(limit)) { return false; } } return true; } _calculatePhraseMatch(query, pageIndex, pageContent, entireWord) { const matches = []; const queryLen = query.length; let matchIdx = -queryLen; while (true) { matchIdx = pageContent.indexOf(query, matchIdx + queryLen); if (matchIdx === -1) { break; } if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) { continue; } matches.push(matchIdx); } this._pageMatches[pageIndex] = matches; } _calculateWordMatch(query, pageIndex, pageContent, entireWord) { const matchesWithLength = []; const queryArray = query.match(/\S+/g); for (let i = 0, len = queryArray.length; i < len; i++) { const subquery = queryArray[i]; const subqueryLen = subquery.length; let matchIdx = -subqueryLen; while (true) { matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen); if (matchIdx === -1) { break; } if (entireWord && !this._isEntireWord(pageContent, matchIdx, subqueryLen)) { continue; } matchesWithLength.push({ match: matchIdx, matchLength: subqueryLen, skipped: false }); } } this._pageMatchesLength[pageIndex] = []; this._pageMatches[pageIndex] = []; this._prepareMatches(matchesWithLength, this._pageMatches[pageIndex], this._pageMatchesLength[pageIndex]); } _calculateMatch(pageIndex) { let pageContent = this._pageContents[pageIndex]; let query = this._query; const { caseSensitive, entireWord, phraseSearch } = this._state; if (query.length === 0) { return; } if (!caseSensitive) { pageContent = pageContent.toLowerCase(); query = query.toLowerCase(); } if (phraseSearch) { this._calculatePhraseMatch(query, pageIndex, pageContent, entireWord); } else { this._calculateWordMatch(query, pageIndex, pageContent, entireWord); } if (this._state.highlightAll) { this._updatePage(pageIndex); } if (this._resumePageIdx === pageIndex) { this._resumePageIdx = null; this._nextPageMatch(); } const pageMatchesCount = this._pageMatches[pageIndex].length; if (pageMatchesCount > 0) { this._matchesCountTotal += pageMatchesCount; this._updateUIResultsCount(); } } _extractText() { if (this._extractTextPromises.length > 0) { return; } let promise = Promise.resolve(); for (let i = 0, ii = this._linkService.pagesCount; i < ii; i++) { const extractTextCapability = (0, _pdfjsLib.createPromiseCapability)(); this._extractTextPromises[i] = extractTextCapability.promise; promise = promise.then(() => { return this._pdfDocument.getPage(i + 1).then(pdfPage => { return pdfPage.getTextContent({ normalizeWhitespace: true }); }).then(textContent => { const textItems = textContent.items; const strBuf = []; for (let j = 0, jj = textItems.length; j < jj; j++) { strBuf.push(textItems[j].str); } this._pageContents[i] = normalize(strBuf.join("")); extractTextCapability.resolve(i); }, reason => { console.error(`Unable to get text content for page ${i + 1}`, reason); this._pageContents[i] = ""; extractTextCapability.resolve(i); }); }); } } _updatePage(index) { if (this._scrollMatches && this._selected.pageIdx === index) { this._linkService.page = index + 1; } this._eventBus.dispatch("updatetextlayermatches", { source: this, pageIndex: index }); } _updateAllPages() { this._eventBus.dispatch("updatetextlayermatches", { source: this, pageIndex: -1 }); } _nextMatch() { const previous = this._state.findPrevious; const currentPageIndex = this._linkService.page - 1; const numPages = this._linkService.pagesCount; this._highlightMatches = true; if (this._dirtyMatch) { this._dirtyMatch = false; this._selected.pageIdx = this._selected.matchIdx = -1; this._offset.pageIdx = currentPageIndex; this._offset.matchIdx = null; this._offset.wrapped = false; this._resumePageIdx = null; this._pageMatches.length = 0; this._pageMatchesLength.length = 0; this._matchesCountTotal = 0; this._updateAllPages(); for (let i = 0; i < numPages; i++) { if (this._pendingFindMatches[i] === true) { continue; } this._pendingFindMatches[i] = true; this._extractTextPromises[i].then(pageIdx => { delete this._pendingFindMatches[pageIdx]; this._calculateMatch(pageIdx); }); } } if (this._query === "") { this._updateUIState(FindState.FOUND); return; } if (this._resumePageIdx) { return; } const offset = this._offset; this._pagesToSearch = numPages; if (offset.matchIdx !== null) { const numPageMatches = this._pageMatches[offset.pageIdx].length; if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) { offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1; this._updateMatch(true); return; } this._advanceOffsetPage(previous); } this._nextPageMatch(); } _matchesReady(matches) { const offset = this._offset; const numMatches = matches.length; const previous = this._state.findPrevious; if (numMatches) { offset.matchIdx = previous ? numMatches - 1 : 0; this._updateMatch(true); return true; } this._advanceOffsetPage(previous); if (offset.wrapped) { offset.matchIdx = null; if (this._pagesToSearch < 0) { this._updateMatch(false); return true; } } return false; } _nextPageMatch() { if (this._resumePageIdx !== null) { console.error("There can only be one pending page."); } let matches = null; do { const pageIdx = this._offset.pageIdx; matches = this._pageMatches[pageIdx]; if (!matches) { this._resumePageIdx = pageIdx; break; } } while (!this._matchesReady(matches)); } _advanceOffsetPage(previous) { const offset = this._offset; const numPages = this._linkService.pagesCount; offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1; offset.matchIdx = null; this._pagesToSearch--; if (offset.pageIdx >= numPages || offset.pageIdx < 0) { offset.pageIdx = previous ? numPages - 1 : 0; offset.wrapped = true; } } _updateMatch(found = false) { let state = FindState.NOT_FOUND; const wrapped = this._offset.wrapped; this._offset.wrapped = false; if (found) { const previousPage = this._selected.pageIdx; this._selected.pageIdx = this._offset.pageIdx; this._selected.matchIdx = this._offset.matchIdx; state = wrapped ? FindState.WRAPPED : FindState.FOUND; if (previousPage !== -1 && previousPage !== this._selected.pageIdx) { this._updatePage(previousPage); } } this._updateUIState(state, this._state.findPrevious); if (this._selected.pageIdx !== -1) { this._scrollMatches = true; this._updatePage(this._selected.pageIdx); } } _onFindBarClose(evt) { const pdfDocument = this._pdfDocument; this._firstPageCapability.promise.then(() => { if (!this._pdfDocument || pdfDocument && this._pdfDocument !== pdfDocument) { return; } if (this._findTimeout) { clearTimeout(this._findTimeout); this._findTimeout = null; } if (this._resumePageIdx) { this._resumePageIdx = null; this._dirtyMatch = true; } this._updateUIState(FindState.FOUND); this._highlightMatches = false; this._updateAllPages(); }); } _requestMatchesCount() { const { pageIdx, matchIdx } = this._selected; let current = 0, total = this._matchesCountTotal; if (matchIdx !== -1) { for (let i = 0; i < pageIdx; i++) { current += this._pageMatches[i] && this._pageMatches[i].length || 0; } current += matchIdx + 1; } if (current < 1 || current > total) { current = total = 0; } return { current, total }; } _updateUIResultsCount() { this._eventBus.dispatch("updatefindmatchescount", { source: this, matchesCount: this._requestMatchesCount() }); } _updateUIState(state, previous) { this._eventBus.dispatch("updatefindcontrolstate", { source: this, state, previous, matchesCount: this._requestMatchesCount(), rawQuery: this._state ? this._state.query : null }); } } exports.PDFFindController = PDFFindController;
/***/ }),
/* 11 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.getCharacterType = getCharacterType; exports.CharacterType = void 0; const CharacterType = { SPACE: 0, ALPHA_LETTER: 1, PUNCT: 2, HAN_LETTER: 3, KATAKANA_LETTER: 4, HIRAGANA_LETTER: 5, HALFWIDTH_KATAKANA_LETTER: 6, THAI_LETTER: 7 }; exports.CharacterType = CharacterType; function isAlphabeticalScript(charCode) { return charCode < 0x2e80; } function isAscii(charCode) { return (charCode & 0xff80) === 0; } function isAsciiAlpha(charCode) { return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a; } function isAsciiDigit(charCode) { return charCode >= 0x30 && charCode <= 0x39; } function isAsciiSpace(charCode) { return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a; } function isHan(charCode) { return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff; } function isKatakana(charCode) { return charCode >= 0x30a0 && charCode <= 0x30ff; } function isHiragana(charCode) { return charCode >= 0x3040 && charCode <= 0x309f; } function isHalfwidthKatakana(charCode) { return charCode >= 0xff60 && charCode <= 0xff9f; } function isThai(charCode) { return (charCode & 0xff80) === 0x0e00; } function getCharacterType(charCode) { if (isAlphabeticalScript(charCode)) { if (isAscii(charCode)) { if (isAsciiSpace(charCode)) { return CharacterType.SPACE; } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) { return CharacterType.ALPHA_LETTER; } return CharacterType.PUNCT; } else if (isThai(charCode)) { return CharacterType.THAI_LETTER; } else if (charCode === 0xa0) { return CharacterType.SPACE; } return CharacterType.ALPHA_LETTER; } if (isHan(charCode)) { return CharacterType.HAN_LETTER; } else if (isKatakana(charCode)) { return CharacterType.KATAKANA_LETTER; } else if (isHiragana(charCode)) { return CharacterType.HIRAGANA_LETTER; } else if (isHalfwidthKatakana(charCode)) { return CharacterType.HALFWIDTH_KATAKANA_LETTER; } return CharacterType.ALPHA_LETTER; }
/***/ }),
/* 12 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.isDestHashesEqual = isDestHashesEqual; exports.isDestArraysEqual = isDestArraysEqual; exports.PDFHistory = void 0; var _ui_utils = __w_pdfjs_require__(3); const HASH_CHANGE_TIMEOUT = 1000; const POSITION_UPDATED_THRESHOLD = 50; const UPDATE_VIEWAREA_TIMEOUT = 1000; function getCurrentHash() { return document.location.hash; } class PDFHistory { constructor({ linkService, eventBus }) { this.linkService = linkService; this.eventBus = eventBus; this._initialized = false; this._fingerprint = ""; this.reset(); this._boundEvents = null; this._isViewerInPresentationMode = false; this.eventBus._on("presentationmodechanged", evt => { this._isViewerInPresentationMode = evt.active || evt.switchInProgress; }); this.eventBus._on("pagesinit", () => { this._isPagesLoaded = false; const onPagesLoaded = evt => { this.eventBus._off("pagesloaded", onPagesLoaded); this._isPagesLoaded = !!evt.pagesCount; }; this.eventBus._on("pagesloaded", onPagesLoaded); }); } initialize({ fingerprint, resetHistory = false, updateUrl = false }) { if (!fingerprint || typeof fingerprint !== "string") { console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.'); return; } if (this._initialized) { this.reset(); } const reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint; this._fingerprint = fingerprint; this._updateUrl = updateUrl === true; this._initialized = true; this._bindEvents(); const state = window.history.state; this._popStateInProgress = false; this._blockHashChange = 0; this._currentHash = getCurrentHash(); this._numPositionUpdates = 0; this._uid = this._maxUid = 0; this._destination = null; this._position = null; if (!this._isValidState(state, true) || resetHistory) { const { hash, page, rotation } = this._parseCurrentHash(true); if (!hash || reInitialized || resetHistory) { this._pushOrReplaceState(null, true); return; } this._pushOrReplaceState({ hash, page, rotation }, true); return; } const destination = state.destination; this._updateInternalState(destination, state.uid, true); if (this._uid > this._maxUid) { this._maxUid = this._uid; } if (destination.rotation !== undefined) { this._initialRotation = destination.rotation; } if (destination.dest) { this._initialBookmark = JSON.stringify(destination.dest); this._destination.page = null; } else if (destination.hash) { this._initialBookmark = destination.hash; } else if (destination.page) { this._initialBookmark = `page=${destination.page}`; } } reset() { if (this._initialized) { this._pageHide(); this._initialized = false; this._unbindEvents(); } if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } this._initialBookmark = null; this._initialRotation = null; } push({ namedDest = null, explicitDest, pageNumber }) { if (!this._initialized) { return; } if (namedDest && typeof namedDest !== "string") { console.error("PDFHistory.push: " + `"${namedDest}" is not a valid namedDest parameter.`); return; } else if (!Array.isArray(explicitDest)) { console.error("PDFHistory.push: " + `"${explicitDest}" is not a valid explicitDest parameter.`); return; } else if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.linkService.pagesCount)) { if (pageNumber !== null || this._destination) { console.error("PDFHistory.push: " + `"${pageNumber}" is not a valid pageNumber parameter.`); return; } } const hash = namedDest || JSON.stringify(explicitDest); if (!hash) { return; } let forceReplace = false; if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) { if (this._destination.page) { return; } forceReplace = true; } if (this._popStateInProgress && !forceReplace) { return; } this._pushOrReplaceState({ dest: explicitDest, hash, page: pageNumber, rotation: this.linkService.rotation }, forceReplace); if (!this._popStateInProgress) { this._popStateInProgress = true; Promise.resolve().then(() => { this._popStateInProgress = false; }); } } pushCurrentPosition() { if (!this._initialized || this._popStateInProgress) { return; } this._tryPushCurrentPosition(); } back() { if (!this._initialized || this._popStateInProgress) { return; } const state = window.history.state; if (this._isValidState(state) && state.uid > 0) { window.history.back(); } } forward() { if (!this._initialized || this._popStateInProgress) { return; } const state = window.history.state; if (this._isValidState(state) && state.uid < this._maxUid) { window.history.forward(); } } get popStateInProgress() { return this._initialized && (this._popStateInProgress || this._blockHashChange > 0); } get initialBookmark() { return this._initialized ? this._initialBookmark : null; } get initialRotation() { return this._initialized ? this._initialRotation : null; } _pushOrReplaceState(destination, forceReplace = false) { const shouldReplace = forceReplace || !this._destination; const newState = { fingerprint: this._fingerprint, uid: shouldReplace ? this._uid : this._uid + 1, destination }; this._updateInternalState(destination, newState.uid); let newUrl; if (this._updateUrl && destination && destination.hash) { const baseUrl = document.location.href.split("#")[0];
if (!baseUrl.startsWith("file://")) {
newUrl = `${baseUrl}#${destination.hash}`; } } if (shouldReplace) { window.history.replaceState(newState, "", newUrl); } else { this._maxUid = this._uid; window.history.pushState(newState, "", newUrl); } } _tryPushCurrentPosition(temporary = false) { if (!this._position) { return; } let position = this._position; if (temporary) { position = Object.assign(Object.create(null), this._position); position.temporary = true; } if (!this._destination) { this._pushOrReplaceState(position); return; } if (this._destination.temporary) { this._pushOrReplaceState(position, true); return; } if (this._destination.hash === position.hash) { return; } if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) { return; } let forceReplace = false; if (this._destination.page >= position.first && this._destination.page <= position.page) { if (this._destination.dest || !this._destination.first) { return; } forceReplace = true; } this._pushOrReplaceState(position, forceReplace); } _isValidState(state, checkReload = false) { if (!state) { return false; } if (state.fingerprint !== this._fingerprint) { if (checkReload) { if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) { return false; } const [perfEntry] = performance.getEntriesByType("navigation"); if (!perfEntry || perfEntry.type !== "reload") { return false; } } else { return false; } } if (!Number.isInteger(state.uid) || state.uid < 0) { return false; } if (state.destination === null || typeof state.destination !== "object") { return false; } return true; } _updateInternalState(destination, uid, removeTemporary = false) { if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } if (removeTemporary && destination && destination.temporary) { delete destination.temporary; } this._destination = destination; this._uid = uid; this._numPositionUpdates = 0; } _parseCurrentHash(checkNameddest = false) { const hash = unescape(getCurrentHash()).substring(1); const params = (0, _ui_utils.parseQueryString)(hash); const nameddest = params.nameddest || ""; let page = params.page | 0; if (!(Number.isInteger(page) && page > 0 && page <= this.linkService.pagesCount) || checkNameddest && nameddest.length > 0) { page = null; } return { hash, page, rotation: this.linkService.rotation }; } _updateViewarea({ location }) { if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } this._position = { hash: this._isViewerInPresentationMode ? `page=${location.pageNumber}` : location.pdfOpenParams.substring(1), page: this.linkService.page, first: location.pageNumber, rotation: location.rotation }; if (this._popStateInProgress) { return; } if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) { this._numPositionUpdates++; } if (UPDATE_VIEWAREA_TIMEOUT > 0) { this._updateViewareaTimeout = setTimeout(() => { if (!this._popStateInProgress) { this._tryPushCurrentPosition(true); } this._updateViewareaTimeout = null; }, UPDATE_VIEWAREA_TIMEOUT); } } _popState({ state }) { const newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash; this._currentHash = newHash; if (!state) { this._uid++; const { hash, page, rotation } = this._parseCurrentHash(); this._pushOrReplaceState({ hash, page, rotation }, true); return; } if (!this._isValidState(state)) { return; } this._popStateInProgress = true; if (hashChanged) { this._blockHashChange++; (0, _ui_utils.waitOnEventOrTimeout)({ target: window, name: "hashchange", delay: HASH_CHANGE_TIMEOUT }).then(() => { this._blockHashChange--; }); } const destination = state.destination; this._updateInternalState(destination, state.uid, true); if (this._uid > this._maxUid) { this._maxUid = this._uid; } if ((0, _ui_utils.isValidRotation)(destination.rotation)) { this.linkService.rotation = destination.rotation; } if (destination.dest) { this.linkService.navigateTo(destination.dest); } else if (destination.hash) { this.linkService.setHash(destination.hash); } else if (destination.page) { this.linkService.page = destination.page; } Promise.resolve().then(() => { this._popStateInProgress = false; }); } _pageHide() { if (!this._destination || this._destination.temporary) { this._tryPushCurrentPosition(); } } _bindEvents() { if (this._boundEvents) { return; } this._boundEvents = { updateViewarea: this._updateViewarea.bind(this), popState: this._popState.bind(this), pageHide: this._pageHide.bind(this) }; this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea); window.addEventListener("popstate", this._boundEvents.popState); window.addEventListener("pagehide", this._boundEvents.pageHide); } _unbindEvents() { if (!this._boundEvents) { return; } this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea); window.removeEventListener("popstate", this._boundEvents.popState); window.removeEventListener("pagehide", this._boundEvents.pageHide); this._boundEvents = null; } } exports.PDFHistory = PDFHistory; function isDestHashesEqual(destHash, pushHash) { if (typeof destHash !== "string" || typeof pushHash !== "string") { return false; } if (destHash === pushHash) { return true; } const { nameddest } = (0, _ui_utils.parseQueryString)(destHash); if (nameddest === pushHash) { return true; } return false; } function isDestArraysEqual(firstDest, secondDest) { function isEntryEqual(first, second) { if (typeof first !== typeof second) { return false; } if (Array.isArray(first) || Array.isArray(second)) { return false; } if (first !== null && typeof first === "object" && second !== null) { if (Object.keys(first).length !== Object.keys(second).length) { return false; } for (const key in first) { if (!isEntryEqual(first[key], second[key])) { return false; } } return true; } return first === second || Number.isNaN(first) && Number.isNaN(second); } if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) { return false; } if (firstDest.length !== secondDest.length) { return false; } for (let i = 0, ii = firstDest.length; i < ii; i++) { if (!isEntryEqual(firstDest[i], secondDest[i])) { return false; } } return true; }
/***/ }),
/* 13 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFPageView = void 0; var _ui_utils = __w_pdfjs_require__(3); var _pdfjsLib = __w_pdfjs_require__(2); var _pdf_rendering_queue = __w_pdfjs_require__(14); var _viewer_compatibility = __w_pdfjs_require__(7); const MAX_CANVAS_PIXELS = _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels || 16777216; class PDFPageView { constructor(options) { const container = options.container; const defaultViewport = options.defaultViewport; this.id = options.id; this.renderingId = "page" + this.id; this.pdfPage = null; this.pageLabel = null; this.rotation = 0; this.scale = options.scale || _ui_utils.DEFAULT_SCALE; this.viewport = defaultViewport; this.pdfPageRotate = defaultViewport.rotation; this._annotationStorage = options.annotationStorage || null; this._optionalContentConfigPromise = options.optionalContentConfigPromise || null; this.hasRestrictedScaling = false; this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE; this.imageResourcesPath = options.imageResourcesPath || ""; this.renderInteractiveForms = typeof options.renderInteractiveForms === "boolean" ? options.renderInteractiveForms : true; this.useOnlyCssZoom = options.useOnlyCssZoom || false; this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS; this.eventBus = options.eventBus; this.renderingQueue = options.renderingQueue; this.textLayerFactory = options.textLayerFactory; this.annotationLayerFactory = options.annotationLayerFactory; this.renderer = options.renderer || _ui_utils.RendererType.CANVAS; this.enableWebGL = options.enableWebGL || false; this.l10n = options.l10n || _ui_utils.NullL10n; this.paintTask = null; this.paintedViewportMap = new WeakMap(); this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL; this.resume = null; this.error = null; this.annotationLayer = null; this.textLayer = null; this.zoomLayer = null; const div = document.createElement("div"); div.className = "page"; div.style.width = Math.floor(this.viewport.width) + "px"; div.style.height = Math.floor(this.viewport.height) + "px"; div.setAttribute("data-page-number", this.id); this.div = div; container.appendChild(div); } setPdfPage(pdfPage) { this.pdfPage = pdfPage; this.pdfPageRotate = pdfPage.rotate; const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = pdfPage.getViewport({ scale: this.scale * _ui_utils.CSS_UNITS, rotation: totalRotation }); this.stats = pdfPage.stats; this.reset(); } destroy() { this.reset(); if (this.pdfPage) { this.pdfPage.cleanup(); } } async _renderAnnotationLayer() { let error = null; try { await this.annotationLayer.render(this.viewport, "display"); } catch (ex) { error = ex; } finally { this.eventBus.dispatch("annotationlayerrendered", { source: this, pageNumber: this.id, error }); } } _resetZoomLayer(removeFromDOM = false) { if (!this.zoomLayer) { return; } const zoomLayerCanvas = this.zoomLayer.firstChild; this.paintedViewportMap.delete(zoomLayerCanvas); zoomLayerCanvas.width = 0; zoomLayerCanvas.height = 0; if (removeFromDOM) { this.zoomLayer.remove(); } this.zoomLayer = null; } reset(keepZoomLayer = false, keepAnnotations = false) { this.cancelRendering(keepAnnotations); this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL; const div = this.div; div.style.width = Math.floor(this.viewport.width) + "px"; div.style.height = Math.floor(this.viewport.height) + "px"; const childNodes = div.childNodes; const currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null; const currentAnnotationNode = keepAnnotations && this.annotationLayer && this.annotationLayer.div || null; for (let i = childNodes.length - 1; i >= 0; i--) { const node = childNodes[i]; if (currentZoomLayerNode === node || currentAnnotationNode === node) { continue; } div.removeChild(node); } div.removeAttribute("data-loaded"); if (currentAnnotationNode) { this.annotationLayer.hide(); } else if (this.annotationLayer) { this.annotationLayer.cancel(); this.annotationLayer = null; } if (!currentZoomLayerNode) { if (this.canvas) { this.paintedViewportMap.delete(this.canvas); this.canvas.width = 0; this.canvas.height = 0; delete this.canvas; } this._resetZoomLayer(); } if (this.svg) { this.paintedViewportMap.delete(this.svg); delete this.svg; } this.loadingIconDiv = document.createElement("div"); this.loadingIconDiv.className = "loadingIcon"; div.appendChild(this.loadingIconDiv); } update(scale, rotation, optionalContentConfigPromise = null) { this.scale = scale || this.scale; if (typeof rotation !== "undefined") { this.rotation = rotation; } if (optionalContentConfigPromise instanceof Promise) { this._optionalContentConfigPromise = optionalContentConfigPromise; } const totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = this.viewport.clone({ scale: this.scale * _ui_utils.CSS_UNITS, rotation: totalRotation }); if (this.svg) { this.cssTransform(this.svg, true); this.eventBus.dispatch("pagerendered", { source: this, pageNumber: this.id, cssTransform: true, timestamp: performance.now() }); return; } let isScalingRestricted = false; if (this.canvas && this.maxCanvasPixels > 0) { const outputScale = this.outputScale; if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) { isScalingRestricted = true; } } if (this.canvas) { if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) { this.cssTransform(this.canvas, true); this.eventBus.dispatch("pagerendered", { source: this, pageNumber: this.id, cssTransform: true, timestamp: performance.now() }); return; } if (!this.zoomLayer && !this.canvas.hasAttribute("hidden")) { this.zoomLayer = this.canvas.parentNode; this.zoomLayer.style.position = "absolute"; } } if (this.zoomLayer) { this.cssTransform(this.zoomLayer.firstChild); } this.reset(true, true); } cancelRendering(keepAnnotations = false) { if (this.paintTask) { this.paintTask.cancel(); this.paintTask = null; } this.resume = null; if (this.textLayer) { this.textLayer.cancel(); this.textLayer = null; } if (!keepAnnotations && this.annotationLayer) { this.annotationLayer.cancel(); this.annotationLayer = null; } } cssTransform(target, redrawAnnotations = false) { const width = this.viewport.width; const height = this.viewport.height; const div = this.div; target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px"; target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px"; const relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation; const absRotation = Math.abs(relativeRotation); let scaleX = 1, scaleY = 1; if (absRotation === 90 || absRotation === 270) { scaleX = height / width; scaleY = width / height; } const cssTransform = "rotate(" + relativeRotation + "deg) " + "scale(" + scaleX + "," + scaleY + ")"; target.style.transform = cssTransform; if (this.textLayer) { const textLayerViewport = this.textLayer.viewport; const textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation; const textAbsRotation = Math.abs(textRelativeRotation); let scale = width / textLayerViewport.width; if (textAbsRotation === 90 || textAbsRotation === 270) { scale = width / textLayerViewport.height; } const textLayerDiv = this.textLayer.textLayerDiv; let transX, transY; switch (textAbsRotation) { case 0: transX = transY = 0; break; case 90: transX = 0; transY = "-" + textLayerDiv.style.height; break; case 180: transX = "-" + textLayerDiv.style.width; transY = "-" + textLayerDiv.style.height; break; case 270: transX = "-" + textLayerDiv.style.width; transY = 0; break; default: console.error("Bad rotation value."); break; } textLayerDiv.style.transform = "rotate(" + textAbsRotation + "deg) " + "scale(" + scale + ", " + scale + ") " + "translate(" + transX + ", " + transY + ")"; textLayerDiv.style.transformOrigin = "0% 0%"; } if (redrawAnnotations && this.annotationLayer) { this._renderAnnotationLayer(); } } get width() { return this.viewport.width; } get height() { return this.viewport.height; } getPagePoint(x, y) { return this.viewport.convertToPdfPoint(x, y); } draw() { if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) { console.error("Must be in new state before drawing"); this.reset(); } const { div, pdfPage } = this; if (!pdfPage) { this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED; if (this.loadingIconDiv) { div.removeChild(this.loadingIconDiv); delete this.loadingIconDiv; } return Promise.reject(new Error("pdfPage is not loaded")); } this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING; const canvasWrapper = document.createElement("div"); canvasWrapper.style.width = div.style.width; canvasWrapper.style.height = div.style.height; canvasWrapper.classList.add("canvasWrapper"); if (this.annotationLayer && this.annotationLayer.div) { div.insertBefore(canvasWrapper, this.annotationLayer.div); } else { div.appendChild(canvasWrapper); } let textLayer = null; if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) { const textLayerDiv = document.createElement("div"); textLayerDiv.className = "textLayer"; textLayerDiv.style.width = canvasWrapper.style.width; textLayerDiv.style.height = canvasWrapper.style.height; if (this.annotationLayer && this.annotationLayer.div) { div.insertBefore(textLayerDiv, this.annotationLayer.div); } else { div.appendChild(textLayerDiv); } textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus); } this.textLayer = textLayer; let renderContinueCallback = null; if (this.renderingQueue) { renderContinueCallback = cont => { if (!this.renderingQueue.isHighestPriority(this)) { this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED; this.resume = () => { this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING; cont(); }; return; } cont(); }; } const finishPaintTask = async error => { if (paintTask === this.paintTask) { this.paintTask = null; } if (error instanceof _pdfjsLib.RenderingCancelledException) { this.error = null; return; } this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED; if (this.loadingIconDiv) { div.removeChild(this.loadingIconDiv); delete this.loadingIconDiv; } this._resetZoomLayer(true); this.error = error; this.stats = pdfPage.stats; this.eventBus.dispatch("pagerendered", { source: this, pageNumber: this.id, cssTransform: false, timestamp: performance.now() }); if (error) { throw error; } }; const paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper); paintTask.onRenderContinue = renderContinueCallback; this.paintTask = paintTask; const resultPromise = paintTask.promise.then(function () { return finishPaintTask(null).then(function () { if (textLayer) { const readableStream = pdfPage.streamTextContent({ normalizeWhitespace: true }); textLayer.setTextContentStream(readableStream); textLayer.render(); } }); }, function (reason) { return finishPaintTask(reason); }); if (this.annotationLayerFactory) { if (!this.annotationLayer) { this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, this._annotationStorage, this.imageResourcesPath, this.renderInteractiveForms, this.l10n); } this._renderAnnotationLayer(); } div.setAttribute("data-loaded", true); this.eventBus.dispatch("pagerender", { source: this, pageNumber: this.id }); return resultPromise; } paintOnCanvas(canvasWrapper) { const renderCapability = (0, _pdfjsLib.createPromiseCapability)(); const result = { promise: renderCapability.promise, onRenderContinue(cont) { cont(); }, cancel() { renderTask.cancel(); } }; const viewport = this.viewport; const canvas = document.createElement("canvas"); this.l10n.get("page_canvas", { page: this.id }, "Page {{page}}").then(msg => { canvas.setAttribute("aria-label", msg); }); canvas.setAttribute("hidden", "hidden"); let isCanvasHidden = true; const showCanvas = function () { if (isCanvasHidden) { canvas.removeAttribute("hidden"); isCanvasHidden = false; } }; canvasWrapper.appendChild(canvas); this.canvas = canvas; canvas.mozOpaque = true; const ctx = canvas.getContext("2d", { alpha: false }); const outputScale = (0, _ui_utils.getOutputScale)(ctx); this.outputScale = outputScale; if (this.useOnlyCssZoom) { const actualSizeViewport = viewport.clone({ scale: _ui_utils.CSS_UNITS }); outputScale.sx *= actualSizeViewport.width / viewport.width; outputScale.sy *= actualSizeViewport.height / viewport.height; outputScale.scaled = true; } if (this.maxCanvasPixels > 0) { const pixelsInViewport = viewport.width * viewport.height; const maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport); if (outputScale.sx > maxScale || outputScale.sy > maxScale) { outputScale.sx = maxScale; outputScale.sy = maxScale; outputScale.scaled = true; this.hasRestrictedScaling = true; } else { this.hasRestrictedScaling = false; } } const sfx = (0, _ui_utils.approximateFraction)(outputScale.sx); const sfy = (0, _ui_utils.approximateFraction)(outputScale.sy); canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]); canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]); canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px"; canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px"; this.paintedViewportMap.set(canvas, viewport); const transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0]; const renderContext = { canvasContext: ctx, transform, viewport: this.viewport, enableWebGL: this.enableWebGL, renderInteractiveForms: this.renderInteractiveForms, optionalContentConfigPromise: this._optionalContentConfigPromise }; const renderTask = this.pdfPage.render(renderContext); renderTask.onContinue = function (cont) { showCanvas(); if (result.onRenderContinue) { result.onRenderContinue(cont); } else { cont(); } }; renderTask.promise.then(function () { showCanvas(); renderCapability.resolve(undefined); }, function (error) { showCanvas(); renderCapability.reject(error); }); return result; } paintOnSvg(wrapper) { let cancelled = false; const ensureNotCancelled = () => { if (cancelled) { throw new _pdfjsLib.RenderingCancelledException(`Rendering cancelled, page ${this.id}`, "svg"); } }; const pdfPage = this.pdfPage; const actualSizeViewport = this.viewport.clone({ scale: _ui_utils.CSS_UNITS }); const promise = pdfPage.getOperatorList().then(opList => { ensureNotCancelled(); const svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs); return svgGfx.getSVG(opList, actualSizeViewport).then(svg => { ensureNotCancelled(); this.svg = svg; this.paintedViewportMap.set(svg, actualSizeViewport); svg.style.width = wrapper.style.width; svg.style.height = wrapper.style.height; this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED; wrapper.appendChild(svg); }); }); return { promise, onRenderContinue(cont) { cont(); }, cancel() { cancelled = true; } }; } setPageLabel(label) { this.pageLabel = typeof label === "string" ? label : null; if (this.pageLabel !== null) { this.div.setAttribute("data-page-label", this.pageLabel); } else { this.div.removeAttribute("data-page-label"); } } } exports.PDFPageView = PDFPageView;
/***/ }),
/* 14 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFRenderingQueue = exports.RenderingStates = void 0; const CLEANUP_TIMEOUT = 30000; const RenderingStates = { INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3 }; exports.RenderingStates = RenderingStates; class PDFRenderingQueue { constructor() { this.pdfViewer = null; this.pdfThumbnailViewer = null; this.onIdle = null; this.highestPriorityPage = null; this.idleTimeout = null; this.printing = false; this.isThumbnailViewEnabled = false; } setViewer(pdfViewer) { this.pdfViewer = pdfViewer; } setThumbnailViewer(pdfThumbnailViewer) { this.pdfThumbnailViewer = pdfThumbnailViewer; } isHighestPriority(view) { return this.highestPriorityPage === view.renderingId; } renderHighestPriority(currentlyVisiblePages) { if (this.idleTimeout) { clearTimeout(this.idleTimeout); this.idleTimeout = null; } if (this.pdfViewer.forceRendering(currentlyVisiblePages)) { return; } if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) { if (this.pdfThumbnailViewer.forceRendering()) { return; } } if (this.printing) { return; } if (this.onIdle) { this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT); } } getHighestPriority(visible, views, scrolledDown) { const visibleViews = visible.views; const numVisible = visibleViews.length; if (numVisible === 0) { return null; } for (let i = 0; i < numVisible; ++i) { const view = visibleViews[i].view; if (!this.isViewFinished(view)) { return view; } } if (scrolledDown) { const nextPageIndex = visible.last.id; if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) { return views[nextPageIndex]; } } else { const previousPageIndex = visible.first.id - 2; if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) { return views[previousPageIndex]; } } return null; } isViewFinished(view) { return view.renderingState === RenderingStates.FINISHED; } renderView(view) { switch (view.renderingState) { case RenderingStates.FINISHED: return false; case RenderingStates.PAUSED: this.highestPriorityPage = view.renderingId; view.resume(); break; case RenderingStates.RUNNING: this.highestPriorityPage = view.renderingId; break; case RenderingStates.INITIAL: this.highestPriorityPage = view.renderingId; view.draw().finally(() => { this.renderHighestPriority(); }).catch(reason => { console.error(`renderView: "${reason}"`); }); break; } return true; } } exports.PDFRenderingQueue = PDFRenderingQueue;
/***/ }),
/* 15 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFSinglePageViewer = void 0; var _base_viewer = __w_pdfjs_require__(16); var _pdfjsLib = __w_pdfjs_require__(2); class PDFSinglePageViewer extends _base_viewer.BaseViewer { constructor(options) { super(options); this.eventBus._on("pagesinit", evt => { this._ensurePageViewVisible(); }); } get _viewerElement() { return (0, _pdfjsLib.shadow)(this, "_viewerElement", this._shadowViewer); } _resetView() { super._resetView(); this._previousPageNumber = 1; this._shadowViewer = document.createDocumentFragment(); this._updateScrollDown = null; } _ensurePageViewVisible() { const pageView = this._pages[this._currentPageNumber - 1]; const previousPageView = this._pages[this._previousPageNumber - 1]; const viewerNodes = this.viewer.childNodes; switch (viewerNodes.length) { case 0: this.viewer.appendChild(pageView.div); break; case 1: if (viewerNodes[0] !== previousPageView.div) { throw new Error("_ensurePageViewVisible: Unexpected previously visible page."); } if (pageView === previousPageView) { break; } this._shadowViewer.appendChild(previousPageView.div); this.viewer.appendChild(pageView.div); this.container.scrollTop = 0; break; default: throw new Error("_ensurePageViewVisible: Only one page should be visible at a time."); } this._previousPageNumber = this._currentPageNumber; } _scrollUpdate() { if (this._updateScrollDown) { this._updateScrollDown(); } super._scrollUpdate(); } _scrollIntoView({ pageDiv, pageSpot = null, pageNumber = null }) { if (pageNumber) { this._setCurrentPageNumber(pageNumber); } const scrolledDown = this._currentPageNumber >= this._previousPageNumber; this._ensurePageViewVisible(); this.update(); super._scrollIntoView({ pageDiv, pageSpot, pageNumber }); this._updateScrollDown = () => { this.scroll.down = scrolledDown; this._updateScrollDown = null; }; } _getVisiblePages() { return this._getCurrentVisiblePage(); } _updateHelper(visiblePages) {} get _isScrollModeHorizontal() { return (0, _pdfjsLib.shadow)(this, "_isScrollModeHorizontal", false); } _updateScrollMode() {} _updateSpreadMode() {} } exports.PDFSinglePageViewer = PDFSinglePageViewer;
/***/ }),
/* 16 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.BaseViewer = void 0; var _ui_utils = __w_pdfjs_require__(3); var _pdf_rendering_queue = __w_pdfjs_require__(14); var _annotation_layer_builder = __w_pdfjs_require__(1); var _pdfjsLib = __w_pdfjs_require__(2); var _pdf_page_view = __w_pdfjs_require__(13); var _pdf_link_service = __w_pdfjs_require__(4); var _text_layer_builder = __w_pdfjs_require__(5); const DEFAULT_CACHE_SIZE = 10; function PDFPageViewBuffer(size) { const data = []; this.push = function (view) { const i = data.indexOf(view); if (i >= 0) { data.splice(i, 1); } data.push(view); if (data.length > size) { data.shift().destroy(); } }; this.resize = function (newSize, pagesToKeep) { size = newSize; if (pagesToKeep) { const pageIdsToKeep = new Set(); for (let i = 0, iMax = pagesToKeep.length; i < iMax; ++i) { pageIdsToKeep.add(pagesToKeep[i].id); } (0, _ui_utils.moveToEndOfArray)(data, function (page) { return pageIdsToKeep.has(page.id); }); } while (data.length > size) { data.shift().destroy(); } }; } function isSameScale(oldScale, newScale) { if (newScale === oldScale) { return true; } if (Math.abs(newScale - oldScale) < 1e-15) { return true; } return false; } class BaseViewer { constructor(options) { if (this.constructor === BaseViewer) { throw new Error("Cannot initialize BaseViewer."); } this._name = this.constructor.name; this.container = options.container; this.viewer = options.viewer || options.container.firstElementChild; if (!(this.container instanceof HTMLDivElement && this.viewer instanceof HTMLDivElement)) { throw new Error("Invalid `container` and/or `viewer` option."); } this.eventBus = options.eventBus; this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService(); this.downloadManager = options.downloadManager || null; this.findController = options.findController || null; this.removePageBorders = options.removePageBorders || false; this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE; this.imageResourcesPath = options.imageResourcesPath || ""; this.renderInteractiveForms = typeof options.renderInteractiveForms === "boolean" ? options.renderInteractiveForms : true; this.enablePrintAutoRotate = options.enablePrintAutoRotate || false; this.renderer = options.renderer || _ui_utils.RendererType.CANVAS; this.enableWebGL = options.enableWebGL || false; this.useOnlyCssZoom = options.useOnlyCssZoom || false; this.maxCanvasPixels = options.maxCanvasPixels; this.l10n = options.l10n || _ui_utils.NullL10n; this.defaultRenderingQueue = !options.renderingQueue; if (this.defaultRenderingQueue) { this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue(); this.renderingQueue.setViewer(this); } else { this.renderingQueue = options.renderingQueue; } this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this)); this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN; this._onBeforeDraw = this._onAfterDraw = null; this._resetView(); if (this.removePageBorders) { this.viewer.classList.add("removePageBorders"); } Promise.resolve().then(() => { this.eventBus.dispatch("baseviewerinit", { source: this }); }); } get pagesCount() { return this._pages.length; } getPageView(index) { return this._pages[index]; } get pageViewsReady() { if (!this._pagesCapability.settled) { return false; } return this._pages.every(function (pageView) { return pageView && pageView.pdfPage; }); } get currentPageNumber() { return this._currentPageNumber; } set currentPageNumber(val) { if (!Number.isInteger(val)) { throw new Error("Invalid page number."); } if (!this.pdfDocument) { return; } if (!this._setCurrentPageNumber(val, true)) { console.error(`${this._name}.currentPageNumber: "${val}" is not a valid page.`); } } _setCurrentPageNumber(val, resetCurrentPageView = false) { if (this._currentPageNumber === val) { if (resetCurrentPageView) { this._resetCurrentPageView(); } return true; } if (!(0 < val && val <= this.pagesCount)) { return false; } this._currentPageNumber = val; this.eventBus.dispatch("pagechanging", { source: this, pageNumber: val, pageLabel: this._pageLabels && this._pageLabels[val - 1] }); if (resetCurrentPageView) { this._resetCurrentPageView(); } return true; } get currentPageLabel() { return this._pageLabels && this._pageLabels[this._currentPageNumber - 1]; } set currentPageLabel(val) { if (!this.pdfDocument) { return; } let page = val | 0; if (this._pageLabels) { const i = this._pageLabels.indexOf(val); if (i >= 0) { page = i + 1; } } if (!this._setCurrentPageNumber(page, true)) { console.error(`${this._name}.currentPageLabel: "${val}" is not a valid page.`); } } get currentScale() { return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE; } set currentScale(val) { if (isNaN(val)) { throw new Error("Invalid numeric scale."); } if (!this.pdfDocument) { return; } this._setScale(val, false); } get currentScaleValue() { return this._currentScaleValue; } set currentScaleValue(val) { if (!this.pdfDocument) { return; } this._setScale(val, false); } get pagesRotation() { return this._pagesRotation; } set pagesRotation(rotation) { if (!(0, _ui_utils.isValidRotation)(rotation)) { throw new Error("Invalid pages rotation angle."); } if (!this.pdfDocument) { return; } if (this._pagesRotation === rotation) { return; } this._pagesRotation = rotation; const pageNumber = this._currentPageNumber; for (let i = 0, ii = this._pages.length; i < ii; i++) { const pageView = this._pages[i]; pageView.update(pageView.scale, rotation); } if (this._currentScaleValue) { this._setScale(this._currentScaleValue, true); } this.eventBus.dispatch("rotationchanging", { source: this, pagesRotation: rotation, pageNumber }); if (this.defaultRenderingQueue) { this.update(); } } get firstPagePromise() { return this.pdfDocument ? this._firstPageCapability.promise : null; } get onePageRendered() { return this.pdfDocument ? this._onePageRenderedCapability.promise : null; } get pagesPromise() { return this.pdfDocument ? this._pagesCapability.promise : null; } get _viewerElement() { throw new Error("Not implemented: _viewerElement"); } _onePageRenderedOrForceFetch() { if (!this.container.offsetParent || this._getVisiblePages().views.length === 0) { return Promise.resolve(); } return this._onePageRenderedCapability.promise; } setDocument(pdfDocument) { if (this.pdfDocument) { this._cancelRendering(); this._resetView(); if (this.findController) { this.findController.setDocument(null); } } this.pdfDocument = pdfDocument; if (!pdfDocument) { return; } const pagesCount = pdfDocument.numPages; const firstPagePromise = pdfDocument.getPage(1); const annotationStorage = pdfDocument.annotationStorage; const optionalContentConfigPromise = pdfDocument.getOptionalContentConfig(); this._pagesCapability.promise.then(() => { this.eventBus.dispatch("pagesloaded", { source: this, pagesCount }); }); this._onBeforeDraw = evt => { const pageView = this._pages[evt.pageNumber - 1]; if (!pageView) { return; } this._buffer.push(pageView); }; this.eventBus._on("pagerender", this._onBeforeDraw); this._onAfterDraw = evt => { if (evt.cssTransform || this._onePageRenderedCapability.settled) { return; } this._onePageRenderedCapability.resolve(); this.eventBus._off("pagerendered", this._onAfterDraw); this._onAfterDraw = null; }; this.eventBus._on("pagerendered", this._onAfterDraw); firstPagePromise.then(firstPdfPage => { this._firstPageCapability.resolve(firstPdfPage); this._optionalContentConfigPromise = optionalContentConfigPromise; const scale = this.currentScale; const viewport = firstPdfPage.getViewport({ scale: scale * _ui_utils.CSS_UNITS }); const textLayerFactory = this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE ? this : null; for (let pageNum = 1; pageNum <= pagesCount; ++pageNum) { const pageView = new _pdf_page_view.PDFPageView({ container: this._viewerElement, eventBus: this.eventBus, id: pageNum, scale, defaultViewport: viewport.clone(), annotationStorage, optionalContentConfigPromise, renderingQueue: this.renderingQueue, textLayerFactory, textLayerMode: this.textLayerMode, annotationLayerFactory: this, imageResourcesPath: this.imageResourcesPath, renderInteractiveForms: this.renderInteractiveForms, renderer: this.renderer, enableWebGL: this.enableWebGL, useOnlyCssZoom: this.useOnlyCssZoom, maxCanvasPixels: this.maxCanvasPixels, l10n: this.l10n }); this._pages.push(pageView); } const firstPageView = this._pages[0]; if (firstPageView) { firstPageView.setPdfPage(firstPdfPage); this.linkService.cachePageRef(1, firstPdfPage.ref); } if (this._spreadMode !== _ui_utils.SpreadMode.NONE) { this._updateSpreadMode(); } this._onePageRenderedOrForceFetch().then(() => { if (this.findController) { this.findController.setDocument(pdfDocument); } if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > 7500) { this._pagesCapability.resolve(); return; } let getPagesLeft = pagesCount - 1; if (getPagesLeft <= 0) { this._pagesCapability.resolve(); return; } for (let pageNum = 2; pageNum <= pagesCount; ++pageNum) { pdfDocument.getPage(pageNum).then(pdfPage => { const pageView = this._pages[pageNum - 1]; if (!pageView.pdfPage) { pageView.setPdfPage(pdfPage); } this.linkService.cachePageRef(pageNum, pdfPage.ref); if (--getPagesLeft === 0) { this._pagesCapability.resolve(); } }, reason => { console.error(`Unable to get page ${pageNum} to initialize viewer`, reason); if (--getPagesLeft === 0) { this._pagesCapability.resolve(); } }); } }); this.eventBus.dispatch("pagesinit", { source: this }); if (this.defaultRenderingQueue) { this.update(); } }).catch(reason => { console.error("Unable to initialize viewer", reason); }); } setPageLabels(labels) { if (!this.pdfDocument) { return; } if (!labels) { this._pageLabels = null; } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) { this._pageLabels = null; console.error(`${this._name}.setPageLabels: Invalid page labels.`); } else { this._pageLabels = labels; } for (let i = 0, ii = this._pages.length; i < ii; i++) { const pageView = this._pages[i]; const label = this._pageLabels && this._pageLabels[i]; pageView.setPageLabel(label); } } _resetView() { this._pages = []; this._currentPageNumber = 1; this._currentScale = _ui_utils.UNKNOWN_SCALE; this._currentScaleValue = null; this._pageLabels = null; this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE); this._location = null; this._pagesRotation = 0; this._optionalContentConfigPromise = null; this._pagesRequests = new WeakMap(); this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)(); this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)(); this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)(); this._scrollMode = _ui_utils.ScrollMode.VERTICAL; this._spreadMode = _ui_utils.SpreadMode.NONE; if (this._onBeforeDraw) { this.eventBus._off("pagerender", this._onBeforeDraw); this._onBeforeDraw = null; } if (this._onAfterDraw) { this.eventBus._off("pagerendered", this._onAfterDraw); this._onAfterDraw = null; } this.viewer.textContent = ""; this._updateScrollMode(); } _scrollUpdate() { if (this.pagesCount === 0) { return; } this.update(); } _scrollIntoView({ pageDiv, pageSpot = null, pageNumber = null }) { (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot); } _setScaleUpdatePages(newScale, newValue, noScroll = false, preset = false) { this._currentScaleValue = newValue.toString(); if (isSameScale(this._currentScale, newScale)) { if (preset) { this.eventBus.dispatch("scalechanging", { source: this, scale: newScale, presetValue: newValue }); } return; } for (let i = 0, ii = this._pages.length; i < ii; i++) { this._pages[i].update(newScale); } this._currentScale = newScale; if (!noScroll) { let page = this._currentPageNumber, dest; if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) { page = this._location.pageNumber; dest = [null, { name: "XYZ" }, this._location.left, this._location.top, null]; } this.scrollPageIntoView({ pageNumber: page, destArray: dest, allowNegativeOffset: true }); } this.eventBus.dispatch("scalechanging", { source: this, scale: newScale, presetValue: preset ? newValue : undefined }); if (this.defaultRenderingQueue) { this.update(); } } _setScale(value, noScroll = false) { let scale = parseFloat(value); if (scale > 0) { this._setScaleUpdatePages(scale, value, noScroll, false); } else { const currentPage = this._pages[this._currentPageNumber - 1]; if (!currentPage) { return; } const noPadding = this.isInPresentationMode || this.removePageBorders; let hPadding = noPadding ? 0 : _ui_utils.SCROLLBAR_PADDING; let vPadding = noPadding ? 0 : _ui_utils.VERTICAL_PADDING; if (!noPadding && this._isScrollModeHorizontal) { [hPadding, vPadding] = [vPadding, hPadding]; } const pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale; const pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale; switch (value) { case "page-actual": scale = 1; break; case "page-width": scale = pageWidthScale; break; case "page-height": scale = pageHeightScale; break; case "page-fit": scale = Math.min(pageWidthScale, pageHeightScale); break; case "auto": const horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale); scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale); break; default: console.error(`${this._name}._setScale: "${value}" is an unknown zoom value.`); return; } this._setScaleUpdatePages(scale, value, noScroll, true); } } _resetCurrentPageView() { if (this.isInPresentationMode) { this._setScale(this._currentScaleValue, true); } const pageView = this._pages[this._currentPageNumber - 1]; this._scrollIntoView({ pageDiv: pageView.div }); } scrollPageIntoView({ pageNumber, destArray = null, allowNegativeOffset = false, ignoreDestinationZoom = false }) { if (!this.pdfDocument) { return; } const pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1]; if (!pageView) { console.error(`${this._name}.scrollPageIntoView: ` + `"${pageNumber}" is not a valid pageNumber parameter.`); return; } if (this.isInPresentationMode || !destArray) { this._setCurrentPageNumber(pageNumber, true); return; } let x = 0, y = 0; let width = 0, height = 0, widthScale, heightScale; const changeOrientation = pageView.rotation % 180 !== 0; const pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _ui_utils.CSS_UNITS; const pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _ui_utils.CSS_UNITS; let scale = 0; switch (destArray[1].name) { case "XYZ": x = destArray[2]; y = destArray[3]; scale = destArray[4]; x = x !== null ? x : 0; y = y !== null ? y : pageHeight; break; case "Fit": case "FitB": scale = "page-fit"; break; case "FitH": case "FitBH": y = destArray[2]; scale = "page-width"; if (y === null && this._location) { x = this._location.left; y = this._location.top; } break; case "FitV": case "FitBV": x = destArray[2]; width = pageWidth; height = pageHeight; scale = "page-height"; break; case "FitR": x = destArray[2]; y = destArray[3]; width = destArray[4] - x; height = destArray[5] - y; const hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING; const vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING; widthScale = (this.container.clientWidth - hPadding) / width / _ui_utils.CSS_UNITS; heightScale = (this.container.clientHeight - vPadding) / height / _ui_utils.CSS_UNITS; scale = Math.min(Math.abs(widthScale), Math.abs(heightScale)); break; default: console.error(`${this._name}.scrollPageIntoView: ` + `"${destArray[1].name}" is not a valid destination type.`); return; } if (!ignoreDestinationZoom) { if (scale && scale !== this._currentScale) { this.currentScaleValue = scale; } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) { this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; } } if (scale === "page-fit" && !destArray[4]) { this._scrollIntoView({ pageDiv: pageView.div, pageNumber }); return; } const boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)]; let left = Math.min(boundingRect[0][0], boundingRect[1][0]); let top = Math.min(boundingRect[0][1], boundingRect[1][1]); if (!allowNegativeOffset) { left = Math.max(left, 0); top = Math.max(top, 0); } this._scrollIntoView({ pageDiv: pageView.div, pageSpot: { left, top }, pageNumber }); } _updateLocation(firstPage) { const currentScale = this._currentScale; const currentScaleValue = this._currentScaleValue; const normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue; const pageNumber = firstPage.id; let pdfOpenParams = "#page=" + pageNumber; pdfOpenParams += "&zoom=" + normalizedScaleValue; const currentPageView = this._pages[pageNumber - 1]; const container = this.container; const topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y); const intLeft = Math.round(topLeft[0]); const intTop = Math.round(topLeft[1]); pdfOpenParams += "," + intLeft + "," + intTop; this._location = { pageNumber, scale: normalizedScaleValue, top: intTop, left: intLeft, rotation: this._pagesRotation, pdfOpenParams }; } _updateHelper(visiblePages) { throw new Error("Not implemented: _updateHelper"); } update() { const visible = this._getVisiblePages(); const visiblePages = visible.views, numVisiblePages = visiblePages.length; if (numVisiblePages === 0) { return; } const newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1); this._buffer.resize(newCacheSize, visiblePages); this.renderingQueue.renderHighestPriority(visible); this._updateHelper(visiblePages); this._updateLocation(visible.first); this.eventBus.dispatch("updateviewarea", { source: this, location: this._location }); } containsElement(element) { return this.container.contains(element); } focus() { this.container.focus(); } get _isScrollModeHorizontal() { return this.isInPresentationMode ? false : this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL; } get isInPresentationMode() { return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN; } get isChangingPresentationMode() { return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING; } get isHorizontalScrollbarEnabled() { return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth; } get isVerticalScrollbarEnabled() { return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight; } _getCurrentVisiblePage() { if (!this.pagesCount) { return { views: [] }; } const pageView = this._pages[this._currentPageNumber - 1]; const element = pageView.div; const view = { id: pageView.id, x: element.offsetLeft + element.clientLeft, y: element.offsetTop + element.clientTop, view: pageView }; return { first: view, last: view, views: [view] }; } _getVisiblePages() { return (0, _ui_utils.getVisibleElements)(this.container, this._pages, true, this._isScrollModeHorizontal); } isPageVisible(pageNumber) { if (!this.pdfDocument) { return false; } if (pageNumber < 1 || pageNumber > this.pagesCount) { console.error(`${this._name}.isPageVisible: "${pageNumber}" is out of bounds.`); return false; } return this._getVisiblePages().views.some(function (view) { return view.id === pageNumber; }); } cleanup() { for (let i = 0, ii = this._pages.length; i < ii; i++) { if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) { this._pages[i].reset(); } } } _cancelRendering() { for (let i = 0, ii = this._pages.length; i < ii; i++) { if (this._pages[i]) { this._pages[i].cancelRendering(); } } } _ensurePdfPageLoaded(pageView) { if (pageView.pdfPage) { return Promise.resolve(pageView.pdfPage); } if (this._pagesRequests.has(pageView)) { return this._pagesRequests.get(pageView); } const promise = this.pdfDocument.getPage(pageView.id).then(pdfPage => { if (!pageView.pdfPage) { pageView.setPdfPage(pdfPage); } this._pagesRequests.delete(pageView); return pdfPage; }).catch(reason => { console.error("Unable to get page for page view", reason); this._pagesRequests.delete(pageView); }); this._pagesRequests.set(pageView, promise); return promise; } forceRendering(currentlyVisiblePages) { const visiblePages = currentlyVisiblePages || this._getVisiblePages(); const scrollAhead = this._isScrollModeHorizontal ? this.scroll.right : this.scroll.down; const pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead); if (pageView) { this._ensurePdfPageLoaded(pageView).then(() => { this.renderingQueue.renderView(pageView); }); return true; } return false; } createTextLayerBuilder(textLayerDiv, pageIndex, viewport, enhanceTextSelection = false, eventBus) { return new _text_layer_builder.TextLayerBuilder({ textLayerDiv, eventBus, pageIndex, viewport, findController: this.isInPresentationMode ? null : this.findController, enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection }); } createAnnotationLayerBuilder(pageDiv, pdfPage, annotationStorage = null, imageResourcesPath = "", renderInteractiveForms = false, l10n = _ui_utils.NullL10n) { return new _annotation_layer_builder.AnnotationLayerBuilder({ pageDiv, pdfPage, annotationStorage, imageResourcesPath, renderInteractiveForms, linkService: this.linkService, downloadManager: this.downloadManager, l10n }); } get hasEqualPageSizes() { const firstPageView = this._pages[0]; for (let i = 1, ii = this._pages.length; i < ii; ++i) { const pageView = this._pages[i]; if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) { return false; } } return true; } getPagesOverview() { const pagesOverview = this._pages.map(function (pageView) { const viewport = pageView.pdfPage.getViewport({ scale: 1 }); return { width: viewport.width, height: viewport.height, rotation: viewport.rotation }; }); if (!this.enablePrintAutoRotate) { return pagesOverview; } return pagesOverview.map(function (size) { if ((0, _ui_utils.isPortraitOrientation)(size)) { return size; } return { width: size.height, height: size.width, rotation: (size.rotation + 90) % 360 }; }); } get optionalContentConfigPromise() { if (!this.pdfDocument) { return Promise.resolve(null); } if (!this._optionalContentConfigPromise) { return this.pdfDocument.getOptionalContentConfig(); } return this._optionalContentConfigPromise; } set optionalContentConfigPromise(promise) { if (!(promise instanceof Promise)) { throw new Error(`Invalid optionalContentConfigPromise: ${promise}`); } if (!this.pdfDocument) { return; } if (!this._optionalContentConfigPromise) { return; } this._optionalContentConfigPromise = promise; for (const pageView of this._pages) { pageView.update(pageView.scale, pageView.rotation, promise); } this.update(); this.eventBus.dispatch("optionalcontentconfigchanged", { source: this, promise }); } get scrollMode() { return this._scrollMode; } set scrollMode(mode) { if (this._scrollMode === mode) { return; } if (!(0, _ui_utils.isValidScrollMode)(mode)) { throw new Error(`Invalid scroll mode: ${mode}`); } this._scrollMode = mode; this.eventBus.dispatch("scrollmodechanged", { source: this, mode }); this._updateScrollMode(this._currentPageNumber); } _updateScrollMode(pageNumber = null) { const scrollMode = this._scrollMode, viewer = this.viewer; viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL); viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED); if (!this.pdfDocument || !pageNumber) { return; } if (this._currentScaleValue && isNaN(this._currentScaleValue)) { this._setScale(this._currentScaleValue, true); } this._setCurrentPageNumber(pageNumber, true); this.update(); } get spreadMode() { return this._spreadMode; } set spreadMode(mode) { if (this._spreadMode === mode) { return; } if (!(0, _ui_utils.isValidSpreadMode)(mode)) { throw new Error(`Invalid spread mode: ${mode}`); } this._spreadMode = mode; this.eventBus.dispatch("spreadmodechanged", { source: this, mode }); this._updateSpreadMode(this._currentPageNumber); } _updateSpreadMode(pageNumber = null) { if (!this.pdfDocument) { return; } const viewer = this.viewer, pages = this._pages; viewer.textContent = ""; if (this._spreadMode === _ui_utils.SpreadMode.NONE) { for (let i = 0, iMax = pages.length; i < iMax; ++i) { viewer.appendChild(pages[i].div); } } else { const parity = this._spreadMode - 1; let spread = null; for (let i = 0, iMax = pages.length; i < iMax; ++i) { if (spread === null) { spread = document.createElement("div"); spread.className = "spread"; viewer.appendChild(spread); } else if (i % 2 === parity) { spread = spread.cloneNode(false); viewer.appendChild(spread); } spread.appendChild(pages[i].div); } } if (!pageNumber) { return; } this._setCurrentPageNumber(pageNumber, true); this.update(); } } exports.BaseViewer = BaseViewer;
/***/ }),
/* 17 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFViewer = void 0; var _base_viewer = __w_pdfjs_require__(16); var _pdfjsLib = __w_pdfjs_require__(2); class PDFViewer extends _base_viewer.BaseViewer { get _viewerElement() { return (0, _pdfjsLib.shadow)(this, "_viewerElement", this.viewer); } _scrollIntoView({ pageDiv, pageSpot = null, pageNumber = null }) { if (!pageSpot && !this.isInPresentationMode) { const left = pageDiv.offsetLeft + pageDiv.clientLeft; const right = left + pageDiv.clientWidth; const { scrollLeft, clientWidth } = this.container; if (this._isScrollModeHorizontal || left < scrollLeft || right > scrollLeft + clientWidth) { pageSpot = { left: 0, top: 0 }; } } super._scrollIntoView({ pageDiv, pageSpot, pageNumber }); } _getVisiblePages() { if (this.isInPresentationMode) { return this._getCurrentVisiblePage(); } return super._getVisiblePages(); } _updateHelper(visiblePages) { if (this.isInPresentationMode) { return; } let currentId = this._currentPageNumber; let stillFullyVisible = false; for (const page of visiblePages) { if (page.percent < 100) { break; } if (page.id === currentId) { stillFullyVisible = true; break; } } if (!stillFullyVisible) { currentId = visiblePages[0].id; } this._setCurrentPageNumber(currentId); } } exports.PDFViewer = PDFViewer;
/***/ })
/******/ ]);
});
//# sourceMappingURL=pdf_viewer.js.map
"use strict"; var pdfViewer=null; var pdfColor=null; $(function() { if(!$("#viewerContainer").length) return; var width=$(window).width(); $(window).on("resize",function() { if(width==$(window).width()) return; width=$(window).width(); pdfViewer.currentScaleValue="page-width"; }); $("body").on("pdfjs",function() { var color=$("#viewerContainer").attr("data-color"); pdfColor=[parseInt(color.substr(0,2),16),parseInt(color.substr(2,2),16),parseInt(color.substr(4,2),16)]; if(pdfViewer==null) { pdfjsLib.GlobalWorkerOptions.workerSrc="pdfjs/pdf.worker.min.js"; var file=$("#viewerContainer").attr("data-file"); pdfjsLib.getDocument(file).promise.then(function(pdfDocument) { var container=document.getElementById("viewerContainer"); var eventBus=new pdfjsViewer.EventBus(); pdfViewer=new pdfjsViewer.PDFViewer({ container:container, eventBus:eventBus, }); var fn1=function() { pdfViewer.currentScaleValue="page-width"; }; var fn2=function() { $("a",container).each(function() { $(this).attr("target","_blank"); }); }; eventBus.on("pagesinit",fn1); eventBus.on("textlayerrendered",fn2); pdfViewer.removePageBorders=true; pdfViewer.setDocument(pdfDocument); },function(message,exception) { console.log(message); console.log(exception); }); } else {
pdfViewer.currentScaleValue=pdfViewer.currentScale*2; // TRUC PER FORZAR EL REDIBUIXAT DEL PDF
pdfViewer.currentScaleValue="page-width"; } }).trigger("pdfjs"); });