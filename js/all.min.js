/*! jQuery v3.4.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(e,t){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error("jQuery requires a window with a document");return t(e)}:t(e)}("undefined"!=typeof window?window:this,function(C,e){"use strict";var t=[],E=C.document,r=Object.getPrototypeOf,s=t.slice,g=t.concat,u=t.push,i=t.indexOf,n={},o=n.toString,v=n.hasOwnProperty,a=v.toString,l=a.call(Object),y={},m=function(e){return"function"==typeof e&&"number"!=typeof e.nodeType},x=function(e){return null!=e&&e===e.window},c={type:!0,src:!0,nonce:!0,noModule:!0};function b(e,t,n){var r,i,o=(n=n||E).createElement("script");if(o.text=e,t)for(r in c)(i=t[r]||t.getAttribute&&t.getAttribute(r))&&o.setAttribute(r,i);n.head.appendChild(o).parentNode.removeChild(o)}function w(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?n[o.call(e)]||"object":typeof e}var f="3.4.1",k=function(e,t){return new k.fn.init(e,t)},p=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;function d(e){var t=!!e&&"length"in e&&e.length,n=w(e);return!m(e)&&!x(e)&&("array"===n||0===t||"number"==typeof t&&0<t&&t-1 in e)}k.fn=k.prototype={jquery:f,constructor:k,length:0,toArray:function(){return s.call(this)},get:function(e){return null==e?s.call(this):e<0?this[e+this.length]:this[e]},pushStack:function(e){var t=k.merge(this.constructor(),e);return t.prevObject=this,t},each:function(e){return k.each(this,e)},map:function(n){return this.pushStack(k.map(this,function(e,t){return n.call(e,t,e)}))},slice:function(){return this.pushStack(s.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(e<0?t:0);return this.pushStack(0<=n&&n<t?[this[n]]:[])},end:function(){return this.prevObject||this.constructor()},push:u,sort:t.sort,splice:t.splice},k.extend=k.fn.extend=function(){var e,t,n,r,i,o,a=arguments[0]||{},s=1,u=arguments.length,l=!1;for("boolean"==typeof a&&(l=a,a=arguments[s]||{},s++),"object"==typeof a||m(a)||(a={}),s===u&&(a=this,s--);s<u;s++)if(null!=(e=arguments[s]))for(t in e)r=e[t],"__proto__"!==t&&a!==r&&(l&&r&&(k.isPlainObject(r)||(i=Array.isArray(r)))?(n=a[t],o=i&&!Array.isArray(n)?[]:i||k.isPlainObject(n)?n:{},i=!1,a[t]=k.extend(l,o,r)):void 0!==r&&(a[t]=r));return a},k.extend({expando:"jQuery"+(f+Math.random()).replace(/\D/g,""),isReady:!0,error:function(e){throw new Error(e)},noop:function(){},isPlainObject:function(e){var t,n;return!(!e||"[object Object]"!==o.call(e))&&(!(t=r(e))||"function"==typeof(n=v.call(t,"constructor")&&t.constructor)&&a.call(n)===l)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},globalEval:function(e,t){b(e,{nonce:t&&t.nonce})},each:function(e,t){var n,r=0;if(d(e)){for(n=e.length;r<n;r++)if(!1===t.call(e[r],r,e[r]))break}else for(r in e)if(!1===t.call(e[r],r,e[r]))break;return e},trim:function(e){return null==e?"":(e+"").replace(p,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(d(Object(e))?k.merge(n,"string"==typeof e?[e]:e):u.call(n,e)),n},inArray:function(e,t,n){return null==t?-1:i.call(t,e,n)},merge:function(e,t){for(var n=+t.length,r=0,i=e.length;r<n;r++)e[i++]=t[r];return e.length=i,e},grep:function(e,t,n){for(var r=[],i=0,o=e.length,a=!n;i<o;i++)!t(e[i],i)!==a&&r.push(e[i]);return r},map:function(e,t,n){var r,i,o=0,a=[];if(d(e))for(r=e.length;o<r;o++)null!=(i=t(e[o],o,n))&&a.push(i);else for(o in e)null!=(i=t(e[o],o,n))&&a.push(i);return g.apply([],a)},guid:1,support:y}),"function"==typeof Symbol&&(k.fn[Symbol.iterator]=t[Symbol.iterator]),k.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(e,t){n["[object "+t+"]"]=t.toLowerCase()});var h=function(n){var e,d,b,o,i,h,f,g,w,u,l,T,C,a,E,v,s,c,y,k="sizzle"+1*new Date,m=n.document,S=0,r=0,p=ue(),x=ue(),N=ue(),A=ue(),D=function(e,t){return e===t&&(l=!0),0},j={}.hasOwnProperty,t=[],q=t.pop,L=t.push,H=t.push,O=t.slice,P=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return-1},R="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",I="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",W="\\["+M+"*("+I+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+I+"))|)"+M+"*\\]",$=":("+I+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+W+")*)|.*)\\)|)",F=new RegExp(M+"+","g"),B=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),_=new RegExp("^"+M+"*,"+M+"*"),z=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp(M+"|>"),X=new RegExp($),V=new RegExp("^"+I+"$"),G={ID:new RegExp("^#("+I+")"),CLASS:new RegExp("^\\.("+I+")"),TAG:new RegExp("^("+I+"|[*])"),ATTR:new RegExp("^"+W),PSEUDO:new RegExp("^"+$),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+R+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/HTML$/i,Q=/^(?:input|select|textarea|button)$/i,J=/^h\d$/i,K=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),ne=function(e,t,n){var r="0x"+t-65536;return r!=r||n?t:r<0?String.fromCharCode(r+65536):String.fromCharCode(r>>10|55296,1023&r|56320)},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){T()},ae=be(function(e){return!0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{H.apply(t=O.call(m.childNodes),m.childNodes),t[m.childNodes.length].nodeType}catch(e){H={apply:t.length?function(e,t){L.apply(e,O.call(t))}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1}}}function se(t,e,n,r){var i,o,a,s,u,l,c,f=e&&e.ownerDocument,p=e?e.nodeType:9;if(n=n||[],"string"!=typeof t||!t||1!==p&&9!==p&&11!==p)return n;if(!r&&((e?e.ownerDocument||e:m)!==C&&T(e),e=e||C,E)){if(11!==p&&(u=Z.exec(t)))if(i=u[1]){if(9===p){if(!(a=e.getElementById(i)))return n;if(a.id===i)return n.push(a),n}else if(f&&(a=f.getElementById(i))&&y(e,a)&&a.id===i)return n.push(a),n}else{if(u[2])return H.apply(n,e.getElementsByTagName(t)),n;if((i=u[3])&&d.getElementsByClassName&&e.getElementsByClassName)return H.apply(n,e.getElementsByClassName(i)),n}if(d.qsa&&!A[t+" "]&&(!v||!v.test(t))&&(1!==p||"object"!==e.nodeName.toLowerCase())){if(c=t,f=e,1===p&&U.test(t)){(s=e.getAttribute("id"))?s=s.replace(re,ie):e.setAttribute("id",s=k),o=(l=h(t)).length;while(o--)l[o]="#"+s+" "+xe(l[o]);c=l.join(","),f=ee.test(t)&&ye(e.parentNode)||e}try{return H.apply(n,f.querySelectorAll(c)),n}catch(e){A(t,!0)}finally{s===k&&e.removeAttribute("id")}}}return g(t.replace(B,"$1"),e,n,r)}function ue(){var r=[];return function e(t,n){return r.push(t+" ")>b.cacheLength&&delete e[r.shift()],e[t+" "]=n}}function le(e){return e[k]=!0,e}function ce(e){var t=C.createElement("fieldset");try{return!!e(t)}catch(e){return!1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null}}function fe(e,t){var n=e.split("|"),r=n.length;while(r--)b.attrHandle[n[r]]=t}function pe(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function de(t){return function(e){return"input"===e.nodeName.toLowerCase()&&e.type===t}}function he(n){return function(e){var t=e.nodeName.toLowerCase();return("input"===t||"button"===t)&&e.type===n}}function ge(t){return function(e){return"form"in e?e.parentNode&&!1===e.disabled?"label"in e?"label"in e.parentNode?e.parentNode.disabled===t:e.disabled===t:e.isDisabled===t||e.isDisabled!==!t&&ae(e)===t:e.disabled===t:"label"in e&&e.disabled===t}}function ve(a){return le(function(o){return o=+o,le(function(e,t){var n,r=a([],e.length,o),i=r.length;while(i--)e[n=r[i]]&&(e[n]=!(t[n]=e[n]))})})}function ye(e){return e&&"undefined"!=typeof e.getElementsByTagName&&e}for(e in d=se.support={},i=se.isXML=function(e){var t=e.namespaceURI,n=(e.ownerDocument||e).documentElement;return!Y.test(t||n&&n.nodeName||"HTML")},T=se.setDocument=function(e){var t,n,r=e?e.ownerDocument||e:m;return r!==C&&9===r.nodeType&&r.documentElement&&(a=(C=r).documentElement,E=!i(C),m!==C&&(n=C.defaultView)&&n.top!==n&&(n.addEventListener?n.addEventListener("unload",oe,!1):n.attachEvent&&n.attachEvent("onunload",oe)),d.attributes=ce(function(e){return e.className="i",!e.getAttribute("className")}),d.getElementsByTagName=ce(function(e){return e.appendChild(C.createComment("")),!e.getElementsByTagName("*").length}),d.getElementsByClassName=K.test(C.getElementsByClassName),d.getById=ce(function(e){return a.appendChild(e).id=k,!C.getElementsByName||!C.getElementsByName(k).length}),d.getById?(b.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n=t.getElementById(e);return n?[n]:[]}}):(b.filter.ID=function(e){var n=e.replace(te,ne);return function(e){var t="undefined"!=typeof e.getAttributeNode&&e.getAttributeNode("id");return t&&t.value===n}},b.find.ID=function(e,t){if("undefined"!=typeof t.getElementById&&E){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return[o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return[o]}return[]}}),b.find.TAG=d.getElementsByTagName?function(e,t){return"undefined"!=typeof t.getElementsByTagName?t.getElementsByTagName(e):d.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},b.find.CLASS=d.getElementsByClassName&&function(e,t){if("undefined"!=typeof t.getElementsByClassName&&E)return t.getElementsByClassName(e)},s=[],v=[],(d.qsa=K.test(C.querySelectorAll))&&(ce(function(e){a.appendChild(e).innerHTML="<a id='"+k+"'></a><select id='"+k+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&v.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||v.push("\\["+M+"*(?:value|"+R+")"),e.querySelectorAll("[id~="+k+"-]").length||v.push("~="),e.querySelectorAll(":checked").length||v.push(":checked"),e.querySelectorAll("a#"+k+"+*").length||v.push(".#.+[+~]")}),ce(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=C.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&v.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&v.push(":enabled",":disabled"),a.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&v.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),v.push(",.*:")})),(d.matchesSelector=K.test(c=a.matches||a.webkitMatchesSelector||a.mozMatchesSelector||a.oMatchesSelector||a.msMatchesSelector))&&ce(function(e){d.disconnectedMatch=c.call(e,"*"),c.call(e,"[s!='']:x"),s.push("!=",$)}),v=v.length&&new RegExp(v.join("|")),s=s.length&&new RegExp(s.join("|")),t=K.test(a.compareDocumentPosition),y=t||K.test(a.contains)?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},D=t?function(e,t){if(e===t)return l=!0,0;var n=!e.compareDocumentPosition-!t.compareDocumentPosition;return n||(1&(n=(e.ownerDocument||e)===(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!d.sortDetached&&t.compareDocumentPosition(e)===n?e===C||e.ownerDocument===m&&y(m,e)?-1:t===C||t.ownerDocument===m&&y(m,t)?1:u?P(u,e)-P(u,t):0:4&n?-1:1)}:function(e,t){if(e===t)return l=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,a=[e],s=[t];if(!i||!o)return e===C?-1:t===C?1:i?-1:o?1:u?P(u,e)-P(u,t):0;if(i===o)return pe(e,t);n=e;while(n=n.parentNode)a.unshift(n);n=t;while(n=n.parentNode)s.unshift(n);while(a[r]===s[r])r++;return r?pe(a[r],s[r]):a[r]===m?-1:s[r]===m?1:0}),C},se.matches=function(e,t){return se(e,null,null,t)},se.matchesSelector=function(e,t){if((e.ownerDocument||e)!==C&&T(e),d.matchesSelector&&E&&!A[t+" "]&&(!s||!s.test(t))&&(!v||!v.test(t)))try{var n=c.call(e,t);if(n||d.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(e){A(t,!0)}return 0<se(t,C,null,[e]).length},se.contains=function(e,t){return(e.ownerDocument||e)!==C&&T(e),y(e,t)},se.attr=function(e,t){(e.ownerDocument||e)!==C&&T(e);var n=b.attrHandle[t.toLowerCase()],r=n&&j.call(b.attrHandle,t.toLowerCase())?n(e,t,!E):void 0;return void 0!==r?r:d.attributes||!E?e.getAttribute(t):(r=e.getAttributeNode(t))&&r.specified?r.value:null},se.escape=function(e){return(e+"").replace(re,ie)},se.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},se.uniqueSort=function(e){var t,n=[],r=0,i=0;if(l=!d.detectDuplicates,u=!d.sortStable&&e.slice(0),e.sort(D),l){while(t=e[i++])t===e[i]&&(r=n.push(i));while(r--)e.splice(n[r],1)}return u=null,e},o=se.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else while(t=e[r++])n+=o(t);return n},(b=se.selectors={cacheLength:50,createPseudo:le,match:G,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||se.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&se.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return G.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=h(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return"*"===e?function(){return!0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=p[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&p(e,function(e){return t.test("string"==typeof e.className&&e.className||"undefined"!=typeof e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(n,r,i){return function(e){var t=se.attr(e,n);return null==t?"!="===r:!r||(t+="","="===r?t===i:"!="===r?t!==i:"^="===r?i&&0===t.indexOf(i):"*="===r?i&&-1<t.indexOf(i):"$="===r?i&&t.slice(-i.length)===i:"~="===r?-1<(" "+t.replace(F," ")+" ").indexOf(i):"|="===r&&(t===i||t.slice(0,i.length+1)===i+"-"))}},CHILD:function(h,e,t,g,v){var y="nth"!==h.slice(0,3),m="last"!==h.slice(-4),x="of-type"===e;return 1===g&&0===v?function(e){return!!e.parentNode}:function(e,t,n){var r,i,o,a,s,u,l=y!==m?"nextSibling":"previousSibling",c=e.parentNode,f=x&&e.nodeName.toLowerCase(),p=!n&&!x,d=!1;if(c){if(y){while(l){a=e;while(a=a[l])if(x?a.nodeName.toLowerCase()===f:1===a.nodeType)return!1;u=l="only"===h&&!u&&"nextSibling"}return!0}if(u=[m?c.firstChild:c.lastChild],m&&p){d=(s=(r=(i=(o=(a=c)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1])&&r[2],a=s&&c.childNodes[s];while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if(1===a.nodeType&&++d&&a===e){i[h]=[S,s,d];break}}else if(p&&(d=s=(r=(i=(o=(a=e)[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]||[])[0]===S&&r[1]),!1===d)while(a=++s&&a&&a[l]||(d=s=0)||u.pop())if((x?a.nodeName.toLowerCase()===f:1===a.nodeType)&&++d&&(p&&((i=(o=a[k]||(a[k]={}))[a.uniqueID]||(o[a.uniqueID]={}))[h]=[S,d]),a===e))break;return(d-=v)===g||d%g==0&&0<=d/g}}},PSEUDO:function(e,o){var t,a=b.pseudos[e]||b.setFilters[e.toLowerCase()]||se.error("unsupported pseudo: "+e);return a[k]?a(o):1<a.length?(t=[e,e,"",o],b.setFilters.hasOwnProperty(e.toLowerCase())?le(function(e,t){var n,r=a(e,o),i=r.length;while(i--)e[n=P(e,r[i])]=!(t[n]=r[i])}):function(e){return a(e,0,t)}):a}},pseudos:{not:le(function(e){var r=[],i=[],s=f(e.replace(B,"$1"));return s[k]?le(function(e,t,n,r){var i,o=s(e,null,r,[]),a=e.length;while(a--)(i=o[a])&&(e[a]=!(t[a]=i))}):function(e,t,n){return r[0]=e,s(r,null,n,i),r[0]=null,!i.pop()}}),has:le(function(t){return function(e){return 0<se(t,e).length}}),contains:le(function(t){return t=t.replace(te,ne),function(e){return-1<(e.textContent||o(e)).indexOf(t)}}),lang:le(function(n){return V.test(n||"")||se.error("unsupported lang: "+n),n=n.replace(te,ne).toLowerCase(),function(e){var t;do{if(t=E?e.lang:e.getAttribute("xml:lang")||e.getAttribute("lang"))return(t=t.toLowerCase())===n||0===t.indexOf(n+"-")}while((e=e.parentNode)&&1===e.nodeType);return!1}}),target:function(e){var t=n.location&&n.location.hash;return t&&t.slice(1)===e.id},root:function(e){return e===a},focus:function(e){return e===C.activeElement&&(!C.hasFocus||C.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:ge(!1),disabled:ge(!0),checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return!1;return!0},parent:function(e){return!b.pseudos.empty(e)},header:function(e){return J.test(e.nodeName)},input:function(e){return Q.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:ve(function(){return[0]}),last:ve(function(e,t){return[t-1]}),eq:ve(function(e,t,n){return[n<0?n+t:n]}),even:ve(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:ve(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:ve(function(e,t,n){for(var r=n<0?n+t:t<n?t:n;0<=--r;)e.push(r);return e}),gt:ve(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=b.pseudos.eq,{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})b.pseudos[e]=de(e);for(e in{submit:!0,reset:!0})b.pseudos[e]=he(e);function me(){}function xe(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function be(s,e,t){var u=e.dir,l=e.next,c=l||u,f=t&&"parentNode"===c,p=r++;return e.first?function(e,t,n){while(e=e[u])if(1===e.nodeType||f)return s(e,t,n);return!1}:function(e,t,n){var r,i,o,a=[S,p];if(n){while(e=e[u])if((1===e.nodeType||f)&&s(e,t,n))return!0}else while(e=e[u])if(1===e.nodeType||f)if(i=(o=e[k]||(e[k]={}))[e.uniqueID]||(o[e.uniqueID]={}),l&&l===e.nodeName.toLowerCase())e=e[u]||e;else{if((r=i[c])&&r[0]===S&&r[1]===p)return a[2]=r[2];if((i[c]=a)[2]=s(e,t,n))return!0}return!1}}function we(i){return 1<i.length?function(e,t,n){var r=i.length;while(r--)if(!i[r](e,t,n))return!1;return!0}:i[0]}function Te(e,t,n,r,i){for(var o,a=[],s=0,u=e.length,l=null!=t;s<u;s++)(o=e[s])&&(n&&!n(o,r,i)||(a.push(o),l&&t.push(s)));return a}function Ce(d,h,g,v,y,e){return v&&!v[k]&&(v=Ce(v)),y&&!y[k]&&(y=Ce(y,e)),le(function(e,t,n,r){var i,o,a,s=[],u=[],l=t.length,c=e||function(e,t,n){for(var r=0,i=t.length;r<i;r++)se(e,t[r],n);return n}(h||"*",n.nodeType?[n]:n,[]),f=!d||!e&&h?c:Te(c,s,d,n,r),p=g?y||(e?d:l||v)?[]:t:f;if(g&&g(f,p,n,r),v){i=Te(p,u),v(i,[],n,r),o=i.length;while(o--)(a=i[o])&&(p[u[o]]=!(f[u[o]]=a))}if(e){if(y||d){if(y){i=[],o=p.length;while(o--)(a=p[o])&&i.push(f[o]=a);y(null,p=[],i,r)}o=p.length;while(o--)(a=p[o])&&-1<(i=y?P(e,a):s[o])&&(e[i]=!(t[i]=a))}}else p=Te(p===t?p.splice(l,p.length):p),y?y(null,t,p,r):H.apply(t,p)})}function Ee(e){for(var i,t,n,r=e.length,o=b.relative[e[0].type],a=o||b.relative[" "],s=o?1:0,u=be(function(e){return e===i},a,!0),l=be(function(e){return-1<P(i,e)},a,!0),c=[function(e,t,n){var r=!o&&(n||t!==w)||((i=t).nodeType?u(e,t,n):l(e,t,n));return i=null,r}];s<r;s++)if(t=b.relative[e[s].type])c=[be(we(c),t)];else{if((t=b.filter[e[s].type].apply(null,e[s].matches))[k]){for(n=++s;n<r;n++)if(b.relative[e[n].type])break;return Ce(1<s&&we(c),1<s&&xe(e.slice(0,s-1).concat({value:" "===e[s-2].type?"*":""})).replace(B,"$1"),t,s<n&&Ee(e.slice(s,n)),n<r&&Ee(e=e.slice(n)),n<r&&xe(e))}c.push(t)}return we(c)}return me.prototype=b.filters=b.pseudos,b.setFilters=new me,h=se.tokenize=function(e,t){var n,r,i,o,a,s,u,l=x[e+" "];if(l)return t?0:l.slice(0);a=e,s=[],u=b.preFilter;while(a){for(o in n&&!(r=_.exec(a))||(r&&(a=a.slice(r[0].length)||a),s.push(i=[])),n=!1,(r=z.exec(a))&&(n=r.shift(),i.push({value:n,type:r[0].replace(B," ")}),a=a.slice(n.length)),b.filter)!(r=G[o].exec(a))||u[o]&&!(r=u[o](r))||(n=r.shift(),i.push({value:n,type:o,matches:r}),a=a.slice(n.length));if(!n)break}return t?a.length:a?se.error(e):x(e,s).slice(0)},f=se.compile=function(e,t){var n,v,y,m,x,r,i=[],o=[],a=N[e+" "];if(!a){t||(t=h(e)),n=t.length;while(n--)(a=Ee(t[n]))[k]?i.push(a):o.push(a);(a=N(e,(v=o,m=0<(y=i).length,x=0<v.length,r=function(e,t,n,r,i){var o,a,s,u=0,l="0",c=e&&[],f=[],p=w,d=e||x&&b.find.TAG("*",i),h=S+=null==p?1:Math.random()||.1,g=d.length;for(i&&(w=t===C||t||i);l!==g&&null!=(o=d[l]);l++){if(x&&o){a=0,t||o.ownerDocument===C||(T(o),n=!E);while(s=v[a++])if(s(o,t||C,n)){r.push(o);break}i&&(S=h)}m&&((o=!s&&o)&&u--,e&&c.push(o))}if(u+=l,m&&l!==u){a=0;while(s=y[a++])s(c,f,t,n);if(e){if(0<u)while(l--)c[l]||f[l]||(f[l]=q.call(r));f=Te(f)}H.apply(r,f),i&&!e&&0<f.length&&1<u+y.length&&se.uniqueSort(r)}return i&&(S=h,w=p),c},m?le(r):r))).selector=e}return a},g=se.select=function(e,t,n,r){var i,o,a,s,u,l="function"==typeof e&&e,c=!r&&h(e=l.selector||e);if(n=n||[],1===c.length){if(2<(o=c[0]=c[0].slice(0)).length&&"ID"===(a=o[0]).type&&9===t.nodeType&&E&&b.relative[o[1].type]){if(!(t=(b.find.ID(a.matches[0].replace(te,ne),t)||[])[0]))return n;l&&(t=t.parentNode),e=e.slice(o.shift().value.length)}i=G.needsContext.test(e)?0:o.length;while(i--){if(a=o[i],b.relative[s=a.type])break;if((u=b.find[s])&&(r=u(a.matches[0].replace(te,ne),ee.test(o[0].type)&&ye(t.parentNode)||t))){if(o.splice(i,1),!(e=r.length&&xe(o)))return H.apply(n,r),n;break}}}return(l||f(e,c))(r,t,!E,n,!t||ee.test(e)&&ye(t.parentNode)||t),n},d.sortStable=k.split("").sort(D).join("")===k,d.detectDuplicates=!!l,T(),d.sortDetached=ce(function(e){return 1&e.compareDocumentPosition(C.createElement("fieldset"))}),ce(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),d.attributes&&ce(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),ce(function(e){return null==e.getAttribute("disabled")})||fe(R,function(e,t,n){var r;if(!n)return!0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null}),se}(C);k.find=h,k.expr=h.selectors,k.expr[":"]=k.expr.pseudos,k.uniqueSort=k.unique=h.uniqueSort,k.text=h.getText,k.isXMLDoc=h.isXML,k.contains=h.contains,k.escapeSelector=h.escape;var T=function(e,t,n){var r=[],i=void 0!==n;while((e=e[t])&&9!==e.nodeType)if(1===e.nodeType){if(i&&k(e).is(n))break;r.push(e)}return r},S=function(e,t){for(var n=[];e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n},N=k.expr.match.needsContext;function A(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()}var D=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;function j(e,n,r){return m(n)?k.grep(e,function(e,t){return!!n.call(e,t,e)!==r}):n.nodeType?k.grep(e,function(e){return e===n!==r}):"string"!=typeof n?k.grep(e,function(e){return-1<i.call(n,e)!==r}):k.filter(n,e,r)}k.filter=function(e,t,n){var r=t[0];return n&&(e=":not("+e+")"),1===t.length&&1===r.nodeType?k.find.matchesSelector(r,e)?[r]:[]:k.find.matches(e,k.grep(t,function(e){return 1===e.nodeType}))},k.fn.extend({find:function(e){var t,n,r=this.length,i=this;if("string"!=typeof e)return this.pushStack(k(e).filter(function(){for(t=0;t<r;t++)if(k.contains(i[t],this))return!0}));for(n=this.pushStack([]),t=0;t<r;t++)k.find(e,i[t],n);return 1<r?k.uniqueSort(n):n},filter:function(e){return this.pushStack(j(this,e||[],!1))},not:function(e){return this.pushStack(j(this,e||[],!0))},is:function(e){return!!j(this,"string"==typeof e&&N.test(e)?k(e):e||[],!1).length}});var q,L=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;(k.fn.init=function(e,t,n){var r,i;if(!e)return this;if(n=n||q,"string"==typeof e){if(!(r="<"===e[0]&&">"===e[e.length-1]&&3<=e.length?[null,e,null]:L.exec(e))||!r[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(r[1]){if(t=t instanceof k?t[0]:t,k.merge(this,k.parseHTML(r[1],t&&t.nodeType?t.ownerDocument||t:E,!0)),D.test(r[1])&&k.isPlainObject(t))for(r in t)m(this[r])?this[r](t[r]):this.attr(r,t[r]);return this}return(i=E.getElementById(r[2]))&&(this[0]=i,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):m(e)?void 0!==n.ready?n.ready(e):e(k):k.makeArray(e,this)}).prototype=k.fn,q=k(E);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};function P(e,t){while((e=e[t])&&1!==e.nodeType);return e}k.fn.extend({has:function(e){var t=k(e,this),n=t.length;return this.filter(function(){for(var e=0;e<n;e++)if(k.contains(this,t[e]))return!0})},closest:function(e,t){var n,r=0,i=this.length,o=[],a="string"!=typeof e&&k(e);if(!N.test(e))for(;r<i;r++)for(n=this[r];n&&n!==t;n=n.parentNode)if(n.nodeType<11&&(a?-1<a.index(n):1===n.nodeType&&k.find.matchesSelector(n,e))){o.push(n);break}return this.pushStack(1<o.length?k.uniqueSort(o):o)},index:function(e){return e?"string"==typeof e?i.call(k(e),this[0]):i.call(this,e.jquery?e[0]:e):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){return this.pushStack(k.uniqueSort(k.merge(this.get(),k(e,t))))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),k.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return T(e,"parentNode")},parentsUntil:function(e,t,n){return T(e,"parentNode",n)},next:function(e){return P(e,"nextSibling")},prev:function(e){return P(e,"previousSibling")},nextAll:function(e){return T(e,"nextSibling")},prevAll:function(e){return T(e,"previousSibling")},nextUntil:function(e,t,n){return T(e,"nextSibling",n)},prevUntil:function(e,t,n){return T(e,"previousSibling",n)},siblings:function(e){return S((e.parentNode||{}).firstChild,e)},children:function(e){return S(e.firstChild)},contents:function(e){return"undefined"!=typeof e.contentDocument?e.contentDocument:(A(e,"template")&&(e=e.content||e),k.merge([],e.childNodes))}},function(r,i){k.fn[r]=function(e,t){var n=k.map(this,i,e);return"Until"!==r.slice(-5)&&(t=e),t&&"string"==typeof t&&(n=k.filter(t,n)),1<this.length&&(O[r]||k.uniqueSort(n),H.test(r)&&n.reverse()),this.pushStack(n)}});var R=/[^\x20\t\r\n\f]+/g;function M(e){return e}function I(e){throw e}function W(e,t,n,r){var i;try{e&&m(i=e.promise)?i.call(e).done(t).fail(n):e&&m(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}k.Callbacks=function(r){var e,n;r="string"==typeof r?(e=r,n={},k.each(e.match(R)||[],function(e,t){n[t]=!0}),n):k.extend({},r);var i,t,o,a,s=[],u=[],l=-1,c=function(){for(a=a||r.once,o=i=!0;u.length;l=-1){t=u.shift();while(++l<s.length)!1===s[l].apply(t[0],t[1])&&r.stopOnFalse&&(l=s.length,t=!1)}r.memory||(t=!1),i=!1,a&&(s=t?[]:"")},f={add:function(){return s&&(t&&!i&&(l=s.length-1,u.push(t)),function n(e){k.each(e,function(e,t){m(t)?r.unique&&f.has(t)||s.push(t):t&&t.length&&"string"!==w(t)&&n(t)})}(arguments),t&&!i&&c()),this},remove:function(){return k.each(arguments,function(e,t){var n;while(-1<(n=k.inArray(t,s,n)))s.splice(n,1),n<=l&&l--}),this},has:function(e){return e?-1<k.inArray(e,s):0<s.length},empty:function(){return s&&(s=[]),this},disable:function(){return a=u=[],s=t="",this},disabled:function(){return!s},lock:function(){return a=u=[],t||i||(s=t=""),this},locked:function(){return!!a},fireWith:function(e,t){return a||(t=[e,(t=t||[]).slice?t.slice():t],u.push(t),i||c()),this},fire:function(){return f.fireWith(this,arguments),this},fired:function(){return!!o}};return f},k.extend({Deferred:function(e){var o=[["notify","progress",k.Callbacks("memory"),k.Callbacks("memory"),2],["resolve","done",k.Callbacks("once memory"),k.Callbacks("once memory"),0,"resolved"],["reject","fail",k.Callbacks("once memory"),k.Callbacks("once memory"),1,"rejected"]],i="pending",a={state:function(){return i},always:function(){return s.done(arguments).fail(arguments),this},"catch":function(e){return a.then(null,e)},pipe:function(){var i=arguments;return k.Deferred(function(r){k.each(o,function(e,t){var n=m(i[t[4]])&&i[t[4]];s[t[1]](function(){var e=n&&n.apply(this,arguments);e&&m(e.promise)?e.promise().progress(r.notify).done(r.resolve).fail(r.reject):r[t[0]+"With"](this,n?[e]:arguments)})}),i=null}).promise()},then:function(t,n,r){var u=0;function l(i,o,a,s){return function(){var n=this,r=arguments,e=function(){var e,t;if(!(i<u)){if((e=a.apply(n,r))===o.promise())throw new TypeError("Thenable self-resolution");t=e&&("object"==typeof e||"function"==typeof e)&&e.then,m(t)?s?t.call(e,l(u,o,M,s),l(u,o,I,s)):(u++,t.call(e,l(u,o,M,s),l(u,o,I,s),l(u,o,M,o.notifyWith))):(a!==M&&(n=void 0,r=[e]),(s||o.resolveWith)(n,r))}},t=s?e:function(){try{e()}catch(e){k.Deferred.exceptionHook&&k.Deferred.exceptionHook(e,t.stackTrace),u<=i+1&&(a!==I&&(n=void 0,r=[e]),o.rejectWith(n,r))}};i?t():(k.Deferred.getStackHook&&(t.stackTrace=k.Deferred.getStackHook()),C.setTimeout(t))}}return k.Deferred(function(e){o[0][3].add(l(0,e,m(r)?r:M,e.notifyWith)),o[1][3].add(l(0,e,m(t)?t:M)),o[2][3].add(l(0,e,m(n)?n:I))}).promise()},promise:function(e){return null!=e?k.extend(e,a):a}},s={};return k.each(o,function(e,t){var n=t[2],r=t[5];a[t[1]]=n.add,r&&n.add(function(){i=r},o[3-e][2].disable,o[3-e][3].disable,o[0][2].lock,o[0][3].lock),n.add(t[3].fire),s[t[0]]=function(){return s[t[0]+"With"](this===s?void 0:this,arguments),this},s[t[0]+"With"]=n.fireWith}),a.promise(s),e&&e.call(s,s),s},when:function(e){var n=arguments.length,t=n,r=Array(t),i=s.call(arguments),o=k.Deferred(),a=function(t){return function(e){r[t]=this,i[t]=1<arguments.length?s.call(arguments):e,--n||o.resolveWith(r,i)}};if(n<=1&&(W(e,o.done(a(t)).resolve,o.reject,!n),"pending"===o.state()||m(i[t]&&i[t].then)))return o.then();while(t--)W(i[t],a(t),o.reject);return o.promise()}});var $=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;k.Deferred.exceptionHook=function(e,t){C.console&&C.console.warn&&e&&$.test(e.name)&&C.console.warn("jQuery.Deferred exception: "+e.message,e.stack,t)},k.readyException=function(e){C.setTimeout(function(){throw e})};var F=k.Deferred();function B(){E.removeEventListener("DOMContentLoaded",B),C.removeEventListener("load",B),k.ready()}k.fn.ready=function(e){return F.then(e)["catch"](function(e){k.readyException(e)}),this},k.extend({isReady:!1,readyWait:1,ready:function(e){(!0===e?--k.readyWait:k.isReady)||(k.isReady=!0)!==e&&0<--k.readyWait||F.resolveWith(E,[k])}}),k.ready.then=F.then,"complete"===E.readyState||"loading"!==E.readyState&&!E.documentElement.doScroll?C.setTimeout(k.ready):(E.addEventListener("DOMContentLoaded",B),C.addEventListener("load",B));var _=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if("object"===w(n))for(s in i=!0,n)_(e,t,s,n[s],!0,o,a);else if(void 0!==r&&(i=!0,m(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(k(e),n)})),t))for(;s<u;s++)t(e[s],n,a?r:r.call(e[s],s,t(e[s],n)));return i?e:l?t.call(e):u?t(e[0],n):o},z=/^-ms-/,U=/-([a-z])/g;function X(e,t){return t.toUpperCase()}function V(e){return e.replace(z,"ms-").replace(U,X)}var G=function(e){return 1===e.nodeType||9===e.nodeType||!+e.nodeType};function Y(){this.expando=k.expando+Y.uid++}Y.uid=1,Y.prototype={cache:function(e){var t=e[this.expando];return t||(t={},G(e)&&(e.nodeType?e[this.expando]=t:Object.defineProperty(e,this.expando,{value:t,configurable:!0}))),t},set:function(e,t,n){var r,i=this.cache(e);if("string"==typeof t)i[V(t)]=n;else for(r in t)i[V(r)]=t[r];return i},get:function(e,t){return void 0===t?this.cache(e):e[this.expando]&&e[this.expando][V(t)]},access:function(e,t,n){return void 0===t||t&&"string"==typeof t&&void 0===n?this.get(e,t):(this.set(e,t,n),void 0!==n?n:t)},remove:function(e,t){var n,r=e[this.expando];if(void 0!==r){if(void 0!==t){n=(t=Array.isArray(t)?t.map(V):(t=V(t))in r?[t]:t.match(R)||[]).length;while(n--)delete r[t[n]]}(void 0===t||k.isEmptyObject(r))&&(e.nodeType?e[this.expando]=void 0:delete e[this.expando])}},hasData:function(e){var t=e[this.expando];return void 0!==t&&!k.isEmptyObject(t)}};var Q=new Y,J=new Y,K=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function ee(e,t,n){var r,i;if(void 0===n&&1===e.nodeType)if(r="data-"+t.replace(Z,"-$&").toLowerCase(),"string"==typeof(n=e.getAttribute(r))){try{n="true"===(i=n)||"false"!==i&&("null"===i?null:i===+i+""?+i:K.test(i)?JSON.parse(i):i)}catch(e){}J.set(e,t,n)}else n=void 0;return n}k.extend({hasData:function(e){return J.hasData(e)||Q.hasData(e)},data:function(e,t,n){return J.access(e,t,n)},removeData:function(e,t){J.remove(e,t)},_data:function(e,t,n){return Q.access(e,t,n)},_removeData:function(e,t){Q.remove(e,t)}}),k.fn.extend({data:function(n,e){var t,r,i,o=this[0],a=o&&o.attributes;if(void 0===n){if(this.length&&(i=J.get(o),1===o.nodeType&&!Q.get(o,"hasDataAttrs"))){t=a.length;while(t--)a[t]&&0===(r=a[t].name).indexOf("data-")&&(r=V(r.slice(5)),ee(o,r,i[r]));Q.set(o,"hasDataAttrs",!0)}return i}return"object"==typeof n?this.each(function(){J.set(this,n)}):_(this,function(e){var t;if(o&&void 0===e)return void 0!==(t=J.get(o,n))?t:void 0!==(t=ee(o,n))?t:void 0;this.each(function(){J.set(this,n,e)})},null,e,1<arguments.length,null,!0)},removeData:function(e){return this.each(function(){J.remove(this,e)})}}),k.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=Q.get(e,t),n&&(!r||Array.isArray(n)?r=Q.access(e,t,k.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=k.queue(e,t),r=n.length,i=n.shift(),o=k._queueHooks(e,t);"inprogress"===i&&(i=n.shift(),r--),i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,function(){k.dequeue(e,t)},o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return Q.get(e,n)||Q.access(e,n,{empty:k.Callbacks("once memory").add(function(){Q.remove(e,[t+"queue",n])})})}}),k.fn.extend({queue:function(t,n){var e=2;return"string"!=typeof t&&(n=t,t="fx",e--),arguments.length<e?k.queue(this[0],t):void 0===n?this:this.each(function(){var e=k.queue(this,t,n);k._queueHooks(this,t),"fx"===t&&"inprogress"!==e[0]&&k.dequeue(this,t)})},dequeue:function(e){return this.each(function(){k.dequeue(this,e)})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,t){var n,r=1,i=k.Deferred(),o=this,a=this.length,s=function(){--r||i.resolveWith(o,[o])};"string"!=typeof e&&(t=e,e=void 0),e=e||"fx";while(a--)(n=Q.get(o[a],e+"queueHooks"))&&n.empty&&(r++,n.empty.add(s));return s(),i.promise(t)}});var te=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ne=new RegExp("^(?:([+-])=|)("+te+")([a-z%]*)$","i"),re=["Top","Right","Bottom","Left"],ie=E.documentElement,oe=function(e){return k.contains(e.ownerDocument,e)},ae={composed:!0};ie.getRootNode&&(oe=function(e){return k.contains(e.ownerDocument,e)||e.getRootNode(ae)===e.ownerDocument});var se=function(e,t){return"none"===(e=t||e).style.display||""===e.style.display&&oe(e)&&"none"===k.css(e,"display")},ue=function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];for(o in i=n.apply(e,r||[]),t)e.style[o]=a[o];return i};function le(e,t,n,r){var i,o,a=20,s=r?function(){return r.cur()}:function(){return k.css(e,t,"")},u=s(),l=n&&n[3]||(k.cssNumber[t]?"":"px"),c=e.nodeType&&(k.cssNumber[t]||"px"!==l&&+u)&&ne.exec(k.css(e,t));if(c&&c[3]!==l){u/=2,l=l||c[3],c=+u||1;while(a--)k.style(e,t,c+l),(1-o)*(1-(o=s()/u||.5))<=0&&(a=0),c/=o;c*=2,k.style(e,t,c+l),n=n||[]}return n&&(c=+c||+u||0,i=n[1]?c+(n[1]+1)*n[2]:+n[2],r&&(r.unit=l,r.start=c,r.end=i)),i}var ce={};function fe(e,t){for(var n,r,i,o,a,s,u,l=[],c=0,f=e.length;c<f;c++)(r=e[c]).style&&(n=r.style.display,t?("none"===n&&(l[c]=Q.get(r,"display")||null,l[c]||(r.style.display="")),""===r.style.display&&se(r)&&(l[c]=(u=a=o=void 0,a=(i=r).ownerDocument,s=i.nodeName,(u=ce[s])||(o=a.body.appendChild(a.createElement(s)),u=k.css(o,"display"),o.parentNode.removeChild(o),"none"===u&&(u="block"),ce[s]=u)))):"none"!==n&&(l[c]="none",Q.set(r,"display",n)));for(c=0;c<f;c++)null!=l[c]&&(e[c].style.display=l[c]);return e}k.fn.extend({show:function(){return fe(this,!0)},hide:function(){return fe(this)},toggle:function(e){return"boolean"==typeof e?e?this.show():this.hide():this.each(function(){se(this)?k(this).show():k(this).hide()})}});var pe=/^(?:checkbox|radio)$/i,de=/<([a-z][^\/\0>\x20\t\r\n\f]*)/i,he=/^$|^module$|\/(?:java|ecma)script/i,ge={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};function ve(e,t){var n;return n="undefined"!=typeof e.getElementsByTagName?e.getElementsByTagName(t||"*"):"undefined"!=typeof e.querySelectorAll?e.querySelectorAll(t||"*"):[],void 0===t||t&&A(e,t)?k.merge([e],n):n}function ye(e,t){for(var n=0,r=e.length;n<r;n++)Q.set(e[n],"globalEval",!t||Q.get(t[n],"globalEval"))}ge.optgroup=ge.option,ge.tbody=ge.tfoot=ge.colgroup=ge.caption=ge.thead,ge.th=ge.td;var me,xe,be=/<|&#?\w+;/;function we(e,t,n,r,i){for(var o,a,s,u,l,c,f=t.createDocumentFragment(),p=[],d=0,h=e.length;d<h;d++)if((o=e[d])||0===o)if("object"===w(o))k.merge(p,o.nodeType?[o]:o);else if(be.test(o)){a=a||f.appendChild(t.createElement("div")),s=(de.exec(o)||["",""])[1].toLowerCase(),u=ge[s]||ge._default,a.innerHTML=u[1]+k.htmlPrefilter(o)+u[2],c=u[0];while(c--)a=a.lastChild;k.merge(p,a.childNodes),(a=f.firstChild).textContent=""}else p.push(t.createTextNode(o));f.textContent="",d=0;while(o=p[d++])if(r&&-1<k.inArray(o,r))i&&i.push(o);else if(l=oe(o),a=ve(f.appendChild(o),"script"),l&&ye(a),n){c=0;while(o=a[c++])he.test(o.type||"")&&n.push(o)}return f}me=E.createDocumentFragment().appendChild(E.createElement("div")),(xe=E.createElement("input")).setAttribute("type","radio"),xe.setAttribute("checked","checked"),xe.setAttribute("name","t"),me.appendChild(xe),y.checkClone=me.cloneNode(!0).cloneNode(!0).lastChild.checked,me.innerHTML="<textarea>x</textarea>",y.noCloneChecked=!!me.cloneNode(!0).lastChild.defaultValue;var Te=/^key/,Ce=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,Ee=/^([^.]*)(?:\.(.+)|)/;function ke(){return!0}function Se(){return!1}function Ne(e,t){return e===function(){try{return E.activeElement}catch(e){}}()==("focus"===t)}function Ae(e,t,n,r,i,o){var a,s;if("object"==typeof t){for(s in"string"!=typeof n&&(r=r||n,n=void 0),t)Ae(e,s,n,r,t[s],o);return e}if(null==r&&null==i?(i=n,r=n=void 0):null==i&&("string"==typeof n?(i=r,r=void 0):(i=r,r=n,n=void 0)),!1===i)i=Se;else if(!i)return e;return 1===o&&(a=i,(i=function(e){return k().off(e),a.apply(this,arguments)}).guid=a.guid||(a.guid=k.guid++)),e.each(function(){k.event.add(this,t,i,r,n)})}function De(e,i,o){o?(Q.set(e,i,!1),k.event.add(e,i,{namespace:!1,handler:function(e){var t,n,r=Q.get(this,i);if(1&e.isTrigger&&this[i]){if(r.length)(k.event.special[i]||{}).delegateType&&e.stopPropagation();else if(r=s.call(arguments),Q.set(this,i,r),t=o(this,i),this[i](),r!==(n=Q.get(this,i))||t?Q.set(this,i,!1):n={},r!==n)return e.stopImmediatePropagation(),e.preventDefault(),n.value}else r.length&&(Q.set(this,i,{value:k.event.trigger(k.extend(r[0],k.Event.prototype),r.slice(1),this)}),e.stopImmediatePropagation())}})):void 0===Q.get(e,i)&&k.event.add(e,i,ke)}k.event={global:{},add:function(t,e,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.get(t);if(v){n.handler&&(n=(o=n).handler,i=o.selector),i&&k.find.matchesSelector(ie,i),n.guid||(n.guid=k.guid++),(u=v.events)||(u=v.events={}),(a=v.handle)||(a=v.handle=function(e){return"undefined"!=typeof k&&k.event.triggered!==e.type?k.event.dispatch.apply(t,arguments):void 0}),l=(e=(e||"").match(R)||[""]).length;while(l--)d=g=(s=Ee.exec(e[l])||[])[1],h=(s[2]||"").split(".").sort(),d&&(f=k.event.special[d]||{},d=(i?f.delegateType:f.bindType)||d,f=k.event.special[d]||{},c=k.extend({type:d,origType:g,data:r,handler:n,guid:n.guid,selector:i,needsContext:i&&k.expr.match.needsContext.test(i),namespace:h.join(".")},o),(p=u[d])||((p=u[d]=[]).delegateCount=0,f.setup&&!1!==f.setup.call(t,r,h,a)||t.addEventListener&&t.addEventListener(d,a)),f.add&&(f.add.call(t,c),c.handler.guid||(c.handler.guid=n.guid)),i?p.splice(p.delegateCount++,0,c):p.push(c),k.event.global[d]=!0)}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,f,p,d,h,g,v=Q.hasData(e)&&Q.get(e);if(v&&(u=v.events)){l=(t=(t||"").match(R)||[""]).length;while(l--)if(d=g=(s=Ee.exec(t[l])||[])[1],h=(s[2]||"").split(".").sort(),d){f=k.event.special[d]||{},p=u[d=(r?f.delegateType:f.bindType)||d]||[],s=s[2]&&new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),a=o=p.length;while(o--)c=p[o],!i&&g!==c.origType||n&&n.guid!==c.guid||s&&!s.test(c.namespace)||r&&r!==c.selector&&("**"!==r||!c.selector)||(p.splice(o,1),c.selector&&p.delegateCount--,f.remove&&f.remove.call(e,c));a&&!p.length&&(f.teardown&&!1!==f.teardown.call(e,h,v.handle)||k.removeEvent(e,d,v.handle),delete u[d])}else for(d in u)k.event.remove(e,d+t[l],n,r,!0);k.isEmptyObject(u)&&Q.remove(e,"handle events")}},dispatch:function(e){var t,n,r,i,o,a,s=k.event.fix(e),u=new Array(arguments.length),l=(Q.get(this,"events")||{})[s.type]||[],c=k.event.special[s.type]||{};for(u[0]=s,t=1;t<arguments.length;t++)u[t]=arguments[t];if(s.delegateTarget=this,!c.preDispatch||!1!==c.preDispatch.call(this,s)){a=k.event.handlers.call(this,s,l),t=0;while((i=a[t++])&&!s.isPropagationStopped()){s.currentTarget=i.elem,n=0;while((o=i.handlers[n++])&&!s.isImmediatePropagationStopped())s.rnamespace&&!1!==o.namespace&&!s.rnamespace.test(o.namespace)||(s.handleObj=o,s.data=o.data,void 0!==(r=((k.event.special[o.origType]||{}).handle||o.handler).apply(i.elem,u))&&!1===(s.result=r)&&(s.preventDefault(),s.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,s),s.result}},handlers:function(e,t){var n,r,i,o,a,s=[],u=t.delegateCount,l=e.target;if(u&&l.nodeType&&!("click"===e.type&&1<=e.button))for(;l!==this;l=l.parentNode||this)if(1===l.nodeType&&("click"!==e.type||!0!==l.disabled)){for(o=[],a={},n=0;n<u;n++)void 0===a[i=(r=t[n]).selector+" "]&&(a[i]=r.needsContext?-1<k(i,this).index(l):k.find(i,this,null,[l]).length),a[i]&&o.push(r);o.length&&s.push({elem:l,handlers:o})}return l=this,u<t.length&&s.push({elem:l,handlers:t.slice(u)}),s},addProp:function(t,e){Object.defineProperty(k.Event.prototype,t,{enumerable:!0,configurable:!0,get:m(e)?function(){if(this.originalEvent)return e(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[t]},set:function(e){Object.defineProperty(this,t,{enumerable:!0,configurable:!0,writable:!0,value:e})}})},fix:function(e){return e[k.expando]?e:new k.Event(e)},special:{load:{noBubble:!0},click:{setup:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click",ke),!1},trigger:function(e){var t=this||e;return pe.test(t.type)&&t.click&&A(t,"input")&&De(t,"click"),!0},_default:function(e){var t=e.target;return pe.test(t.type)&&t.click&&A(t,"input")&&Q.get(t,"click")||A(t,"a")}},beforeunload:{postDispatch:function(e){void 0!==e.result&&e.originalEvent&&(e.originalEvent.returnValue=e.result)}}}},k.removeEvent=function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n)},k.Event=function(e,t){if(!(this instanceof k.Event))return new k.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||void 0===e.defaultPrevented&&!1===e.returnValue?ke:Se,this.target=e.target&&3===e.target.nodeType?e.target.parentNode:e.target,this.currentTarget=e.currentTarget,this.relatedTarget=e.relatedTarget):this.type=e,t&&k.extend(this,t),this.timeStamp=e&&e.timeStamp||Date.now(),this[k.expando]=!0},k.Event.prototype={constructor:k.Event,isDefaultPrevented:Se,isPropagationStopped:Se,isImmediatePropagationStopped:Se,isSimulated:!1,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=ke,e&&!this.isSimulated&&e.preventDefault()},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=ke,e&&!this.isSimulated&&e.stopPropagation()},stopImmediatePropagation:function(){var e=this.originalEvent;this.isImmediatePropagationStopped=ke,e&&!this.isSimulated&&e.stopImmediatePropagation(),this.stopPropagation()}},k.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,code:!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(e){var t=e.button;return null==e.which&&Te.test(e.type)?null!=e.charCode?e.charCode:e.keyCode:!e.which&&void 0!==t&&Ce.test(e.type)?1&t?1:2&t?3:4&t?2:0:e.which}},k.event.addProp),k.each({focus:"focusin",blur:"focusout"},function(e,t){k.event.special[e]={setup:function(){return De(this,e,Ne),!1},trigger:function(){return De(this,e),!0},delegateType:t}}),k.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(e,i){k.event.special[e]={delegateType:i,bindType:i,handle:function(e){var t,n=e.relatedTarget,r=e.handleObj;return n&&(n===this||k.contains(this,n))||(e.type=r.origType,t=r.handler.apply(this,arguments),e.type=i),t}}}),k.fn.extend({on:function(e,t,n,r){return Ae(this,e,t,n,r)},one:function(e,t,n,r){return Ae(this,e,t,n,r,1)},off:function(e,t,n){var r,i;if(e&&e.preventDefault&&e.handleObj)return r=e.handleObj,k(e.delegateTarget).off(r.namespace?r.origType+"."+r.namespace:r.origType,r.selector,r.handler),this;if("object"==typeof e){for(i in e)this.off(i,t,e[i]);return this}return!1!==t&&"function"!=typeof t||(n=t,t=void 0),!1===n&&(n=Se),this.each(function(){k.event.remove(this,e,n,t)})}});var je=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,qe=/<script|<style|<link/i,Le=/checked\s*(?:[^=]|=\s*.checked.)/i,He=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Oe(e,t){return A(e,"table")&&A(11!==t.nodeType?t:t.firstChild,"tr")&&k(e).children("tbody")[0]||e}function Pe(e){return e.type=(null!==e.getAttribute("type"))+"/"+e.type,e}function Re(e){return"true/"===(e.type||"").slice(0,5)?e.type=e.type.slice(5):e.removeAttribute("type"),e}function Me(e,t){var n,r,i,o,a,s,u,l;if(1===t.nodeType){if(Q.hasData(e)&&(o=Q.access(e),a=Q.set(t,o),l=o.events))for(i in delete a.handle,a.events={},l)for(n=0,r=l[i].length;n<r;n++)k.event.add(t,i,l[i][n]);J.hasData(e)&&(s=J.access(e),u=k.extend({},s),J.set(t,u))}}function Ie(n,r,i,o){r=g.apply([],r);var e,t,a,s,u,l,c=0,f=n.length,p=f-1,d=r[0],h=m(d);if(h||1<f&&"string"==typeof d&&!y.checkClone&&Le.test(d))return n.each(function(e){var t=n.eq(e);h&&(r[0]=d.call(this,e,t.html())),Ie(t,r,i,o)});if(f&&(t=(e=we(r,n[0].ownerDocument,!1,n,o)).firstChild,1===e.childNodes.length&&(e=t),t||o)){for(s=(a=k.map(ve(e,"script"),Pe)).length;c<f;c++)u=e,c!==p&&(u=k.clone(u,!0,!0),s&&k.merge(a,ve(u,"script"))),i.call(n[c],u,c);if(s)for(l=a[a.length-1].ownerDocument,k.map(a,Re),c=0;c<s;c++)u=a[c],he.test(u.type||"")&&!Q.access(u,"globalEval")&&k.contains(l,u)&&(u.src&&"module"!==(u.type||"").toLowerCase()?k._evalUrl&&!u.noModule&&k._evalUrl(u.src,{nonce:u.nonce||u.getAttribute("nonce")}):b(u.textContent.replace(He,""),u,l))}return n}function We(e,t,n){for(var r,i=t?k.filter(t,e):e,o=0;null!=(r=i[o]);o++)n||1!==r.nodeType||k.cleanData(ve(r)),r.parentNode&&(n&&oe(r)&&ye(ve(r,"script")),r.parentNode.removeChild(r));return e}k.extend({htmlPrefilter:function(e){return e.replace(je,"<$1></$2>")},clone:function(e,t,n){var r,i,o,a,s,u,l,c=e.cloneNode(!0),f=oe(e);if(!(y.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||k.isXMLDoc(e)))for(a=ve(c),r=0,i=(o=ve(e)).length;r<i;r++)s=o[r],u=a[r],void 0,"input"===(l=u.nodeName.toLowerCase())&&pe.test(s.type)?u.checked=s.checked:"input"!==l&&"textarea"!==l||(u.defaultValue=s.defaultValue);if(t)if(n)for(o=o||ve(e),a=a||ve(c),r=0,i=o.length;r<i;r++)Me(o[r],a[r]);else Me(e,c);return 0<(a=ve(c,"script")).length&&ye(a,!f&&ve(e,"script")),c},cleanData:function(e){for(var t,n,r,i=k.event.special,o=0;void 0!==(n=e[o]);o++)if(G(n)){if(t=n[Q.expando]){if(t.events)for(r in t.events)i[r]?k.event.remove(n,r):k.removeEvent(n,r,t.handle);n[Q.expando]=void 0}n[J.expando]&&(n[J.expando]=void 0)}}}),k.fn.extend({detach:function(e){return We(this,e,!0)},remove:function(e){return We(this,e)},text:function(e){return _(this,function(e){return void 0===e?k.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=e)})},null,e,arguments.length)},append:function(){return Ie(this,arguments,function(e){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||Oe(this,e).appendChild(e)})},prepend:function(){return Ie(this,arguments,function(e){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var t=Oe(this,e);t.insertBefore(e,t.firstChild)}})},before:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return Ie(this,arguments,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},empty:function(){for(var e,t=0;null!=(e=this[t]);t++)1===e.nodeType&&(k.cleanData(ve(e,!1)),e.textContent="");return this},clone:function(e,t){return e=null!=e&&e,t=null==t?e:t,this.map(function(){return k.clone(this,e,t)})},html:function(e){return _(this,function(e){var t=this[0]||{},n=0,r=this.length;if(void 0===e&&1===t.nodeType)return t.innerHTML;if("string"==typeof e&&!qe.test(e)&&!ge[(de.exec(e)||["",""])[1].toLowerCase()]){e=k.htmlPrefilter(e);try{for(;n<r;n++)1===(t=this[n]||{}).nodeType&&(k.cleanData(ve(t,!1)),t.innerHTML=e);t=0}catch(e){}}t&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(){var n=[];return Ie(this,arguments,function(e){var t=this.parentNode;k.inArray(this,n)<0&&(k.cleanData(ve(this)),t&&t.replaceChild(e,this))},n)}}),k.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,a){k.fn[e]=function(e){for(var t,n=[],r=k(e),i=r.length-1,o=0;o<=i;o++)t=o===i?this:this.clone(!0),k(r[o])[a](t),u.apply(n,t.get());return this.pushStack(n)}});var $e=new RegExp("^("+te+")(?!px)[a-z%]+$","i"),Fe=function(e){var t=e.ownerDocument.defaultView;return t&&t.opener||(t=C),t.getComputedStyle(e)},Be=new RegExp(re.join("|"),"i");function _e(e,t,n){var r,i,o,a,s=e.style;return(n=n||Fe(e))&&(""!==(a=n.getPropertyValue(t)||n[t])||oe(e)||(a=k.style(e,t)),!y.pixelBoxStyles()&&$e.test(a)&&Be.test(t)&&(r=s.width,i=s.minWidth,o=s.maxWidth,s.minWidth=s.maxWidth=s.width=a,a=n.width,s.width=r,s.minWidth=i,s.maxWidth=o)),void 0!==a?a+"":a}function ze(e,t){return{get:function(){if(!e())return(this.get=t).apply(this,arguments);delete this.get}}}!function(){function e(){if(u){s.style.cssText="position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0",u.style.cssText="position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%",ie.appendChild(s).appendChild(u);var e=C.getComputedStyle(u);n="1%"!==e.top,a=12===t(e.marginLeft),u.style.right="60%",o=36===t(e.right),r=36===t(e.width),u.style.position="absolute",i=12===t(u.offsetWidth/3),ie.removeChild(s),u=null}}function t(e){return Math.round(parseFloat(e))}var n,r,i,o,a,s=E.createElement("div"),u=E.createElement("div");u.style&&(u.style.backgroundClip="content-box",u.cloneNode(!0).style.backgroundClip="",y.clearCloneStyle="content-box"===u.style.backgroundClip,k.extend(y,{boxSizingReliable:function(){return e(),r},pixelBoxStyles:function(){return e(),o},pixelPosition:function(){return e(),n},reliableMarginLeft:function(){return e(),a},scrollboxSize:function(){return e(),i}}))}();var Ue=["Webkit","Moz","ms"],Xe=E.createElement("div").style,Ve={};function Ge(e){var t=k.cssProps[e]||Ve[e];return t||(e in Xe?e:Ve[e]=function(e){var t=e[0].toUpperCase()+e.slice(1),n=Ue.length;while(n--)if((e=Ue[n]+t)in Xe)return e}(e)||e)}var Ye=/^(none|table(?!-c[ea]).+)/,Qe=/^--/,Je={position:"absolute",visibility:"hidden",display:"block"},Ke={letterSpacing:"0",fontWeight:"400"};function Ze(e,t,n){var r=ne.exec(t);return r?Math.max(0,r[2]-(n||0))+(r[3]||"px"):t}function et(e,t,n,r,i,o){var a="width"===t?1:0,s=0,u=0;if(n===(r?"border":"content"))return 0;for(;a<4;a+=2)"margin"===n&&(u+=k.css(e,n+re[a],!0,i)),r?("content"===n&&(u-=k.css(e,"padding"+re[a],!0,i)),"margin"!==n&&(u-=k.css(e,"border"+re[a]+"Width",!0,i))):(u+=k.css(e,"padding"+re[a],!0,i),"padding"!==n?u+=k.css(e,"border"+re[a]+"Width",!0,i):s+=k.css(e,"border"+re[a]+"Width",!0,i));return!r&&0<=o&&(u+=Math.max(0,Math.ceil(e["offset"+t[0].toUpperCase()+t.slice(1)]-o-u-s-.5))||0),u}function tt(e,t,n){var r=Fe(e),i=(!y.boxSizingReliable()||n)&&"border-box"===k.css(e,"boxSizing",!1,r),o=i,a=_e(e,t,r),s="offset"+t[0].toUpperCase()+t.slice(1);if($e.test(a)){if(!n)return a;a="auto"}return(!y.boxSizingReliable()&&i||"auto"===a||!parseFloat(a)&&"inline"===k.css(e,"display",!1,r))&&e.getClientRects().length&&(i="border-box"===k.css(e,"boxSizing",!1,r),(o=s in e)&&(a=e[s])),(a=parseFloat(a)||0)+et(e,t,n||(i?"border":"content"),o,r,a)+"px"}function nt(e,t,n,r,i){return new nt.prototype.init(e,t,n,r,i)}k.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=_e(e,"opacity");return""===n?"1":n}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,gridArea:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnStart:!0,gridRow:!0,gridRowEnd:!0,gridRowStart:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{},style:function(e,t,n,r){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var i,o,a,s=V(t),u=Qe.test(t),l=e.style;if(u||(t=Ge(s)),a=k.cssHooks[t]||k.cssHooks[s],void 0===n)return a&&"get"in a&&void 0!==(i=a.get(e,!1,r))?i:l[t];"string"===(o=typeof n)&&(i=ne.exec(n))&&i[1]&&(n=le(e,t,i),o="number"),null!=n&&n==n&&("number"!==o||u||(n+=i&&i[3]||(k.cssNumber[s]?"":"px")),y.clearCloneStyle||""!==n||0!==t.indexOf("background")||(l[t]="inherit"),a&&"set"in a&&void 0===(n=a.set(e,n,r))||(u?l.setProperty(t,n):l[t]=n))}},css:function(e,t,n,r){var i,o,a,s=V(t);return Qe.test(t)||(t=Ge(s)),(a=k.cssHooks[t]||k.cssHooks[s])&&"get"in a&&(i=a.get(e,!0,n)),void 0===i&&(i=_e(e,t,r)),"normal"===i&&t in Ke&&(i=Ke[t]),""===n||n?(o=parseFloat(i),!0===n||isFinite(o)?o||0:i):i}}),k.each(["height","width"],function(e,u){k.cssHooks[u]={get:function(e,t,n){if(t)return!Ye.test(k.css(e,"display"))||e.getClientRects().length&&e.getBoundingClientRect().width?tt(e,u,n):ue(e,Je,function(){return tt(e,u,n)})},set:function(e,t,n){var r,i=Fe(e),o=!y.scrollboxSize()&&"absolute"===i.position,a=(o||n)&&"border-box"===k.css(e,"boxSizing",!1,i),s=n?et(e,u,n,a,i):0;return a&&o&&(s-=Math.ceil(e["offset"+u[0].toUpperCase()+u.slice(1)]-parseFloat(i[u])-et(e,u,"border",!1,i)-.5)),s&&(r=ne.exec(t))&&"px"!==(r[3]||"px")&&(e.style[u]=t,t=k.css(e,u)),Ze(0,t,s)}}}),k.cssHooks.marginLeft=ze(y.reliableMarginLeft,function(e,t){if(t)return(parseFloat(_e(e,"marginLeft"))||e.getBoundingClientRect().left-ue(e,{marginLeft:0},function(){return e.getBoundingClientRect().left}))+"px"}),k.each({margin:"",padding:"",border:"Width"},function(i,o){k.cssHooks[i+o]={expand:function(e){for(var t=0,n={},r="string"==typeof e?e.split(" "):[e];t<4;t++)n[i+re[t]+o]=r[t]||r[t-2]||r[0];return n}},"margin"!==i&&(k.cssHooks[i+o].set=Ze)}),k.fn.extend({css:function(e,t){return _(this,function(e,t,n){var r,i,o={},a=0;if(Array.isArray(t)){for(r=Fe(e),i=t.length;a<i;a++)o[t[a]]=k.css(e,t[a],!1,r);return o}return void 0!==n?k.style(e,t,n):k.css(e,t)},e,t,1<arguments.length)}}),((k.Tween=nt).prototype={constructor:nt,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||k.easing._default,this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(k.cssNumber[n]?"":"px")},cur:function(){var e=nt.propHooks[this.prop];return e&&e.get?e.get(this):nt.propHooks._default.get(this)},run:function(e){var t,n=nt.propHooks[this.prop];return this.options.duration?this.pos=t=k.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):nt.propHooks._default.set(this),this}}).init.prototype=nt.prototype,(nt.propHooks={_default:{get:function(e){var t;return 1!==e.elem.nodeType||null!=e.elem[e.prop]&&null==e.elem.style[e.prop]?e.elem[e.prop]:(t=k.css(e.elem,e.prop,""))&&"auto"!==t?t:0},set:function(e){k.fx.step[e.prop]?k.fx.step[e.prop](e):1!==e.elem.nodeType||!k.cssHooks[e.prop]&&null==e.elem.style[Ge(e.prop)]?e.elem[e.prop]=e.now:k.style(e.elem,e.prop,e.now+e.unit)}}}).scrollTop=nt.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},k.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},_default:"swing"},k.fx=nt.prototype.init,k.fx.step={};var rt,it,ot,at,st=/^(?:toggle|show|hide)$/,ut=/queueHooks$/;function lt(){it&&(!1===E.hidden&&C.requestAnimationFrame?C.requestAnimationFrame(lt):C.setTimeout(lt,k.fx.interval),k.fx.tick())}function ct(){return C.setTimeout(function(){rt=void 0}),rt=Date.now()}function ft(e,t){var n,r=0,i={height:e};for(t=t?1:0;r<4;r+=2-t)i["margin"+(n=re[r])]=i["padding"+n]=e;return t&&(i.opacity=i.width=e),i}function pt(e,t,n){for(var r,i=(dt.tweeners[t]||[]).concat(dt.tweeners["*"]),o=0,a=i.length;o<a;o++)if(r=i[o].call(n,t,e))return r}function dt(o,e,t){var n,a,r=0,i=dt.prefilters.length,s=k.Deferred().always(function(){delete u.elem}),u=function(){if(a)return!1;for(var e=rt||ct(),t=Math.max(0,l.startTime+l.duration-e),n=1-(t/l.duration||0),r=0,i=l.tweens.length;r<i;r++)l.tweens[r].run(n);return s.notifyWith(o,[l,n,t]),n<1&&i?t:(i||s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l]),!1)},l=s.promise({elem:o,props:k.extend({},e),opts:k.extend(!0,{specialEasing:{},easing:k.easing._default},t),originalProperties:e,originalOptions:t,startTime:rt||ct(),duration:t.duration,tweens:[],createTween:function(e,t){var n=k.Tween(o,l.opts,e,t,l.opts.specialEasing[e]||l.opts.easing);return l.tweens.push(n),n},stop:function(e){var t=0,n=e?l.tweens.length:0;if(a)return this;for(a=!0;t<n;t++)l.tweens[t].run(1);return e?(s.notifyWith(o,[l,1,0]),s.resolveWith(o,[l,e])):s.rejectWith(o,[l,e]),this}}),c=l.props;for(!function(e,t){var n,r,i,o,a;for(n in e)if(i=t[r=V(n)],o=e[n],Array.isArray(o)&&(i=o[1],o=e[n]=o[0]),n!==r&&(e[r]=o,delete e[n]),(a=k.cssHooks[r])&&"expand"in a)for(n in o=a.expand(o),delete e[r],o)n in e||(e[n]=o[n],t[n]=i);else t[r]=i}(c,l.opts.specialEasing);r<i;r++)if(n=dt.prefilters[r].call(l,o,c,l.opts))return m(n.stop)&&(k._queueHooks(l.elem,l.opts.queue).stop=n.stop.bind(n)),n;return k.map(c,pt,l),m(l.opts.start)&&l.opts.start.call(o,l),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always),k.fx.timer(k.extend(u,{elem:o,anim:l,queue:l.opts.queue})),l}k.Animation=k.extend(dt,{tweeners:{"*":[function(e,t){var n=this.createTween(e,t);return le(n.elem,e,ne.exec(t),n),n}]},tweener:function(e,t){m(e)?(t=e,e=["*"]):e=e.match(R);for(var n,r=0,i=e.length;r<i;r++)n=e[r],dt.tweeners[n]=dt.tweeners[n]||[],dt.tweeners[n].unshift(t)},prefilters:[function(e,t,n){var r,i,o,a,s,u,l,c,f="width"in t||"height"in t,p=this,d={},h=e.style,g=e.nodeType&&se(e),v=Q.get(e,"fxshow");for(r in n.queue||(null==(a=k._queueHooks(e,"fx")).unqueued&&(a.unqueued=0,s=a.empty.fire,a.empty.fire=function(){a.unqueued||s()}),a.unqueued++,p.always(function(){p.always(function(){a.unqueued--,k.queue(e,"fx").length||a.empty.fire()})})),t)if(i=t[r],st.test(i)){if(delete t[r],o=o||"toggle"===i,i===(g?"hide":"show")){if("show"!==i||!v||void 0===v[r])continue;g=!0}d[r]=v&&v[r]||k.style(e,r)}if((u=!k.isEmptyObject(t))||!k.isEmptyObject(d))for(r in f&&1===e.nodeType&&(n.overflow=[h.overflow,h.overflowX,h.overflowY],null==(l=v&&v.display)&&(l=Q.get(e,"display")),"none"===(c=k.css(e,"display"))&&(l?c=l:(fe([e],!0),l=e.style.display||l,c=k.css(e,"display"),fe([e]))),("inline"===c||"inline-block"===c&&null!=l)&&"none"===k.css(e,"float")&&(u||(p.done(function(){h.display=l}),null==l&&(c=h.display,l="none"===c?"":c)),h.display="inline-block")),n.overflow&&(h.overflow="hidden",p.always(function(){h.overflow=n.overflow[0],h.overflowX=n.overflow[1],h.overflowY=n.overflow[2]})),u=!1,d)u||(v?"hidden"in v&&(g=v.hidden):v=Q.access(e,"fxshow",{display:l}),o&&(v.hidden=!g),g&&fe([e],!0),p.done(function(){for(r in g||fe([e]),Q.remove(e,"fxshow"),d)k.style(e,r,d[r])})),u=pt(g?v[r]:0,r,p),r in v||(v[r]=u.start,g&&(u.end=u.start,u.start=0))}],prefilter:function(e,t){t?dt.prefilters.unshift(e):dt.prefilters.push(e)}}),k.speed=function(e,t,n){var r=e&&"object"==typeof e?k.extend({},e):{complete:n||!n&&t||m(e)&&e,duration:e,easing:n&&t||t&&!m(t)&&t};return k.fx.off?r.duration=0:"number"!=typeof r.duration&&(r.duration in k.fx.speeds?r.duration=k.fx.speeds[r.duration]:r.duration=k.fx.speeds._default),null!=r.queue&&!0!==r.queue||(r.queue="fx"),r.old=r.complete,r.complete=function(){m(r.old)&&r.old.call(this),r.queue&&k.dequeue(this,r.queue)},r},k.fn.extend({fadeTo:function(e,t,n,r){return this.filter(se).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(t,e,n,r){var i=k.isEmptyObject(t),o=k.speed(e,n,r),a=function(){var e=dt(this,k.extend({},t),o);(i||Q.get(this,"finish"))&&e.stop(!0)};return a.finish=a,i||!1===o.queue?this.each(a):this.queue(o.queue,a)},stop:function(i,e,o){var a=function(e){var t=e.stop;delete e.stop,t(o)};return"string"!=typeof i&&(o=e,e=i,i=void 0),e&&!1!==i&&this.queue(i||"fx",[]),this.each(function(){var e=!0,t=null!=i&&i+"queueHooks",n=k.timers,r=Q.get(this);if(t)r[t]&&r[t].stop&&a(r[t]);else for(t in r)r[t]&&r[t].stop&&ut.test(t)&&a(r[t]);for(t=n.length;t--;)n[t].elem!==this||null!=i&&n[t].queue!==i||(n[t].anim.stop(o),e=!1,n.splice(t,1));!e&&o||k.dequeue(this,i)})},finish:function(a){return!1!==a&&(a=a||"fx"),this.each(function(){var e,t=Q.get(this),n=t[a+"queue"],r=t[a+"queueHooks"],i=k.timers,o=n?n.length:0;for(t.finish=!0,k.queue(this,a,[]),r&&r.stop&&r.stop.call(this,!0),e=i.length;e--;)i[e].elem===this&&i[e].queue===a&&(i[e].anim.stop(!0),i.splice(e,1));for(e=0;e<o;e++)n[e]&&n[e].finish&&n[e].finish.call(this);delete t.finish})}}),k.each(["toggle","show","hide"],function(e,r){var i=k.fn[r];k.fn[r]=function(e,t,n){return null==e||"boolean"==typeof e?i.apply(this,arguments):this.animate(ft(r,!0),e,t,n)}}),k.each({slideDown:ft("show"),slideUp:ft("hide"),slideToggle:ft("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,r){k.fn[e]=function(e,t,n){return this.animate(r,e,t,n)}}),k.timers=[],k.fx.tick=function(){var e,t=0,n=k.timers;for(rt=Date.now();t<n.length;t++)(e=n[t])()||n[t]!==e||n.splice(t--,1);n.length||k.fx.stop(),rt=void 0},k.fx.timer=function(e){k.timers.push(e),k.fx.start()},k.fx.interval=13,k.fx.start=function(){it||(it=!0,lt())},k.fx.stop=function(){it=null},k.fx.speeds={slow:600,fast:200,_default:400},k.fn.delay=function(r,e){return r=k.fx&&k.fx.speeds[r]||r,e=e||"fx",this.queue(e,function(e,t){var n=C.setTimeout(e,r);t.stop=function(){C.clearTimeout(n)}})},ot=E.createElement("input"),at=E.createElement("select").appendChild(E.createElement("option")),ot.type="checkbox",y.checkOn=""!==ot.value,y.optSelected=at.selected,(ot=E.createElement("input")).value="t",ot.type="radio",y.radioValue="t"===ot.value;var ht,gt=k.expr.attrHandle;k.fn.extend({attr:function(e,t){return _(this,k.attr,e,t,1<arguments.length)},removeAttr:function(e){return this.each(function(){k.removeAttr(this,e)})}}),k.extend({attr:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return"undefined"==typeof e.getAttribute?k.prop(e,t,n):(1===o&&k.isXMLDoc(e)||(i=k.attrHooks[t.toLowerCase()]||(k.expr.match.bool.test(t)?ht:void 0)),void 0!==n?null===n?void k.removeAttr(e,t):i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:(e.setAttribute(t,n+""),n):i&&"get"in i&&null!==(r=i.get(e,t))?r:null==(r=k.find.attr(e,t))?void 0:r)},attrHooks:{type:{set:function(e,t){if(!y.radioValue&&"radio"===t&&A(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},removeAttr:function(e,t){var n,r=0,i=t&&t.match(R);if(i&&1===e.nodeType)while(n=i[r++])e.removeAttribute(n)}}),ht={set:function(e,t,n){return!1===t?k.removeAttr(e,n):e.setAttribute(n,n),n}},k.each(k.expr.match.bool.source.match(/\w+/g),function(e,t){var a=gt[t]||k.find.attr;gt[t]=function(e,t,n){var r,i,o=t.toLowerCase();return n||(i=gt[o],gt[o]=r,r=null!=a(e,t,n)?o:null,gt[o]=i),r}});var vt=/^(?:input|select|textarea|button)$/i,yt=/^(?:a|area)$/i;function mt(e){return(e.match(R)||[]).join(" ")}function xt(e){return e.getAttribute&&e.getAttribute("class")||""}function bt(e){return Array.isArray(e)?e:"string"==typeof e&&e.match(R)||[]}k.fn.extend({prop:function(e,t){return _(this,k.prop,e,t,1<arguments.length)},removeProp:function(e){return this.each(function(){delete this[k.propFix[e]||e]})}}),k.extend({prop:function(e,t,n){var r,i,o=e.nodeType;if(3!==o&&8!==o&&2!==o)return 1===o&&k.isXMLDoc(e)||(t=k.propFix[t]||t,i=k.propHooks[t]),void 0!==n?i&&"set"in i&&void 0!==(r=i.set(e,n,t))?r:e[t]=n:i&&"get"in i&&null!==(r=i.get(e,t))?r:e[t]},propHooks:{tabIndex:{get:function(e){var t=k.find.attr(e,"tabindex");return t?parseInt(t,10):vt.test(e.nodeName)||yt.test(e.nodeName)&&e.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),y.optSelected||(k.propHooks.selected={get:function(e){var t=e.parentNode;return t&&t.parentNode&&t.parentNode.selectedIndex,null},set:function(e){var t=e.parentNode;t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex)}}),k.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){k.propFix[this.toLowerCase()]=this}),k.fn.extend({addClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).addClass(t.call(this,e,xt(this)))});if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])r.indexOf(" "+o+" ")<0&&(r+=o+" ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},removeClass:function(t){var e,n,r,i,o,a,s,u=0;if(m(t))return this.each(function(e){k(this).removeClass(t.call(this,e,xt(this)))});if(!arguments.length)return this.attr("class","");if((e=bt(t)).length)while(n=this[u++])if(i=xt(n),r=1===n.nodeType&&" "+mt(i)+" "){a=0;while(o=e[a++])while(-1<r.indexOf(" "+o+" "))r=r.replace(" "+o+" "," ");i!==(s=mt(r))&&n.setAttribute("class",s)}return this},toggleClass:function(i,t){var o=typeof i,a="string"===o||Array.isArray(i);return"boolean"==typeof t&&a?t?this.addClass(i):this.removeClass(i):m(i)?this.each(function(e){k(this).toggleClass(i.call(this,e,xt(this),t),t)}):this.each(function(){var e,t,n,r;if(a){t=0,n=k(this),r=bt(i);while(e=r[t++])n.hasClass(e)?n.removeClass(e):n.addClass(e)}else void 0!==i&&"boolean"!==o||((e=xt(this))&&Q.set(this,"__className__",e),this.setAttribute&&this.setAttribute("class",e||!1===i?"":Q.get(this,"__className__")||""))})},hasClass:function(e){var t,n,r=0;t=" "+e+" ";while(n=this[r++])if(1===n.nodeType&&-1<(" "+mt(xt(n))+" ").indexOf(t))return!0;return!1}});var wt=/\r/g;k.fn.extend({val:function(n){var r,e,i,t=this[0];return arguments.length?(i=m(n),this.each(function(e){var t;1===this.nodeType&&(null==(t=i?n.call(this,e,k(this).val()):n)?t="":"number"==typeof t?t+="":Array.isArray(t)&&(t=k.map(t,function(e){return null==e?"":e+""})),(r=k.valHooks[this.type]||k.valHooks[this.nodeName.toLowerCase()])&&"set"in r&&void 0!==r.set(this,t,"value")||(this.value=t))})):t?(r=k.valHooks[t.type]||k.valHooks[t.nodeName.toLowerCase()])&&"get"in r&&void 0!==(e=r.get(t,"value"))?e:"string"==typeof(e=t.value)?e.replace(wt,""):null==e?"":e:void 0}}),k.extend({valHooks:{option:{get:function(e){var t=k.find.attr(e,"value");return null!=t?t:mt(k.text(e))}},select:{get:function(e){var t,n,r,i=e.options,o=e.selectedIndex,a="select-one"===e.type,s=a?null:[],u=a?o+1:i.length;for(r=o<0?u:a?o:0;r<u;r++)if(((n=i[r]).selected||r===o)&&!n.disabled&&(!n.parentNode.disabled||!A(n.parentNode,"optgroup"))){if(t=k(n).val(),a)return t;s.push(t)}return s},set:function(e,t){var n,r,i=e.options,o=k.makeArray(t),a=i.length;while(a--)((r=i[a]).selected=-1<k.inArray(k.valHooks.option.get(r),o))&&(n=!0);return n||(e.selectedIndex=-1),o}}}}),k.each(["radio","checkbox"],function(){k.valHooks[this]={set:function(e,t){if(Array.isArray(t))return e.checked=-1<k.inArray(k(e).val(),t)}},y.checkOn||(k.valHooks[this].get=function(e){return null===e.getAttribute("value")?"on":e.value})}),y.focusin="onfocusin"in C;var Tt=/^(?:focusinfocus|focusoutblur)$/,Ct=function(e){e.stopPropagation()};k.extend(k.event,{trigger:function(e,t,n,r){var i,o,a,s,u,l,c,f,p=[n||E],d=v.call(e,"type")?e.type:e,h=v.call(e,"namespace")?e.namespace.split("."):[];if(o=f=a=n=n||E,3!==n.nodeType&&8!==n.nodeType&&!Tt.test(d+k.event.triggered)&&(-1<d.indexOf(".")&&(d=(h=d.split(".")).shift(),h.sort()),u=d.indexOf(":")<0&&"on"+d,(e=e[k.expando]?e:new k.Event(d,"object"==typeof e&&e)).isTrigger=r?2:3,e.namespace=h.join("."),e.rnamespace=e.namespace?new RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,e.result=void 0,e.target||(e.target=n),t=null==t?[e]:k.makeArray(t,[e]),c=k.event.special[d]||{},r||!c.trigger||!1!==c.trigger.apply(n,t))){if(!r&&!c.noBubble&&!x(n)){for(s=c.delegateType||d,Tt.test(s+d)||(o=o.parentNode);o;o=o.parentNode)p.push(o),a=o;a===(n.ownerDocument||E)&&p.push(a.defaultView||a.parentWindow||C)}i=0;while((o=p[i++])&&!e.isPropagationStopped())f=o,e.type=1<i?s:c.bindType||d,(l=(Q.get(o,"events")||{})[e.type]&&Q.get(o,"handle"))&&l.apply(o,t),(l=u&&o[u])&&l.apply&&G(o)&&(e.result=l.apply(o,t),!1===e.result&&e.preventDefault());return e.type=d,r||e.isDefaultPrevented()||c._default&&!1!==c._default.apply(p.pop(),t)||!G(n)||u&&m(n[d])&&!x(n)&&((a=n[u])&&(n[u]=null),k.event.triggered=d,e.isPropagationStopped()&&f.addEventListener(d,Ct),n[d](),e.isPropagationStopped()&&f.removeEventListener(d,Ct),k.event.triggered=void 0,a&&(n[u]=a)),e.result}},simulate:function(e,t,n){var r=k.extend(new k.Event,n,{type:e,isSimulated:!0});k.event.trigger(r,null,t)}}),k.fn.extend({trigger:function(e,t){return this.each(function(){k.event.trigger(e,t,this)})},triggerHandler:function(e,t){var n=this[0];if(n)return k.event.trigger(e,t,n,!0)}}),y.focusin||k.each({focus:"focusin",blur:"focusout"},function(n,r){var i=function(e){k.event.simulate(r,e.target,k.event.fix(e))};k.event.special[r]={setup:function(){var e=this.ownerDocument||this,t=Q.access(e,r);t||e.addEventListener(n,i,!0),Q.access(e,r,(t||0)+1)},teardown:function(){var e=this.ownerDocument||this,t=Q.access(e,r)-1;t?Q.access(e,r,t):(e.removeEventListener(n,i,!0),Q.remove(e,r))}}});var Et=C.location,kt=Date.now(),St=/\?/;k.parseXML=function(e){var t;if(!e||"string"!=typeof e)return null;try{t=(new C.DOMParser).parseFromString(e,"text/xml")}catch(e){t=void 0}return t&&!t.getElementsByTagName("parsererror").length||k.error("Invalid XML: "+e),t};var Nt=/\[\]$/,At=/\r?\n/g,Dt=/^(?:submit|button|image|reset|file)$/i,jt=/^(?:input|select|textarea|keygen)/i;function qt(n,e,r,i){var t;if(Array.isArray(e))k.each(e,function(e,t){r||Nt.test(n)?i(n,t):qt(n+"["+("object"==typeof t&&null!=t?e:"")+"]",t,r,i)});else if(r||"object"!==w(e))i(n,e);else for(t in e)qt(n+"["+t+"]",e[t],r,i)}k.param=function(e,t){var n,r=[],i=function(e,t){var n=m(t)?t():t;r[r.length]=encodeURIComponent(e)+"="+encodeURIComponent(null==n?"":n)};if(null==e)return"";if(Array.isArray(e)||e.jquery&&!k.isPlainObject(e))k.each(e,function(){i(this.name,this.value)});else for(n in e)qt(n,e[n],t,i);return r.join("&")},k.fn.extend({serialize:function(){return k.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=k.prop(this,"elements");return e?k.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!k(this).is(":disabled")&&jt.test(this.nodeName)&&!Dt.test(e)&&(this.checked||!pe.test(e))}).map(function(e,t){var n=k(this).val();return null==n?null:Array.isArray(n)?k.map(n,function(e){return{name:t.name,value:e.replace(At,"\r\n")}}):{name:t.name,value:n.replace(At,"\r\n")}}).get()}});var Lt=/%20/g,Ht=/#.*$/,Ot=/([?&])_=[^&]*/,Pt=/^(.*?):[ \t]*([^\r\n]*)$/gm,Rt=/^(?:GET|HEAD)$/,Mt=/^\/\//,It={},Wt={},$t="*/".concat("*"),Ft=E.createElement("a");function Bt(o){return function(e,t){"string"!=typeof e&&(t=e,e="*");var n,r=0,i=e.toLowerCase().match(R)||[];if(m(t))while(n=i[r++])"+"===n[0]?(n=n.slice(1)||"*",(o[n]=o[n]||[]).unshift(t)):(o[n]=o[n]||[]).push(t)}}function _t(t,i,o,a){var s={},u=t===Wt;function l(e){var r;return s[e]=!0,k.each(t[e]||[],function(e,t){var n=t(i,o,a);return"string"!=typeof n||u||s[n]?u?!(r=n):void 0:(i.dataTypes.unshift(n),l(n),!1)}),r}return l(i.dataTypes[0])||!s["*"]&&l("*")}function zt(e,t){var n,r,i=k.ajaxSettings.flatOptions||{};for(n in t)void 0!==t[n]&&((i[n]?e:r||(r={}))[n]=t[n]);return r&&k.extend(!0,e,r),e}Ft.href=Et.href,k.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:Et.href,type:"GET",isLocal:/^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(Et.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":$t,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":k.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?zt(zt(e,k.ajaxSettings),t):zt(k.ajaxSettings,e)},ajaxPrefilter:Bt(It),ajaxTransport:Bt(Wt),ajax:function(e,t){"object"==typeof e&&(t=e,e=void 0),t=t||{};var c,f,p,n,d,r,h,g,i,o,v=k.ajaxSetup({},t),y=v.context||v,m=v.context&&(y.nodeType||y.jquery)?k(y):k.event,x=k.Deferred(),b=k.Callbacks("once memory"),w=v.statusCode||{},a={},s={},u="canceled",T={readyState:0,getResponseHeader:function(e){var t;if(h){if(!n){n={};while(t=Pt.exec(p))n[t[1].toLowerCase()+" "]=(n[t[1].toLowerCase()+" "]||[]).concat(t[2])}t=n[e.toLowerCase()+" "]}return null==t?null:t.join(", ")},getAllResponseHeaders:function(){return h?p:null},setRequestHeader:function(e,t){return null==h&&(e=s[e.toLowerCase()]=s[e.toLowerCase()]||e,a[e]=t),this},overrideMimeType:function(e){return null==h&&(v.mimeType=e),this},statusCode:function(e){var t;if(e)if(h)T.always(e[T.status]);else for(t in e)w[t]=[w[t],e[t]];return this},abort:function(e){var t=e||u;return c&&c.abort(t),l(0,t),this}};if(x.promise(T),v.url=((e||v.url||Et.href)+"").replace(Mt,Et.protocol+"//"),v.type=t.method||t.type||v.method||v.type,v.dataTypes=(v.dataType||"*").toLowerCase().match(R)||[""],null==v.crossDomain){r=E.createElement("a");try{r.href=v.url,r.href=r.href,v.crossDomain=Ft.protocol+"//"+Ft.host!=r.protocol+"//"+r.host}catch(e){v.crossDomain=!0}}if(v.data&&v.processData&&"string"!=typeof v.data&&(v.data=k.param(v.data,v.traditional)),_t(It,v,t,T),h)return T;for(i in(g=k.event&&v.global)&&0==k.active++&&k.event.trigger("ajaxStart"),v.type=v.type.toUpperCase(),v.hasContent=!Rt.test(v.type),f=v.url.replace(Ht,""),v.hasContent?v.data&&v.processData&&0===(v.contentType||"").indexOf("application/x-www-form-urlencoded")&&(v.data=v.data.replace(Lt,"+")):(o=v.url.slice(f.length),v.data&&(v.processData||"string"==typeof v.data)&&(f+=(St.test(f)?"&":"?")+v.data,delete v.data),!1===v.cache&&(f=f.replace(Ot,"$1"),o=(St.test(f)?"&":"?")+"_="+kt+++o),v.url=f+o),v.ifModified&&(k.lastModified[f]&&T.setRequestHeader("If-Modified-Since",k.lastModified[f]),k.etag[f]&&T.setRequestHeader("If-None-Match",k.etag[f])),(v.data&&v.hasContent&&!1!==v.contentType||t.contentType)&&T.setRequestHeader("Content-Type",v.contentType),T.setRequestHeader("Accept",v.dataTypes[0]&&v.accepts[v.dataTypes[0]]?v.accepts[v.dataTypes[0]]+("*"!==v.dataTypes[0]?", "+$t+"; q=0.01":""):v.accepts["*"]),v.headers)T.setRequestHeader(i,v.headers[i]);if(v.beforeSend&&(!1===v.beforeSend.call(y,T,v)||h))return T.abort();if(u="abort",b.add(v.complete),T.done(v.success),T.fail(v.error),c=_t(Wt,v,t,T)){if(T.readyState=1,g&&m.trigger("ajaxSend",[T,v]),h)return T;v.async&&0<v.timeout&&(d=C.setTimeout(function(){T.abort("timeout")},v.timeout));try{h=!1,c.send(a,l)}catch(e){if(h)throw e;l(-1,e)}}else l(-1,"No Transport");function l(e,t,n,r){var i,o,a,s,u,l=t;h||(h=!0,d&&C.clearTimeout(d),c=void 0,p=r||"",T.readyState=0<e?4:0,i=200<=e&&e<300||304===e,n&&(s=function(e,t,n){var r,i,o,a,s=e.contents,u=e.dataTypes;while("*"===u[0])u.shift(),void 0===r&&(r=e.mimeType||t.getResponseHeader("Content-Type"));if(r)for(i in s)if(s[i]&&s[i].test(r)){u.unshift(i);break}if(u[0]in n)o=u[0];else{for(i in n){if(!u[0]||e.converters[i+" "+u[0]]){o=i;break}a||(a=i)}o=o||a}if(o)return o!==u[0]&&u.unshift(o),n[o]}(v,T,n)),s=function(e,t,n,r){var i,o,a,s,u,l={},c=e.dataTypes.slice();if(c[1])for(a in e.converters)l[a.toLowerCase()]=e.converters[a];o=c.shift();while(o)if(e.responseFields[o]&&(n[e.responseFields[o]]=t),!u&&r&&e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u=o,o=c.shift())if("*"===o)o=u;else if("*"!==u&&u!==o){if(!(a=l[u+" "+o]||l["* "+o]))for(i in l)if((s=i.split(" "))[1]===o&&(a=l[u+" "+s[0]]||l["* "+s[0]])){!0===a?a=l[i]:!0!==l[i]&&(o=s[0],c.unshift(s[1]));break}if(!0!==a)if(a&&e["throws"])t=a(t);else try{t=a(t)}catch(e){return{state:"parsererror",error:a?e:"No conversion from "+u+" to "+o}}}return{state:"success",data:t}}(v,s,T,i),i?(v.ifModified&&((u=T.getResponseHeader("Last-Modified"))&&(k.lastModified[f]=u),(u=T.getResponseHeader("etag"))&&(k.etag[f]=u)),204===e||"HEAD"===v.type?l="nocontent":304===e?l="notmodified":(l=s.state,o=s.data,i=!(a=s.error))):(a=l,!e&&l||(l="error",e<0&&(e=0))),T.status=e,T.statusText=(t||l)+"",i?x.resolveWith(y,[o,l,T]):x.rejectWith(y,[T,l,a]),T.statusCode(w),w=void 0,g&&m.trigger(i?"ajaxSuccess":"ajaxError",[T,v,i?o:a]),b.fireWith(y,[T,l]),g&&(m.trigger("ajaxComplete",[T,v]),--k.active||k.event.trigger("ajaxStop")))}return T},getJSON:function(e,t,n){return k.get(e,t,n,"json")},getScript:function(e,t){return k.get(e,void 0,t,"script")}}),k.each(["get","post"],function(e,i){k[i]=function(e,t,n,r){return m(t)&&(r=r||n,n=t,t=void 0),k.ajax(k.extend({url:e,type:i,dataType:r,data:t,success:n},k.isPlainObject(e)&&e))}}),k._evalUrl=function(e,t){return k.ajax({url:e,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,converters:{"text script":function(){}},dataFilter:function(e){k.globalEval(e,t)}})},k.fn.extend({wrapAll:function(e){var t;return this[0]&&(m(e)&&(e=e.call(this[0])),t=k(e,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstElementChild)e=e.firstElementChild;return e}).append(this)),this},wrapInner:function(n){return m(n)?this.each(function(e){k(this).wrapInner(n.call(this,e))}):this.each(function(){var e=k(this),t=e.contents();t.length?t.wrapAll(n):e.append(n)})},wrap:function(t){var n=m(t);return this.each(function(e){k(this).wrapAll(n?t.call(this,e):t)})},unwrap:function(e){return this.parent(e).not("body").each(function(){k(this).replaceWith(this.childNodes)}),this}}),k.expr.pseudos.hidden=function(e){return!k.expr.pseudos.visible(e)},k.expr.pseudos.visible=function(e){return!!(e.offsetWidth||e.offsetHeight||e.getClientRects().length)},k.ajaxSettings.xhr=function(){try{return new C.XMLHttpRequest}catch(e){}};var Ut={0:200,1223:204},Xt=k.ajaxSettings.xhr();y.cors=!!Xt&&"withCredentials"in Xt,y.ajax=Xt=!!Xt,k.ajaxTransport(function(i){var o,a;if(y.cors||Xt&&!i.crossDomain)return{send:function(e,t){var n,r=i.xhr();if(r.open(i.type,i.url,i.async,i.username,i.password),i.xhrFields)for(n in i.xhrFields)r[n]=i.xhrFields[n];for(n in i.mimeType&&r.overrideMimeType&&r.overrideMimeType(i.mimeType),i.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest"),e)r.setRequestHeader(n,e[n]);o=function(e){return function(){o&&(o=a=r.onload=r.onerror=r.onabort=r.ontimeout=r.onreadystatechange=null,"abort"===e?r.abort():"error"===e?"number"!=typeof r.status?t(0,"error"):t(r.status,r.statusText):t(Ut[r.status]||r.status,r.statusText,"text"!==(r.responseType||"text")||"string"!=typeof r.responseText?{binary:r.response}:{text:r.responseText},r.getAllResponseHeaders()))}},r.onload=o(),a=r.onerror=r.ontimeout=o("error"),void 0!==r.onabort?r.onabort=a:r.onreadystatechange=function(){4===r.readyState&&C.setTimeout(function(){o&&a()})},o=o("abort");try{r.send(i.hasContent&&i.data||null)}catch(e){if(o)throw e}},abort:function(){o&&o()}}}),k.ajaxPrefilter(function(e){e.crossDomain&&(e.contents.script=!1)}),k.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(e){return k.globalEval(e),e}}}),k.ajaxPrefilter("script",function(e){void 0===e.cache&&(e.cache=!1),e.crossDomain&&(e.type="GET")}),k.ajaxTransport("script",function(n){var r,i;if(n.crossDomain||n.scriptAttrs)return{send:function(e,t){r=k("<script>").attr(n.scriptAttrs||{}).prop({charset:n.scriptCharset,src:n.url}).on("load error",i=function(e){r.remove(),i=null,e&&t("error"===e.type?404:200,e.type)}),E.head.appendChild(r[0])},abort:function(){i&&i()}}});var Vt,Gt=[],Yt=/(=)\?(?=&|$)|\?\?/;k.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Gt.pop()||k.expando+"_"+kt++;return this[e]=!0,e}}),k.ajaxPrefilter("json jsonp",function(e,t,n){var r,i,o,a=!1!==e.jsonp&&(Yt.test(e.url)?"url":"string"==typeof e.data&&0===(e.contentType||"").indexOf("application/x-www-form-urlencoded")&&Yt.test(e.data)&&"data");if(a||"jsonp"===e.dataTypes[0])return r=e.jsonpCallback=m(e.jsonpCallback)?e.jsonpCallback():e.jsonpCallback,a?e[a]=e[a].replace(Yt,"$1"+r):!1!==e.jsonp&&(e.url+=(St.test(e.url)?"&":"?")+e.jsonp+"="+r),e.converters["script json"]=function(){return o||k.error(r+" was not called"),o[0]},e.dataTypes[0]="json",i=C[r],C[r]=function(){o=arguments},n.always(function(){void 0===i?k(C).removeProp(r):C[r]=i,e[r]&&(e.jsonpCallback=t.jsonpCallback,Gt.push(r)),o&&m(i)&&i(o[0]),o=i=void 0}),"script"}),y.createHTMLDocument=((Vt=E.implementation.createHTMLDocument("").body).innerHTML="<form></form><form></form>",2===Vt.childNodes.length),k.parseHTML=function(e,t,n){return"string"!=typeof e?[]:("boolean"==typeof t&&(n=t,t=!1),t||(y.createHTMLDocument?((r=(t=E.implementation.createHTMLDocument("")).createElement("base")).href=E.location.href,t.head.appendChild(r)):t=E),o=!n&&[],(i=D.exec(e))?[t.createElement(i[1])]:(i=we([e],t,o),o&&o.length&&k(o).remove(),k.merge([],i.childNodes)));var r,i,o},k.fn.load=function(e,t,n){var r,i,o,a=this,s=e.indexOf(" ");return-1<s&&(r=mt(e.slice(s)),e=e.slice(0,s)),m(t)?(n=t,t=void 0):t&&"object"==typeof t&&(i="POST"),0<a.length&&k.ajax({url:e,type:i||"GET",dataType:"html",data:t}).done(function(e){o=arguments,a.html(r?k("<div>").append(k.parseHTML(e)).find(r):e)}).always(n&&function(e,t){a.each(function(){n.apply(this,o||[e.responseText,t,e])})}),this},k.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){k.fn[t]=function(e){return this.on(t,e)}}),k.expr.pseudos.animated=function(t){return k.grep(k.timers,function(e){return t===e.elem}).length},k.offset={setOffset:function(e,t,n){var r,i,o,a,s,u,l=k.css(e,"position"),c=k(e),f={};"static"===l&&(e.style.position="relative"),s=c.offset(),o=k.css(e,"top"),u=k.css(e,"left"),("absolute"===l||"fixed"===l)&&-1<(o+u).indexOf("auto")?(a=(r=c.position()).top,i=r.left):(a=parseFloat(o)||0,i=parseFloat(u)||0),m(t)&&(t=t.call(e,n,k.extend({},s))),null!=t.top&&(f.top=t.top-s.top+a),null!=t.left&&(f.left=t.left-s.left+i),"using"in t?t.using.call(e,f):c.css(f)}},k.fn.extend({offset:function(t){if(arguments.length)return void 0===t?this:this.each(function(e){k.offset.setOffset(this,t,e)});var e,n,r=this[0];return r?r.getClientRects().length?(e=r.getBoundingClientRect(),n=r.ownerDocument.defaultView,{top:e.top+n.pageYOffset,left:e.left+n.pageXOffset}):{top:0,left:0}:void 0},position:function(){if(this[0]){var e,t,n,r=this[0],i={top:0,left:0};if("fixed"===k.css(r,"position"))t=r.getBoundingClientRect();else{t=this.offset(),n=r.ownerDocument,e=r.offsetParent||n.documentElement;while(e&&(e===n.body||e===n.documentElement)&&"static"===k.css(e,"position"))e=e.parentNode;e&&e!==r&&1===e.nodeType&&((i=k(e).offset()).top+=k.css(e,"borderTopWidth",!0),i.left+=k.css(e,"borderLeftWidth",!0))}return{top:t.top-i.top-k.css(r,"marginTop",!0),left:t.left-i.left-k.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent;while(e&&"static"===k.css(e,"position"))e=e.offsetParent;return e||ie})}}),k.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(t,i){var o="pageYOffset"===i;k.fn[t]=function(e){return _(this,function(e,t,n){var r;if(x(e)?r=e:9===e.nodeType&&(r=e.defaultView),void 0===n)return r?r[i]:e[t];r?r.scrollTo(o?r.pageXOffset:n,o?n:r.pageYOffset):e[t]=n},t,e,arguments.length)}}),k.each(["top","left"],function(e,n){k.cssHooks[n]=ze(y.pixelPosition,function(e,t){if(t)return t=_e(e,n),$e.test(t)?k(e).position()[n]+"px":t})}),k.each({Height:"height",Width:"width"},function(a,s){k.each({padding:"inner"+a,content:s,"":"outer"+a},function(r,o){k.fn[o]=function(e,t){var n=arguments.length&&(r||"boolean"!=typeof e),i=r||(!0===e||!0===t?"margin":"border");return _(this,function(e,t,n){var r;return x(e)?0===o.indexOf("outer")?e["inner"+a]:e.document.documentElement["client"+a]:9===e.nodeType?(r=e.documentElement,Math.max(e.body["scroll"+a],r["scroll"+a],e.body["offset"+a],r["offset"+a],r["client"+a])):void 0===n?k.css(e,t,i):k.style(e,t,n,i)},s,n?e:void 0,n)}})}),k.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(e,n){k.fn[n]=function(e,t){return 0<arguments.length?this.on(n,null,e,t):this.trigger(n)}}),k.fn.extend({hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),k.fn.extend({bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)}}),k.proxy=function(e,t){var n,r,i;if("string"==typeof t&&(n=e[t],t=e,e=n),m(e))return r=s.call(arguments,2),(i=function(){return e.apply(t||this,r.concat(s.call(arguments)))}).guid=e.guid=e.guid||k.guid++,i},k.holdReady=function(e){e?k.readyWait++:k.ready(!0)},k.isArray=Array.isArray,k.parseJSON=JSON.parse,k.nodeName=A,k.isFunction=m,k.isWindow=x,k.camelCase=V,k.type=w,k.now=Date.now,k.isNumeric=function(e){var t=k.type(e);return("number"===t||"string"===t)&&!isNaN(e-parseFloat(e))},"function"==typeof define&&define.amd&&define("jquery",[],function(){return k});var Qt=C.jQuery,Jt=C.$;return k.noConflict=function(e){return C.$===k&&(C.$=Jt),e&&C.jQuery===k&&(C.jQuery=Qt),k},e||(C.jQuery=C.$=k),k});
/*!
* Bootstrap v4.3.1 (https://getbootstrap.com/)
* Copyright 2011-2019 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
* Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
*/
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("jquery")):"function"==typeof define&&define.amd?define(["exports","jquery"],e):e((t=t||self).bootstrap={},t.jQuery)}(this,function(t,p){"use strict";function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}function s(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}function l(o){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{},e=Object.keys(r);"function"==typeof Object.getOwnPropertySymbols&&(e=e.concat(Object.getOwnPropertySymbols(r).filter(function(t){return Object.getOwnPropertyDescriptor(r,t).enumerable}))),e.forEach(function(t){var e,n,i;e=o,i=r[n=t],n in e?Object.defineProperty(e,n,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[n]=i})}return o}p=p&&p.hasOwnProperty("default")?p.default:p;var e="transitionend";function n(t){var e=this,n=!1;return p(this).one(m.TRANSITION_END,function(){n=!0}),setTimeout(function(){n||m.triggerTransitionEnd(e)},t),this}var m={TRANSITION_END:"bsTransitionEnd",getUID:function(t){for(;t+=~~(1e6*Math.random()),document.getElementById(t););return t},getSelectorFromElement:function(t){var e=t.getAttribute("data-target");if(!e||"#"===e){var n=t.getAttribute("href");e=n&&"#"!==n?n.trim():""}try{return document.querySelector(e)?e:null}catch(t){return null}},getTransitionDurationFromElement:function(t){if(!t)return 0;var e=p(t).css("transition-duration"),n=p(t).css("transition-delay"),i=parseFloat(e),o=parseFloat(n);return i||o?(e=e.split(",")[0],n=n.split(",")[0],1e3*(parseFloat(e)+parseFloat(n))):0},reflow:function(t){return t.offsetHeight},triggerTransitionEnd:function(t){p(t).trigger(e)},supportsTransitionEnd:function(){return Boolean(e)},isElement:function(t){return(t[0]||t).nodeType},typeCheckConfig:function(t,e,n){for(var i in n)if(Object.prototype.hasOwnProperty.call(n,i)){var o=n[i],r=e[i],s=r&&m.isElement(r)?"element":(a=r,{}.toString.call(a).match(/\s([a-z]+)/i)[1].toLowerCase());if(!new RegExp(o).test(s))throw new Error(t.toUpperCase()+': Option "'+i+'" provided type "'+s+'" but expected type "'+o+'".')}var a},findShadowRoot:function(t){if(!document.documentElement.attachShadow)return null;if("function"!=typeof t.getRootNode)return t instanceof ShadowRoot?t:t.parentNode?m.findShadowRoot(t.parentNode):null;var e=t.getRootNode();return e instanceof ShadowRoot?e:null}};p.fn.emulateTransitionEnd=n,p.event.special[m.TRANSITION_END]={bindType:e,delegateType:e,handle:function(t){if(p(t.target).is(this))return t.handleObj.handler.apply(this,arguments)}};var o="alert",r="bs.alert",a="."+r,c=p.fn[o],h={CLOSE:"close"+a,CLOSED:"closed"+a,CLICK_DATA_API:"click"+a+".data-api"},u="alert",f="fade",d="show",g=function(){function i(t){this._element=t}var t=i.prototype;return t.close=function(t){var e=this._element;t&&(e=this._getRootElement(t)),this._triggerCloseEvent(e).isDefaultPrevented()||this._removeElement(e)},t.dispose=function(){p.removeData(this._element,r),this._element=null},t._getRootElement=function(t){var e=m.getSelectorFromElement(t),n=!1;return e&&(n=document.querySelector(e)),n||(n=p(t).closest("."+u)[0]),n},t._triggerCloseEvent=function(t){var e=p.Event(h.CLOSE);return p(t).trigger(e),e},t._removeElement=function(e){var n=this;if(p(e).removeClass(d),p(e).hasClass(f)){var t=m.getTransitionDurationFromElement(e);p(e).one(m.TRANSITION_END,function(t){return n._destroyElement(e,t)}).emulateTransitionEnd(t)}else this._destroyElement(e)},t._destroyElement=function(t){p(t).detach().trigger(h.CLOSED).remove()},i._jQueryInterface=function(n){return this.each(function(){var t=p(this),e=t.data(r);e||(e=new i(this),t.data(r,e)),"close"===n&&e[n](this)})},i._handleDismiss=function(e){return function(t){t&&t.preventDefault(),e.close(this)}},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}}]),i}();p(document).on(h.CLICK_DATA_API,'[data-dismiss="alert"]',g._handleDismiss(new g)),p.fn[o]=g._jQueryInterface,p.fn[o].Constructor=g,p.fn[o].noConflict=function(){return p.fn[o]=c,g._jQueryInterface};var _="button",v="bs.button",y="."+v,E=".data-api",b=p.fn[_],w="active",C="btn",T="focus",S='[data-toggle^="button"]',D='[data-toggle="buttons"]',I='input:not([type="hidden"])',A=".active",O=".btn",N={CLICK_DATA_API:"click"+y+E,FOCUS_BLUR_DATA_API:"focus"+y+E+" blur"+y+E},k=function(){function n(t){this._element=t}var t=n.prototype;return t.toggle=function(){var t=!0,e=!0,n=p(this._element).closest(D)[0];if(n){var i=this._element.querySelector(I);if(i){if("radio"===i.type)if(i.checked&&this._element.classList.contains(w))t=!1;else{var o=n.querySelector(A);o&&p(o).removeClass(w)}if(t){if(i.hasAttribute("disabled")||n.hasAttribute("disabled")||i.classList.contains("disabled")||n.classList.contains("disabled"))return;i.checked=!this._element.classList.contains(w),p(i).trigger("change")}i.focus(),e=!1}}e&&this._element.setAttribute("aria-pressed",!this._element.classList.contains(w)),t&&p(this._element).toggleClass(w)},t.dispose=function(){p.removeData(this._element,v),this._element=null},n._jQueryInterface=function(e){return this.each(function(){var t=p(this).data(v);t||(t=new n(this),p(this).data(v,t)),"toggle"===e&&t[e]()})},s(n,null,[{key:"VERSION",get:function(){return"4.3.1"}}]),n}();p(document).on(N.CLICK_DATA_API,S,function(t){t.preventDefault();var e=t.target;p(e).hasClass(C)||(e=p(e).closest(O)),k._jQueryInterface.call(p(e),"toggle")}).on(N.FOCUS_BLUR_DATA_API,S,function(t){var e=p(t.target).closest(O)[0];p(e).toggleClass(T,/^focus(in)?$/.test(t.type))}),p.fn[_]=k._jQueryInterface,p.fn[_].Constructor=k,p.fn[_].noConflict=function(){return p.fn[_]=b,k._jQueryInterface};var L="carousel",x="bs.carousel",P="."+x,H=".data-api",j=p.fn[L],R={interval:5e3,keyboard:!0,slide:!1,pause:"hover",wrap:!0,touch:!0},F={interval:"(number|boolean)",keyboard:"boolean",slide:"(boolean|string)",pause:"(string|boolean)",wrap:"boolean",touch:"boolean"},M="next",W="prev",U="left",B="right",q={SLIDE:"slide"+P,SLID:"slid"+P,KEYDOWN:"keydown"+P,MOUSEENTER:"mouseenter"+P,MOUSELEAVE:"mouseleave"+P,TOUCHSTART:"touchstart"+P,TOUCHMOVE:"touchmove"+P,TOUCHEND:"touchend"+P,POINTERDOWN:"pointerdown"+P,POINTERUP:"pointerup"+P,DRAG_START:"dragstart"+P,LOAD_DATA_API:"load"+P+H,CLICK_DATA_API:"click"+P+H},K="carousel",Q="active",V="slide",Y="carousel-item-right",z="carousel-item-left",X="carousel-item-next",G="carousel-item-prev",$="pointer-event",J=".active",Z=".active.carousel-item",tt=".carousel-item",et=".carousel-item img",nt=".carousel-item-next, .carousel-item-prev",it=".carousel-indicators",ot="[data-slide], [data-slide-to]",rt='[data-ride="carousel"]',st={TOUCH:"touch",PEN:"pen"},at=function(){function r(t,e){this._items=null,this._interval=null,this._activeElement=null,this._isPaused=!1,this._isSliding=!1,this.touchTimeout=null,this.touchStartX=0,this.touchDeltaX=0,this._config=this._getConfig(e),this._element=t,this._indicatorsElement=this._element.querySelector(it),this._touchSupported="ontouchstart"in document.documentElement||0<navigator.maxTouchPoints,this._pointerEvent=Boolean(window.PointerEvent||window.MSPointerEvent),this._addEventListeners()}var t=r.prototype;return t.next=function(){this._isSliding||this._slide(M)},t.nextWhenVisible=function(){!document.hidden&&p(this._element).is(":visible")&&"hidden"!==p(this._element).css("visibility")&&this.next()},t.prev=function(){this._isSliding||this._slide(W)},t.pause=function(t){t||(this._isPaused=!0),this._element.querySelector(nt)&&(m.triggerTransitionEnd(this._element),this.cycle(!0)),clearInterval(this._interval),this._interval=null},t.cycle=function(t){t||(this._isPaused=!1),this._interval&&(clearInterval(this._interval),this._interval=null),this._config.interval&&!this._isPaused&&(this._interval=setInterval((document.visibilityState?this.nextWhenVisible:this.next).bind(this),this._config.interval))},t.to=function(t){var e=this;this._activeElement=this._element.querySelector(Z);var n=this._getItemIndex(this._activeElement);if(!(t>this._items.length-1||t<0))if(this._isSliding)p(this._element).one(q.SLID,function(){return e.to(t)});else{if(n===t)return this.pause(),void this.cycle();var i=n<t?M:W;this._slide(i,this._items[t])}},t.dispose=function(){p(this._element).off(P),p.removeData(this._element,x),this._items=null,this._config=null,this._element=null,this._interval=null,this._isPaused=null,this._isSliding=null,this._activeElement=null,this._indicatorsElement=null},t._getConfig=function(t){return t=l({},R,t),m.typeCheckConfig(L,t,F),t},t._handleSwipe=function(){var t=Math.abs(this.touchDeltaX);if(!(t<=40)){var e=t/this.touchDeltaX;0<e&&this.prev(),e<0&&this.next()}},t._addEventListeners=function(){var e=this;this._config.keyboard&&p(this._element).on(q.KEYDOWN,function(t){return e._keydown(t)}),"hover"===this._config.pause&&p(this._element).on(q.MOUSEENTER,function(t){return e.pause(t)}).on(q.MOUSELEAVE,function(t){return e.cycle(t)}),this._config.touch&&this._addTouchEventListeners()},t._addTouchEventListeners=function(){var n=this;if(this._touchSupported){var e=function(t){n._pointerEvent&&st[t.originalEvent.pointerType.toUpperCase()]?n.touchStartX=t.originalEvent.clientX:n._pointerEvent||(n.touchStartX=t.originalEvent.touches[0].clientX)},i=function(t){n._pointerEvent&&st[t.originalEvent.pointerType.toUpperCase()]&&(n.touchDeltaX=t.originalEvent.clientX-n.touchStartX),n._handleSwipe(),"hover"===n._config.pause&&(n.pause(),n.touchTimeout&&clearTimeout(n.touchTimeout),n.touchTimeout=setTimeout(function(t){return n.cycle(t)},500+n._config.interval))};p(this._element.querySelectorAll(et)).on(q.DRAG_START,function(t){return t.preventDefault()}),this._pointerEvent?(p(this._element).on(q.POINTERDOWN,function(t){return e(t)}),p(this._element).on(q.POINTERUP,function(t){return i(t)}),this._element.classList.add($)):(p(this._element).on(q.TOUCHSTART,function(t){return e(t)}),p(this._element).on(q.TOUCHMOVE,function(t){var e;(e=t).originalEvent.touches&&1<e.originalEvent.touches.length?n.touchDeltaX=0:n.touchDeltaX=e.originalEvent.touches[0].clientX-n.touchStartX}),p(this._element).on(q.TOUCHEND,function(t){return i(t)}))}},t._keydown=function(t){if(!/input|textarea/i.test(t.target.tagName))switch(t.which){case 37:t.preventDefault(),this.prev();break;case 39:t.preventDefault(),this.next()}},t._getItemIndex=function(t){return this._items=t&&t.parentNode?[].slice.call(t.parentNode.querySelectorAll(tt)):[],this._items.indexOf(t)},t._getItemByDirection=function(t,e){var n=t===M,i=t===W,o=this._getItemIndex(e),r=this._items.length-1;if((i&&0===o||n&&o===r)&&!this._config.wrap)return e;var s=(o+(t===W?-1:1))%this._items.length;return-1===s?this._items[this._items.length-1]:this._items[s]},t._triggerSlideEvent=function(t,e){var n=this._getItemIndex(t),i=this._getItemIndex(this._element.querySelector(Z)),o=p.Event(q.SLIDE,{relatedTarget:t,direction:e,from:i,to:n});return p(this._element).trigger(o),o},t._setActiveIndicatorElement=function(t){if(this._indicatorsElement){var e=[].slice.call(this._indicatorsElement.querySelectorAll(J));p(e).removeClass(Q);var n=this._indicatorsElement.children[this._getItemIndex(t)];n&&p(n).addClass(Q)}},t._slide=function(t,e){var n,i,o,r=this,s=this._element.querySelector(Z),a=this._getItemIndex(s),l=e||s&&this._getItemByDirection(t,s),c=this._getItemIndex(l),h=Boolean(this._interval);if(o=t===M?(n=z,i=X,U):(n=Y,i=G,B),l&&p(l).hasClass(Q))this._isSliding=!1;else if(!this._triggerSlideEvent(l,o).isDefaultPrevented()&&s&&l){this._isSliding=!0,h&&this.pause(),this._setActiveIndicatorElement(l);var u=p.Event(q.SLID,{relatedTarget:l,direction:o,from:a,to:c});if(p(this._element).hasClass(V)){p(l).addClass(i),m.reflow(l),p(s).addClass(n),p(l).addClass(n);var f=parseInt(l.getAttribute("data-interval"),10);this._config.interval=f?(this._config.defaultInterval=this._config.defaultInterval||this._config.interval,f):this._config.defaultInterval||this._config.interval;var d=m.getTransitionDurationFromElement(s);p(s).one(m.TRANSITION_END,function(){p(l).removeClass(n+" "+i).addClass(Q),p(s).removeClass(Q+" "+i+" "+n),r._isSliding=!1,setTimeout(function(){return p(r._element).trigger(u)},0)}).emulateTransitionEnd(d)}else p(s).removeClass(Q),p(l).addClass(Q),this._isSliding=!1,p(this._element).trigger(u);h&&this.cycle()}},r._jQueryInterface=function(i){return this.each(function(){var t=p(this).data(x),e=l({},R,p(this).data());"object"==typeof i&&(e=l({},e,i));var n="string"==typeof i?i:e.slide;if(t||(t=new r(this,e),p(this).data(x,t)),"number"==typeof i)t.to(i);else if("string"==typeof n){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}else e.interval&&e.ride&&(t.pause(),t.cycle())})},r._dataApiClickHandler=function(t){var e=m.getSelectorFromElement(this);if(e){var n=p(e)[0];if(n&&p(n).hasClass(K)){var i=l({},p(n).data(),p(this).data()),o=this.getAttribute("data-slide-to");o&&(i.interval=!1),r._jQueryInterface.call(p(n),i),o&&p(n).data(x).to(o),t.preventDefault()}}},s(r,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return R}}]),r}();p(document).on(q.CLICK_DATA_API,ot,at._dataApiClickHandler),p(window).on(q.LOAD_DATA_API,function(){for(var t=[].slice.call(document.querySelectorAll(rt)),e=0,n=t.length;e<n;e++){var i=p(t[e]);at._jQueryInterface.call(i,i.data())}}),p.fn[L]=at._jQueryInterface,p.fn[L].Constructor=at,p.fn[L].noConflict=function(){return p.fn[L]=j,at._jQueryInterface};var lt="collapse",ct="bs.collapse",ht="."+ct,ut=p.fn[lt],ft={toggle:!0,parent:""},dt={toggle:"boolean",parent:"(string|element)"},pt={SHOW:"show"+ht,SHOWN:"shown"+ht,HIDE:"hide"+ht,HIDDEN:"hidden"+ht,CLICK_DATA_API:"click"+ht+".data-api"},mt="show",gt="collapse",_t="collapsing",vt="collapsed",yt="width",Et="height",bt=".show, .collapsing",wt='[data-toggle="collapse"]',Ct=function(){function a(e,t){this._isTransitioning=!1,this._element=e,this._config=this._getConfig(t),this._triggerArray=[].slice.call(document.querySelectorAll('[data-toggle="collapse"][href="#'+e.id+'"],[data-toggle="collapse"][data-target="#'+e.id+'"]'));for(var n=[].slice.call(document.querySelectorAll(wt)),i=0,o=n.length;i<o;i++){var r=n[i],s=m.getSelectorFromElement(r),a=[].slice.call(document.querySelectorAll(s)).filter(function(t){return t===e});null!==s&&0<a.length&&(this._selector=s,this._triggerArray.push(r))}this._parent=this._config.parent?this._getParent():null,this._config.parent||this._addAriaAndCollapsedClass(this._element,this._triggerArray),this._config.toggle&&this.toggle()}var t=a.prototype;return t.toggle=function(){p(this._element).hasClass(mt)?this.hide():this.show()},t.show=function(){var t,e,n=this;if(!this._isTransitioning&&!p(this._element).hasClass(mt)&&(this._parent&&0===(t=[].slice.call(this._parent.querySelectorAll(bt)).filter(function(t){return"string"==typeof n._config.parent?t.getAttribute("data-parent")===n._config.parent:t.classList.contains(gt)})).length&&(t=null),!(t&&(e=p(t).not(this._selector).data(ct))&&e._isTransitioning))){var i=p.Event(pt.SHOW);if(p(this._element).trigger(i),!i.isDefaultPrevented()){t&&(a._jQueryInterface.call(p(t).not(this._selector),"hide"),e||p(t).data(ct,null));var o=this._getDimension();p(this._element).removeClass(gt).addClass(_t),this._element.style[o]=0,this._triggerArray.length&&p(this._triggerArray).removeClass(vt).attr("aria-expanded",!0),this.setTransitioning(!0);var r="scroll"+(o[0].toUpperCase()+o.slice(1)),s=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,function(){p(n._element).removeClass(_t).addClass(gt).addClass(mt),n._element.style[o]="",n.setTransitioning(!1),p(n._element).trigger(pt.SHOWN)}).emulateTransitionEnd(s),this._element.style[o]=this._element[r]+"px"}}},t.hide=function(){var t=this;if(!this._isTransitioning&&p(this._element).hasClass(mt)){var e=p.Event(pt.HIDE);if(p(this._element).trigger(e),!e.isDefaultPrevented()){var n=this._getDimension();this._element.style[n]=this._element.getBoundingClientRect()[n]+"px",m.reflow(this._element),p(this._element).addClass(_t).removeClass(gt).removeClass(mt);var i=this._triggerArray.length;if(0<i)for(var o=0;o<i;o++){var r=this._triggerArray[o],s=m.getSelectorFromElement(r);if(null!==s)p([].slice.call(document.querySelectorAll(s))).hasClass(mt)||p(r).addClass(vt).attr("aria-expanded",!1)}this.setTransitioning(!0);this._element.style[n]="";var a=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,function(){t.setTransitioning(!1),p(t._element).removeClass(_t).addClass(gt).trigger(pt.HIDDEN)}).emulateTransitionEnd(a)}}},t.setTransitioning=function(t){this._isTransitioning=t},t.dispose=function(){p.removeData(this._element,ct),this._config=null,this._parent=null,this._element=null,this._triggerArray=null,this._isTransitioning=null},t._getConfig=function(t){return(t=l({},ft,t)).toggle=Boolean(t.toggle),m.typeCheckConfig(lt,t,dt),t},t._getDimension=function(){return p(this._element).hasClass(yt)?yt:Et},t._getParent=function(){var t,n=this;m.isElement(this._config.parent)?(t=this._config.parent,"undefined"!=typeof this._config.parent.jquery&&(t=this._config.parent[0])):t=document.querySelector(this._config.parent);var e='[data-toggle="collapse"][data-parent="'+this._config.parent+'"]',i=[].slice.call(t.querySelectorAll(e));return p(i).each(function(t,e){n._addAriaAndCollapsedClass(a._getTargetFromElement(e),[e])}),t},t._addAriaAndCollapsedClass=function(t,e){var n=p(t).hasClass(mt);e.length&&p(e).toggleClass(vt,!n).attr("aria-expanded",n)},a._getTargetFromElement=function(t){var e=m.getSelectorFromElement(t);return e?document.querySelector(e):null},a._jQueryInterface=function(i){return this.each(function(){var t=p(this),e=t.data(ct),n=l({},ft,t.data(),"object"==typeof i&&i?i:{});if(!e&&n.toggle&&/show|hide/.test(i)&&(n.toggle=!1),e||(e=new a(this,n),t.data(ct,e)),"string"==typeof i){if("undefined"==typeof e[i])throw new TypeError('No method named "'+i+'"');e[i]()}})},s(a,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return ft}}]),a}();p(document).on(pt.CLICK_DATA_API,wt,function(t){"A"===t.currentTarget.tagName&&t.preventDefault();var n=p(this),e=m.getSelectorFromElement(this),i=[].slice.call(document.querySelectorAll(e));p(i).each(function(){var t=p(this),e=t.data(ct)?"toggle":n.data();Ct._jQueryInterface.call(t,e)})}),p.fn[lt]=Ct._jQueryInterface,p.fn[lt].Constructor=Ct,p.fn[lt].noConflict=function(){return p.fn[lt]=ut,Ct._jQueryInterface};for(var Tt="undefined"!=typeof window&&"undefined"!=typeof document,St=["Edge","Trident","Firefox"],Dt=0,It=0;It<St.length;It+=1)if(Tt&&0<=navigator.userAgent.indexOf(St[It])){Dt=1;break}var At=Tt&&window.Promise?function(t){var e=!1;return function(){e||(e=!0,window.Promise.resolve().then(function(){e=!1,t()}))}}:function(t){var e=!1;return function(){e||(e=!0,setTimeout(function(){e=!1,t()},Dt))}};function Ot(t){return t&&"[object Function]"==={}.toString.call(t)}function Nt(t,e){if(1!==t.nodeType)return[];var n=t.ownerDocument.defaultView.getComputedStyle(t,null);return e?n[e]:n}function kt(t){return"HTML"===t.nodeName?t:t.parentNode||t.host}function Lt(t){if(!t)return document.body;switch(t.nodeName){case"HTML":case"BODY":return t.ownerDocument.body;case"#document":return t.body}var e=Nt(t),n=e.overflow,i=e.overflowX,o=e.overflowY;return/(auto|scroll|overlay)/.test(n+o+i)?t:Lt(kt(t))}var xt=Tt&&!(!window.MSInputMethodContext||!document.documentMode),Pt=Tt&&/MSIE 10/.test(navigator.userAgent);function Ht(t){return 11===t?xt:10===t?Pt:xt||Pt}function jt(t){if(!t)return document.documentElement;for(var e=Ht(10)?document.body:null,n=t.offsetParent||null;n===e&&t.nextElementSibling;)n=(t=t.nextElementSibling).offsetParent;var i=n&&n.nodeName;return i&&"BODY"!==i&&"HTML"!==i?-1!==["TH","TD","TABLE"].indexOf(n.nodeName)&&"static"===Nt(n,"position")?jt(n):n:t?t.ownerDocument.documentElement:document.documentElement}function Rt(t){return null!==t.parentNode?Rt(t.parentNode):t}function Ft(t,e){if(!(t&&t.nodeType&&e&&e.nodeType))return document.documentElement;var n=t.compareDocumentPosition(e)&Node.DOCUMENT_POSITION_FOLLOWING,i=n?t:e,o=n?e:t,r=document.createRange();r.setStart(i,0),r.setEnd(o,0);var s,a,l=r.commonAncestorContainer;if(t!==l&&e!==l||i.contains(o))return"BODY"===(a=(s=l).nodeName)||"HTML"!==a&&jt(s.firstElementChild)!==s?jt(l):l;var c=Rt(t);return c.host?Ft(c.host,e):Ft(t,Rt(e).host)}function Mt(t){var e="top"===(1<arguments.length&&void 0!==arguments[1]?arguments[1]:"top")?"scrollTop":"scrollLeft",n=t.nodeName;if("BODY"!==n&&"HTML"!==n)return t[e];var i=t.ownerDocument.documentElement;return(t.ownerDocument.scrollingElement||i)[e]}function Wt(t,e){var n="x"===e?"Left":"Top",i="Left"===n?"Right":"Bottom";return parseFloat(t["border"+n+"Width"],10)+parseFloat(t["border"+i+"Width"],10)}function Ut(t,e,n,i){return Math.max(e["offset"+t],e["scroll"+t],n["client"+t],n["offset"+t],n["scroll"+t],Ht(10)?parseInt(n["offset"+t])+parseInt(i["margin"+("Height"===t?"Top":"Left")])+parseInt(i["margin"+("Height"===t?"Bottom":"Right")]):0)}function Bt(t){var e=t.body,n=t.documentElement,i=Ht(10)&&getComputedStyle(n);return{height:Ut("Height",e,n,i),width:Ut("Width",e,n,i)}}var qt=function(){function i(t,e){for(var n=0;n<e.length;n++){var i=e[n];i.enumerable=i.enumerable||!1,i.configurable=!0,"value"in i&&(i.writable=!0),Object.defineProperty(t,i.key,i)}}return function(t,e,n){return e&&i(t.prototype,e),n&&i(t,n),t}}(),Kt=function(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t},Qt=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var i in n)Object.prototype.hasOwnProperty.call(n,i)&&(t[i]=n[i])}return t};function Vt(t){return Qt({},t,{right:t.left+t.width,bottom:t.top+t.height})}function Yt(t){var e={};try{if(Ht(10)){e=t.getBoundingClientRect();var n=Mt(t,"top"),i=Mt(t,"left");e.top+=n,e.left+=i,e.bottom+=n,e.right+=i}else e=t.getBoundingClientRect()}catch(t){}var o={left:e.left,top:e.top,width:e.right-e.left,height:e.bottom-e.top},r="HTML"===t.nodeName?Bt(t.ownerDocument):{},s=r.width||t.clientWidth||o.right-o.left,a=r.height||t.clientHeight||o.bottom-o.top,l=t.offsetWidth-s,c=t.offsetHeight-a;if(l||c){var h=Nt(t);l-=Wt(h,"x"),c-=Wt(h,"y"),o.width-=l,o.height-=c}return Vt(o)}function zt(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=Ht(10),o="HTML"===e.nodeName,r=Yt(t),s=Yt(e),a=Lt(t),l=Nt(e),c=parseFloat(l.borderTopWidth,10),h=parseFloat(l.borderLeftWidth,10);n&&o&&(s.top=Math.max(s.top,0),s.left=Math.max(s.left,0));var u=Vt({top:r.top-s.top-c,left:r.left-s.left-h,width:r.width,height:r.height});if(u.marginTop=0,u.marginLeft=0,!i&&o){var f=parseFloat(l.marginTop,10),d=parseFloat(l.marginLeft,10);u.top-=c-f,u.bottom-=c-f,u.left-=h-d,u.right-=h-d,u.marginTop=f,u.marginLeft=d}return(i&&!n?e.contains(a):e===a&&"BODY"!==a.nodeName)&&(u=function(t,e){var n=2<arguments.length&&void 0!==arguments[2]&&arguments[2],i=Mt(e,"top"),o=Mt(e,"left"),r=n?-1:1;return t.top+=i*r,t.bottom+=i*r,t.left+=o*r,t.right+=o*r,t}(u,e)),u}function Xt(t){if(!t||!t.parentElement||Ht())return document.documentElement;for(var e=t.parentElement;e&&"none"===Nt(e,"transform");)e=e.parentElement;return e||document.documentElement}function Gt(t,e,n,i){var o=4<arguments.length&&void 0!==arguments[4]&&arguments[4],r={top:0,left:0},s=o?Xt(t):Ft(t,e);if("viewport"===i)r=function(t){var e=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n=t.ownerDocument.documentElement,i=zt(t,n),o=Math.max(n.clientWidth,window.innerWidth||0),r=Math.max(n.clientHeight,window.innerHeight||0),s=e?0:Mt(n),a=e?0:Mt(n,"left");return Vt({top:s-i.top+i.marginTop,left:a-i.left+i.marginLeft,width:o,height:r})}(s,o);else{var a=void 0;"scrollParent"===i?"BODY"===(a=Lt(kt(e))).nodeName&&(a=t.ownerDocument.documentElement):a="window"===i?t.ownerDocument.documentElement:i;var l=zt(a,s,o);if("HTML"!==a.nodeName||function t(e){var n=e.nodeName;if("BODY"===n||"HTML"===n)return!1;if("fixed"===Nt(e,"position"))return!0;var i=kt(e);return!!i&&t(i)}(s))r=l;else{var c=Bt(t.ownerDocument),h=c.height,u=c.width;r.top+=l.top-l.marginTop,r.bottom=h+l.top,r.left+=l.left-l.marginLeft,r.right=u+l.left}}var f="number"==typeof(n=n||0);return r.left+=f?n:n.left||0,r.top+=f?n:n.top||0,r.right-=f?n:n.right||0,r.bottom-=f?n:n.bottom||0,r}function $t(t,e,i,n,o){var r=5<arguments.length&&void 0!==arguments[5]?arguments[5]:0;if(-1===t.indexOf("auto"))return t;var s=Gt(i,n,r,o),a={top:{width:s.width,height:e.top-s.top},right:{width:s.right-e.right,height:s.height},bottom:{width:s.width,height:s.bottom-e.bottom},left:{width:e.left-s.left,height:s.height}},l=Object.keys(a).map(function(t){return Qt({key:t},a[t],{area:(e=a[t],e.width*e.height)});var e}).sort(function(t,e){return e.area-t.area}),c=l.filter(function(t){var e=t.width,n=t.height;return e>=i.clientWidth&&n>=i.clientHeight}),h=0<c.length?c[0].key:l[0].key,u=t.split("-")[1];return h+(u?"-"+u:"")}function Jt(t,e,n){var i=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return zt(n,i?Xt(e):Ft(e,n),i)}function Zt(t){var e=t.ownerDocument.defaultView.getComputedStyle(t),n=parseFloat(e.marginTop||0)+parseFloat(e.marginBottom||0),i=parseFloat(e.marginLeft||0)+parseFloat(e.marginRight||0);return{width:t.offsetWidth+i,height:t.offsetHeight+n}}function te(t){var e={left:"right",right:"left",bottom:"top",top:"bottom"};return t.replace(/left|right|bottom|top/g,function(t){return e[t]})}function ee(t,e,n){n=n.split("-")[0];var i=Zt(t),o={width:i.width,height:i.height},r=-1!==["right","left"].indexOf(n),s=r?"top":"left",a=r?"left":"top",l=r?"height":"width",c=r?"width":"height";return o[s]=e[s]+e[l]/2-i[l]/2,o[a]=n===a?e[a]-i[c]:e[te(a)],o}function ne(t,e){return Array.prototype.find?t.find(e):t.filter(e)[0]}function ie(t,n,e){return(void 0===e?t:t.slice(0,function(t,e,n){if(Array.prototype.findIndex)return t.findIndex(function(t){return t[e]===n});var i=ne(t,function(t){return t[e]===n});return t.indexOf(i)}(t,"name",e))).forEach(function(t){t.function&&console.warn("`modifier.function` is deprecated, use `modifier.fn`!");var e=t.function||t.fn;t.enabled&&Ot(e)&&(n.offsets.popper=Vt(n.offsets.popper),n.offsets.reference=Vt(n.offsets.reference),n=e(n,t))}),n}function oe(t,n){return t.some(function(t){var e=t.name;return t.enabled&&e===n})}function re(t){for(var e=[!1,"ms","Webkit","Moz","O"],n=t.charAt(0).toUpperCase()+t.slice(1),i=0;i<e.length;i++){var o=e[i],r=o?""+o+n:t;if("undefined"!=typeof document.body.style[r])return r}return null}function se(t){var e=t.ownerDocument;return e?e.defaultView:window}function ae(t,e,n,i){n.updateBound=i,se(t).addEventListener("resize",n.updateBound,{passive:!0});var o=Lt(t);return function t(e,n,i,o){var r="BODY"===e.nodeName,s=r?e.ownerDocument.defaultView:e;s.addEventListener(n,i,{passive:!0}),r||t(Lt(s.parentNode),n,i,o),o.push(s)}(o,"scroll",n.updateBound,n.scrollParents),n.scrollElement=o,n.eventsEnabled=!0,n}function le(){var t,e;this.state.eventsEnabled&&(cancelAnimationFrame(this.scheduleUpdate),this.state=(t=this.reference,e=this.state,se(t).removeEventListener("resize",e.updateBound),e.scrollParents.forEach(function(t){t.removeEventListener("scroll",e.updateBound)}),e.updateBound=null,e.scrollParents=[],e.scrollElement=null,e.eventsEnabled=!1,e))}function ce(t){return""!==t&&!isNaN(parseFloat(t))&&isFinite(t)}function he(n,i){Object.keys(i).forEach(function(t){var e="";-1!==["width","height","top","right","bottom","left"].indexOf(t)&&ce(i[t])&&(e="px"),n.style[t]=i[t]+e})}var ue=Tt&&/Firefox/i.test(navigator.userAgent);function fe(t,e,n){var i=ne(t,function(t){return t.name===e}),o=!!i&&t.some(function(t){return t.name===n&&t.enabled&&t.order<i.order});if(!o){var r="`"+e+"`",s="`"+n+"`";console.warn(s+" modifier is required by "+r+" modifier in order to work, be sure to include it before "+r+"!")}return o}var de=["auto-start","auto","auto-end","top-start","top","top-end","right-start","right","right-end","bottom-end","bottom","bottom-start","left-end","left","left-start"],pe=de.slice(3);function me(t){var e=1<arguments.length&&void 0!==arguments[1]&&arguments[1],n=pe.indexOf(t),i=pe.slice(n+1).concat(pe.slice(0,n));return e?i.reverse():i}var ge="flip",_e="clockwise",ve="counterclockwise";function ye(t,o,r,e){var s=[0,0],a=-1!==["right","left"].indexOf(e),n=t.split(/(\+|\-)/).map(function(t){return t.trim()}),i=n.indexOf(ne(n,function(t){return-1!==t.search(/,|\s/)}));n[i]&&-1===n[i].indexOf(",")&&console.warn("Offsets separated by white space(s) are deprecated, use a comma (,) instead.");var l=/\s*,\s*|\s+/,c=-1!==i?[n.slice(0,i).concat([n[i].split(l)[0]]),[n[i].split(l)[1]].concat(n.slice(i+1))]:[n];return(c=c.map(function(t,e){var n=(1===e?!a:a)?"height":"width",i=!1;return t.reduce(function(t,e){return""===t[t.length-1]&&-1!==["+","-"].indexOf(e)?(t[t.length-1]=e,i=!0,t):i?(t[t.length-1]+=e,i=!1,t):t.concat(e)},[]).map(function(t){return function(t,e,n,i){var o=t.match(/((?:\-|\+)?\d*\.?\d*)(.*)/),r=+o[1],s=o[2];if(!r)return t;if(0!==s.indexOf("%"))return"vh"!==s&&"vw"!==s?r:("vh"===s?Math.max(document.documentElement.clientHeight,window.innerHeight||0):Math.max(document.documentElement.clientWidth,window.innerWidth||0))/100*r;var a=void 0;switch(s){case"%p":a=n;break;case"%":case"%r":default:a=i}return Vt(a)[e]/100*r}(t,n,o,r)})})).forEach(function(n,i){n.forEach(function(t,e){ce(t)&&(s[i]+=t*("-"===n[e-1]?-1:1))})}),s}var Ee={placement:"bottom",positionFixed:!1,eventsEnabled:!0,removeOnDestroy:!1,onCreate:function(){},onUpdate:function(){},modifiers:{shift:{order:100,enabled:!0,fn:function(t){var e=t.placement,n=e.split("-")[0],i=e.split("-")[1];if(i){var o=t.offsets,r=o.reference,s=o.popper,a=-1!==["bottom","top"].indexOf(n),l=a?"left":"top",c=a?"width":"height",h={start:Kt({},l,r[l]),end:Kt({},l,r[l]+r[c]-s[c])};t.offsets.popper=Qt({},s,h[i])}return t}},offset:{order:200,enabled:!0,fn:function(t,e){var n=e.offset,i=t.placement,o=t.offsets,r=o.popper,s=o.reference,a=i.split("-")[0],l=void 0;return l=ce(+n)?[+n,0]:ye(n,r,s,a),"left"===a?(r.top+=l[0],r.left-=l[1]):"right"===a?(r.top+=l[0],r.left+=l[1]):"top"===a?(r.left+=l[0],r.top-=l[1]):"bottom"===a&&(r.left+=l[0],r.top+=l[1]),t.popper=r,t},offset:0},preventOverflow:{order:300,enabled:!0,fn:function(t,i){var e=i.boundariesElement||jt(t.instance.popper);t.instance.reference===e&&(e=jt(e));var n=re("transform"),o=t.instance.popper.style,r=o.top,s=o.left,a=o[n];o.top="",o.left="",o[n]="";var l=Gt(t.instance.popper,t.instance.reference,i.padding,e,t.positionFixed);o.top=r,o.left=s,o[n]=a,i.boundaries=l;var c=i.priority,h=t.offsets.popper,u={primary:function(t){var e=h[t];return h[t]<l[t]&&!i.escapeWithReference&&(e=Math.max(h[t],l[t])),Kt({},t,e)},secondary:function(t){var e="right"===t?"left":"top",n=h[e];return h[t]>l[t]&&!i.escapeWithReference&&(n=Math.min(h[e],l[t]-("right"===t?h.width:h.height))),Kt({},e,n)}};return c.forEach(function(t){var e=-1!==["left","top"].indexOf(t)?"primary":"secondary";h=Qt({},h,u[e](t))}),t.offsets.popper=h,t},priority:["left","right","top","bottom"],padding:5,boundariesElement:"scrollParent"},keepTogether:{order:400,enabled:!0,fn:function(t){var e=t.offsets,n=e.popper,i=e.reference,o=t.placement.split("-")[0],r=Math.floor,s=-1!==["top","bottom"].indexOf(o),a=s?"right":"bottom",l=s?"left":"top",c=s?"width":"height";return n[a]<r(i[l])&&(t.offsets.popper[l]=r(i[l])-n[c]),n[l]>r(i[a])&&(t.offsets.popper[l]=r(i[a])),t}},arrow:{order:500,enabled:!0,fn:function(t,e){var n;if(!fe(t.instance.modifiers,"arrow","keepTogether"))return t;var i=e.element;if("string"==typeof i){if(!(i=t.instance.popper.querySelector(i)))return t}else if(!t.instance.popper.contains(i))return console.warn("WARNING: `arrow.element` must be child of its popper element!"),t;var o=t.placement.split("-")[0],r=t.offsets,s=r.popper,a=r.reference,l=-1!==["left","right"].indexOf(o),c=l?"height":"width",h=l?"Top":"Left",u=h.toLowerCase(),f=l?"left":"top",d=l?"bottom":"right",p=Zt(i)[c];a[d]-p<s[u]&&(t.offsets.popper[u]-=s[u]-(a[d]-p)),a[u]+p>s[d]&&(t.offsets.popper[u]+=a[u]+p-s[d]),t.offsets.popper=Vt(t.offsets.popper);var m=a[u]+a[c]/2-p/2,g=Nt(t.instance.popper),_=parseFloat(g["margin"+h],10),v=parseFloat(g["border"+h+"Width"],10),y=m-t.offsets.popper[u]-_-v;return y=Math.max(Math.min(s[c]-p,y),0),t.arrowElement=i,t.offsets.arrow=(Kt(n={},u,Math.round(y)),Kt(n,f,""),n),t},element:"[x-arrow]"},flip:{order:600,enabled:!0,fn:function(p,m){if(oe(p.instance.modifiers,"inner"))return p;if(p.flipped&&p.placement===p.originalPlacement)return p;var g=Gt(p.instance.popper,p.instance.reference,m.padding,m.boundariesElement,p.positionFixed),_=p.placement.split("-")[0],v=te(_),y=p.placement.split("-")[1]||"",E=[];switch(m.behavior){case ge:E=[_,v];break;case _e:E=me(_);break;case ve:E=me(_,!0);break;default:E=m.behavior}return E.forEach(function(t,e){if(_!==t||E.length===e+1)return p;_=p.placement.split("-")[0],v=te(_);var n,i=p.offsets.popper,o=p.offsets.reference,r=Math.floor,s="left"===_&&r(i.right)>r(o.left)||"right"===_&&r(i.left)<r(o.right)||"top"===_&&r(i.bottom)>r(o.top)||"bottom"===_&&r(i.top)<r(o.bottom),a=r(i.left)<r(g.left),l=r(i.right)>r(g.right),c=r(i.top)<r(g.top),h=r(i.bottom)>r(g.bottom),u="left"===_&&a||"right"===_&&l||"top"===_&&c||"bottom"===_&&h,f=-1!==["top","bottom"].indexOf(_),d=!!m.flipVariations&&(f&&"start"===y&&a||f&&"end"===y&&l||!f&&"start"===y&&c||!f&&"end"===y&&h);(s||u||d)&&(p.flipped=!0,(s||u)&&(_=E[e+1]),d&&(y="end"===(n=y)?"start":"start"===n?"end":n),p.placement=_+(y?"-"+y:""),p.offsets.popper=Qt({},p.offsets.popper,ee(p.instance.popper,p.offsets.reference,p.placement)),p=ie(p.instance.modifiers,p,"flip"))}),p},behavior:"flip",padding:5,boundariesElement:"viewport"},inner:{order:700,enabled:!1,fn:function(t){var e=t.placement,n=e.split("-")[0],i=t.offsets,o=i.popper,r=i.reference,s=-1!==["left","right"].indexOf(n),a=-1===["top","left"].indexOf(n);return o[s?"left":"top"]=r[n]-(a?o[s?"width":"height"]:0),t.placement=te(e),t.offsets.popper=Vt(o),t}},hide:{order:800,enabled:!0,fn:function(t){if(!fe(t.instance.modifiers,"hide","preventOverflow"))return t;var e=t.offsets.reference,n=ne(t.instance.modifiers,function(t){return"preventOverflow"===t.name}).boundaries;if(e.bottom<n.top||e.left>n.right||e.top>n.bottom||e.right<n.left){if(!0===t.hide)return t;t.hide=!0,t.attributes["x-out-of-boundaries"]=""}else{if(!1===t.hide)return t;t.hide=!1,t.attributes["x-out-of-boundaries"]=!1}return t}},computeStyle:{order:850,enabled:!0,fn:function(t,e){var n=e.x,i=e.y,o=t.offsets.popper,r=ne(t.instance.modifiers,function(t){return"applyStyle"===t.name}).gpuAcceleration;void 0!==r&&console.warn("WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!");var s,a,l,c,h,u,f,d,p,m,g,_,v,y,E=void 0!==r?r:e.gpuAcceleration,b=jt(t.instance.popper),w=Yt(b),C={position:o.position},T=(s=t,a=window.devicePixelRatio<2||!ue,l=s.offsets,c=l.popper,h=l.reference,u=Math.round,f=Math.floor,d=function(t){return t},p=u(h.width),m=u(c.width),g=-1!==["left","right"].indexOf(s.placement),_=-1!==s.placement.indexOf("-"),y=a?u:d,{left:(v=a?g||_||p%2==m%2?u:f:d)(p%2==1&&m%2==1&&!_&&a?c.left-1:c.left),top:y(c.top),bottom:y(c.bottom),right:v(c.right)}),S="bottom"===n?"top":"bottom",D="right"===i?"left":"right",I=re("transform"),A=void 0,O=void 0;if(O="bottom"===S?"HTML"===b.nodeName?-b.clientHeight+T.bottom:-w.height+T.bottom:T.top,A="right"===D?"HTML"===b.nodeName?-b.clientWidth+T.right:-w.width+T.right:T.left,E&&I)C[I]="translate3d("+A+"px, "+O+"px, 0)",C[S]=0,C[D]=0,C.willChange="transform";else{var N="bottom"===S?-1:1,k="right"===D?-1:1;C[S]=O*N,C[D]=A*k,C.willChange=S+", "+D}var L={"x-placement":t.placement};return t.attributes=Qt({},L,t.attributes),t.styles=Qt({},C,t.styles),t.arrowStyles=Qt({},t.offsets.arrow,t.arrowStyles),t},gpuAcceleration:!0,x:"bottom",y:"right"},applyStyle:{order:900,enabled:!0,fn:function(t){var e,n;return he(t.instance.popper,t.styles),e=t.instance.popper,n=t.attributes,Object.keys(n).forEach(function(t){!1!==n[t]?e.setAttribute(t,n[t]):e.removeAttribute(t)}),t.arrowElement&&Object.keys(t.arrowStyles).length&&he(t.arrowElement,t.arrowStyles),t},onLoad:function(t,e,n,i,o){var r=Jt(o,e,t,n.positionFixed),s=$t(n.placement,r,e,t,n.modifiers.flip.boundariesElement,n.modifiers.flip.padding);return e.setAttribute("x-placement",s),he(e,{position:n.positionFixed?"fixed":"absolute"}),n},gpuAcceleration:void 0}}},be=function(){function r(t,e){var n=this,i=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,r),this.scheduleUpdate=function(){return requestAnimationFrame(n.update)},this.update=At(this.update.bind(this)),this.options=Qt({},r.Defaults,i),this.state={isDestroyed:!1,isCreated:!1,scrollParents:[]},this.reference=t&&t.jquery?t[0]:t,this.popper=e&&e.jquery?e[0]:e,this.options.modifiers={},Object.keys(Qt({},r.Defaults.modifiers,i.modifiers)).forEach(function(t){n.options.modifiers[t]=Qt({},r.Defaults.modifiers[t]||{},i.modifiers?i.modifiers[t]:{})}),this.modifiers=Object.keys(this.options.modifiers).map(function(t){return Qt({name:t},n.options.modifiers[t])}).sort(function(t,e){return t.order-e.order}),this.modifiers.forEach(function(t){t.enabled&&Ot(t.onLoad)&&t.onLoad(n.reference,n.popper,n.options,t,n.state)}),this.update();var o=this.options.eventsEnabled;o&&this.enableEventListeners(),this.state.eventsEnabled=o}return qt(r,[{key:"update",value:function(){return function(){if(!this.state.isDestroyed){var t={instance:this,styles:{},arrowStyles:{},attributes:{},flipped:!1,offsets:{}};t.offsets.reference=Jt(this.state,this.popper,this.reference,this.options.positionFixed),t.placement=$t(this.options.placement,t.offsets.reference,this.popper,this.reference,this.options.modifiers.flip.boundariesElement,this.options.modifiers.flip.padding),t.originalPlacement=t.placement,t.positionFixed=this.options.positionFixed,t.offsets.popper=ee(this.popper,t.offsets.reference,t.placement),t.offsets.popper.position=this.options.positionFixed?"fixed":"absolute",t=ie(this.modifiers,t),this.state.isCreated?this.options.onUpdate(t):(this.state.isCreated=!0,this.options.onCreate(t))}}.call(this)}},{key:"destroy",value:function(){return function(){return this.state.isDestroyed=!0,oe(this.modifiers,"applyStyle")&&(this.popper.removeAttribute("x-placement"),this.popper.style.position="",this.popper.style.top="",this.popper.style.left="",this.popper.style.right="",this.popper.style.bottom="",this.popper.style.willChange="",this.popper.style[re("transform")]=""),this.disableEventListeners(),this.options.removeOnDestroy&&this.popper.parentNode.removeChild(this.popper),this}.call(this)}},{key:"enableEventListeners",value:function(){return function(){this.state.eventsEnabled||(this.state=ae(this.reference,this.options,this.state,this.scheduleUpdate))}.call(this)}},{key:"disableEventListeners",value:function(){return le.call(this)}}]),r}();be.Utils=("undefined"!=typeof window?window:global).PopperUtils,be.placements=de,be.Defaults=Ee;var we="dropdown",Ce="bs.dropdown",Te="."+Ce,Se=".data-api",De=p.fn[we],Ie=new RegExp("38|40|27"),Ae={HIDE:"hide"+Te,HIDDEN:"hidden"+Te,SHOW:"show"+Te,SHOWN:"shown"+Te,CLICK:"click"+Te,CLICK_DATA_API:"click"+Te+Se,KEYDOWN_DATA_API:"keydown"+Te+Se,KEYUP_DATA_API:"keyup"+Te+Se},Oe="disabled",Ne="show",ke="dropup",Le="dropright",xe="dropleft",Pe="dropdown-menu-right",He="position-static",je='[data-toggle="dropdown"]',Re=".dropdown form",Fe=".dropdown-menu",Me=".navbar-nav",We=".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",Ue="top-start",Be="top-end",qe="bottom-start",Ke="bottom-end",Qe="right-start",Ve="left-start",Ye={offset:0,flip:!0,boundary:"scrollParent",reference:"toggle",display:"dynamic"},ze={offset:"(number|string|function)",flip:"boolean",boundary:"(string|element)",reference:"(string|element)",display:"string"},Xe=function(){function c(t,e){this._element=t,this._popper=null,this._config=this._getConfig(e),this._menu=this._getMenuElement(),this._inNavbar=this._detectNavbar(),this._addEventListeners()}var t=c.prototype;return t.toggle=function(){if(!this._element.disabled&&!p(this._element).hasClass(Oe)){var t=c._getParentFromElement(this._element),e=p(this._menu).hasClass(Ne);if(c._clearMenus(),!e){var n={relatedTarget:this._element},i=p.Event(Ae.SHOW,n);if(p(t).trigger(i),!i.isDefaultPrevented()){if(!this._inNavbar){if("undefined"==typeof be)throw new TypeError("Bootstrap's dropdowns require Popper.js (https://popper.js.org/)");var o=this._element;"parent"===this._config.reference?o=t:m.isElement(this._config.reference)&&(o=this._config.reference,"undefined"!=typeof this._config.reference.jquery&&(o=this._config.reference[0])),"scrollParent"!==this._config.boundary&&p(t).addClass(He),this._popper=new be(o,this._menu,this._getPopperConfig())}"ontouchstart"in document.documentElement&&0===p(t).closest(Me).length&&p(document.body).children().on("mouseover",null,p.noop),this._element.focus(),this._element.setAttribute("aria-expanded",!0),p(this._menu).toggleClass(Ne),p(t).toggleClass(Ne).trigger(p.Event(Ae.SHOWN,n))}}}},t.show=function(){if(!(this._element.disabled||p(this._element).hasClass(Oe)||p(this._menu).hasClass(Ne))){var t={relatedTarget:this._element},e=p.Event(Ae.SHOW,t),n=c._getParentFromElement(this._element);p(n).trigger(e),e.isDefaultPrevented()||(p(this._menu).toggleClass(Ne),p(n).toggleClass(Ne).trigger(p.Event(Ae.SHOWN,t)))}},t.hide=function(){if(!this._element.disabled&&!p(this._element).hasClass(Oe)&&p(this._menu).hasClass(Ne)){var t={relatedTarget:this._element},e=p.Event(Ae.HIDE,t),n=c._getParentFromElement(this._element);p(n).trigger(e),e.isDefaultPrevented()||(p(this._menu).toggleClass(Ne),p(n).toggleClass(Ne).trigger(p.Event(Ae.HIDDEN,t)))}},t.dispose=function(){p.removeData(this._element,Ce),p(this._element).off(Te),this._element=null,(this._menu=null)!==this._popper&&(this._popper.destroy(),this._popper=null)},t.update=function(){this._inNavbar=this._detectNavbar(),null!==this._popper&&this._popper.scheduleUpdate()},t._addEventListeners=function(){var e=this;p(this._element).on(Ae.CLICK,function(t){t.preventDefault(),t.stopPropagation(),e.toggle()})},t._getConfig=function(t){return t=l({},this.constructor.Default,p(this._element).data(),t),m.typeCheckConfig(we,t,this.constructor.DefaultType),t},t._getMenuElement=function(){if(!this._menu){var t=c._getParentFromElement(this._element);t&&(this._menu=t.querySelector(Fe))}return this._menu},t._getPlacement=function(){var t=p(this._element.parentNode),e=qe;return t.hasClass(ke)?(e=Ue,p(this._menu).hasClass(Pe)&&(e=Be)):t.hasClass(Le)?e=Qe:t.hasClass(xe)?e=Ve:p(this._menu).hasClass(Pe)&&(e=Ke),e},t._detectNavbar=function(){return 0<p(this._element).closest(".navbar").length},t._getOffset=function(){var e=this,t={};return"function"==typeof this._config.offset?t.fn=function(t){return t.offsets=l({},t.offsets,e._config.offset(t.offsets,e._element)||{}),t}:t.offset=this._config.offset,t},t._getPopperConfig=function(){var t={placement:this._getPlacement(),modifiers:{offset:this._getOffset(),flip:{enabled:this._config.flip},preventOverflow:{boundariesElement:this._config.boundary}}};return"static"===this._config.display&&(t.modifiers.applyStyle={enabled:!1}),t},c._jQueryInterface=function(e){return this.each(function(){var t=p(this).data(Ce);if(t||(t=new c(this,"object"==typeof e?e:null),p(this).data(Ce,t)),"string"==typeof e){if("undefined"==typeof t[e])throw new TypeError('No method named "'+e+'"');t[e]()}})},c._clearMenus=function(t){if(!t||3!==t.which&&("keyup"!==t.type||9===t.which))for(var e=[].slice.call(document.querySelectorAll(je)),n=0,i=e.length;n<i;n++){var o=c._getParentFromElement(e[n]),r=p(e[n]).data(Ce),s={relatedTarget:e[n]};if(t&&"click"===t.type&&(s.clickEvent=t),r){var a=r._menu;if(p(o).hasClass(Ne)&&!(t&&("click"===t.type&&/input|textarea/i.test(t.target.tagName)||"keyup"===t.type&&9===t.which)&&p.contains(o,t.target))){var l=p.Event(Ae.HIDE,s);p(o).trigger(l),l.isDefaultPrevented()||("ontouchstart"in document.documentElement&&p(document.body).children().off("mouseover",null,p.noop),e[n].setAttribute("aria-expanded","false"),p(a).removeClass(Ne),p(o).removeClass(Ne).trigger(p.Event(Ae.HIDDEN,s)))}}}},c._getParentFromElement=function(t){var e,n=m.getSelectorFromElement(t);return n&&(e=document.querySelector(n)),e||t.parentNode},c._dataApiKeydownHandler=function(t){if((/input|textarea/i.test(t.target.tagName)?!(32===t.which||27!==t.which&&(40!==t.which&&38!==t.which||p(t.target).closest(Fe).length)):Ie.test(t.which))&&(t.preventDefault(),t.stopPropagation(),!this.disabled&&!p(this).hasClass(Oe))){var e=c._getParentFromElement(this),n=p(e).hasClass(Ne);if(n&&(!n||27!==t.which&&32!==t.which)){var i=[].slice.call(e.querySelectorAll(We));if(0!==i.length){var o=i.indexOf(t.target);38===t.which&&0<o&&o--,40===t.which&&o<i.length-1&&o++,o<0&&(o=0),i[o].focus()}}else{if(27===t.which){var r=e.querySelector(je);p(r).trigger("focus")}p(this).trigger("click")}}},s(c,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return Ye}},{key:"DefaultType",get:function(){return ze}}]),c}();p(document).on(Ae.KEYDOWN_DATA_API,je,Xe._dataApiKeydownHandler).on(Ae.KEYDOWN_DATA_API,Fe,Xe._dataApiKeydownHandler).on(Ae.CLICK_DATA_API+" "+Ae.KEYUP_DATA_API,Xe._clearMenus).on(Ae.CLICK_DATA_API,je,function(t){t.preventDefault(),t.stopPropagation(),Xe._jQueryInterface.call(p(this),"toggle")}).on(Ae.CLICK_DATA_API,Re,function(t){t.stopPropagation()}),p.fn[we]=Xe._jQueryInterface,p.fn[we].Constructor=Xe,p.fn[we].noConflict=function(){return p.fn[we]=De,Xe._jQueryInterface};var Ge="modal",$e="bs.modal",Je="."+$e,Ze=p.fn[Ge],tn={backdrop:!0,keyboard:!0,focus:!0,show:!0},en={backdrop:"(boolean|string)",keyboard:"boolean",focus:"boolean",show:"boolean"},nn={HIDE:"hide"+Je,HIDDEN:"hidden"+Je,SHOW:"show"+Je,SHOWN:"shown"+Je,FOCUSIN:"focusin"+Je,RESIZE:"resize"+Je,CLICK_DISMISS:"click.dismiss"+Je,KEYDOWN_DISMISS:"keydown.dismiss"+Je,MOUSEUP_DISMISS:"mouseup.dismiss"+Je,MOUSEDOWN_DISMISS:"mousedown.dismiss"+Je,CLICK_DATA_API:"click"+Je+".data-api"},on="modal-dialog-scrollable",rn="modal-scrollbar-measure",sn="modal-backdrop",an="modal-open",ln="fade",cn="show",hn=".modal-dialog",un=".modal-body",fn='[data-toggle="modal"]',dn='[data-dismiss="modal"]',pn=".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",mn=".sticky-top",gn=function(){function o(t,e){this._config=this._getConfig(e),this._element=t,this._dialog=t.querySelector(hn),this._backdrop=null,this._isShown=!1,this._isBodyOverflowing=!1,this._ignoreBackdropClick=!1,this._isTransitioning=!1,this._scrollbarWidth=0}var t=o.prototype;return t.toggle=function(t){return this._isShown?this.hide():this.show(t)},t.show=function(t){var e=this;if(!this._isShown&&!this._isTransitioning){p(this._element).hasClass(ln)&&(this._isTransitioning=!0);var n=p.Event(nn.SHOW,{relatedTarget:t});p(this._element).trigger(n),this._isShown||n.isDefaultPrevented()||(this._isShown=!0,this._checkScrollbar(),this._setScrollbar(),this._adjustDialog(),this._setEscapeEvent(),this._setResizeEvent(),p(this._element).on(nn.CLICK_DISMISS,dn,function(t){return e.hide(t)}),p(this._dialog).on(nn.MOUSEDOWN_DISMISS,function(){p(e._element).one(nn.MOUSEUP_DISMISS,function(t){p(t.target).is(e._element)&&(e._ignoreBackdropClick=!0)})}),this._showBackdrop(function(){return e._showElement(t)}))}},t.hide=function(t){var e=this;if(t&&t.preventDefault(),this._isShown&&!this._isTransitioning){var n=p.Event(nn.HIDE);if(p(this._element).trigger(n),this._isShown&&!n.isDefaultPrevented()){this._isShown=!1;var i=p(this._element).hasClass(ln);if(i&&(this._isTransitioning=!0),this._setEscapeEvent(),this._setResizeEvent(),p(document).off(nn.FOCUSIN),p(this._element).removeClass(cn),p(this._element).off(nn.CLICK_DISMISS),p(this._dialog).off(nn.MOUSEDOWN_DISMISS),i){var o=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,function(t){return e._hideModal(t)}).emulateTransitionEnd(o)}else this._hideModal()}}},t.dispose=function(){[window,this._element,this._dialog].forEach(function(t){return p(t).off(Je)}),p(document).off(nn.FOCUSIN),p.removeData(this._element,$e),this._config=null,this._element=null,this._dialog=null,this._backdrop=null,this._isShown=null,this._isBodyOverflowing=null,this._ignoreBackdropClick=null,this._isTransitioning=null,this._scrollbarWidth=null},t.handleUpdate=function(){this._adjustDialog()},t._getConfig=function(t){return t=l({},tn,t),m.typeCheckConfig(Ge,t,en),t},t._showElement=function(t){var e=this,n=p(this._element).hasClass(ln);this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE||document.body.appendChild(this._element),this._element.style.display="block",this._element.removeAttribute("aria-hidden"),this._element.setAttribute("aria-modal",!0),p(this._dialog).hasClass(on)?this._dialog.querySelector(un).scrollTop=0:this._element.scrollTop=0,n&&m.reflow(this._element),p(this._element).addClass(cn),this._config.focus&&this._enforceFocus();var i=p.Event(nn.SHOWN,{relatedTarget:t}),o=function(){e._config.focus&&e._element.focus(),e._isTransitioning=!1,p(e._element).trigger(i)};if(n){var r=m.getTransitionDurationFromElement(this._dialog);p(this._dialog).one(m.TRANSITION_END,o).emulateTransitionEnd(r)}else o()},t._enforceFocus=function(){var e=this;p(document).off(nn.FOCUSIN).on(nn.FOCUSIN,function(t){document!==t.target&&e._element!==t.target&&0===p(e._element).has(t.target).length&&e._element.focus()})},t._setEscapeEvent=function(){var e=this;this._isShown&&this._config.keyboard?p(this._element).on(nn.KEYDOWN_DISMISS,function(t){27===t.which&&(t.preventDefault(),e.hide())}):this._isShown||p(this._element).off(nn.KEYDOWN_DISMISS)},t._setResizeEvent=function(){var e=this;this._isShown?p(window).on(nn.RESIZE,function(t){return e.handleUpdate(t)}):p(window).off(nn.RESIZE)},t._hideModal=function(){var t=this;this._element.style.display="none",this._element.setAttribute("aria-hidden",!0),this._element.removeAttribute("aria-modal"),this._isTransitioning=!1,this._showBackdrop(function(){p(document.body).removeClass(an),t._resetAdjustments(),t._resetScrollbar(),p(t._element).trigger(nn.HIDDEN)})},t._removeBackdrop=function(){this._backdrop&&(p(this._backdrop).remove(),this._backdrop=null)},t._showBackdrop=function(t){var e=this,n=p(this._element).hasClass(ln)?ln:"";if(this._isShown&&this._config.backdrop){if(this._backdrop=document.createElement("div"),this._backdrop.className=sn,n&&this._backdrop.classList.add(n),p(this._backdrop).appendTo(document.body),p(this._element).on(nn.CLICK_DISMISS,function(t){e._ignoreBackdropClick?e._ignoreBackdropClick=!1:t.target===t.currentTarget&&("static"===e._config.backdrop?e._element.focus():e.hide())}),n&&m.reflow(this._backdrop),p(this._backdrop).addClass(cn),!t)return;if(!n)return void t();var i=m.getTransitionDurationFromElement(this._backdrop);p(this._backdrop).one(m.TRANSITION_END,t).emulateTransitionEnd(i)}else if(!this._isShown&&this._backdrop){p(this._backdrop).removeClass(cn);var o=function(){e._removeBackdrop(),t&&t()};if(p(this._element).hasClass(ln)){var r=m.getTransitionDurationFromElement(this._backdrop);p(this._backdrop).one(m.TRANSITION_END,o).emulateTransitionEnd(r)}else o()}else t&&t()},t._adjustDialog=function(){var t=this._element.scrollHeight>document.documentElement.clientHeight;!this._isBodyOverflowing&&t&&(this._element.style.paddingLeft=this._scrollbarWidth+"px"),this._isBodyOverflowing&&!t&&(this._element.style.paddingRight=this._scrollbarWidth+"px")},t._resetAdjustments=function(){this._element.style.paddingLeft="",this._element.style.paddingRight=""},t._checkScrollbar=function(){var t=document.body.getBoundingClientRect();this._isBodyOverflowing=t.left+t.right<window.innerWidth,this._scrollbarWidth=this._getScrollbarWidth()},t._setScrollbar=function(){var o=this;if(this._isBodyOverflowing){var t=[].slice.call(document.querySelectorAll(pn)),e=[].slice.call(document.querySelectorAll(mn));p(t).each(function(t,e){var n=e.style.paddingRight,i=p(e).css("padding-right");p(e).data("padding-right",n).css("padding-right",parseFloat(i)+o._scrollbarWidth+"px")}),p(e).each(function(t,e){var n=e.style.marginRight,i=p(e).css("margin-right");p(e).data("margin-right",n).css("margin-right",parseFloat(i)-o._scrollbarWidth+"px")});var n=document.body.style.paddingRight,i=p(document.body).css("padding-right");p(document.body).data("padding-right",n).css("padding-right",parseFloat(i)+this._scrollbarWidth+"px")}p(document.body).addClass(an)},t._resetScrollbar=function(){var t=[].slice.call(document.querySelectorAll(pn));p(t).each(function(t,e){var n=p(e).data("padding-right");p(e).removeData("padding-right"),e.style.paddingRight=n||""});var e=[].slice.call(document.querySelectorAll(""+mn));p(e).each(function(t,e){var n=p(e).data("margin-right");"undefined"!=typeof n&&p(e).css("margin-right",n).removeData("margin-right")});var n=p(document.body).data("padding-right");p(document.body).removeData("padding-right"),document.body.style.paddingRight=n||""},t._getScrollbarWidth=function(){var t=document.createElement("div");t.className=rn,document.body.appendChild(t);var e=t.getBoundingClientRect().width-t.clientWidth;return document.body.removeChild(t),e},o._jQueryInterface=function(n,i){return this.each(function(){var t=p(this).data($e),e=l({},tn,p(this).data(),"object"==typeof n&&n?n:{});if(t||(t=new o(this,e),p(this).data($e,t)),"string"==typeof n){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n](i)}else e.show&&t.show(i)})},s(o,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return tn}}]),o}();p(document).on(nn.CLICK_DATA_API,fn,function(t){var e,n=this,i=m.getSelectorFromElement(this);i&&(e=document.querySelector(i));var o=p(e).data($e)?"toggle":l({},p(e).data(),p(this).data());"A"!==this.tagName&&"AREA"!==this.tagName||t.preventDefault();var r=p(e).one(nn.SHOW,function(t){t.isDefaultPrevented()||r.one(nn.HIDDEN,function(){p(n).is(":visible")&&n.focus()})});gn._jQueryInterface.call(p(e),o,this)}),p.fn[Ge]=gn._jQueryInterface,p.fn[Ge].Constructor=gn,p.fn[Ge].noConflict=function(){return p.fn[Ge]=Ze,gn._jQueryInterface};var _n=["background","cite","href","itemtype","longdesc","poster","src","xlink:href"],vn={"*":["class","dir","id","lang","role",/^aria-[\w-]*$/i],a:["target","href","title","rel"],area:[],b:[],br:[],col:[],code:[],div:[],em:[],hr:[],h1:[],h2:[],h3:[],h4:[],h5:[],h6:[],i:[],img:["src","alt","title","width","height"],li:[],ol:[],p:[],pre:[],s:[],small:[],span:[],sub:[],sup:[],strong:[],u:[],ul:[]},yn=/^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi,En=/^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;function bn(t,s,e){if(0===t.length)return t;if(e&&"function"==typeof e)return e(t);for(var n=(new window.DOMParser).parseFromString(t,"text/html"),a=Object.keys(s),l=[].slice.call(n.body.querySelectorAll("*")),i=function(t,e){var n=l[t],i=n.nodeName.toLowerCase();if(-1===a.indexOf(n.nodeName.toLowerCase()))return n.parentNode.removeChild(n),"continue";var o=[].slice.call(n.attributes),r=[].concat(s["*"]||[],s[i]||[]);o.forEach(function(t){(function(t,e){var n=t.nodeName.toLowerCase();if(-1!==e.indexOf(n))return-1===_n.indexOf(n)||Boolean(t.nodeValue.match(yn)||t.nodeValue.match(En));for(var i=e.filter(function(t){return t instanceof RegExp}),o=0,r=i.length;o<r;o++)if(n.match(i[o]))return!0;return!1})(t,r)||n.removeAttribute(t.nodeName)})},o=0,r=l.length;o<r;o++)i(o);return n.body.innerHTML}var wn="tooltip",Cn="bs.tooltip",Tn="."+Cn,Sn=p.fn[wn],Dn="bs-tooltip",In=new RegExp("(^|\\s)"+Dn+"\\S+","g"),An=["sanitize","whiteList","sanitizeFn"],On={animation:"boolean",template:"string",title:"(string|element|function)",trigger:"string",delay:"(number|object)",html:"boolean",selector:"(string|boolean)",placement:"(string|function)",offset:"(number|string|function)",container:"(string|element|boolean)",fallbackPlacement:"(string|array)",boundary:"(string|element)",sanitize:"boolean",sanitizeFn:"(null|function)",whiteList:"object"},Nn={AUTO:"auto",TOP:"top",RIGHT:"right",BOTTOM:"bottom",LEFT:"left"},kn={animation:!0,template:'<div class="tooltip" role="tooltip"><div class="arrow"></div><div class="tooltip-inner"></div></div>',trigger:"hover focus",title:"",delay:0,html:!1,selector:!1,placement:"top",offset:0,container:!1,fallbackPlacement:"flip",boundary:"scrollParent",sanitize:!0,sanitizeFn:null,whiteList:vn},Ln="show",xn="out",Pn={HIDE:"hide"+Tn,HIDDEN:"hidden"+Tn,SHOW:"show"+Tn,SHOWN:"shown"+Tn,INSERTED:"inserted"+Tn,CLICK:"click"+Tn,FOCUSIN:"focusin"+Tn,FOCUSOUT:"focusout"+Tn,MOUSEENTER:"mouseenter"+Tn,MOUSELEAVE:"mouseleave"+Tn},Hn="fade",jn="show",Rn=".tooltip-inner",Fn=".arrow",Mn="hover",Wn="focus",Un="click",Bn="manual",qn=function(){function i(t,e){if("undefined"==typeof be)throw new TypeError("Bootstrap's tooltips require Popper.js (https://popper.js.org/)");this._isEnabled=!0,this._timeout=0,this._hoverState="",this._activeTrigger={},this._popper=null,this.element=t,this.config=this._getConfig(e),this.tip=null,this._setListeners()}var t=i.prototype;return t.enable=function(){this._isEnabled=!0},t.disable=function(){this._isEnabled=!1},t.toggleEnabled=function(){this._isEnabled=!this._isEnabled},t.toggle=function(t){if(this._isEnabled)if(t){var e=this.constructor.DATA_KEY,n=p(t.currentTarget).data(e);n||(n=new this.constructor(t.currentTarget,this._getDelegateConfig()),p(t.currentTarget).data(e,n)),n._activeTrigger.click=!n._activeTrigger.click,n._isWithActiveTrigger()?n._enter(null,n):n._leave(null,n)}else{if(p(this.getTipElement()).hasClass(jn))return void this._leave(null,this);this._enter(null,this)}},t.dispose=function(){clearTimeout(this._timeout),p.removeData(this.element,this.constructor.DATA_KEY),p(this.element).off(this.constructor.EVENT_KEY),p(this.element).closest(".modal").off("hide.bs.modal"),this.tip&&p(this.tip).remove(),this._isEnabled=null,this._timeout=null,this._hoverState=null,(this._activeTrigger=null)!==this._popper&&this._popper.destroy(),this._popper=null,this.element=null,this.config=null,this.tip=null},t.show=function(){var e=this;if("none"===p(this.element).css("display"))throw new Error("Please use show on visible elements");var t=p.Event(this.constructor.Event.SHOW);if(this.isWithContent()&&this._isEnabled){p(this.element).trigger(t);var n=m.findShadowRoot(this.element),i=p.contains(null!==n?n:this.element.ownerDocument.documentElement,this.element);if(t.isDefaultPrevented()||!i)return;var o=this.getTipElement(),r=m.getUID(this.constructor.NAME);o.setAttribute("id",r),this.element.setAttribute("aria-describedby",r),this.setContent(),this.config.animation&&p(o).addClass(Hn);var s="function"==typeof this.config.placement?this.config.placement.call(this,o,this.element):this.config.placement,a=this._getAttachment(s);this.addAttachmentClass(a);var l=this._getContainer();p(o).data(this.constructor.DATA_KEY,this),p.contains(this.element.ownerDocument.documentElement,this.tip)||p(o).appendTo(l),p(this.element).trigger(this.constructor.Event.INSERTED),this._popper=new be(this.element,o,{placement:a,modifiers:{offset:this._getOffset(),flip:{behavior:this.config.fallbackPlacement},arrow:{element:Fn},preventOverflow:{boundariesElement:this.config.boundary}},onCreate:function(t){t.originalPlacement!==t.placement&&e._handlePopperPlacementChange(t)},onUpdate:function(t){return e._handlePopperPlacementChange(t)}}),p(o).addClass(jn),"ontouchstart"in document.documentElement&&p(document.body).children().on("mouseover",null,p.noop);var c=function(){e.config.animation&&e._fixTransition();var t=e._hoverState;e._hoverState=null,p(e.element).trigger(e.constructor.Event.SHOWN),t===xn&&e._leave(null,e)};if(p(this.tip).hasClass(Hn)){var h=m.getTransitionDurationFromElement(this.tip);p(this.tip).one(m.TRANSITION_END,c).emulateTransitionEnd(h)}else c()}},t.hide=function(t){var e=this,n=this.getTipElement(),i=p.Event(this.constructor.Event.HIDE),o=function(){e._hoverState!==Ln&&n.parentNode&&n.parentNode.removeChild(n),e._cleanTipClass(),e.element.removeAttribute("aria-describedby"),p(e.element).trigger(e.constructor.Event.HIDDEN),null!==e._popper&&e._popper.destroy(),t&&t()};if(p(this.element).trigger(i),!i.isDefaultPrevented()){if(p(n).removeClass(jn),"ontouchstart"in document.documentElement&&p(document.body).children().off("mouseover",null,p.noop),this._activeTrigger[Un]=!1,this._activeTrigger[Wn]=!1,this._activeTrigger[Mn]=!1,p(this.tip).hasClass(Hn)){var r=m.getTransitionDurationFromElement(n);p(n).one(m.TRANSITION_END,o).emulateTransitionEnd(r)}else o();this._hoverState=""}},t.update=function(){null!==this._popper&&this._popper.scheduleUpdate()},t.isWithContent=function(){return Boolean(this.getTitle())},t.addAttachmentClass=function(t){p(this.getTipElement()).addClass(Dn+"-"+t)},t.getTipElement=function(){return this.tip=this.tip||p(this.config.template)[0],this.tip},t.setContent=function(){var t=this.getTipElement();this.setElementContent(p(t.querySelectorAll(Rn)),this.getTitle()),p(t).removeClass(Hn+" "+jn)},t.setElementContent=function(t,e){"object"!=typeof e||!e.nodeType&&!e.jquery?this.config.html?(this.config.sanitize&&(e=bn(e,this.config.whiteList,this.config.sanitizeFn)),t.html(e)):t.text(e):this.config.html?p(e).parent().is(t)||t.empty().append(e):t.text(p(e).text())},t.getTitle=function(){var t=this.element.getAttribute("data-original-title");return t||(t="function"==typeof this.config.title?this.config.title.call(this.element):this.config.title),t},t._getOffset=function(){var e=this,t={};return"function"==typeof this.config.offset?t.fn=function(t){return t.offsets=l({},t.offsets,e.config.offset(t.offsets,e.element)||{}),t}:t.offset=this.config.offset,t},t._getContainer=function(){return!1===this.config.container?document.body:m.isElement(this.config.container)?p(this.config.container):p(document).find(this.config.container)},t._getAttachment=function(t){return Nn[t.toUpperCase()]},t._setListeners=function(){var i=this;this.config.trigger.split(" ").forEach(function(t){if("click"===t)p(i.element).on(i.constructor.Event.CLICK,i.config.selector,function(t){return i.toggle(t)});else if(t!==Bn){var e=t===Mn?i.constructor.Event.MOUSEENTER:i.constructor.Event.FOCUSIN,n=t===Mn?i.constructor.Event.MOUSELEAVE:i.constructor.Event.FOCUSOUT;p(i.element).on(e,i.config.selector,function(t){return i._enter(t)}).on(n,i.config.selector,function(t){return i._leave(t)})}}),p(this.element).closest(".modal").on("hide.bs.modal",function(){i.element&&i.hide()}),this.config.selector?this.config=l({},this.config,{trigger:"manual",selector:""}):this._fixTitle()},t._fixTitle=function(){var t=typeof this.element.getAttribute("data-original-title");(this.element.getAttribute("title")||"string"!==t)&&(this.element.setAttribute("data-original-title",this.element.getAttribute("title")||""),this.element.setAttribute("title",""))},t._enter=function(t,e){var n=this.constructor.DATA_KEY;(e=e||p(t.currentTarget).data(n))||(e=new this.constructor(t.currentTarget,this._getDelegateConfig()),p(t.currentTarget).data(n,e)),t&&(e._activeTrigger["focusin"===t.type?Wn:Mn]=!0),p(e.getTipElement()).hasClass(jn)||e._hoverState===Ln?e._hoverState=Ln:(clearTimeout(e._timeout),e._hoverState=Ln,e.config.delay&&e.config.delay.show?e._timeout=setTimeout(function(){e._hoverState===Ln&&e.show()},e.config.delay.show):e.show())},t._leave=function(t,e){var n=this.constructor.DATA_KEY;(e=e||p(t.currentTarget).data(n))||(e=new this.constructor(t.currentTarget,this._getDelegateConfig()),p(t.currentTarget).data(n,e)),t&&(e._activeTrigger["focusout"===t.type?Wn:Mn]=!1),e._isWithActiveTrigger()||(clearTimeout(e._timeout),e._hoverState=xn,e.config.delay&&e.config.delay.hide?e._timeout=setTimeout(function(){e._hoverState===xn&&e.hide()},e.config.delay.hide):e.hide())},t._isWithActiveTrigger=function(){for(var t in this._activeTrigger)if(this._activeTrigger[t])return!0;return!1},t._getConfig=function(t){var e=p(this.element).data();return Object.keys(e).forEach(function(t){-1!==An.indexOf(t)&&delete e[t]}),"number"==typeof(t=l({},this.constructor.Default,e,"object"==typeof t&&t?t:{})).delay&&(t.delay={show:t.delay,hide:t.delay}),"number"==typeof t.title&&(t.title=t.title.toString()),"number"==typeof t.content&&(t.content=t.content.toString()),m.typeCheckConfig(wn,t,this.constructor.DefaultType),t.sanitize&&(t.template=bn(t.template,t.whiteList,t.sanitizeFn)),t},t._getDelegateConfig=function(){var t={};if(this.config)for(var e in this.config)this.constructor.Default[e]!==this.config[e]&&(t[e]=this.config[e]);return t},t._cleanTipClass=function(){var t=p(this.getTipElement()),e=t.attr("class").match(In);null!==e&&e.length&&t.removeClass(e.join(""))},t._handlePopperPlacementChange=function(t){var e=t.instance;this.tip=e.popper,this._cleanTipClass(),this.addAttachmentClass(this._getAttachment(t.placement))},t._fixTransition=function(){var t=this.getTipElement(),e=this.config.animation;null===t.getAttribute("x-placement")&&(p(t).removeClass(Hn),this.config.animation=!1,this.hide(),this.show(),this.config.animation=e)},i._jQueryInterface=function(n){return this.each(function(){var t=p(this).data(Cn),e="object"==typeof n&&n;if((t||!/dispose|hide/.test(n))&&(t||(t=new i(this,e),p(this).data(Cn,t)),"string"==typeof n)){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}})},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return kn}},{key:"NAME",get:function(){return wn}},{key:"DATA_KEY",get:function(){return Cn}},{key:"Event",get:function(){return Pn}},{key:"EVENT_KEY",get:function(){return Tn}},{key:"DefaultType",get:function(){return On}}]),i}();p.fn[wn]=qn._jQueryInterface,p.fn[wn].Constructor=qn,p.fn[wn].noConflict=function(){return p.fn[wn]=Sn,qn._jQueryInterface};var Kn="popover",Qn="bs.popover",Vn="."+Qn,Yn=p.fn[Kn],zn="bs-popover",Xn=new RegExp("(^|\\s)"+zn+"\\S+","g"),Gn=l({},qn.Default,{placement:"right",trigger:"click",content:"",template:'<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>'}),$n=l({},qn.DefaultType,{content:"(string|element|function)"}),Jn="fade",Zn="show",ti=".popover-header",ei=".popover-body",ni={HIDE:"hide"+Vn,HIDDEN:"hidden"+Vn,SHOW:"show"+Vn,SHOWN:"shown"+Vn,INSERTED:"inserted"+Vn,CLICK:"click"+Vn,FOCUSIN:"focusin"+Vn,FOCUSOUT:"focusout"+Vn,MOUSEENTER:"mouseenter"+Vn,MOUSELEAVE:"mouseleave"+Vn},ii=function(t){var e,n;function i(){return t.apply(this,arguments)||this}n=t,(e=i).prototype=Object.create(n.prototype),(e.prototype.constructor=e).__proto__=n;var o=i.prototype;return o.isWithContent=function(){return this.getTitle()||this._getContent()},o.addAttachmentClass=function(t){p(this.getTipElement()).addClass(zn+"-"+t)},o.getTipElement=function(){return this.tip=this.tip||p(this.config.template)[0],this.tip},o.setContent=function(){var t=p(this.getTipElement());this.setElementContent(t.find(ti),this.getTitle());var e=this._getContent();"function"==typeof e&&(e=e.call(this.element)),this.setElementContent(t.find(ei),e),t.removeClass(Jn+" "+Zn)},o._getContent=function(){return this.element.getAttribute("data-content")||this.config.content},o._cleanTipClass=function(){var t=p(this.getTipElement()),e=t.attr("class").match(Xn);null!==e&&0<e.length&&t.removeClass(e.join(""))},i._jQueryInterface=function(n){return this.each(function(){var t=p(this).data(Qn),e="object"==typeof n?n:null;if((t||!/dispose|hide/.test(n))&&(t||(t=new i(this,e),p(this).data(Qn,t)),"string"==typeof n)){if("undefined"==typeof t[n])throw new TypeError('No method named "'+n+'"');t[n]()}})},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return Gn}},{key:"NAME",get:function(){return Kn}},{key:"DATA_KEY",get:function(){return Qn}},{key:"Event",get:function(){return ni}},{key:"EVENT_KEY",get:function(){return Vn}},{key:"DefaultType",get:function(){return $n}}]),i}(qn);p.fn[Kn]=ii._jQueryInterface,p.fn[Kn].Constructor=ii,p.fn[Kn].noConflict=function(){return p.fn[Kn]=Yn,ii._jQueryInterface};var oi="scrollspy",ri="bs.scrollspy",si="."+ri,ai=p.fn[oi],li={offset:10,method:"auto",target:""},ci={offset:"number",method:"string",target:"(string|element)"},hi={ACTIVATE:"activate"+si,SCROLL:"scroll"+si,LOAD_DATA_API:"load"+si+".data-api"},ui="dropdown-item",fi="active",di='[data-spy="scroll"]',pi=".nav, .list-group",mi=".nav-link",gi=".nav-item",_i=".list-group-item",vi=".dropdown",yi=".dropdown-item",Ei=".dropdown-toggle",bi="offset",wi="position",Ci=function(){function n(t,e){var n=this;this._element=t,this._scrollElement="BODY"===t.tagName?window:t,this._config=this._getConfig(e),this._selector=this._config.target+" "+mi+","+this._config.target+" "+_i+","+this._config.target+" "+yi,this._offsets=[],this._targets=[],this._activeTarget=null,this._scrollHeight=0,p(this._scrollElement).on(hi.SCROLL,function(t){return n._process(t)}),this.refresh(),this._process()}var t=n.prototype;return t.refresh=function(){var e=this,t=this._scrollElement===this._scrollElement.window?bi:wi,o="auto"===this._config.method?t:this._config.method,r=o===wi?this._getScrollTop():0;this._offsets=[],this._targets=[],this._scrollHeight=this._getScrollHeight(),[].slice.call(document.querySelectorAll(this._selector)).map(function(t){var e,n=m.getSelectorFromElement(t);if(n&&(e=document.querySelector(n)),e){var i=e.getBoundingClientRect();if(i.width||i.height)return[p(e)[o]().top+r,n]}return null}).filter(function(t){return t}).sort(function(t,e){return t[0]-e[0]}).forEach(function(t){e._offsets.push(t[0]),e._targets.push(t[1])})},t.dispose=function(){p.removeData(this._element,ri),p(this._scrollElement).off(si),this._element=null,this._scrollElement=null,this._config=null,this._selector=null,this._offsets=null,this._targets=null,this._activeTarget=null,this._scrollHeight=null},t._getConfig=function(t){if("string"!=typeof(t=l({},li,"object"==typeof t&&t?t:{})).target){var e=p(t.target).attr("id");e||(e=m.getUID(oi),p(t.target).attr("id",e)),t.target="#"+e}return m.typeCheckConfig(oi,t,ci),t},t._getScrollTop=function(){return this._scrollElement===window?this._scrollElement.pageYOffset:this._scrollElement.scrollTop},t._getScrollHeight=function(){return this._scrollElement.scrollHeight||Math.max(document.body.scrollHeight,document.documentElement.scrollHeight)},t._getOffsetHeight=function(){return this._scrollElement===window?window.innerHeight:this._scrollElement.getBoundingClientRect().height},t._process=function(){var t=this._getScrollTop()+this._config.offset,e=this._getScrollHeight(),n=this._config.offset+e-this._getOffsetHeight();if(this._scrollHeight!==e&&this.refresh(),n<=t){var i=this._targets[this._targets.length-1];this._activeTarget!==i&&this._activate(i)}else{if(this._activeTarget&&t<this._offsets[0]&&0<this._offsets[0])return this._activeTarget=null,void this._clear();for(var o=this._offsets.length;o--;){this._activeTarget!==this._targets[o]&&t>=this._offsets[o]&&("undefined"==typeof this._offsets[o+1]||t<this._offsets[o+1])&&this._activate(this._targets[o])}}},t._activate=function(e){this._activeTarget=e,this._clear();var t=this._selector.split(",").map(function(t){return t+'[data-target="'+e+'"],'+t+'[href="'+e+'"]'}),n=p([].slice.call(document.querySelectorAll(t.join(","))));n.hasClass(ui)?(n.closest(vi).find(Ei).addClass(fi),n.addClass(fi)):(n.addClass(fi),n.parents(pi).prev(mi+", "+_i).addClass(fi),n.parents(pi).prev(gi).children(mi).addClass(fi)),p(this._scrollElement).trigger(hi.ACTIVATE,{relatedTarget:e})},t._clear=function(){[].slice.call(document.querySelectorAll(this._selector)).filter(function(t){return t.classList.contains(fi)}).forEach(function(t){return t.classList.remove(fi)})},n._jQueryInterface=function(e){return this.each(function(){var t=p(this).data(ri);if(t||(t=new n(this,"object"==typeof e&&e),p(this).data(ri,t)),"string"==typeof e){if("undefined"==typeof t[e])throw new TypeError('No method named "'+e+'"');t[e]()}})},s(n,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"Default",get:function(){return li}}]),n}();p(window).on(hi.LOAD_DATA_API,function(){for(var t=[].slice.call(document.querySelectorAll(di)),e=t.length;e--;){var n=p(t[e]);Ci._jQueryInterface.call(n,n.data())}}),p.fn[oi]=Ci._jQueryInterface,p.fn[oi].Constructor=Ci,p.fn[oi].noConflict=function(){return p.fn[oi]=ai,Ci._jQueryInterface};var Ti="bs.tab",Si="."+Ti,Di=p.fn.tab,Ii={HIDE:"hide"+Si,HIDDEN:"hidden"+Si,SHOW:"show"+Si,SHOWN:"shown"+Si,CLICK_DATA_API:"click"+Si+".data-api"},Ai="dropdown-menu",Oi="active",Ni="disabled",ki="fade",Li="show",xi=".dropdown",Pi=".nav, .list-group",Hi=".active",ji="> li > .active",Ri='[data-toggle="tab"], [data-toggle="pill"], [data-toggle="list"]',Fi=".dropdown-toggle",Mi="> .dropdown-menu .active",Wi=function(){function i(t){this._element=t}var t=i.prototype;return t.show=function(){var n=this;if(!(this._element.parentNode&&this._element.parentNode.nodeType===Node.ELEMENT_NODE&&p(this._element).hasClass(Oi)||p(this._element).hasClass(Ni))){var t,i,e=p(this._element).closest(Pi)[0],o=m.getSelectorFromElement(this._element);if(e){var r="UL"===e.nodeName||"OL"===e.nodeName?ji:Hi;i=(i=p.makeArray(p(e).find(r)))[i.length-1]}var s=p.Event(Ii.HIDE,{relatedTarget:this._element}),a=p.Event(Ii.SHOW,{relatedTarget:i});if(i&&p(i).trigger(s),p(this._element).trigger(a),!a.isDefaultPrevented()&&!s.isDefaultPrevented()){o&&(t=document.querySelector(o)),this._activate(this._element,e);var l=function(){var t=p.Event(Ii.HIDDEN,{relatedTarget:n._element}),e=p.Event(Ii.SHOWN,{relatedTarget:i});p(i).trigger(t),p(n._element).trigger(e)};t?this._activate(t,t.parentNode,l):l()}}},t.dispose=function(){p.removeData(this._element,Ti),this._element=null},t._activate=function(t,e,n){var i=this,o=(!e||"UL"!==e.nodeName&&"OL"!==e.nodeName?p(e).children(Hi):p(e).find(ji))[0],r=n&&o&&p(o).hasClass(ki),s=function(){return i._transitionComplete(t,o,n)};if(o&&r){var a=m.getTransitionDurationFromElement(o);p(o).removeClass(Li).one(m.TRANSITION_END,s).emulateTransitionEnd(a)}else s()},t._transitionComplete=function(t,e,n){if(e){p(e).removeClass(Oi);var i=p(e.parentNode).find(Mi)[0];i&&p(i).removeClass(Oi),"tab"===e.getAttribute("role")&&e.setAttribute("aria-selected",!1)}if(p(t).addClass(Oi),"tab"===t.getAttribute("role")&&t.setAttribute("aria-selected",!0),m.reflow(t),t.classList.contains(ki)&&t.classList.add(Li),t.parentNode&&p(t.parentNode).hasClass(Ai)){var o=p(t).closest(xi)[0];if(o){var r=[].slice.call(o.querySelectorAll(Fi));p(r).addClass(Oi)}t.setAttribute("aria-expanded",!0)}n&&n()},i._jQueryInterface=function(n){return this.each(function(){var t=p(this),e=t.data(Ti);if(e||(e=new i(this),t.data(Ti,e)),"string"==typeof n){if("undefined"==typeof e[n])throw new TypeError('No method named "'+n+'"');e[n]()}})},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}}]),i}();p(document).on(Ii.CLICK_DATA_API,Ri,function(t){t.preventDefault(),Wi._jQueryInterface.call(p(this),"show")}),p.fn.tab=Wi._jQueryInterface,p.fn.tab.Constructor=Wi,p.fn.tab.noConflict=function(){return p.fn.tab=Di,Wi._jQueryInterface};var Ui="toast",Bi="bs.toast",qi="."+Bi,Ki=p.fn[Ui],Qi={CLICK_DISMISS:"click.dismiss"+qi,HIDE:"hide"+qi,HIDDEN:"hidden"+qi,SHOW:"show"+qi,SHOWN:"shown"+qi},Vi="fade",Yi="hide",zi="show",Xi="showing",Gi={animation:"boolean",autohide:"boolean",delay:"number"},$i={animation:!0,autohide:!0,delay:500},Ji='[data-dismiss="toast"]',Zi=function(){function i(t,e){this._element=t,this._config=this._getConfig(e),this._timeout=null,this._setListeners()}var t=i.prototype;return t.show=function(){var t=this;p(this._element).trigger(Qi.SHOW),this._config.animation&&this._element.classList.add(Vi);var e=function(){t._element.classList.remove(Xi),t._element.classList.add(zi),p(t._element).trigger(Qi.SHOWN),t._config.autohide&&t.hide()};if(this._element.classList.remove(Yi),this._element.classList.add(Xi),this._config.animation){var n=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,e).emulateTransitionEnd(n)}else e()},t.hide=function(t){var e=this;this._element.classList.contains(zi)&&(p(this._element).trigger(Qi.HIDE),t?this._close():this._timeout=setTimeout(function(){e._close()},this._config.delay))},t.dispose=function(){clearTimeout(this._timeout),this._timeout=null,this._element.classList.contains(zi)&&this._element.classList.remove(zi),p(this._element).off(Qi.CLICK_DISMISS),p.removeData(this._element,Bi),this._element=null,this._config=null},t._getConfig=function(t){return t=l({},$i,p(this._element).data(),"object"==typeof t&&t?t:{}),m.typeCheckConfig(Ui,t,this.constructor.DefaultType),t},t._setListeners=function(){var t=this;p(this._element).on(Qi.CLICK_DISMISS,Ji,function(){return t.hide(!0)})},t._close=function(){var t=this,e=function(){t._element.classList.add(Yi),p(t._element).trigger(Qi.HIDDEN)};if(this._element.classList.remove(zi),this._config.animation){var n=m.getTransitionDurationFromElement(this._element);p(this._element).one(m.TRANSITION_END,e).emulateTransitionEnd(n)}else e()},i._jQueryInterface=function(n){return this.each(function(){var t=p(this),e=t.data(Bi);if(e||(e=new i(this,"object"==typeof n&&n),t.data(Bi,e)),"string"==typeof n){if("undefined"==typeof e[n])throw new TypeError('No method named "'+n+'"');e[n](this)}})},s(i,null,[{key:"VERSION",get:function(){return"4.3.1"}},{key:"DefaultType",get:function(){return Gi}},{key:"Default",get:function(){return $i}}]),i}();p.fn[Ui]=Zi._jQueryInterface,p.fn[Ui].Constructor=Zi,p.fn[Ui].noConflict=function(){return p.fn[Ui]=Ki,Zi._jQueryInterface},function(){if("undefined"==typeof p)throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");var t=p.fn.jquery.split(" ")[0].split(".");if(t[0]<2&&t[1]<9||1===t[0]&&9===t[1]&&t[2]<1||4<=t[0])throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0")}(),t.Util=m,t.Alert=g,t.Button=k,t.Carousel=at,t.Collapse=Ct,t.Dropdown=Xe,t.Modal=gn,t.Popover=ii,t.Scrollspy=Ci,t.Tab=Wi,t.Toast=Zi,t.Tooltip=qn,Object.defineProperty(t,"__esModule",{value:!0})});
(function(factory){if(typeof define==="function"&&define.amd){define(["jquery"],function($){return factory($)})}else if(typeof module==="object"&&typeof module.exports==="object"){exports=factory(require("jquery"))}else{factory(jQuery)}})(function($){$.easing.jswing=$.easing.swing;var pow=Math.pow,sqrt=Math.sqrt,sin=Math.sin,cos=Math.cos,PI=Math.PI,c1=1.70158,c2=c1*1.525,c3=c1+1,c4=2*PI/3,c5=2*PI/4.5;function bounceOut(x){var n1=7.5625,d1=2.75;if(x<1/d1){return n1*x*x}else if(x<2/d1){return n1*(x-=1.5/d1)*x+.75}else if(x<2.5/d1){return n1*(x-=2.25/d1)*x+.9375}else{return n1*(x-=2.625/d1)*x+.984375}}$.extend($.easing,{def:"easeOutQuad",swing:function(x){return $.easing[$.easing.def](x)},easeInQuad:function(x){return x*x},easeOutQuad:function(x){return 1-(1-x)*(1-x)},easeInOutQuad:function(x){return x<.5?2*x*x:1-pow(-2*x+2,2)/2},easeInCubic:function(x){return x*x*x},easeOutCubic:function(x){return 1-pow(1-x,3)},easeInOutCubic:function(x){return x<.5?4*x*x*x:1-pow(-2*x+2,3)/2},easeInQuart:function(x){return x*x*x*x},easeOutQuart:function(x){return 1-pow(1-x,4)},easeInOutQuart:function(x){return x<.5?8*x*x*x*x:1-pow(-2*x+2,4)/2},easeInQuint:function(x){return x*x*x*x*x},easeOutQuint:function(x){return 1-pow(1-x,5)},easeInOutQuint:function(x){return x<.5?16*x*x*x*x*x:1-pow(-2*x+2,5)/2},easeInSine:function(x){return 1-cos(x*PI/2)},easeOutSine:function(x){return sin(x*PI/2)},easeInOutSine:function(x){return-(cos(PI*x)-1)/2},easeInExpo:function(x){return x===0?0:pow(2,10*x-10)},easeOutExpo:function(x){return x===1?1:1-pow(2,-10*x)},easeInOutExpo:function(x){return x===0?0:x===1?1:x<.5?pow(2,20*x-10)/2:(2-pow(2,-20*x+10))/2},easeInCirc:function(x){return 1-sqrt(1-pow(x,2))},easeOutCirc:function(x){return sqrt(1-pow(x-1,2))},easeInOutCirc:function(x){return x<.5?(1-sqrt(1-pow(2*x,2)))/2:(sqrt(1-pow(-2*x+2,2))+1)/2},easeInElastic:function(x){return x===0?0:x===1?1:-pow(2,10*x-10)*sin((x*10-10.75)*c4)},easeOutElastic:function(x){return x===0?0:x===1?1:pow(2,-10*x)*sin((x*10-.75)*c4)+1},easeInOutElastic:function(x){return x===0?0:x===1?1:x<.5?-(pow(2,20*x-10)*sin((20*x-11.125)*c5))/2:pow(2,-20*x+10)*sin((20*x-11.125)*c5)/2+1},easeInBack:function(x){return c3*x*x*x-c1*x*x},easeOutBack:function(x){return 1+c3*pow(x-1,3)+c1*pow(x-1,2)},easeInOutBack:function(x){return x<.5?pow(2*x,2)*((c2+1)*2*x-c2)/2:(pow(2*x-2,2)*((c2+1)*(x*2-2)+c2)+2)/2},easeInBounce:function(x){return 1-bounceOut(1-x)},easeOutBounce:bounceOut,easeInOutBounce:function(x){return x<.5?(1-bounceOut(1-2*x))/2:(1+bounceOut(2*x-1))/2}})});
/* jqBootstrapValidation
* A plugin for automating validation on Twitter Bootstrap formatted forms. * * v1.3.6 *
* License: MIT <http://opensource.org/licenses/mit-license.php> - see LICENSE file
*
* http://ReactiveRaven.github.com/jqBootstrapValidation/
*/ (function( $ ){ var createdElements = []; var defaults = { options: { prependExistingHelpBlock: false,
sniffHtml: true, // sniff for 'required', 'maxlength', etc
preventSubmit: true, // stop the form submit event from firing if validation fails
submitError: false, // function called if there is an error when trying to submit
submitSuccess: false, // function called just before a successful submit event is sent to the server
semanticallyStrict: false, // set to true to tidy up generated HTML output
autoAdd: { helpBlocks: true }, filter: function () {
// return $(this).is(":visible"); // only validate elements you can see
return true; // validate everything
} }, methods: { init : function( options ) { var settings = $.extend(true, {}, defaults); settings.options = $.extend(true, settings.options, options); var $siblingElements = this; var uniqueForms = $.unique( $siblingElements.map( function () { return $(this).parents("form")[0]; }).toArray() ); $(uniqueForms).bind("submit", function (e) { var $form = $(this); var warningsFound = 0; var $inputs = $form.find("input,textarea,select").not("[type=submit],[type=image]").filter(settings.options.filter); $inputs.trigger("submit.validation").trigger("validationLostFocus.validation"); $inputs.each(function (i, el) { var $this = $(el), $controlGroup = $this.parents(".control-group").first(); if ( $controlGroup.hasClass("warning") ) { $controlGroup.removeClass("warning").addClass("error"); warningsFound++; } }); $inputs.trigger("validationLostFocus.validation"); if (warningsFound) { if (settings.options.preventSubmit) { e.preventDefault(); } $form.addClass("error"); if ($.isFunction(settings.options.submitError)) { settings.options.submitError($form, e, $inputs.jqBootstrapValidation("collectErrors", true)); } } else { $form.removeClass("error"); if ($.isFunction(settings.options.submitSuccess)) { settings.options.submitSuccess($form, e); } } }); return this.each(function(){
// Get references to everything we're interested in
var $this = $(this), $controlGroup = $this.parents(".control-group").first(), $helpBlock = $controlGroup.find(".help-block").first(), $form = $this.parents("form").first(), validatorNames = [];
// create message container if not exists
if (!$helpBlock.length && settings.options.autoAdd && settings.options.autoAdd.helpBlocks) { $helpBlock = $('<div class="help-block" />'); $controlGroup.find('.controls').append($helpBlock); createdElements.push($helpBlock[0]); }
// =============================================================
// SNIFF HTML FOR VALIDATORS
// =============================================================
// *snort sniff snuffle*
if (settings.options.sniffHtml) { var message = "";
// ---------------------------------------------------------
// PATTERN
// ---------------------------------------------------------
if ($this.attr("pattern") !== undefined) { message = "Not in the expected format<!-- data-validation-pattern-message to override -->"; if ($this.data("validationPatternMessage")) { message = $this.data("validationPatternMessage"); } $this.data("validationPatternMessage", message); $this.data("validationPatternRegex", $this.attr("pattern")); }
// ---------------------------------------------------------
// MAX
// ---------------------------------------------------------
if ($this.attr("max") !== undefined || $this.attr("aria-valuemax") !== undefined) { var max = ($this.attr("max") !== undefined ? $this.attr("max") : $this.attr("aria-valuemax")); message = "Too high: Maximum of '" + max + "'<!-- data-validation-max-message to override -->"; if ($this.data("validationMaxMessage")) { message = $this.data("validationMaxMessage"); } $this.data("validationMaxMessage", message); $this.data("validationMaxMax", max); }
// ---------------------------------------------------------
// MIN
// ---------------------------------------------------------
if ($this.attr("min") !== undefined || $this.attr("aria-valuemin") !== undefined) { var min = ($this.attr("min") !== undefined ? $this.attr("min") : $this.attr("aria-valuemin")); message = "Too low: Minimum of '" + min + "'<!-- data-validation-min-message to override -->"; if ($this.data("validationMinMessage")) { message = $this.data("validationMinMessage"); } $this.data("validationMinMessage", message); $this.data("validationMinMin", min); }
// ---------------------------------------------------------
// MAXLENGTH
// ---------------------------------------------------------
if ($this.attr("maxlength") !== undefined) { message = "Too long: Maximum of '" + $this.attr("maxlength") + "' characters<!-- data-validation-maxlength-message to override -->"; if ($this.data("validationMaxlengthMessage")) { message = $this.data("validationMaxlengthMessage"); } $this.data("validationMaxlengthMessage", message); $this.data("validationMaxlengthMaxlength", $this.attr("maxlength")); }
// ---------------------------------------------------------
// MINLENGTH
// ---------------------------------------------------------
if ($this.attr("minlength") !== undefined) { message = "Too short: Minimum of '" + $this.attr("minlength") + "' characters<!-- data-validation-minlength-message to override -->"; if ($this.data("validationMinlengthMessage")) { message = $this.data("validationMinlengthMessage"); } $this.data("validationMinlengthMessage", message); $this.data("validationMinlengthMinlength", $this.attr("minlength")); }
// ---------------------------------------------------------
// REQUIRED
// ---------------------------------------------------------
if ($this.attr("required") !== undefined || $this.attr("aria-required") !== undefined) { message = settings.builtInValidators.required.message; if ($this.data("validationRequiredMessage")) { message = $this.data("validationRequiredMessage"); } $this.data("validationRequiredMessage", message); }
// ---------------------------------------------------------
// NUMBER
// ---------------------------------------------------------
if ($this.attr("type") !== undefined && $this.attr("type").toLowerCase() === "number") { message = settings.builtInValidators.number.message; if ($this.data("validationNumberMessage")) { message = $this.data("validationNumberMessage"); } $this.data("validationNumberMessage", message); }
// ---------------------------------------------------------
// EMAIL
// ---------------------------------------------------------
if ($this.attr("type") !== undefined && $this.attr("type").toLowerCase() === "email") { message = "Not a valid email address<!-- data-validator-validemail-message to override -->"; if ($this.data("validationValidemailMessage")) { message = $this.data("validationValidemailMessage"); } else if ($this.data("validationEmailMessage")) { message = $this.data("validationEmailMessage"); } $this.data("validationValidemailMessage", message); }
// ---------------------------------------------------------
// MINCHECKED
// ---------------------------------------------------------
if ($this.attr("minchecked") !== undefined) { message = "Not enough options checked; Minimum of '" + $this.attr("minchecked") + "' required<!-- data-validation-minchecked-message to override -->"; if ($this.data("validationMincheckedMessage")) { message = $this.data("validationMincheckedMessage"); } $this.data("validationMincheckedMessage", message); $this.data("validationMincheckedMinchecked", $this.attr("minchecked")); }
// ---------------------------------------------------------
// MAXCHECKED
// ---------------------------------------------------------
if ($this.attr("maxchecked") !== undefined) { message = "Too many options checked; Maximum of '" + $this.attr("maxchecked") + "' required<!-- data-validation-maxchecked-message to override -->"; if ($this.data("validationMaxcheckedMessage")) { message = $this.data("validationMaxcheckedMessage"); } $this.data("validationMaxcheckedMessage", message); $this.data("validationMaxcheckedMaxchecked", $this.attr("maxchecked")); } }
// =============================================================
// COLLECT VALIDATOR NAMES
// =============================================================
// Get named validators
if ($this.data("validation") !== undefined) { validatorNames = $this.data("validation").split(","); }
// Get extra ones defined on the element's data attributes
$.each($this.data(), function (i, el) { var parts = i.replace(/([A-Z])/g, ",$1").split(","); if (parts[0] === "validation" && parts[1]) { validatorNames.push(parts[1]); } });
// =============================================================
// NORMALISE VALIDATOR NAMES
// =============================================================
var validatorNamesToInspect = validatorNames; var newValidatorNamesToInspect = [];
do // repeatedly expand 'shortcut' validators into their real validators
{
// Uppercase only the first letter of each name
$.each(validatorNames, function (i, el) { validatorNames[i] = formatValidatorName(el); });
// Remove duplicate validator names
validatorNames = $.unique(validatorNames);
// Pull out the new validator names from each shortcut
newValidatorNamesToInspect = []; $.each(validatorNamesToInspect, function(i, el) { if ($this.data("validation" + el + "Shortcut") !== undefined) {
// Are these custom validators?
// Pull them out!
$.each($this.data("validation" + el + "Shortcut").split(","), function(i2, el2) { newValidatorNamesToInspect.push(el2); }); } else if (settings.builtInValidators[el.toLowerCase()]) {
// Is this a recognised built-in?
// Pull it out!
var validator = settings.builtInValidators[el.toLowerCase()]; if (validator.type.toLowerCase() === "shortcut") { $.each(validator.shortcut.split(","), function (i, el) { el = formatValidatorName(el); newValidatorNamesToInspect.push(el); validatorNames.push(el); }); } } }); validatorNamesToInspect = newValidatorNamesToInspect; } while (validatorNamesToInspect.length > 0)
// =============================================================
// SET UP VALIDATOR ARRAYS
// =============================================================
var validators = {}; $.each(validatorNames, function (i, el) {
// Set up the 'override' message
var message = $this.data("validation" + el + "Message"); var hasOverrideMessage = (message !== undefined); var foundValidator = false; message = ( message ? message : "'" + el + "' validation failed <!-- Add attribute 'data-validation-" + el.toLowerCase() + "-message' to input to change this message -->" ) ; $.each( settings.validatorTypes, function (validatorType, validatorTemplate) { if (validators[validatorType] === undefined) { validators[validatorType] = []; } if (!foundValidator && $this.data("validation" + el + formatValidatorName(validatorTemplate.name)) !== undefined) { validators[validatorType].push( $.extend( true, { name: formatValidatorName(validatorTemplate.name), message: message }, validatorTemplate.init($this, el) ) ); foundValidator = true; } } ); if (!foundValidator && settings.builtInValidators[el.toLowerCase()]) { var validator = $.extend(true, {}, settings.builtInValidators[el.toLowerCase()]); if (hasOverrideMessage) { validator.message = message; } var validatorType = validator.type.toLowerCase(); if (validatorType === "shortcut") { foundValidator = true; } else { $.each( settings.validatorTypes, function (validatorTemplateType, validatorTemplate) { if (validators[validatorTemplateType] === undefined) { validators[validatorTemplateType] = []; } if (!foundValidator && validatorType === validatorTemplateType.toLowerCase()) { $this.data("validation" + el + formatValidatorName(validatorTemplate.name), validator[validatorTemplate.name.toLowerCase()]); validators[validatorType].push( $.extend( validator, validatorTemplate.init($this, el) ) ); foundValidator = true; } } ); } } if (! foundValidator) { $.error("Cannot find validation info for '" + el + "'"); } });
// =============================================================
// STORE FALLBACK VALUES
// =============================================================
$helpBlock.data( "original-contents", ( $helpBlock.data("original-contents") ? $helpBlock.data("original-contents") : $helpBlock.html() ) ); $helpBlock.data( "original-role", ( $helpBlock.data("original-role") ? $helpBlock.data("original-role") : $helpBlock.attr("role") ) ); $controlGroup.data( "original-classes", ( $controlGroup.data("original-clases") ? $controlGroup.data("original-classes") : $controlGroup.attr("class") ) ); $this.data( "original-aria-invalid", ( $this.data("original-aria-invalid") ? $this.data("original-aria-invalid") : $this.attr("aria-invalid") ) );
// =============================================================
// VALIDATION
// =============================================================
$this.bind( "validation.validation", function (event, params) { var value = getValue($this);
// Get a list of the errors to apply
var errorsFound = []; $.each(validators, function (validatorType, validatorTypeArray) { if (value || value.length || (params && params.includeEmpty) || (!!settings.validatorTypes[validatorType].blockSubmit && params && !!params.submitting)) { $.each(validatorTypeArray, function (i, validator) { if (settings.validatorTypes[validatorType].validate($this, value, validator)) { errorsFound.push(validator.message); } }); } }); return errorsFound; } ); $this.bind( "getValidators.validation", function () { return validators; } );
// =============================================================
// WATCH FOR CHANGES
// =============================================================
$this.bind( "submit.validation", function () { return $this.triggerHandler("change.validation", {submitting: true}); } ); $this.bind( [ "keyup", "focus", "blur", "click", "keydown", "keypress", "change" ].join(".validation ") + ".validation", function (e, params) { var value = getValue($this); var errorsFound = []; $controlGroup.find("input,textarea,select").each(function (i, el) { var oldCount = errorsFound.length; $.each($(el).triggerHandler("validation.validation", params), function (j, message) { errorsFound.push(message); }); if (errorsFound.length > oldCount) { $(el).attr("aria-invalid", "true"); } else { var original = $this.data("original-aria-invalid"); $(el).attr("aria-invalid", (original !== undefined ? original : false)); } }); $form.find("input,select,textarea").not($this).not("[name=\"" + $this.attr("name") + "\"]").trigger("validationLostFocus.validation"); errorsFound = $.unique(errorsFound.sort());
// Were there any errors?
if (errorsFound.length) {
// Better flag it up as a warning.
$controlGroup.removeClass("success error").addClass("warning");
// How many errors did we find?
if (settings.options.semanticallyStrict && errorsFound.length === 1) {
// Only one? Being strict? Just output it.
$helpBlock.html(errorsFound[0] + ( settings.options.prependExistingHelpBlock ? $helpBlock.data("original-contents") : "" )); } else {
// Multiple? Being sloppy? Glue them together into an UL.
$helpBlock.html("<ul role=\"alert\"><li>" + errorsFound.join("</li><li>") + "</li></ul>" + ( settings.options.prependExistingHelpBlock ? $helpBlock.data("original-contents") : "" )); } } else { $controlGroup.removeClass("warning error success"); if (value.length > 0) { $controlGroup.addClass("success"); } $helpBlock.html($helpBlock.data("original-contents")); } if (e.type === "blur") { $controlGroup.removeClass("success"); } } ); $this.bind("validationLostFocus.validation", function () { $controlGroup.removeClass("success"); }); }); }, destroy : function( ) { return this.each( function() { var $this = $(this), $controlGroup = $this.parents(".control-group").first(), $helpBlock = $controlGroup.find(".help-block").first();
// remove our events
$this.unbind('.validation'); // events are namespaced.
// reset help text
$helpBlock.html($helpBlock.data("original-contents"));
// reset classes
$controlGroup.attr("class", $controlGroup.data("original-classes"));
// reset aria
$this.attr("aria-invalid", $this.data("original-aria-invalid"));
// reset role
$helpBlock.attr("role", $this.data("original-role"));
// remove all elements we created
if (createdElements.indexOf($helpBlock[0]) > -1) { $helpBlock.remove(); } } ); }, collectErrors : function(includeEmpty) { var errorMessages = {}; this.each(function (i, el) { var $el = $(el); var name = $el.attr("name"); var errors = $el.triggerHandler("validation.validation", {includeEmpty: true}); errorMessages[name] = $.extend(true, errors, errorMessages[name]); }); $.each(errorMessages, function (i, el) { if (el.length === 0) { delete errorMessages[i]; } }); return errorMessages; }, hasErrors: function() { var errorMessages = []; this.each(function (i, el) { errorMessages = errorMessages.concat( $(el).triggerHandler("getValidators.validation") ? $(el).triggerHandler("validation.validation", {submitting: true}) : [] ); }); return (errorMessages.length > 0); }, override : function (newDefaults) { defaults = $.extend(true, defaults, newDefaults); } }, validatorTypes: { callback: { name: "callback", init: function ($this, name) { return { validatorName: name, callback: $this.data("validation" + name + "Callback"), lastValue: $this.val(), lastValid: true, lastFinished: true }; }, validate: function ($this, value, validator) { if (validator.lastValue === value && validator.lastFinished) { return !validator.lastValid; } if (validator.lastFinished === true) { validator.lastValue = value; validator.lastValid = true; validator.lastFinished = false; var rrjqbvValidator = validator; var rrjqbvThis = $this; executeFunctionByName( validator.callback, window, $this, value, function (data) { if (rrjqbvValidator.lastValue === data.value) { rrjqbvValidator.lastValid = data.valid; if (data.message) { rrjqbvValidator.message = data.message; } rrjqbvValidator.lastFinished = true; rrjqbvThis.data("validation" + rrjqbvValidator.validatorName + "Message", rrjqbvValidator.message);
// Timeout is set to avoid problems with the events being considered 'already fired'
setTimeout(function () { rrjqbvThis.trigger("change.validation");
}, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
} } ); } return false; } }, ajax: { name: "ajax", init: function ($this, name) { return { validatorName: name, url: $this.data("validation" + name + "Ajax"), lastValue: $this.val(), lastValid: true, lastFinished: true }; }, validate: function ($this, value, validator) { if (""+validator.lastValue === ""+value && validator.lastFinished === true) { return validator.lastValid === false; } if (validator.lastFinished === true) { validator.lastValue = value; validator.lastValid = true; validator.lastFinished = false; $.ajax({ url: validator.url, data: "value=" + value + "&field=" + $this.attr("name"), dataType: "json", success: function (data) { if (""+validator.lastValue === ""+data.value) { validator.lastValid = !!(data.valid); if (data.message) { validator.message = data.message; } validator.lastFinished = true; $this.data("validation" + validator.validatorName + "Message", validator.message);
// Timeout is set to avoid problems with the events being considered 'already fired'
setTimeout(function () { $this.trigger("change.validation");
}, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
} }, failure: function () { validator.lastValid = true; validator.message = "ajax call failed"; validator.lastFinished = true; $this.data("validation" + validator.validatorName + "Message", validator.message);
// Timeout is set to avoid problems with the events being considered 'already fired'
setTimeout(function () { $this.trigger("change.validation");
}, 1); // doesn't need a long timeout, just long enough for the event bubble to burst
} }); } return false; } }, regex: { name: "regex", init: function ($this, name) { return {regex: regexFromString($this.data("validation" + name + "Regex"))}; }, validate: function ($this, value, validator) { return (!validator.regex.test(value) && ! validator.negative) || (validator.regex.test(value) && validator.negative); } }, required: { name: "required", init: function ($this, name) { return {}; }, validate: function ($this, value, validator) { return !!(value.length === 0 && ! validator.negative) || !!(value.length > 0 && validator.negative); }, blockSubmit: true }, match: { name: "match", init: function ($this, name) { var element = $this.parents("form").first().find("[name=\"" + $this.data("validation" + name + "Match") + "\"]").first(); element.bind("validation.validation", function () { $this.trigger("change.validation", {submitting: true}); }); return {"element": element}; }, validate: function ($this, value, validator) { return (value !== validator.element.val() && ! validator.negative) || (value === validator.element.val() && validator.negative); }, blockSubmit: true }, max: { name: "max", init: function ($this, name) { return {max: $this.data("validation" + name + "Max")}; }, validate: function ($this, value, validator) { return (parseFloat(value, 10) > parseFloat(validator.max, 10) && ! validator.negative) || (parseFloat(value, 10) <= parseFloat(validator.max, 10) && validator.negative); } }, min: { name: "min", init: function ($this, name) { return {min: $this.data("validation" + name + "Min")}; }, validate: function ($this, value, validator) { return (parseFloat(value) < parseFloat(validator.min) && ! validator.negative) || (parseFloat(value) >= parseFloat(validator.min) && validator.negative); } }, maxlength: { name: "maxlength", init: function ($this, name) { return {maxlength: $this.data("validation" + name + "Maxlength")}; }, validate: function ($this, value, validator) { return ((value.length > validator.maxlength) && ! validator.negative) || ((value.length <= validator.maxlength) && validator.negative); } }, minlength: { name: "minlength", init: function ($this, name) { return {minlength: $this.data("validation" + name + "Minlength")}; }, validate: function ($this, value, validator) { return ((value.length < validator.minlength) && ! validator.negative) || ((value.length >= validator.minlength) && validator.negative); } }, maxchecked: { name: "maxchecked", init: function ($this, name) { var elements = $this.parents("form").first().find("[name=\"" + $this.attr("name") + "\"]"); elements.bind("click.validation", function () { $this.trigger("change.validation", {includeEmpty: true}); }); return {maxchecked: $this.data("validation" + name + "Maxchecked"), elements: elements}; }, validate: function ($this, value, validator) { return (validator.elements.filter(":checked").length > validator.maxchecked && ! validator.negative) || (validator.elements.filter(":checked").length <= validator.maxchecked && validator.negative); }, blockSubmit: true }, minchecked: { name: "minchecked", init: function ($this, name) { var elements = $this.parents("form").first().find("[name=\"" + $this.attr("name") + "\"]"); elements.bind("click.validation", function () { $this.trigger("change.validation", {includeEmpty: true}); }); return {minchecked: $this.data("validation" + name + "Minchecked"), elements: elements}; }, validate: function ($this, value, validator) { return (validator.elements.filter(":checked").length < validator.minchecked && ! validator.negative) || (validator.elements.filter(":checked").length >= validator.minchecked && validator.negative); }, blockSubmit: true } }, builtInValidators: { email: { name: "Email", type: "shortcut", shortcut: "validemail" }, validemail: { name: "Validemail", type: "regex", regex: "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\\.[A-Za-z]{2,4}", message: "Not a valid email address<!-- data-validator-validemail-message to override -->" }, passwordagain: { name: "Passwordagain", type: "match", match: "password", message: "Does not match the given password<!-- data-validator-paswordagain-message to override -->" }, positive: { name: "Positive", type: "shortcut", shortcut: "number,positivenumber" }, negative: { name: "Negative", type: "shortcut", shortcut: "number,negativenumber" }, number: { name: "Number", type: "regex", regex: "([+-]?\\\d+(\\\.\\\d*)?([eE][+-]?[0-9]+)?)?", message: "Must be a number<!-- data-validator-number-message to override -->" }, integer: { name: "Integer", type: "regex", regex: "[+-]?\\\d+", message: "No decimal places allowed<!-- data-validator-integer-message to override -->" }, positivenumber: { name: "Positivenumber", type: "min", min: 0, message: "Must be a positive number<!-- data-validator-positivenumber-message to override -->" }, negativenumber: { name: "Negativenumber", type: "max", max: 0, message: "Must be a negative number<!-- data-validator-negativenumber-message to override -->" }, required: { name: "Required", type: "required", message: "This is required<!-- data-validator-required-message to override -->" }, checkone: { name: "Checkone", type: "minchecked", minchecked: 1, message: "Check at least one option<!-- data-validation-checkone-message to override -->" } } }; var formatValidatorName = function (name) { return name .toLowerCase() .replace( /(^|\s)([a-z])/g , function(m,p1,p2) { return p1+p2.toUpperCase(); } ) ; }; var getValue = function ($this) {
// Extract the value we're talking about
var value = $this.val(); var type = $this.attr("type"); if (type === "checkbox") { value = ($this.is(":checked") ? value : ""); } if (type === "radio") { value = ($('input[name="' + $this.attr("name") + '"]:checked').length > 0 ? value : ""); } return value; }; function regexFromString(inputstring) { return new RegExp("^" + inputstring + "$"); }
/**
* Thanks to Jason Bunting via StackOverflow.com *
* http://stackoverflow.com/questions/359788/how-to-execute-a-javascript-function-when-i-have-its-name-as-a-string#answer-359910
* Short link: http://tinyurl.com/executeFunctionByName
**/
function executeFunctionByName(functionName, context /*, args*/) {
var args = Array.prototype.slice.call(arguments).splice(2); var namespaces = functionName.split("."); var func = namespaces.pop(); for(var i = 0; i < namespaces.length; i++) { context = context[namespaces[i]]; } return context[func].apply(this, args); } $.fn.jqBootstrapValidation = function( method ) { if ( defaults.methods[method] ) { return defaults.methods[method].apply( this, Array.prototype.slice.call( arguments, 1 )); } else if ( typeof method === 'object' || ! method ) { return defaults.methods.init.apply( this, arguments ); } else { $.error( 'Method ' + method + ' does not exist on jQuery.jqBootstrapValidation' ); return null; } }; $.jqBootstrapValidation = function (options) { $(":input").not("[type=image],[type=submit]").jqBootstrapValidation.apply(this,arguments); }; })( jQuery ); $(function() { $("#contactForm input,#contactForm textarea").jqBootstrapValidation({ preventSubmit: true, submitError: function($form, event, errors) {
// additional error messages or events
}, submitSuccess: function($form, event) {
event.preventDefault(); // prevent default submit behaviour
// get values from FORM
var name = $("input#name").val(); var email = $("input#email").val(); var phone = $("input#phone").val(); var message = $("textarea#message").val();
var firstName = name; // For Success/Failure Message
// Check for white space in name for Success/Fail message
if (firstName.indexOf(' ') >= 0) { firstName = name.split(' ').slice(0, -1).join(' '); } $this = $("#sendMessageButton");
$this.prop("disabled", true); // Disable submit button until AJAX call is complete to prevent duplicate messages
$.ajax({
url: "https://contactme.saltos.org/php/contact_me.php",
type: "POST", data: { name: name, phone: phone, email: email, message: message }, cache: false, success: function() {
// Success message
$('#success').html("<div class='alert alert-success'>"); $('#success > .alert-success').html("<button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;") .append("</button>"); $('#success > .alert-success') .append("<strong>"+$("#contactForm").attr("data-validation-ok-message")+"</strong>"); $('#success > .alert-success') .append('</div>');
//clear all fields
$('#contactForm').trigger("reset"); }, error: function() {
// Fail message
$('#success').html("<div class='alert alert-danger'>"); $('#success > .alert-danger').html("<button type='button' class='close' data-dismiss='alert' aria-hidden='true'>&times;") .append("</button>"); $('#success > .alert-danger').append("<strong>"+$("#contactForm").attr("data-validation-ko-message")+"</strong>"); $('#success > .alert-danger').append('</div>');
//clear all fields
$('#contactForm').trigger("reset"); }, complete: function() { setTimeout(function() {
$this.prop("disabled", false); // Re-enable submit button when AJAX call is complete
}, 1000); } }); }, filter: function() { return $(this).is(":visible"); }, }); $("a[data-toggle=\"tab\"]").click(function(e) { e.preventDefault(); $(this).tab("show"); }); });
/*When clicking on Full hide fail/success boxes */
$('#name').focus(function() { $('#success').html(''); }); (function($) {
"use strict"; // Start of use strict
// Smooth scrolling using jQuery easing
$('a.js-scroll-trigger[href*="#"]:not([href="#"])').click(function() {
if (location.pathname.replace(/^\//, '') == this.pathname.replace(/^\//, '') && location.hostname == this.hostname) {
var target = $(this.hash); target = target.length ? target : $('[name=' + this.hash.slice(1) + ']'); if (target.length) { $('html, body').animate({ scrollTop: (target.offset().top - 71) }, 1000, "easeInOutExpo"); return false; } } });
// Scroll to top button appear
$(document).scroll(function() { var scrollDistance = $(this).scrollTop(); if (scrollDistance > 100) { $('.scroll-to-top').fadeIn(); } else { $('.scroll-to-top').fadeOut(); } });
// Closes responsive menu when a scroll trigger link is clicked
$('.js-scroll-trigger').click(function() { $('.navbar-collapse').collapse('hide'); });
// Activate scrollspy to add active class to navbar items on scroll
$('body').scrollspy({ target: '#mainNav', offset: 80 });
// Collapse Navbar
var navbarCollapse = function() { if ($("#mainNav").offset().top > 100) { $("#mainNav").addClass("navbar-shrink"); } else { $("#mainNav").removeClass("navbar-shrink"); } };
// Collapse now if page is not at top
navbarCollapse();
// Collapse the navbar when page is scrolled
$(window).scroll(navbarCollapse);
// Floating label headings for the contact form
$(function() { $("body").on("input propertychange", ".floating-label-form-group", function(e) { $(this).toggleClass("floating-label-form-group-with-value", !!$(e.target).val()); }).on("focus", ".floating-label-form-group", function() { $(this).addClass("floating-label-form-group-with-focus"); }).on("blur", ".floating-label-form-group", function() { $(this).removeClass("floating-label-form-group-with-focus"); }); });
})(jQuery); // End of use strict
(function(d){"function"===typeof define&&define.amd?define(["jquery"],d):"object"===typeof exports?module.exports=d(require("jquery")):d(jQuery)})(function(d){function l(b){return f.raw?b:encodeURIComponent(b)}function m(b,e){var a;if(f.raw)a=b;else a:{var c=b;0===c.indexOf('"')&&(c=c.slice(1,-1).replace(/\\"/g,'"').replace(/\\\\/g,"\\"));try{c=decodeURIComponent(c.replace(j," "));a=f.json?JSON.parse(c):c;break a}catch(h){}a=void 0}return d.isFunction(e)?e(a):a}var j=/\+/g,f=d.cookie=function(b,e,
a){if(1<arguments.length&&!d.isFunction(e)){a=d.extend({},f.defaults,a);if("number"===typeof a.expires){var c=a.expires,h=a.expires=new Date;h.setMilliseconds(h.getMilliseconds()+864E5*c)}return document.cookie=[l(b),"=",l(f.json?JSON.stringify(e):""+e),a.expires?"; expires="+a.expires.toUTCString():"",a.path?"; path="+a.path:"",a.domain?"; domain="+a.domain:"",a.secure?"; secure":""].join("")}for(var c=b?void 0:{},h=document.cookie?document.cookie.split("; "):[],k=0,j=h.length;k<j;k++){var g=h[k].split("="),
i;i=g.shift();i=f.raw?i:decodeURIComponent(i);g=g.join("=");if(b===i){c=m(g,e);break}if(!b&&void 0!==(g=m(g)))c[i]=g}return c};f.defaults={};d.removeCookie=function(b,e){d.cookie(b,"",d.extend({},e,{expires:-1}));return!d.cookie(b)}});
"use strict"; $(function() { var colores={ "template":{ ".divider-custom .divider-custom-line":{ "background-color":"#123456", "border-color":"#123456", }, ".divider-custom .divider-custom-icon i":{ "color":"#123456", }, ".divider-custom.divider-light .divider-custom-line":{ "background-color":"#345678", "border-color":"#345678", }, ".divider-custom.divider-light .divider-custom-icon i":{ "color":"#345678", }, ".bg-primary":{ "background-color":"#234567!important", }, ".text-primary":{ "color":"#234567", }, ".btn-primary":{ "color":"#345678", "background-color":"#234567", "border-color":"#234567", }, ".btn-primary:hover":{ "color":"#ffffff", "background-color":"#123456", "border-color":"#123456", }, ".masthead.text-white":{ "color":"#345678!important", }, "#about .text-white":{ "color":"#345678!important", }, ".bg-secondary":{ "background-color":"#123456!important", }, ".text-secondary":{ "color":"#123456!important", }, "#portfolio .portfolio-item-caption":{ "background-color":"rgba(50,100,150,.9)", }, "#portfolio img":{ "background-color":"#234567", }, ".portfolio-modal img":{ "background-color":"#234567", }, ".portfolio-modal .close":{ "color":"#123456", }, ".portfolio-modal a":{ "color":"#123456", "text-decoration":"underline", }, ".portfolio-modal a:hover":{ "text-decoration":"none", }, ".footer":{ "color":"#345678", "background-color":"#234567", }, ".copyright":{ "background-color":"#123456", }, ".copyright a":{ "color":"#ffffff", "text-decoration":"underline", }, ".copyright a:hover":{ "text-decoration":"none", }, ".btn-outline-light":{ "color":"#345678", "border-color":"#345678", }, ".btn-outline-light:hover":{ "color":"#234567", "background-color":"#345678", "border-color":"#345678", }, "#mainNav .nav-link.active":{ "background-color":"#234567!important", "color":"#345678!important", }, "#mainNav .nav-link:hover":{ "background-color":"#234567", "color":"#345678!important", }, "#mainNav button":{ "color":"#345678!important", }, "#mainNav button:hover":{ "background-color":"#345678!important", "color":"#234567!important", } } }; var counter=0; var nombre=["original","blue","green","red","yellow"]; var color1=["2c3e50","1a3561","144321","5d1a15","644b02"]; var color2=["1abc9c","4285f4","34a853","ea4335","fbbc05"]; var color3=[]; var color4=["ffffff","ffffff","ffffff","ffffff","000000"]; var color5=["15997f","4285f4","2f994c","ea4335","cc9904"]; for(var k in nombre) { var color=nombre[k]; colores[color]={}; color3[k]=parseInt(color1[k].substr(0,2),16)+","+parseInt(color1[k].substr(2,2),16)+","+parseInt(color1[k].substr(4,2),16); for(var i in colores["template"]) { colores[color][i]={}; for(var j in colores["template"][i]) { colores[color][i][j]=colores["template"][i][j].replace("123456",color1[k]).replace("234567",color2[k]).replace("50,100,150",color3[k]).replace("345678",color4[k]); } } } $("body").on("color",function() { var color=nombre[counter]; for(var i in colores[color]) { for(var j in colores[color][i]) { $("body").append("<style>"+i+"{"+j+":"+colores[color][i][j]+"}</style>"); } } color=color2[counter]; $("meta[name='theme-color']").attr("content","#"+color); color=color5[counter]; $("#viewerContainer").attr("data-color",color); }); $("body").on("click",function(e) { if($(e.target).is("a")) return; if($(e.target).is("button")) return; if($(e.target).is("i")) return; if($(e.target).is("div.portfolio-item-caption")) return; if($(e.target).is("input")) return; if($(e.target).is("textarea")) return; counter=(counter+1)%nombre.length; $("body").trigger("color"); $("body").trigger("pdfjs"); $.cookie("color",counter,{expires:365,path:"/"}); }); counter=parseInt($.cookie("color"));
//~ if(isNaN(counter)) counter=Math.floor(Math.random()*nombre.length);
if(isNaN(counter)) counter=0; $("body").trigger("color"); $("body").trigger("pdfjs"); $.cookie("color",counter,{expires:365,path:"/"}); var lang=window.location.href.split("/").pop().split(".")[1]; $.cookie("lang",lang,{expires:365,path:"/"}); });
/**
* @licstart The following is the entire license notice for the * Javascript code in this page * * Copyright 2020 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *
* http://www.apache.org/licenses/LICENSE-2.0
* * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * Javascript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define("pdfjs-dist/build/pdf", [], factory); else if(typeof exports === 'object') exports["pdfjs-dist/build/pdf"] = factory(); else root["pdfjs-dist/build/pdf"] = root.pdfjsLib = factory(); })(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__w_pdfjs_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__w_pdfjs_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
/******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__w_pdfjs_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__w_pdfjs_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __w_pdfjs_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__w_pdfjs_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __w_pdfjs_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__w_pdfjs_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__w_pdfjs_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); Object.defineProperty(exports, "addLinkAttributes", { enumerable: true, get: function get() { return _display_utils.addLinkAttributes; } }); Object.defineProperty(exports, "getFilenameFromUrl", { enumerable: true, get: function get() { return _display_utils.getFilenameFromUrl; } }); Object.defineProperty(exports, "LinkTarget", { enumerable: true, get: function get() { return _display_utils.LinkTarget; } }); Object.defineProperty(exports, "loadScript", { enumerable: true, get: function get() { return _display_utils.loadScript; } }); Object.defineProperty(exports, "PDFDateString", { enumerable: true, get: function get() { return _display_utils.PDFDateString; } }); Object.defineProperty(exports, "RenderingCancelledException", { enumerable: true, get: function get() { return _display_utils.RenderingCancelledException; } }); Object.defineProperty(exports, "build", { enumerable: true, get: function get() { return _api.build; } }); Object.defineProperty(exports, "getDocument", { enumerable: true, get: function get() { return _api.getDocument; } }); Object.defineProperty(exports, "LoopbackPort", { enumerable: true, get: function get() { return _api.LoopbackPort; } }); Object.defineProperty(exports, "PDFDataRangeTransport", { enumerable: true, get: function get() { return _api.PDFDataRangeTransport; } }); Object.defineProperty(exports, "PDFWorker", { enumerable: true, get: function get() { return _api.PDFWorker; } }); Object.defineProperty(exports, "version", { enumerable: true, get: function get() { return _api.version; } }); Object.defineProperty(exports, "CMapCompressionType", { enumerable: true, get: function get() { return _util.CMapCompressionType; } }); Object.defineProperty(exports, "createObjectURL", { enumerable: true, get: function get() { return _util.createObjectURL; } }); Object.defineProperty(exports, "createPromiseCapability", { enumerable: true, get: function get() { return _util.createPromiseCapability; } }); Object.defineProperty(exports, "createValidAbsoluteUrl", { enumerable: true, get: function get() { return _util.createValidAbsoluteUrl; } }); Object.defineProperty(exports, "InvalidPDFException", { enumerable: true, get: function get() { return _util.InvalidPDFException; } }); Object.defineProperty(exports, "MissingPDFException", { enumerable: true, get: function get() { return _util.MissingPDFException; } }); Object.defineProperty(exports, "OPS", { enumerable: true, get: function get() { return _util.OPS; } }); Object.defineProperty(exports, "PasswordResponses", { enumerable: true, get: function get() { return _util.PasswordResponses; } }); Object.defineProperty(exports, "PermissionFlag", { enumerable: true, get: function get() { return _util.PermissionFlag; } }); Object.defineProperty(exports, "removeNullCharacters", { enumerable: true, get: function get() { return _util.removeNullCharacters; } }); Object.defineProperty(exports, "shadow", { enumerable: true, get: function get() { return _util.shadow; } }); Object.defineProperty(exports, "UnexpectedResponseException", { enumerable: true, get: function get() { return _util.UnexpectedResponseException; } }); Object.defineProperty(exports, "UNSUPPORTED_FEATURES", { enumerable: true, get: function get() { return _util.UNSUPPORTED_FEATURES; } }); Object.defineProperty(exports, "Util", { enumerable: true, get: function get() { return _util.Util; } }); Object.defineProperty(exports, "VerbosityLevel", { enumerable: true, get: function get() { return _util.VerbosityLevel; } }); Object.defineProperty(exports, "AnnotationLayer", { enumerable: true, get: function get() { return _annotation_layer.AnnotationLayer; } }); Object.defineProperty(exports, "apiCompatibilityParams", { enumerable: true, get: function get() { return _api_compatibility.apiCompatibilityParams; } }); Object.defineProperty(exports, "GlobalWorkerOptions", { enumerable: true, get: function get() { return _worker_options.GlobalWorkerOptions; } }); Object.defineProperty(exports, "renderTextLayer", { enumerable: true, get: function get() { return _text_layer.renderTextLayer; } }); Object.defineProperty(exports, "SVGGraphics", { enumerable: true, get: function get() { return _svg.SVGGraphics; } }); var _display_utils = __w_pdfjs_require__(1); var _api = __w_pdfjs_require__(203); var _util = __w_pdfjs_require__(5); var _annotation_layer = __w_pdfjs_require__(214); var _api_compatibility = __w_pdfjs_require__(205); var _worker_options = __w_pdfjs_require__(208); var _text_layer = __w_pdfjs_require__(215); var _svg = __w_pdfjs_require__(216); var pdfjsVersion = '2.5.207'; var pdfjsBuild = '0974d6052'; { var _require = __w_pdfjs_require__(7), isNodeJS = _require.isNodeJS; if (isNodeJS) { var PDFNodeStream = __w_pdfjs_require__(217).PDFNodeStream; (0, _api.setPDFNetworkStreamFactory)(function (params) { return new PDFNodeStream(params); }); } else { var PDFNetworkStream = __w_pdfjs_require__(220).PDFNetworkStream; var PDFFetchStream; if ((0, _display_utils.isFetchSupported)()) { PDFFetchStream = __w_pdfjs_require__(221).PDFFetchStream; } (0, _api.setPDFNetworkStreamFactory)(function (params) { if (PDFFetchStream && (0, _display_utils.isValidFetchUrl)(params.url)) { return new PDFFetchStream(params); } return new PDFNetworkStream(params); }); } }
/***/ }),
/* 1 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.addLinkAttributes = addLinkAttributes; exports.getFilenameFromUrl = getFilenameFromUrl; exports.isFetchSupported = isFetchSupported; exports.isValidFetchUrl = isValidFetchUrl; exports.loadScript = loadScript; exports.deprecated = deprecated;
exports.PDFDateString = exports.StatTimer = exports.DOMSVGFactory = exports.DOMCMapReaderFactory = exports.DOMCanvasFactory = exports.DEFAULT_LINK_REL = exports.LinkTarget = exports.RenderingCancelledException = exports.PageViewport = void 0;
var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2)); var _util = __w_pdfjs_require__(5); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); } function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var DEFAULT_LINK_REL = "noopener noreferrer nofollow"; exports.DEFAULT_LINK_REL = DEFAULT_LINK_REL;
var SVG_NS = "http://www.w3.org/2000/svg";
var DOMCanvasFactory = /*#__PURE__*/function () {
function DOMCanvasFactory() { _classCallCheck(this, DOMCanvasFactory); } _createClass(DOMCanvasFactory, [{ key: "create", value: function create(width, height) { if (width <= 0 || height <= 0) { throw new Error("Invalid canvas size"); } var canvas = document.createElement("canvas"); var context = canvas.getContext("2d"); canvas.width = width; canvas.height = height; return { canvas: canvas, context: context }; } }, { key: "reset", value: function reset(canvasAndContext, width, height) { if (!canvasAndContext.canvas) { throw new Error("Canvas is not specified"); } if (width <= 0 || height <= 0) { throw new Error("Invalid canvas size"); } canvasAndContext.canvas.width = width; canvasAndContext.canvas.height = height; } }, { key: "destroy", value: function destroy(canvasAndContext) { if (!canvasAndContext.canvas) { throw new Error("Canvas is not specified"); } canvasAndContext.canvas.width = 0; canvasAndContext.canvas.height = 0; canvasAndContext.canvas = null; canvasAndContext.context = null; } }]); return DOMCanvasFactory; }(); exports.DOMCanvasFactory = DOMCanvasFactory;
var DOMCMapReaderFactory = /*#__PURE__*/function () {
function DOMCMapReaderFactory(_ref) { var _ref$baseUrl = _ref.baseUrl, baseUrl = _ref$baseUrl === void 0 ? null : _ref$baseUrl, _ref$isCompressed = _ref.isCompressed, isCompressed = _ref$isCompressed === void 0 ? false : _ref$isCompressed; _classCallCheck(this, DOMCMapReaderFactory); this.baseUrl = baseUrl; this.isCompressed = isCompressed; } _createClass(DOMCMapReaderFactory, [{ key: "fetch", value: function (_fetch) { function fetch(_x) { return _fetch.apply(this, arguments); } fetch.toString = function () { return _fetch.toString(); }; return fetch;
}( /*#__PURE__*/function () {
var _ref3 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2(_ref2) {
var _this = this; var name, url, compressionType; return _regenerator["default"].wrap(function _callee2$(_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0: name = _ref2.name; if (this.baseUrl) { _context2.next = 3; break; } throw new Error('The CMap "baseUrl" parameter must be specified, ensure that ' + 'the "cMapUrl" and "cMapPacked" API parameters are provided.'); case 3: if (name) { _context2.next = 5; break; } throw new Error("CMap name must be specified."); case 5: url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : ""); compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE; if (!(isFetchSupported() && isValidFetchUrl(url, document.baseURI))) { _context2.next = 9; break; }
return _context2.abrupt("return", fetch(url).then( /*#__PURE__*/function () {
var _ref4 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(response) {
var cMapData; return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: if (response.ok) { _context.next = 2; break; } throw new Error(response.statusText); case 2: if (!_this.isCompressed) { _context.next = 10; break; } _context.t0 = Uint8Array; _context.next = 6; return response.arrayBuffer(); case 6: _context.t1 = _context.sent; cMapData = new _context.t0(_context.t1); _context.next = 15; break; case 10: _context.t2 = _util.stringToBytes; _context.next = 13; return response.text(); case 13: _context.t3 = _context.sent; cMapData = (0, _context.t2)(_context.t3); case 15: return _context.abrupt("return", { cMapData: cMapData, compressionType: compressionType }); case 16: case "end": return _context.stop(); } } }, _callee); })); return function (_x3) { return _ref4.apply(this, arguments); }; }())["catch"](function (reason) { throw new Error("Unable to load ".concat(_this.isCompressed ? "binary " : "") + "CMap at: ".concat(url)); })); case 9: return _context2.abrupt("return", new Promise(function (resolve, reject) { var request = new XMLHttpRequest(); request.open("GET", url, true); if (_this.isCompressed) { request.responseType = "arraybuffer"; } request.onreadystatechange = function () { if (request.readyState !== XMLHttpRequest.DONE) { return; } if (request.status === 200 || request.status === 0) { var cMapData; if (_this.isCompressed && request.response) { cMapData = new Uint8Array(request.response); } else if (!_this.isCompressed && request.responseText) { cMapData = (0, _util.stringToBytes)(request.responseText); } if (cMapData) { resolve({ cMapData: cMapData, compressionType: compressionType }); return; } } reject(new Error(request.statusText)); }; request.send(null); })["catch"](function (reason) { throw new Error("Unable to load ".concat(_this.isCompressed ? "binary " : "") + "CMap at: ".concat(url)); })); case 10: case "end": return _context2.stop(); } } }, _callee2, this); })); return function (_x2) { return _ref3.apply(this, arguments); }; }()) }]); return DOMCMapReaderFactory; }(); exports.DOMCMapReaderFactory = DOMCMapReaderFactory;
var DOMSVGFactory = /*#__PURE__*/function () {
function DOMSVGFactory() { _classCallCheck(this, DOMSVGFactory); } _createClass(DOMSVGFactory, [{ key: "create", value: function create(width, height) { (0, _util.assert)(width > 0 && height > 0, "Invalid SVG dimensions"); var svg = document.createElementNS(SVG_NS, "svg:svg"); svg.setAttribute("version", "1.1"); svg.setAttribute("width", width + "px"); svg.setAttribute("height", height + "px"); svg.setAttribute("preserveAspectRatio", "none"); svg.setAttribute("viewBox", "0 0 " + width + " " + height); return svg; } }, { key: "createElement", value: function createElement(type) { (0, _util.assert)(typeof type === "string", "Invalid SVG element type"); return document.createElementNS(SVG_NS, type); } }]); return DOMSVGFactory; }(); exports.DOMSVGFactory = DOMSVGFactory;
var PageViewport = /*#__PURE__*/function () {
function PageViewport(_ref5) { var viewBox = _ref5.viewBox, scale = _ref5.scale, rotation = _ref5.rotation, _ref5$offsetX = _ref5.offsetX, offsetX = _ref5$offsetX === void 0 ? 0 : _ref5$offsetX, _ref5$offsetY = _ref5.offsetY, offsetY = _ref5$offsetY === void 0 ? 0 : _ref5$offsetY, _ref5$dontFlip = _ref5.dontFlip, dontFlip = _ref5$dontFlip === void 0 ? false : _ref5$dontFlip; _classCallCheck(this, PageViewport); this.viewBox = viewBox; this.scale = scale; this.rotation = rotation; this.offsetX = offsetX; this.offsetY = offsetY; var centerX = (viewBox[2] + viewBox[0]) / 2; var centerY = (viewBox[3] + viewBox[1]) / 2; var rotateA, rotateB, rotateC, rotateD; rotation = rotation % 360; rotation = rotation < 0 ? rotation + 360 : rotation; switch (rotation) { case 180: rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1; break; case 90: rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0; break; case 270: rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0; break; case 0: rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1; break; default: throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees."); } if (dontFlip) { rotateC = -rotateC; rotateD = -rotateD; } var offsetCanvasX, offsetCanvasY; var width, height; if (rotateA === 0) { offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX; offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY; width = Math.abs(viewBox[3] - viewBox[1]) * scale; height = Math.abs(viewBox[2] - viewBox[0]) * scale; } else { offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX; offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY; width = Math.abs(viewBox[2] - viewBox[0]) * scale; height = Math.abs(viewBox[3] - viewBox[1]) * scale; }
this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
this.width = width; this.height = height; } _createClass(PageViewport, [{ key: "clone", value: function clone() { var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref6$scale = _ref6.scale, scale = _ref6$scale === void 0 ? this.scale : _ref6$scale, _ref6$rotation = _ref6.rotation, rotation = _ref6$rotation === void 0 ? this.rotation : _ref6$rotation, _ref6$offsetX = _ref6.offsetX, offsetX = _ref6$offsetX === void 0 ? this.offsetX : _ref6$offsetX, _ref6$offsetY = _ref6.offsetY, offsetY = _ref6$offsetY === void 0 ? this.offsetY : _ref6$offsetY, _ref6$dontFlip = _ref6.dontFlip, dontFlip = _ref6$dontFlip === void 0 ? false : _ref6$dontFlip; return new PageViewport({ viewBox: this.viewBox.slice(), scale: scale, rotation: rotation, offsetX: offsetX, offsetY: offsetY, dontFlip: dontFlip }); } }, { key: "convertToViewportPoint", value: function convertToViewportPoint(x, y) { return _util.Util.applyTransform([x, y], this.transform); } }, { key: "convertToViewportRectangle", value: function convertToViewportRectangle(rect) { var topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform); var bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform); return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]]; } }, { key: "convertToPdfPoint", value: function convertToPdfPoint(x, y) { return _util.Util.applyInverseTransform([x, y], this.transform); } }]); return PageViewport; }(); exports.PageViewport = PageViewport;
var RenderingCancelledException = /*#__PURE__*/function (_BaseException) {
_inherits(RenderingCancelledException, _BaseException); var _super = _createSuper(RenderingCancelledException); function RenderingCancelledException(msg, type) { var _this2; _classCallCheck(this, RenderingCancelledException); _this2 = _super.call(this, msg); _this2.type = type; return _this2; } return RenderingCancelledException; }(_util.BaseException); exports.RenderingCancelledException = RenderingCancelledException; var LinkTarget = { NONE: 0, SELF: 1, BLANK: 2, PARENT: 3, TOP: 4 }; exports.LinkTarget = LinkTarget; function addLinkAttributes(link) { var _ref7 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, url = _ref7.url, target = _ref7.target, rel = _ref7.rel, _ref7$enabled = _ref7.enabled, enabled = _ref7$enabled === void 0 ? true : _ref7$enabled; (0, _util.assert)(url && typeof url === "string", 'addLinkAttributes: A valid "url" parameter must provided.'); var urlNullRemoved = (0, _util.removeNullCharacters)(url); if (enabled) { link.href = link.title = urlNullRemoved; } else { link.href = ""; link.title = "Disabled: ".concat(urlNullRemoved); link.onclick = function () { return false; }; } var targetStr = ""; switch (target) { case LinkTarget.NONE: break; case LinkTarget.SELF: targetStr = "_self"; break; case LinkTarget.BLANK: targetStr = "_blank"; break; case LinkTarget.PARENT: targetStr = "_parent"; break; case LinkTarget.TOP: targetStr = "_top"; break; } link.target = targetStr; link.rel = typeof rel === "string" ? rel : DEFAULT_LINK_REL; } function getFilenameFromUrl(url) { var anchor = url.indexOf("#"); var query = url.indexOf("?"); var end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length); return url.substring(url.lastIndexOf("/", end) + 1, end); }
var StatTimer = /*#__PURE__*/function () {
function StatTimer() { _classCallCheck(this, StatTimer); this.started = Object.create(null); this.times = []; } _createClass(StatTimer, [{ key: "time", value: function time(name) { if (name in this.started) { (0, _util.warn)("Timer is already running for ".concat(name)); } this.started[name] = Date.now(); } }, { key: "timeEnd", value: function timeEnd(name) { if (!(name in this.started)) { (0, _util.warn)("Timer has not been started for ".concat(name)); } this.times.push({ name: name, start: this.started[name], end: Date.now() }); delete this.started[name]; } }, { key: "toString", value: function toString() { var outBuf = []; var longest = 0; var _iterator = _createForOfIteratorHelper(this.times), _step; try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var time = _step.value; var name = time.name; if (name.length > longest) { longest = name.length; } } } catch (err) { _iterator.e(err); } finally { _iterator.f(); } var _iterator2 = _createForOfIteratorHelper(this.times), _step2; try { for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) { var _time = _step2.value; var duration = _time.end - _time.start; outBuf.push("".concat(_time.name.padEnd(longest), " ").concat(duration, "ms\n")); } } catch (err) { _iterator2.e(err); } finally { _iterator2.f(); } return outBuf.join(""); } }]); return StatTimer; }(); exports.StatTimer = StatTimer; function isFetchSupported() { return typeof fetch !== "undefined" && typeof Response !== "undefined" && "body" in Response.prototype && typeof ReadableStream !== "undefined"; } function isValidFetchUrl(url, baseUrl) { try { var _ref8 = baseUrl ? new URL(url, baseUrl) : new URL(url), protocol = _ref8.protocol; return protocol === "http:" || protocol === "https:"; } catch (ex) { return false; } } function loadScript(src) { return new Promise(function (resolve, reject) { var script = document.createElement("script"); script.src = src; script.onload = resolve; script.onerror = function () { reject(new Error("Cannot load script at: ".concat(script.src))); }; (document.head || document.documentElement).appendChild(script); }); } function deprecated(details) { console.log("Deprecated API usage: " + details); } var pdfDateStringRegex;
var PDFDateString = /*#__PURE__*/function () {
function PDFDateString() { _classCallCheck(this, PDFDateString); } _createClass(PDFDateString, null, [{ key: "toDateObject", value: function toDateObject(input) { if (!input || !(0, _util.isString)(input)) { return null; } if (!pdfDateStringRegex) { pdfDateStringRegex = new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?"); } var matches = pdfDateStringRegex.exec(input); if (!matches) { return null; } var year = parseInt(matches[1], 10); var month = parseInt(matches[2], 10); month = month >= 1 && month <= 12 ? month - 1 : 0; var day = parseInt(matches[3], 10); day = day >= 1 && day <= 31 ? day : 1; var hour = parseInt(matches[4], 10); hour = hour >= 0 && hour <= 23 ? hour : 0; var minute = parseInt(matches[5], 10); minute = minute >= 0 && minute <= 59 ? minute : 0; var second = parseInt(matches[6], 10); second = second >= 0 && second <= 59 ? second : 0; var universalTimeRelation = matches[7] || "Z"; var offsetHour = parseInt(matches[8], 10); offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0; var offsetMinute = parseInt(matches[9], 10) || 0; offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0; if (universalTimeRelation === "-") { hour += offsetHour; minute += offsetMinute; } else if (universalTimeRelation === "+") { hour -= offsetHour; minute -= offsetMinute; } return new Date(Date.UTC(year, month, day, hour, minute, second)); } }]); return PDFDateString; }(); exports.PDFDateString = PDFDateString;
/***/ }),
/* 2 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; module.exports = __w_pdfjs_require__(3);
/***/ }),
/* 3 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
var runtime = function (exports) { "use strict"; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; var $Symbol = typeof Symbol === "function" ? Symbol : {}; var iteratorSymbol = $Symbol.iterator || "@@iterator"; var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator"; var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); return obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } exports.wrap = wrap; function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } var GenStateSuspendedStart = "suspendedStart"; var GenStateSuspendedYield = "suspendedYield"; var GenStateExecuting = "executing"; var GenStateCompleted = "completed"; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this; }; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto && getProto(getProto(values([]))); if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { IteratorPrototype = NativeIteratorPrototype; } var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } exports.isGeneratorFunction = function (genFun) { var ctor = typeof genFun === "function" && genFun.constructor; return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false; }; exports.mark = function (genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); } else { genFun.__proto__ = GeneratorFunctionPrototype; define(genFun, toStringTagSymbol, "GeneratorFunction"); } genFun.prototype = Object.create(Gp); return genFun; }; exports.awrap = function (arg) { return { __await: arg }; }; function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (record.type === "throw") { reject(record.arg); } else { var result = record.arg; var value = result.value; if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) { return PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }); } return PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped; resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } } var previousPromise; function enqueue(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } this._invoke = enqueue; } defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this; }; exports.AsyncIterator = AsyncIterator; exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { if (PromiseImpl === void 0) PromiseImpl = Promise; var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }; function makeInvokeMethod(innerFn, self, context) { var state = GenStateSuspendedStart; return function invoke(method, arg) { if (state === GenStateExecuting) { throw new Error("Generator is already running"); } if (state === GenStateCompleted) { if (method === "throw") { throw arg; } return doneResult(); } context.method = method; context.arg = arg; while (true) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (context.method === "next") { context.sent = context._sent = context.arg; } else if (context.method === "throw") { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg; } context.dispatchException(context.arg); } else if (context.method === "return") { context.abrupt("return", context.arg); } state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === "normal") { state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } else if (record.type === "throw") { state = GenStateCompleted; context.method = "throw"; context.arg = record.arg; } } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (method === undefined) { context.delegate = null; if (context.method === "throw") { if (delegate.iterator["return"]) { context.method = "return"; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === "throw") { return ContinueSentinel; } } context.method = "throw"; context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === "throw") { context.method = "throw"; context.arg = record.arg; context.delegate = null; return ContinueSentinel; } var info = record.arg; if (!info) { context.method = "throw"; context.arg = new TypeError("iterator result is not an object"); context.delegate = null; return ContinueSentinel; } if (info.done) { context[delegate.resultName] = info.value; context.next = delegate.nextLoc; if (context.method !== "return") { context.method = "next"; context.arg = undefined; } } else { return info; } context.delegate = null; return ContinueSentinel; } defineIteratorMethods(Gp); define(Gp, toStringTagSymbol, "Generator"); Gp[iteratorSymbol] = function () { return this; }; Gp.toString = function () { return "[object Generator]"; }; function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1]; } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; } this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal"; delete record.arg; entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); } exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } keys.reverse(); return function next() { while (keys.length) { var key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next; } } next.done = true; return next; }; }; function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable); } if (typeof iterable.next === "function") { return iterable; } if (!isNaN(iterable.length)) { var i = -1, next = function next() { while (++i < iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next; } } next.value = undefined; next.done = true; return next; }; return next.next = next; } } return { next: doneResult }; } exports.values = values; function doneResult() { return { value: undefined, done: true }; } Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { this.prev = 0; this.next = 0; this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = "next"; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (var name in this) { if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) { this[name] = undefined; } } } }, stop: function stop() { this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === "throw") { throw rootRecord.arg; } return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) { throw exception; } var context = this; function handle(loc, caught) { record.type = "throw"; record.arg = exception; context.next = loc; if (caught) { context.method = "next"; context.arg = undefined; } return !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === "root") { return handle("end"); } if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"); var hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) { return handle(entry.catchLoc, true); } else if (this.prev < entry.finallyLoc) { return handle(entry.finallyLoc); } } else if (hasCatch) { if (this.prev < entry.catchLoc) { return handle(entry.catchLoc, true); } } else if (hasFinally) { if (this.prev < entry.finallyLoc) { return handle(entry.finallyLoc); } } else { throw new Error("try statement without catch or finally"); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) { finallyEntry = null; } var record = finallyEntry ? finallyEntry.completion : {}; record.type = type; record.arg = arg; if (finallyEntry) { this.method = "next"; this.next = finallyEntry.finallyLoc; return ContinueSentinel; } return this.complete(record); }, complete: function complete(record, afterLoc) { if (record.type === "throw") { throw record.arg; } if (record.type === "break" || record.type === "continue") { this.next = record.arg; } else if (record.type === "return") { this.rval = this.arg = record.arg; this.method = "return"; this.next = "end"; } else if (record.type === "normal" && afterLoc) { this.next = afterLoc; } return ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) { this.complete(entry.completion, entry.afterLoc); resetTryEntry(entry); return ContinueSentinel; } } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (record.type === "throw") { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }; if (this.method === "next") { this.arg = undefined; } return ContinueSentinel; } }; return exports; }(( false ? undefined : _typeof(module)) === "object" ? module.exports : {}); try { regeneratorRuntime = runtime; } catch (accidentalStrictMode) { Function("r", "regeneratorRuntime = r")(runtime); }
/* WEBPACK VAR INJECTION */}.call(this, __w_pdfjs_require__(4)(module)))
/***/ }),
/* 4 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; module.exports = function (module) { if (!module.webpackPolyfill) { module.deprecate = function () {}; module.paths = []; if (!module.children) module.children = []; Object.defineProperty(module, "loaded", { enumerable: true, get: function get() { return module.l; } }); Object.defineProperty(module, "id", { enumerable: true, get: function get() { return module.i; } }); module.webpackPolyfill = 1; } return module; };
/***/ }),
/* 5 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.arrayByteLength = arrayByteLength; exports.arraysToBytes = arraysToBytes; exports.assert = assert; exports.bytesToString = bytesToString; exports.createPromiseCapability = createPromiseCapability; exports.getVerbosityLevel = getVerbosityLevel; exports.info = info; exports.isArrayBuffer = isArrayBuffer; exports.isArrayEqual = isArrayEqual; exports.isBool = isBool; exports.isEmptyObj = isEmptyObj; exports.isNum = isNum; exports.isString = isString; exports.isSameOrigin = isSameOrigin; exports.createValidAbsoluteUrl = createValidAbsoluteUrl; exports.removeNullCharacters = removeNullCharacters; exports.setVerbosityLevel = setVerbosityLevel; exports.shadow = shadow; exports.string32 = string32; exports.stringToBytes = stringToBytes; exports.stringToPDFString = stringToPDFString; exports.stringToUTF8String = stringToUTF8String; exports.utf8StringToString = utf8StringToString; exports.warn = warn; exports.unreachable = unreachable;
exports.IsEvalSupportedCached = exports.IsLittleEndianCached = exports.createObjectURL = exports.FormatError = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.StreamType = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.MissingPDFException = exports.InvalidPDFException = exports.AbortException = exports.CMapCompressionType = exports.ImageKind = exports.FontType = exports.AnnotationType = exports.AnnotationStateModelType = exports.AnnotationReviewState = exports.AnnotationReplyType = exports.AnnotationMarkedState = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationBorderStyleType = exports.UNSUPPORTED_FEATURES = exports.VerbosityLevel = exports.OPS = exports.IDENTITY_MATRIX = exports.FONT_IDENTITY_MATRIX = exports.BaseException = void 0;
__w_pdfjs_require__(6);
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); } function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0]; exports.IDENTITY_MATRIX = IDENTITY_MATRIX; var FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0]; exports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX; var PermissionFlag = { PRINT: 0x04, MODIFY_CONTENTS: 0x08, COPY: 0x10, MODIFY_ANNOTATIONS: 0x20, FILL_INTERACTIVE_FORMS: 0x100, COPY_FOR_ACCESSIBILITY: 0x200, ASSEMBLE: 0x400, PRINT_HIGH_QUALITY: 0x800 }; exports.PermissionFlag = PermissionFlag; var TextRenderingMode = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; exports.TextRenderingMode = TextRenderingMode; var ImageKind = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; exports.ImageKind = ImageKind; var AnnotationType = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }; exports.AnnotationType = AnnotationType; var AnnotationStateModelType = { MARKED: "Marked", REVIEW: "Review" }; exports.AnnotationStateModelType = AnnotationStateModelType; var AnnotationMarkedState = { MARKED: "Marked", UNMARKED: "Unmarked" }; exports.AnnotationMarkedState = AnnotationMarkedState; var AnnotationReviewState = { ACCEPTED: "Accepted", REJECTED: "Rejected", CANCELLED: "Cancelled", COMPLETED: "Completed", NONE: "None" }; exports.AnnotationReviewState = AnnotationReviewState; var AnnotationReplyType = { GROUP: "Group", REPLY: "R" }; exports.AnnotationReplyType = AnnotationReplyType; var AnnotationFlag = { INVISIBLE: 0x01, HIDDEN: 0x02, PRINT: 0x04, NOZOOM: 0x08, NOROTATE: 0x10, NOVIEW: 0x20, READONLY: 0x40, LOCKED: 0x80, TOGGLENOVIEW: 0x100, LOCKEDCONTENTS: 0x200 }; exports.AnnotationFlag = AnnotationFlag; var AnnotationFieldFlag = { READONLY: 0x0000001, REQUIRED: 0x0000002, NOEXPORT: 0x0000004, MULTILINE: 0x0001000, PASSWORD: 0x0002000, NOTOGGLETOOFF: 0x0004000, RADIO: 0x0008000, PUSHBUTTON: 0x0010000, COMBO: 0x0020000, EDIT: 0x0040000, SORT: 0x0080000, FILESELECT: 0x0100000, MULTISELECT: 0x0200000, DONOTSPELLCHECK: 0x0400000, DONOTSCROLL: 0x0800000, COMB: 0x1000000, RICHTEXT: 0x2000000, RADIOSINUNISON: 0x2000000, COMMITONSELCHANGE: 0x4000000 }; exports.AnnotationFieldFlag = AnnotationFieldFlag; var AnnotationBorderStyleType = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; exports.AnnotationBorderStyleType = AnnotationBorderStyleType; var StreamType = { UNKNOWN: "UNKNOWN", FLATE: "FLATE", LZW: "LZW", DCT: "DCT", JPX: "JPX", JBIG: "JBIG", A85: "A85", AHX: "AHX", CCF: "CCF", RLX: "RLX" }; exports.StreamType = StreamType; var FontType = { UNKNOWN: "UNKNOWN", TYPE1: "TYPE1", TYPE1C: "TYPE1C", CIDFONTTYPE0: "CIDFONTTYPE0", CIDFONTTYPE0C: "CIDFONTTYPE0C", TRUETYPE: "TRUETYPE", CIDFONTTYPE2: "CIDFONTTYPE2", TYPE3: "TYPE3", OPENTYPE: "OPENTYPE", TYPE0: "TYPE0", MMTYPE1: "MMTYPE1" }; exports.FontType = FontType; var VerbosityLevel = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }; exports.VerbosityLevel = VerbosityLevel; var CMapCompressionType = { NONE: 0, BINARY: 1, STREAM: 2 }; exports.CMapCompressionType = CMapCompressionType; var OPS = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotations: 78, endAnnotations: 79, beginAnnotation: 80, endAnnotation: 81, paintJpegXObject: 82, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; exports.OPS = OPS; var UNSUPPORTED_FEATURES = { unknown: "unknown", forms: "forms", javaScript: "javaScript", smask: "smask", shadingPattern: "shadingPattern", font: "font", errorTilingPattern: "errorTilingPattern", errorExtGState: "errorExtGState", errorXObject: "errorXObject", errorFontLoadType3: "errorFontLoadType3", errorFontState: "errorFontState", errorFontMissing: "errorFontMissing", errorFontTranslate: "errorFontTranslate", errorColorSpace: "errorColorSpace", errorOperatorList: "errorOperatorList", errorFontToUnicode: "errorFontToUnicode", errorFontLoadNative: "errorFontLoadNative", errorFontGetPath: "errorFontGetPath" }; exports.UNSUPPORTED_FEATURES = UNSUPPORTED_FEATURES; var PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; exports.PasswordResponses = PasswordResponses; var verbosity = VerbosityLevel.WARNINGS; function setVerbosityLevel(level) { if (Number.isInteger(level)) { verbosity = level; } } function getVerbosityLevel() { return verbosity; } function info(msg) { if (verbosity >= VerbosityLevel.INFOS) { console.log("Info: ".concat(msg)); } } function warn(msg) { if (verbosity >= VerbosityLevel.WARNINGS) { console.log("Warning: ".concat(msg)); } } function unreachable(msg) { throw new Error(msg); } function assert(cond, msg) { if (!cond) { unreachable(msg); } } function isSameOrigin(baseUrl, otherUrl) { var base; try { base = new URL(baseUrl); if (!base.origin || base.origin === "null") { return false; } } catch (e) { return false; } var other = new URL(otherUrl, base); return base.origin === other.origin; } function _isValidProtocol(url) { if (!url) { return false; } switch (url.protocol) { case "http:": case "https:": case "ftp:": case "mailto:": case "tel:": return true; default: return false; } } function createValidAbsoluteUrl(url, baseUrl) { if (!url) { return null; } try { var absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url); if (_isValidProtocol(absoluteUrl)) { return absoluteUrl; } } catch (ex) {} return null; } function shadow(obj, prop, value) { Object.defineProperty(obj, prop, { value: value, enumerable: true, configurable: true, writable: false }); return value; } var BaseException = function BaseExceptionClosure() { function BaseException(message) { if (this.constructor === BaseException) { unreachable("Cannot initialize BaseException."); } this.message = message; this.name = this.constructor.name; } BaseException.prototype = new Error(); BaseException.constructor = BaseException; return BaseException; }(); exports.BaseException = BaseException;
var PasswordException = /*#__PURE__*/function (_BaseException) {
_inherits(PasswordException, _BaseException); var _super = _createSuper(PasswordException); function PasswordException(msg, code) { var _this; _classCallCheck(this, PasswordException); _this = _super.call(this, msg); _this.code = code; return _this; } return PasswordException; }(BaseException); exports.PasswordException = PasswordException;
var UnknownErrorException = /*#__PURE__*/function (_BaseException2) {
_inherits(UnknownErrorException, _BaseException2); var _super2 = _createSuper(UnknownErrorException); function UnknownErrorException(msg, details) { var _this2; _classCallCheck(this, UnknownErrorException); _this2 = _super2.call(this, msg); _this2.details = details; return _this2; } return UnknownErrorException; }(BaseException); exports.UnknownErrorException = UnknownErrorException;
var InvalidPDFException = /*#__PURE__*/function (_BaseException3) {
_inherits(InvalidPDFException, _BaseException3); var _super3 = _createSuper(InvalidPDFException); function InvalidPDFException() { _classCallCheck(this, InvalidPDFException); return _super3.apply(this, arguments); } return InvalidPDFException; }(BaseException); exports.InvalidPDFException = InvalidPDFException;
var MissingPDFException = /*#__PURE__*/function (_BaseException4) {
_inherits(MissingPDFException, _BaseException4); var _super4 = _createSuper(MissingPDFException); function MissingPDFException() { _classCallCheck(this, MissingPDFException); return _super4.apply(this, arguments); } return MissingPDFException; }(BaseException); exports.MissingPDFException = MissingPDFException;
var UnexpectedResponseException = /*#__PURE__*/function (_BaseException5) {
_inherits(UnexpectedResponseException, _BaseException5); var _super5 = _createSuper(UnexpectedResponseException); function UnexpectedResponseException(msg, status) { var _this3; _classCallCheck(this, UnexpectedResponseException); _this3 = _super5.call(this, msg); _this3.status = status; return _this3; } return UnexpectedResponseException; }(BaseException); exports.UnexpectedResponseException = UnexpectedResponseException;
var FormatError = /*#__PURE__*/function (_BaseException6) {
_inherits(FormatError, _BaseException6); var _super6 = _createSuper(FormatError); function FormatError() { _classCallCheck(this, FormatError); return _super6.apply(this, arguments); } return FormatError; }(BaseException); exports.FormatError = FormatError;
var AbortException = /*#__PURE__*/function (_BaseException7) {
_inherits(AbortException, _BaseException7); var _super7 = _createSuper(AbortException); function AbortException() { _classCallCheck(this, AbortException); return _super7.apply(this, arguments); } return AbortException; }(BaseException); exports.AbortException = AbortException; var NullCharactersRegExp = /\x00/g; function removeNullCharacters(str) { if (typeof str !== "string") { warn("The argument for removeNullCharacters must be a string."); return str; } return str.replace(NullCharactersRegExp, ""); } function bytesToString(bytes) { assert(bytes !== null && _typeof(bytes) === "object" && bytes.length !== undefined, "Invalid argument for bytesToString"); var length = bytes.length; var MAX_ARGUMENT_COUNT = 8192; if (length < MAX_ARGUMENT_COUNT) { return String.fromCharCode.apply(null, bytes); } var strBuf = []; for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) { var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length); var chunk = bytes.subarray(i, chunkEnd); strBuf.push(String.fromCharCode.apply(null, chunk)); } return strBuf.join(""); } function stringToBytes(str) { assert(typeof str === "string", "Invalid argument for stringToBytes"); var length = str.length; var bytes = new Uint8Array(length); for (var i = 0; i < length; ++i) { bytes[i] = str.charCodeAt(i) & 0xff; } return bytes; } function arrayByteLength(arr) { if (arr.length !== undefined) { return arr.length; } assert(arr.byteLength !== undefined, "arrayByteLength - invalid argument."); return arr.byteLength; } function arraysToBytes(arr) { var length = arr.length; if (length === 1 && arr[0] instanceof Uint8Array) { return arr[0]; } var resultLength = 0; for (var i = 0; i < length; i++) { resultLength += arrayByteLength(arr[i]); } var pos = 0; var data = new Uint8Array(resultLength); for (var _i = 0; _i < length; _i++) { var item = arr[_i]; if (!(item instanceof Uint8Array)) { if (typeof item === "string") { item = stringToBytes(item); } else { item = new Uint8Array(item); } } var itemLength = item.byteLength; data.set(item, pos); pos += itemLength; } return data; } function string32(value) { return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff); } function isLittleEndian() { var buffer8 = new Uint8Array(4); buffer8[0] = 1; var view32 = new Uint32Array(buffer8.buffer, 0, 1); return view32[0] === 1; } var IsLittleEndianCached = { get value() { return shadow(this, "value", isLittleEndian()); } }; exports.IsLittleEndianCached = IsLittleEndianCached; function isEvalSupported() { try { new Function(""); return true; } catch (e) { return false; } } var IsEvalSupportedCached = { get value() { return shadow(this, "value", isEvalSupported()); } }; exports.IsEvalSupportedCached = IsEvalSupportedCached; var rgbBuf = ["rgb(", 0, ",", 0, ",", 0, ")"];
var Util = /*#__PURE__*/function () {
function Util() { _classCallCheck(this, Util); } _createClass(Util, null, [{ key: "makeCssRgb", value: function makeCssRgb(r, g, b) { rgbBuf[1] = r; rgbBuf[3] = g; rgbBuf[5] = b; return rgbBuf.join(""); } }, { key: "transform", value: function transform(m1, m2) {
return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
} }, { key: "applyTransform", value: function applyTransform(p, m) { var xt = p[0] * m[0] + p[1] * m[2] + m[4]; var yt = p[0] * m[1] + p[1] * m[3] + m[5]; return [xt, yt]; } }, { key: "applyInverseTransform", value: function applyInverseTransform(p, m) { var d = m[0] * m[3] - m[1] * m[2]; var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d; var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d; return [xt, yt]; } }, { key: "getAxialAlignedBoundingBox", value: function getAxialAlignedBoundingBox(r, m) { var p1 = Util.applyTransform(r, m); var p2 = Util.applyTransform(r.slice(2, 4), m); var p3 = Util.applyTransform([r[0], r[3]], m); var p4 = Util.applyTransform([r[2], r[1]], m); return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])]; } }, { key: "inverseTransform", value: function inverseTransform(m) { var d = m[0] * m[3] - m[1] * m[2]; return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d]; } }, { key: "apply3dTransform", value: function apply3dTransform(m, v) { return [m[0] * v[0] + m[1] * v[1] + m[2] * v[2], m[3] * v[0] + m[4] * v[1] + m[5] * v[2], m[6] * v[0] + m[7] * v[1] + m[8] * v[2]]; } }, { key: "singularValueDecompose2dScale", value: function singularValueDecompose2dScale(m) { var transpose = [m[0], m[2], m[1], m[3]]; var a = m[0] * transpose[0] + m[1] * transpose[2]; var b = m[0] * transpose[1] + m[1] * transpose[3]; var c = m[2] * transpose[0] + m[3] * transpose[2]; var d = m[2] * transpose[1] + m[3] * transpose[3]; var first = (a + d) / 2; var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2; var sx = first + second || 1; var sy = first - second || 1; return [Math.sqrt(sx), Math.sqrt(sy)]; } }, { key: "normalizeRect", value: function normalizeRect(rect) { var r = rect.slice(0); if (rect[0] > rect[2]) { r[0] = rect[2]; r[2] = rect[0]; } if (rect[1] > rect[3]) { r[1] = rect[3]; r[3] = rect[1]; } return r; } }, { key: "intersect", value: function intersect(rect1, rect2) { function compare(a, b) { return a - b; } var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare); var orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare); var result = []; rect1 = Util.normalizeRect(rect1); rect2 = Util.normalizeRect(rect2); if (orderedX[0] === rect1[0] && orderedX[1] === rect2[0] || orderedX[0] === rect2[0] && orderedX[1] === rect1[0]) { result[0] = orderedX[1]; result[2] = orderedX[2]; } else { return null; } if (orderedY[0] === rect1[1] && orderedY[1] === rect2[1] || orderedY[0] === rect2[1] && orderedY[1] === rect1[1]) { result[1] = orderedY[1]; result[3] = orderedY[2]; } else { return null; } return result; } }]); return Util; }(); exports.Util = Util;
var PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C, 0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160, 0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC];
function stringToPDFString(str) { var length = str.length, strBuf = []; if (str[0] === "\xFE" && str[1] === "\xFF") { for (var i = 2; i < length; i += 2) { strBuf.push(String.fromCharCode(str.charCodeAt(i) << 8 | str.charCodeAt(i + 1))); } } else if (str[0] === "\xFF" && str[1] === "\xFE") { for (var _i2 = 2; _i2 < length; _i2 += 2) { strBuf.push(String.fromCharCode(str.charCodeAt(_i2 + 1) << 8 | str.charCodeAt(_i2))); } } else { for (var _i3 = 0; _i3 < length; ++_i3) { var code = PDFStringTranslateTable[str.charCodeAt(_i3)]; strBuf.push(code ? String.fromCharCode(code) : str.charAt(_i3)); } } return strBuf.join(""); } function stringToUTF8String(str) { return decodeURIComponent(escape(str)); } function utf8StringToString(str) { return unescape(encodeURIComponent(str)); } function isEmptyObj(obj) { for (var key in obj) { return false; } return true; } function isBool(v) { return typeof v === "boolean"; } function isNum(v) { return typeof v === "number"; } function isString(v) { return typeof v === "string"; } function isArrayBuffer(v) { return _typeof(v) === "object" && v !== null && v.byteLength !== undefined; } function isArrayEqual(arr1, arr2) { if (arr1.length !== arr2.length) { return false; } return arr1.every(function (element, index) { return element === arr2[index]; }); } function createPromiseCapability() { var capability = Object.create(null); var isSettled = false; Object.defineProperty(capability, "settled", { get: function get() { return isSettled; } }); capability.promise = new Promise(function (resolve, reject) { capability.resolve = function (data) { isSettled = true; resolve(data); }; capability.reject = function (reason) { isSettled = true; reject(reason); }; }); return capability; } var createObjectURL = function createObjectURLClosure() { var digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; return function createObjectURL(data, contentType) { var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; if (!forceDataSchema && URL.createObjectURL) { var blob = new Blob([data], { type: contentType }); return URL.createObjectURL(blob); } var buffer = "data:".concat(contentType, ";base64,"); for (var i = 0, ii = data.length; i < ii; i += 3) { var b1 = data[i] & 0xff; var b2 = data[i + 1] & 0xff; var b3 = data[i + 2] & 0xff; var d1 = b1 >> 2, d2 = (b1 & 3) << 4 | b2 >> 4; var d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64; var d4 = i + 2 < ii ? b3 & 0x3f : 64; buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4]; } return buffer; }; }(); exports.createObjectURL = createObjectURL;
/***/ }),
/* 6 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var _is_node = __w_pdfjs_require__(7);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
if (typeof globalThis === "undefined" || !globalThis._pdfjsCompatibilityChecked) { if (typeof globalThis === "undefined" || globalThis.Math !== Math) { globalThis = __w_pdfjs_require__(8); } globalThis._pdfjsCompatibilityChecked = true; var hasDOM = (typeof window === "undefined" ? "undefined" : _typeof(window)) === "object" && (typeof document === "undefined" ? "undefined" : _typeof(document)) === "object"; var userAgent = typeof navigator !== "undefined" && navigator.userAgent || ""; var isIE = /Trident/.test(userAgent); (function checkNodeBtoa() { if (globalThis.btoa || !_is_node.isNodeJS) { return; } globalThis.btoa = function (chars) { return Buffer.from(chars, "binary").toString("base64"); }; })(); (function checkNodeAtob() { if (globalThis.atob || !_is_node.isNodeJS) { return; } globalThis.atob = function (input) { return Buffer.from(input, "base64").toString("binary"); }; })(); (function checkChildNodeRemove() { if (!hasDOM) { return; } if (typeof Element.prototype.remove !== "undefined") { return; } Element.prototype.remove = function () { if (this.parentNode) { this.parentNode.removeChild(this); } }; })(); (function checkDOMTokenListAddRemove() { if (!hasDOM || _is_node.isNodeJS) { return; } var div = document.createElement("div"); div.classList.add("testOne", "testTwo"); if (div.classList.contains("testOne") === true && div.classList.contains("testTwo") === true) { return; } var OriginalDOMTokenListAdd = DOMTokenList.prototype.add; var OriginalDOMTokenListRemove = DOMTokenList.prototype.remove; DOMTokenList.prototype.add = function () { for (var _len = arguments.length, tokens = new Array(_len), _key = 0; _key < _len; _key++) { tokens[_key] = arguments[_key]; } for (var _i = 0, _tokens = tokens; _i < _tokens.length; _i++) { var token = _tokens[_i]; OriginalDOMTokenListAdd.call(this, token); } }; DOMTokenList.prototype.remove = function () { for (var _len2 = arguments.length, tokens = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) { tokens[_key2] = arguments[_key2]; } for (var _i2 = 0, _tokens2 = tokens; _i2 < _tokens2.length; _i2++) { var token = _tokens2[_i2]; OriginalDOMTokenListRemove.call(this, token); } }; })(); (function checkDOMTokenListToggle() { if (!hasDOM || _is_node.isNodeJS) { return; } var div = document.createElement("div"); if (div.classList.toggle("test", 0) === false) { return; } DOMTokenList.prototype.toggle = function (token) { var force = arguments.length > 1 ? !!arguments[1] : !this.contains(token); return this[force ? "add" : "remove"](token), force; }; })(); (function checkWindowHistoryPushStateReplaceState() { if (!hasDOM || !isIE) { return; } var OriginalPushState = window.history.pushState; var OriginalReplaceState = window.history.replaceState; window.history.pushState = function (state, title, url) { var args = url === undefined ? [state, title] : [state, title, url]; OriginalPushState.apply(this, args); }; window.history.replaceState = function (state, title, url) { var args = url === undefined ? [state, title] : [state, title, url]; OriginalReplaceState.apply(this, args); }; })(); (function checkStringStartsWith() { if (String.prototype.startsWith) { return; } __w_pdfjs_require__(53); })(); (function checkStringEndsWith() { if (String.prototype.endsWith) { return; } __w_pdfjs_require__(64); })(); (function checkStringIncludes() { if (String.prototype.includes) { return; } __w_pdfjs_require__(66); })(); (function checkArrayIncludes() { if (Array.prototype.includes) { return; } __w_pdfjs_require__(68); })(); (function checkArrayFrom() { if (Array.from) { return; } __w_pdfjs_require__(76); })(); (function checkObjectAssign() { if (Object.assign) { return; } __w_pdfjs_require__(99); })(); (function checkMathLog2() { if (Math.log2) { return; } Math.log2 = __w_pdfjs_require__(102); })(); (function checkNumberIsNaN() { if (Number.isNaN) { return; } Number.isNaN = __w_pdfjs_require__(104); })(); (function checkNumberIsInteger() { if (Number.isInteger) { return; } Number.isInteger = __w_pdfjs_require__(106); })(); (function checkTypedArraySlice() { if (Uint8Array.prototype.slice) { return; } __w_pdfjs_require__(109); })(); (function checkPromise() { if (globalThis.Promise && globalThis.Promise.allSettled) { return; } globalThis.Promise = __w_pdfjs_require__(114); })(); (function checkURL() { globalThis.URL = __w_pdfjs_require__(140); })(); (function checkReadableStream() { var isReadableStreamSupported = false; if (typeof ReadableStream !== "undefined") { try { new ReadableStream({ start: function start(controller) { controller.close(); } }); isReadableStreamSupported = true; } catch (e) {} } if (isReadableStreamSupported) { return; } globalThis.ReadableStream = __w_pdfjs_require__(147).ReadableStream; })(); (function checkMapEntries() { if (globalThis.Map && globalThis.Map.prototype.entries) { return; } globalThis.Map = __w_pdfjs_require__(148); })(); (function checkSetEntries() { if (globalThis.Set && globalThis.Set.prototype.entries) { return; } globalThis.Set = __w_pdfjs_require__(155); })(); (function checkWeakMap() { if (globalThis.WeakMap) { return; } globalThis.WeakMap = __w_pdfjs_require__(157); })(); (function checkWeakSet() { if (globalThis.WeakSet) { return; } globalThis.WeakSet = __w_pdfjs_require__(163); })(); (function checkStringCodePointAt() { if (String.prototype.codePointAt) { return; } __w_pdfjs_require__(165); })(); (function checkStringFromCodePoint() { if (String.fromCodePoint) { return; } String.fromCodePoint = __w_pdfjs_require__(167); })(); (function checkSymbol() { if (globalThis.Symbol) { return; } __w_pdfjs_require__(169); })(); (function checkStringPadStart() { if (String.prototype.padStart) { return; } __w_pdfjs_require__(193); })(); (function checkStringPadEnd() { if (String.prototype.padEnd) { return; } __w_pdfjs_require__(198); })(); (function checkObjectValues() { if (Object.values) { return; } Object.values = __w_pdfjs_require__(200); })(); }
/***/ }),
/* 7 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.isNodeJS = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
var isNodeJS = (typeof process === "undefined" ? "undefined" : _typeof(process)) === "object" && process + "" === "[object process]" && !process.versions.nw && !process.versions.electron; exports.isNodeJS = isNodeJS;
/***/ }),
/* 8 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(9); module.exports = __w_pdfjs_require__(11);
/***/ }),
/* 9 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); var global = __w_pdfjs_require__(11); $({ global: true }, { globalThis: global });
/***/ }),
/* 10 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var getOwnPropertyDescriptor = __w_pdfjs_require__(12).f; var createNonEnumerableProperty = __w_pdfjs_require__(26); var redefine = __w_pdfjs_require__(29); var setGlobal = __w_pdfjs_require__(30); var copyConstructorProperties = __w_pdfjs_require__(40); var isForced = __w_pdfjs_require__(52); module.exports = function (options, source) { var TARGET = options.target; var GLOBAL = options.global; var STATIC = options.stat; var FORCED, target, key, targetProperty, sourceProperty, descriptor; if (GLOBAL) { target = global; } else if (STATIC) { target = global[TARGET] || setGlobal(TARGET, {}); } else { target = (global[TARGET] || {}).prototype; } if (target) for (key in source) { sourceProperty = source[key]; if (options.noTargetGet) { descriptor = getOwnPropertyDescriptor(target, key); targetProperty = descriptor && descriptor.value; } else targetProperty = target[key]; FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced); if (!FORCED && targetProperty !== undefined) { if (typeof sourceProperty === typeof targetProperty) continue; copyConstructorProperties(sourceProperty, targetProperty); } if (options.sham || targetProperty && targetProperty.sham) { createNonEnumerableProperty(sourceProperty, 'sham', true); } redefine(target, key, sourceProperty, options); } };
/***/ }),
/* 11 */
/***/ (function(module, exports) {
var check = function (it) { return it && it.Math == Math && it; };
module.exports = check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof global == 'object' && global) || function () {
return this; }() || Function('return this')();
/***/ }),
/* 12 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var DESCRIPTORS = __w_pdfjs_require__(13); var propertyIsEnumerableModule = __w_pdfjs_require__(15); var createPropertyDescriptor = __w_pdfjs_require__(16); var toIndexedObject = __w_pdfjs_require__(17); var toPrimitive = __w_pdfjs_require__(21); var has = __w_pdfjs_require__(23); var IE8_DOM_DEFINE = __w_pdfjs_require__(24); var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) { O = toIndexedObject(O); P = toPrimitive(P, true); if (IE8_DOM_DEFINE) try { return nativeGetOwnPropertyDescriptor(O, P); } catch (error) { } if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]); };
/***/ }),
/* 13 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var fails = __w_pdfjs_require__(14); module.exports = !fails(function () { return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7; });
/***/ }),
/* 14 */
/***/ (function(module, exports) {
module.exports = function (exec) { try { return !!exec(); } catch (error) { return true; } };
/***/ }),
/* 15 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var nativePropertyIsEnumerable = {}.propertyIsEnumerable; var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor; var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1); exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) { var descriptor = getOwnPropertyDescriptor(this, V); return !!descriptor && descriptor.enumerable; } : nativePropertyIsEnumerable;
/***/ }),
/* 16 */
/***/ (function(module, exports) {
module.exports = function (bitmap, value) { return { enumerable: !(bitmap & 1), configurable: !(bitmap & 2), writable: !(bitmap & 4), value: value }; };
/***/ }),
/* 17 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var IndexedObject = __w_pdfjs_require__(18); var requireObjectCoercible = __w_pdfjs_require__(20); module.exports = function (it) { return IndexedObject(requireObjectCoercible(it)); };
/***/ }),
/* 18 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var fails = __w_pdfjs_require__(14); var classof = __w_pdfjs_require__(19); var split = ''.split; module.exports = fails(function () { return !Object('z').propertyIsEnumerable(0); }) ? function (it) { return classof(it) == 'String' ? split.call(it, '') : Object(it); } : Object;
/***/ }),
/* 19 */
/***/ (function(module, exports) {
var toString = {}.toString; module.exports = function (it) { return toString.call(it).slice(8, -1); };
/***/ }),
/* 20 */
/***/ (function(module, exports) {
module.exports = function (it) { if (it == undefined) throw TypeError("Can't call method on " + it); return it; };
/***/ }),
/* 21 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var isObject = __w_pdfjs_require__(22); module.exports = function (input, PREFERRED_STRING) { if (!isObject(input)) return input; var fn, val; if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val; if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val; if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val; throw TypeError("Can't convert object to primitive value"); };
/***/ }),
/* 22 */
/***/ (function(module, exports) {
module.exports = function (it) { return typeof it === 'object' ? it !== null : typeof it === 'function'; };
/***/ }),
/* 23 */
/***/ (function(module, exports) {
var hasOwnProperty = {}.hasOwnProperty; module.exports = function (it, key) { return hasOwnProperty.call(it, key); };
/***/ }),
/* 24 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var DESCRIPTORS = __w_pdfjs_require__(13); var fails = __w_pdfjs_require__(14); var createElement = __w_pdfjs_require__(25); module.exports = !DESCRIPTORS && !fails(function () { return Object.defineProperty(createElement('div'), 'a', { get: function () { return 7; } }).a != 7; });
/***/ }),
/* 25 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var isObject = __w_pdfjs_require__(22); var document = global.document; var EXISTS = isObject(document) && isObject(document.createElement); module.exports = function (it) { return EXISTS ? document.createElement(it) : {}; };
/***/ }),
/* 26 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var DESCRIPTORS = __w_pdfjs_require__(13); var definePropertyModule = __w_pdfjs_require__(27); var createPropertyDescriptor = __w_pdfjs_require__(16); module.exports = DESCRIPTORS ? function (object, key, value) { return definePropertyModule.f(object, key, createPropertyDescriptor(1, value)); } : function (object, key, value) { object[key] = value; return object; };
/***/ }),
/* 27 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var DESCRIPTORS = __w_pdfjs_require__(13); var IE8_DOM_DEFINE = __w_pdfjs_require__(24); var anObject = __w_pdfjs_require__(28); var toPrimitive = __w_pdfjs_require__(21); var nativeDefineProperty = Object.defineProperty; exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) { anObject(O); P = toPrimitive(P, true); anObject(Attributes); if (IE8_DOM_DEFINE) try { return nativeDefineProperty(O, P, Attributes); } catch (error) { } if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported'); if ('value' in Attributes) O[P] = Attributes.value; return O; };
/***/ }),
/* 28 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var isObject = __w_pdfjs_require__(22); module.exports = function (it) { if (!isObject(it)) { throw TypeError(String(it) + ' is not an object'); } return it; };
/***/ }),
/* 29 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var createNonEnumerableProperty = __w_pdfjs_require__(26); var has = __w_pdfjs_require__(23); var setGlobal = __w_pdfjs_require__(30); var inspectSource = __w_pdfjs_require__(31); var InternalStateModule = __w_pdfjs_require__(33); var getInternalState = InternalStateModule.get; var enforceInternalState = InternalStateModule.enforce; var TEMPLATE = String(String).split('String'); (module.exports = function (O, key, value, options) { var unsafe = options ? !!options.unsafe : false; var simple = options ? !!options.enumerable : false; var noTargetGet = options ? !!options.noTargetGet : false; var state; if (typeof value == 'function') { if (typeof key == 'string' && !has(value, 'name')) { createNonEnumerableProperty(value, 'name', key); } state = enforceInternalState(value); if (!state.source) { state.source = TEMPLATE.join(typeof key == 'string' ? key : ''); } } if (O === global) { if (simple) O[key] = value; else setGlobal(key, value); return; } else if (!unsafe) { delete O[key]; } else if (!noTargetGet && O[key]) { simple = true; } if (simple) O[key] = value; else createNonEnumerableProperty(O, key, value); })(Function.prototype, 'toString', function toString() { return typeof this == 'function' && getInternalState(this).source || inspectSource(this); });
/***/ }),
/* 30 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var createNonEnumerableProperty = __w_pdfjs_require__(26); module.exports = function (key, value) { try { createNonEnumerableProperty(global, key, value); } catch (error) { global[key] = value; } return value; };
/***/ }),
/* 31 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var store = __w_pdfjs_require__(32); var functionToString = Function.toString; if (typeof store.inspectSource != 'function') { store.inspectSource = function (it) { return functionToString.call(it); }; } module.exports = store.inspectSource;
/***/ }),
/* 32 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var setGlobal = __w_pdfjs_require__(30); var SHARED = '__core-js_shared__'; var store = global[SHARED] || setGlobal(SHARED, {}); module.exports = store;
/***/ }),
/* 33 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var NATIVE_WEAK_MAP = __w_pdfjs_require__(34); var global = __w_pdfjs_require__(11); var isObject = __w_pdfjs_require__(22); var createNonEnumerableProperty = __w_pdfjs_require__(26); var objectHas = __w_pdfjs_require__(23); var shared = __w_pdfjs_require__(32); var sharedKey = __w_pdfjs_require__(35); var hiddenKeys = __w_pdfjs_require__(39); var WeakMap = global.WeakMap; var set, get, has; var enforce = function (it) { return has(it) ? get(it) : set(it, {}); }; var getterFor = function (TYPE) { return function (it) { var state; if (!isObject(it) || (state = get(it)).type !== TYPE) { throw TypeError('Incompatible receiver, ' + TYPE + ' required'); } return state; }; }; if (NATIVE_WEAK_MAP) { var store = shared.state || (shared.state = new WeakMap()); var wmget = store.get; var wmhas = store.has; var wmset = store.set; set = function (it, metadata) { metadata.facade = it; wmset.call(store, it, metadata); return metadata; }; get = function (it) { return wmget.call(store, it) || {}; }; has = function (it) { return wmhas.call(store, it); }; } else { var STATE = sharedKey('state'); hiddenKeys[STATE] = true; set = function (it, metadata) { metadata.facade = it; createNonEnumerableProperty(it, STATE, metadata); return metadata; }; get = function (it) { return objectHas(it, STATE) ? it[STATE] : {}; }; has = function (it) { return objectHas(it, STATE); }; } module.exports = { set: set, get: get, has: has, enforce: enforce, getterFor: getterFor };
/***/ }),
/* 34 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var inspectSource = __w_pdfjs_require__(31); var WeakMap = global.WeakMap; module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));
/***/ }),
/* 35 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var shared = __w_pdfjs_require__(36); var uid = __w_pdfjs_require__(38); var keys = shared('keys'); module.exports = function (key) { return keys[key] || (keys[key] = uid(key)); };
/***/ }),
/* 36 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var IS_PURE = __w_pdfjs_require__(37); var store = __w_pdfjs_require__(32); (module.exports = function (key, value) { return store[key] || (store[key] = value !== undefined ? value : {}); })('versions', []).push({ version: '3.7.0', mode: IS_PURE ? 'pure' : 'global', copyright: ' 2020 Denis Pushkarev (zloirock.ru)' });
/***/ }),
/* 37 */
/***/ (function(module, exports) {
module.exports = false;
/***/ }),
/* 38 */
/***/ (function(module, exports) {
var id = 0; var postfix = Math.random(); module.exports = function (key) { return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36); };
/***/ }),
/* 39 */
/***/ (function(module, exports) {
module.exports = {};
/***/ }),
/* 40 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var has = __w_pdfjs_require__(23); var ownKeys = __w_pdfjs_require__(41); var getOwnPropertyDescriptorModule = __w_pdfjs_require__(12); var definePropertyModule = __w_pdfjs_require__(27); module.exports = function (target, source) { var keys = ownKeys(source); var defineProperty = definePropertyModule.f; var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f; for (var i = 0; i < keys.length; i++) { var key = keys[i]; if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key)); } };
/***/ }),
/* 41 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var getBuiltIn = __w_pdfjs_require__(42); var getOwnPropertyNamesModule = __w_pdfjs_require__(44); var getOwnPropertySymbolsModule = __w_pdfjs_require__(51); var anObject = __w_pdfjs_require__(28); module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) { var keys = getOwnPropertyNamesModule.f(anObject(it)); var getOwnPropertySymbols = getOwnPropertySymbolsModule.f; return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys; };
/***/ }),
/* 42 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var path = __w_pdfjs_require__(43); var global = __w_pdfjs_require__(11); var aFunction = function (variable) { return typeof variable == 'function' ? variable : undefined; }; module.exports = function (namespace, method) { return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace]) : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method]; };
/***/ }),
/* 43 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); module.exports = global;
/***/ }),
/* 44 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var internalObjectKeys = __w_pdfjs_require__(45); var enumBugKeys = __w_pdfjs_require__(50); var hiddenKeys = enumBugKeys.concat('length', 'prototype'); exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) { return internalObjectKeys(O, hiddenKeys); };
/***/ }),
/* 45 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var has = __w_pdfjs_require__(23); var toIndexedObject = __w_pdfjs_require__(17); var indexOf = __w_pdfjs_require__(46).indexOf; var hiddenKeys = __w_pdfjs_require__(39); module.exports = function (object, names) { var O = toIndexedObject(object); var i = 0; var result = []; var key; for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key); while (names.length > i) if (has(O, key = names[i++])) { ~indexOf(result, key) || result.push(key); } return result; };
/***/ }),
/* 46 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var toIndexedObject = __w_pdfjs_require__(17); var toLength = __w_pdfjs_require__(47); var toAbsoluteIndex = __w_pdfjs_require__(49); var createMethod = function (IS_INCLUDES) { return function ($this, el, fromIndex) { var O = toIndexedObject($this); var length = toLength(O.length); var index = toAbsoluteIndex(fromIndex, length); var value; if (IS_INCLUDES && el != el) while (length > index) { value = O[index++]; if (value != value) return true; } else for (; length > index; index++) { if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0; } return !IS_INCLUDES && -1; }; }; module.exports = { includes: createMethod(true), indexOf: createMethod(false) };
/***/ }),
/* 47 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var toInteger = __w_pdfjs_require__(48); var min = Math.min; module.exports = function (argument) { return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; };
/***/ }),
/* 48 */
/***/ (function(module, exports) {
var ceil = Math.ceil; var floor = Math.floor; module.exports = function (argument) { return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument); };
/***/ }),
/* 49 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var toInteger = __w_pdfjs_require__(48); var max = Math.max; var min = Math.min; module.exports = function (index, length) { var integer = toInteger(index); return integer < 0 ? max(integer + length, 0) : min(integer, length); };
/***/ }),
/* 50 */
/***/ (function(module, exports) {
module.exports = [ 'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'toLocaleString', 'toString', 'valueOf' ];
/***/ }),
/* 51 */
/***/ (function(module, exports) {
exports.f = Object.getOwnPropertySymbols;
/***/ }),
/* 52 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var fails = __w_pdfjs_require__(14); var replacement = /#|\.prototype\./; var isForced = function (feature, detection) { var value = data[normalize(feature)]; return value == POLYFILL ? true : value == NATIVE ? false : typeof detection == 'function' ? fails(detection) : !!detection; }; var normalize = isForced.normalize = function (string) { return String(string).replace(replacement, '.').toLowerCase(); }; var data = isForced.data = {}; var NATIVE = isForced.NATIVE = 'N'; var POLYFILL = isForced.POLYFILL = 'P'; module.exports = isForced;
/***/ }),
/* 53 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(54); var entryUnbind = __w_pdfjs_require__(61); module.exports = entryUnbind('String', 'startsWith');
/***/ }),
/* 54 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var getOwnPropertyDescriptor = __w_pdfjs_require__(12).f; var toLength = __w_pdfjs_require__(47); var notARegExp = __w_pdfjs_require__(55); var requireObjectCoercible = __w_pdfjs_require__(20); var correctIsRegExpLogic = __w_pdfjs_require__(60); var IS_PURE = __w_pdfjs_require__(37); var nativeStartsWith = ''.startsWith; var min = Math.min; var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith'); var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () { var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith'); return descriptor && !descriptor.writable; }(); $({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, { startsWith: function startsWith(searchString) { var that = String(requireObjectCoercible(this)); notARegExp(searchString); var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length)); var search = String(searchString); return nativeStartsWith ? nativeStartsWith.call(that, search, index) : that.slice(index, index + search.length) === search; } });
/***/ }),
/* 55 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var isRegExp = __w_pdfjs_require__(56); module.exports = function (it) { if (isRegExp(it)) { throw TypeError("The method doesn't accept regular expressions"); } return it; };
/***/ }),
/* 56 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var isObject = __w_pdfjs_require__(22); var classof = __w_pdfjs_require__(19); var wellKnownSymbol = __w_pdfjs_require__(57); var MATCH = wellKnownSymbol('match'); module.exports = function (it) { var isRegExp; return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp'); };
/***/ }),
/* 57 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var shared = __w_pdfjs_require__(36); var has = __w_pdfjs_require__(23); var uid = __w_pdfjs_require__(38); var NATIVE_SYMBOL = __w_pdfjs_require__(58); var USE_SYMBOL_AS_UID = __w_pdfjs_require__(59); var WellKnownSymbolsStore = shared('wks'); var Symbol = global.Symbol; var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid; module.exports = function (name) { if (!has(WellKnownSymbolsStore, name)) { if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name]; else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name); } return WellKnownSymbolsStore[name]; };
/***/ }),
/* 58 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var fails = __w_pdfjs_require__(14); module.exports = !!Object.getOwnPropertySymbols && !fails(function () { return !String(Symbol()); });
/***/ }),
/* 59 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var NATIVE_SYMBOL = __w_pdfjs_require__(58); module.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';
/***/ }),
/* 60 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var wellKnownSymbol = __w_pdfjs_require__(57); var MATCH = wellKnownSymbol('match'); module.exports = function (METHOD_NAME) { var regexp = /./; try { '/./'[METHOD_NAME](regexp); } catch (error1) { try { regexp[MATCH] = false; return '/./'[METHOD_NAME](regexp); } catch (error2) { } } return false; };
/***/ }),
/* 61 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var bind = __w_pdfjs_require__(62); var call = Function.call; module.exports = function (CONSTRUCTOR, METHOD, length) { return bind(call, global[CONSTRUCTOR].prototype[METHOD], length); };
/***/ }),
/* 62 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var aFunction = __w_pdfjs_require__(63); module.exports = function (fn, that, length) { aFunction(fn); if (that === undefined) return fn; switch (length) { case 0: return function () { return fn.call(that); }; case 1: return function (a) { return fn.call(that, a); }; case 2: return function (a, b) { return fn.call(that, a, b); }; case 3: return function (a, b, c) { return fn.call(that, a, b, c); }; } return function () { return fn.apply(that, arguments); }; };
/***/ }),
/* 63 */
/***/ (function(module, exports) {
module.exports = function (it) { if (typeof it != 'function') { throw TypeError(String(it) + ' is not a function'); } return it; };
/***/ }),
/* 64 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(65); var entryUnbind = __w_pdfjs_require__(61); module.exports = entryUnbind('String', 'endsWith');
/***/ }),
/* 65 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var getOwnPropertyDescriptor = __w_pdfjs_require__(12).f; var toLength = __w_pdfjs_require__(47); var notARegExp = __w_pdfjs_require__(55); var requireObjectCoercible = __w_pdfjs_require__(20); var correctIsRegExpLogic = __w_pdfjs_require__(60); var IS_PURE = __w_pdfjs_require__(37); var nativeEndsWith = ''.endsWith; var min = Math.min; var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith'); var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () { var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith'); return descriptor && !descriptor.writable; }(); $({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, { endsWith: function endsWith(searchString) { var that = String(requireObjectCoercible(this)); notARegExp(searchString); var endPosition = arguments.length > 1 ? arguments[1] : undefined; var len = toLength(that.length); var end = endPosition === undefined ? len : min(toLength(endPosition), len); var search = String(searchString); return nativeEndsWith ? nativeEndsWith.call(that, search, end) : that.slice(end - search.length, end) === search; } });
/***/ }),
/* 66 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(67); var entryUnbind = __w_pdfjs_require__(61); module.exports = entryUnbind('String', 'includes');
/***/ }),
/* 67 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var notARegExp = __w_pdfjs_require__(55); var requireObjectCoercible = __w_pdfjs_require__(20); var correctIsRegExpLogic = __w_pdfjs_require__(60); $({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, { includes: function includes(searchString) { return !!~String(requireObjectCoercible(this)).indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined); } });
/***/ }),
/* 68 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(69); var entryUnbind = __w_pdfjs_require__(61); module.exports = entryUnbind('Array', 'includes');
/***/ }),
/* 69 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var $includes = __w_pdfjs_require__(46).includes; var addToUnscopables = __w_pdfjs_require__(70); var arrayMethodUsesToLength = __w_pdfjs_require__(75); var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 }); $({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, { includes: function includes(el) { return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined); } }); addToUnscopables('includes');
/***/ }),
/* 70 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var wellKnownSymbol = __w_pdfjs_require__(57); var create = __w_pdfjs_require__(71); var definePropertyModule = __w_pdfjs_require__(27); var UNSCOPABLES = wellKnownSymbol('unscopables'); var ArrayPrototype = Array.prototype; if (ArrayPrototype[UNSCOPABLES] == undefined) { definePropertyModule.f(ArrayPrototype, UNSCOPABLES, { configurable: true, value: create(null) }); } module.exports = function (key) { ArrayPrototype[UNSCOPABLES][key] = true; };
/***/ }),
/* 71 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var anObject = __w_pdfjs_require__(28); var defineProperties = __w_pdfjs_require__(72); var enumBugKeys = __w_pdfjs_require__(50); var hiddenKeys = __w_pdfjs_require__(39); var html = __w_pdfjs_require__(74); var documentCreateElement = __w_pdfjs_require__(25); var sharedKey = __w_pdfjs_require__(35); var GT = '>'; var LT = '<'; var PROTOTYPE = 'prototype'; var SCRIPT = 'script'; var IE_PROTO = sharedKey('IE_PROTO'); var EmptyConstructor = function () { }; var scriptTag = function (content) { return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT; }; var NullProtoObjectViaActiveX = function (activeXDocument) { activeXDocument.write(scriptTag('')); activeXDocument.close(); var temp = activeXDocument.parentWindow.Object; activeXDocument = null; return temp; }; var NullProtoObjectViaIFrame = function () { var iframe = documentCreateElement('iframe'); var JS = 'java' + SCRIPT + ':'; var iframeDocument; iframe.style.display = 'none'; html.appendChild(iframe); iframe.src = String(JS); iframeDocument = iframe.contentWindow.document; iframeDocument.open(); iframeDocument.write(scriptTag('document.F=Object')); iframeDocument.close(); return iframeDocument.F; }; var activeXDocument; var NullProtoObject = function () { try { activeXDocument = document.domain && new ActiveXObject('htmlfile'); } catch (error) { } NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame(); var length = enumBugKeys.length; while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]]; return NullProtoObject(); }; hiddenKeys[IE_PROTO] = true; module.exports = Object.create || function create(O, Properties) { var result; if (O !== null) { EmptyConstructor[PROTOTYPE] = anObject(O); result = new EmptyConstructor(); EmptyConstructor[PROTOTYPE] = null; result[IE_PROTO] = O; } else result = NullProtoObject(); return Properties === undefined ? result : defineProperties(result, Properties); };
/***/ }),
/* 72 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var DESCRIPTORS = __w_pdfjs_require__(13); var definePropertyModule = __w_pdfjs_require__(27); var anObject = __w_pdfjs_require__(28); var objectKeys = __w_pdfjs_require__(73); module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) { anObject(O); var keys = objectKeys(Properties); var length = keys.length; var index = 0; var key; while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]); return O; };
/***/ }),
/* 73 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var internalObjectKeys = __w_pdfjs_require__(45); var enumBugKeys = __w_pdfjs_require__(50); module.exports = Object.keys || function keys(O) { return internalObjectKeys(O, enumBugKeys); };
/***/ }),
/* 74 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var getBuiltIn = __w_pdfjs_require__(42); module.exports = getBuiltIn('document', 'documentElement');
/***/ }),
/* 75 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var DESCRIPTORS = __w_pdfjs_require__(13); var fails = __w_pdfjs_require__(14); var has = __w_pdfjs_require__(23); var defineProperty = Object.defineProperty; var cache = {}; var thrower = function (it) { throw it; }; module.exports = function (METHOD_NAME, options) { if (has(cache, METHOD_NAME)) return cache[METHOD_NAME]; if (!options) options = {}; var method = [][METHOD_NAME]; var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false; var argument0 = has(options, 0) ? options[0] : thrower; var argument1 = has(options, 1) ? options[1] : undefined; return cache[METHOD_NAME] = !!method && !fails(function () { if (ACCESSORS && !DESCRIPTORS) return true; var O = { length: -1 }; if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower }); else O[1] = 1; method.call(O, argument0, argument1); }); };
/***/ }),
/* 76 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(77); __w_pdfjs_require__(89); var path = __w_pdfjs_require__(43); module.exports = path.Array.from;
/***/ }),
/* 77 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var charAt = __w_pdfjs_require__(78).charAt; var InternalStateModule = __w_pdfjs_require__(33); var defineIterator = __w_pdfjs_require__(79); var STRING_ITERATOR = 'String Iterator'; var setInternalState = InternalStateModule.set; var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR); defineIterator(String, 'String', function (iterated) { setInternalState(this, { type: STRING_ITERATOR, string: String(iterated), index: 0 }); }, function next() { var state = getInternalState(this); var string = state.string; var index = state.index; var point; if (index >= string.length) return { value: undefined, done: true }; point = charAt(string, index); state.index += point.length; return { value: point, done: false }; });
/***/ }),
/* 78 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var toInteger = __w_pdfjs_require__(48); var requireObjectCoercible = __w_pdfjs_require__(20); var createMethod = function (CONVERT_TO_STRING) { return function ($this, pos) { var S = String(requireObjectCoercible($this)); var position = toInteger(pos); var size = S.length; var first, second; if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined; first = S.charCodeAt(position);
return first < 0xD800 || first > 0xDBFF || position + 1 === size || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF ? CONVERT_TO_STRING ? S.charAt(position) : first : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
}; }; module.exports = { codeAt: createMethod(false), charAt: createMethod(true) };
/***/ }),
/* 79 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var createIteratorConstructor = __w_pdfjs_require__(80); var getPrototypeOf = __w_pdfjs_require__(82); var setPrototypeOf = __w_pdfjs_require__(87); var setToStringTag = __w_pdfjs_require__(85); var createNonEnumerableProperty = __w_pdfjs_require__(26); var redefine = __w_pdfjs_require__(29); var wellKnownSymbol = __w_pdfjs_require__(57); var IS_PURE = __w_pdfjs_require__(37); var Iterators = __w_pdfjs_require__(86); var IteratorsCore = __w_pdfjs_require__(81); var IteratorPrototype = IteratorsCore.IteratorPrototype; var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS; var ITERATOR = wellKnownSymbol('iterator'); var KEYS = 'keys'; var VALUES = 'values'; var ENTRIES = 'entries'; var returnThis = function () { return this; }; module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) { createIteratorConstructor(IteratorConstructor, NAME, next); var getIterationMethod = function (KIND) { if (KIND === DEFAULT && defaultIterator) return defaultIterator; if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND]; switch (KIND) { case KEYS: return function keys() { return new IteratorConstructor(this, KIND); }; case VALUES: return function values() { return new IteratorConstructor(this, KIND); }; case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); }; } return function () { return new IteratorConstructor(this); }; }; var TO_STRING_TAG = NAME + ' Iterator'; var INCORRECT_VALUES_NAME = false; var IterablePrototype = Iterable.prototype; var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype['@@iterator'] || DEFAULT && IterablePrototype[DEFAULT]; var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT); var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator; var CurrentIteratorPrototype, methods, KEY; if (anyNativeIterator) { CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable())); if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) { if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) { if (setPrototypeOf) { setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype); } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') { createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis); } } setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true); if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis; } } if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) { INCORRECT_VALUES_NAME = true; defaultIterator = function values() { return nativeIterator.call(this); }; } if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) { createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator); } Iterators[NAME] = defaultIterator; if (DEFAULT) { methods = { values: getIterationMethod(VALUES), keys: IS_SET ? defaultIterator : getIterationMethod(KEYS), entries: getIterationMethod(ENTRIES) }; if (FORCED) for (KEY in methods) { if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) { redefine(IterablePrototype, KEY, methods[KEY]); } } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods); } return methods; };
/***/ }),
/* 80 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var IteratorPrototype = __w_pdfjs_require__(81).IteratorPrototype; var create = __w_pdfjs_require__(71); var createPropertyDescriptor = __w_pdfjs_require__(16); var setToStringTag = __w_pdfjs_require__(85); var Iterators = __w_pdfjs_require__(86); var returnThis = function () { return this; }; module.exports = function (IteratorConstructor, NAME, next) { var TO_STRING_TAG = NAME + ' Iterator'; IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) }); setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true); Iterators[TO_STRING_TAG] = returnThis; return IteratorConstructor; };
/***/ }),
/* 81 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var getPrototypeOf = __w_pdfjs_require__(82); var createNonEnumerableProperty = __w_pdfjs_require__(26); var has = __w_pdfjs_require__(23); var wellKnownSymbol = __w_pdfjs_require__(57); var IS_PURE = __w_pdfjs_require__(37); var ITERATOR = wellKnownSymbol('iterator'); var BUGGY_SAFARI_ITERATORS = false; var returnThis = function () { return this; }; var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator; if ([].keys) { arrayIterator = [].keys(); if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true; else { PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator)); if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype; } } if (IteratorPrototype == undefined) IteratorPrototype = {}; if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) { createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis); } module.exports = { IteratorPrototype: IteratorPrototype, BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS };
/***/ }),
/* 82 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var has = __w_pdfjs_require__(23); var toObject = __w_pdfjs_require__(83); var sharedKey = __w_pdfjs_require__(35); var CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__(84); var IE_PROTO = sharedKey('IE_PROTO'); var ObjectPrototype = Object.prototype; module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) { O = toObject(O); if (has(O, IE_PROTO)) return O[IE_PROTO]; if (typeof O.constructor == 'function' && O instanceof O.constructor) { return O.constructor.prototype; } return O instanceof Object ? ObjectPrototype : null; };
/***/ }),
/* 83 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var requireObjectCoercible = __w_pdfjs_require__(20); module.exports = function (argument) { return Object(requireObjectCoercible(argument)); };
/***/ }),
/* 84 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var fails = __w_pdfjs_require__(14); module.exports = !fails(function () { function F() { } F.prototype.constructor = null; return Object.getPrototypeOf(new F()) !== F.prototype; });
/***/ }),
/* 85 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineProperty = __w_pdfjs_require__(27).f; var has = __w_pdfjs_require__(23); var wellKnownSymbol = __w_pdfjs_require__(57); var TO_STRING_TAG = wellKnownSymbol('toStringTag'); module.exports = function (it, TAG, STATIC) { if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) { defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG }); } };
/***/ }),
/* 86 */
/***/ (function(module, exports) {
module.exports = {};
/***/ }),
/* 87 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var anObject = __w_pdfjs_require__(28); var aPossiblePrototype = __w_pdfjs_require__(88); module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () { var CORRECT_SETTER = false; var test = {}; var setter; try { setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set; setter.call(test, []); CORRECT_SETTER = test instanceof Array; } catch (error) { } return function setPrototypeOf(O, proto) { anObject(O); aPossiblePrototype(proto); if (CORRECT_SETTER) setter.call(O, proto); else O.__proto__ = proto; return O; }; }() : undefined);
/***/ }),
/* 88 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var isObject = __w_pdfjs_require__(22); module.exports = function (it) { if (!isObject(it) && it !== null) { throw TypeError("Can't set " + String(it) + ' as a prototype'); } return it; };
/***/ }),
/* 89 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); var from = __w_pdfjs_require__(90); var checkCorrectnessOfIteration = __w_pdfjs_require__(98); var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) { Array.from(iterable); }); $({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, { from: from });
/***/ }),
/* 90 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var bind = __w_pdfjs_require__(62); var toObject = __w_pdfjs_require__(83); var callWithSafeIterationClosing = __w_pdfjs_require__(91); var isArrayIteratorMethod = __w_pdfjs_require__(93); var toLength = __w_pdfjs_require__(47); var createProperty = __w_pdfjs_require__(94); var getIteratorMethod = __w_pdfjs_require__(95); module.exports = function from(arrayLike) { var O = toObject(arrayLike); var C = typeof this == 'function' ? this : Array; var argumentsLength = arguments.length; var mapfn = argumentsLength > 1 ? arguments[1] : undefined; var mapping = mapfn !== undefined; var iteratorMethod = getIteratorMethod(O); var index = 0; var length, result, step, iterator, next, value; if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2); if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) { iterator = iteratorMethod.call(O); next = iterator.next; result = new C(); for (; !(step = next.call(iterator)).done; index++) { value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [ step.value, index ], true) : step.value; createProperty(result, index, value); } } else { length = toLength(O.length); result = new C(length); for (; length > index; index++) { value = mapping ? mapfn(O[index], index) : O[index]; createProperty(result, index, value); } } result.length = index; return result; };
/***/ }),
/* 91 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var anObject = __w_pdfjs_require__(28); var iteratorClose = __w_pdfjs_require__(92); module.exports = function (iterator, fn, value, ENTRIES) { try { return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value); } catch (error) { iteratorClose(iterator); throw error; } };
/***/ }),
/* 92 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var anObject = __w_pdfjs_require__(28); module.exports = function (iterator) { var returnMethod = iterator['return']; if (returnMethod !== undefined) { return anObject(returnMethod.call(iterator)).value; } };
/***/ }),
/* 93 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var wellKnownSymbol = __w_pdfjs_require__(57); var Iterators = __w_pdfjs_require__(86); var ITERATOR = wellKnownSymbol('iterator'); var ArrayPrototype = Array.prototype; module.exports = function (it) { return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it); };
/***/ }),
/* 94 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var toPrimitive = __w_pdfjs_require__(21); var definePropertyModule = __w_pdfjs_require__(27); var createPropertyDescriptor = __w_pdfjs_require__(16); module.exports = function (object, key, value) { var propertyKey = toPrimitive(key); if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value)); else object[propertyKey] = value; };
/***/ }),
/* 95 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var classof = __w_pdfjs_require__(96); var Iterators = __w_pdfjs_require__(86); var wellKnownSymbol = __w_pdfjs_require__(57); var ITERATOR = wellKnownSymbol('iterator'); module.exports = function (it) { if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)]; };
/***/ }),
/* 96 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(97); var classofRaw = __w_pdfjs_require__(19); var wellKnownSymbol = __w_pdfjs_require__(57); var TO_STRING_TAG = wellKnownSymbol('toStringTag'); var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments'; var tryGet = function (it, key) { try { return it[key]; } catch (error) { } }; module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) { var O, tag, result;
return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};
/***/ }),
/* 97 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var wellKnownSymbol = __w_pdfjs_require__(57); var TO_STRING_TAG = wellKnownSymbol('toStringTag'); var test = {}; test[TO_STRING_TAG] = 'z'; module.exports = String(test) === '[object z]';
/***/ }),
/* 98 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var wellKnownSymbol = __w_pdfjs_require__(57); var ITERATOR = wellKnownSymbol('iterator'); var SAFE_CLOSING = false; try { var called = 0; var iteratorWithReturn = { next: function () { return { done: !!called++ }; }, 'return': function () { SAFE_CLOSING = true; } }; iteratorWithReturn[ITERATOR] = function () { return this; }; Array.from(iteratorWithReturn, function () { throw 2; }); } catch (error) { } module.exports = function (exec, SKIP_CLOSING) { if (!SKIP_CLOSING && !SAFE_CLOSING) return false; var ITERATION_SUPPORT = false; try { var object = {}; object[ITERATOR] = function () { return { next: function () { return { done: ITERATION_SUPPORT = true }; } }; }; exec(object); } catch (error) { } return ITERATION_SUPPORT; };
/***/ }),
/* 99 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(100); var path = __w_pdfjs_require__(43); module.exports = path.Object.assign;
/***/ }),
/* 100 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); var assign = __w_pdfjs_require__(101); $({ target: 'Object', stat: true, forced: Object.assign !== assign }, { assign: assign });
/***/ }),
/* 101 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var DESCRIPTORS = __w_pdfjs_require__(13); var fails = __w_pdfjs_require__(14); var objectKeys = __w_pdfjs_require__(73); var getOwnPropertySymbolsModule = __w_pdfjs_require__(51); var propertyIsEnumerableModule = __w_pdfjs_require__(15); var toObject = __w_pdfjs_require__(83); var IndexedObject = __w_pdfjs_require__(18); var nativeAssign = Object.assign; var defineProperty = Object.defineProperty; module.exports = !nativeAssign || fails(function () { if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', { enumerable: true, get: function () { defineProperty(this, 'b', { value: 3, enumerable: false }); } }), { b: 2 })).b !== 1) return true; var A = {}; var B = {}; var symbol = Symbol(); var alphabet = 'abcdefghijklmnopqrst'; A[symbol] = 7; alphabet.split('').forEach(function (chr) { B[chr] = chr; }); return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet; }) ? function assign(target, source) { var T = toObject(target); var argumentsLength = arguments.length; var index = 1; var getOwnPropertySymbols = getOwnPropertySymbolsModule.f; var propertyIsEnumerable = propertyIsEnumerableModule.f; while (argumentsLength > index) { var S = IndexedObject(arguments[index++]); var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S); var length = keys.length; var j = 0; var key; while (length > j) { key = keys[j++]; if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key]; } } return T; } : nativeAssign;
/***/ }),
/* 102 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(103); var path = __w_pdfjs_require__(43); module.exports = path.Math.log2;
/***/ }),
/* 103 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); var log = Math.log; var LN2 = Math.LN2; $({ target: 'Math', stat: true }, { log2: function log2(x) { return log(x) / LN2; } });
/***/ }),
/* 104 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(105); var path = __w_pdfjs_require__(43); module.exports = path.Number.isNaN;
/***/ }),
/* 105 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); $({ target: 'Number', stat: true }, { isNaN: function isNaN(number) { return number != number; } });
/***/ }),
/* 106 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(107); var path = __w_pdfjs_require__(43); module.exports = path.Number.isInteger;
/***/ }),
/* 107 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); var isInteger = __w_pdfjs_require__(108); $({ target: 'Number', stat: true }, { isInteger: isInteger });
/***/ }),
/* 108 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var isObject = __w_pdfjs_require__(22); var floor = Math.floor; module.exports = function isInteger(it) { return !isObject(it) && isFinite(it) && floor(it) === it; };
/***/ }),
/* 109 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(110);
/***/ }),
/* 110 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var ArrayBufferViewCore = __w_pdfjs_require__(111); var speciesConstructor = __w_pdfjs_require__(113); var fails = __w_pdfjs_require__(14); var aTypedArray = ArrayBufferViewCore.aTypedArray; var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor; var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod; var $slice = [].slice; var FORCED = fails(function () { new Int8Array(1).slice(); }); exportTypedArrayMethod('slice', function slice(start, end) { var list = $slice.call(aTypedArray(this), start, end); var C = speciesConstructor(this, this.constructor); var index = 0; var length = list.length; var result = new (aTypedArrayConstructor(C))(length); while (length > index) result[index] = list[index++]; return result; }, FORCED);
/***/ }),
/* 111 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var NATIVE_ARRAY_BUFFER = __w_pdfjs_require__(112); var DESCRIPTORS = __w_pdfjs_require__(13); var global = __w_pdfjs_require__(11); var isObject = __w_pdfjs_require__(22); var has = __w_pdfjs_require__(23); var classof = __w_pdfjs_require__(96); var createNonEnumerableProperty = __w_pdfjs_require__(26); var redefine = __w_pdfjs_require__(29); var defineProperty = __w_pdfjs_require__(27).f; var getPrototypeOf = __w_pdfjs_require__(82); var setPrototypeOf = __w_pdfjs_require__(87); var wellKnownSymbol = __w_pdfjs_require__(57); var uid = __w_pdfjs_require__(38); var Int8Array = global.Int8Array; var Int8ArrayPrototype = Int8Array && Int8Array.prototype; var Uint8ClampedArray = global.Uint8ClampedArray; var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype; var TypedArray = Int8Array && getPrototypeOf(Int8Array); var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype); var ObjectPrototype = Object.prototype; var isPrototypeOf = ObjectPrototype.isPrototypeOf; var TO_STRING_TAG = wellKnownSymbol('toStringTag'); var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG'); var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera'; var TYPED_ARRAY_TAG_REQIRED = false; var NAME; var TypedArrayConstructorsList = { Int8Array: 1, Uint8Array: 1, Uint8ClampedArray: 1, Int16Array: 2, Uint16Array: 2, Int32Array: 4, Uint32Array: 4, Float32Array: 4, Float64Array: 8 }; var isView = function isView(it) { var klass = classof(it); return klass === 'DataView' || has(TypedArrayConstructorsList, klass); }; var isTypedArray = function (it) { return isObject(it) && has(TypedArrayConstructorsList, classof(it)); }; var aTypedArray = function (it) { if (isTypedArray(it)) return it; throw TypeError('Target is not a typed array'); }; var aTypedArrayConstructor = function (C) { if (setPrototypeOf) { if (isPrototypeOf.call(TypedArray, C)) return C; } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) { var TypedArrayConstructor = global[ARRAY]; if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) { return C; } } throw TypeError('Target is not a typed array constructor'); }; var exportTypedArrayMethod = function (KEY, property, forced) { if (!DESCRIPTORS) return; if (forced) for (var ARRAY in TypedArrayConstructorsList) { var TypedArrayConstructor = global[ARRAY]; if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) { delete TypedArrayConstructor.prototype[KEY]; } } if (!TypedArrayPrototype[KEY] || forced) { redefine(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property); } }; var exportTypedArrayStaticMethod = function (KEY, property, forced) { var ARRAY, TypedArrayConstructor; if (!DESCRIPTORS) return; if (setPrototypeOf) { if (forced) for (ARRAY in TypedArrayConstructorsList) { TypedArrayConstructor = global[ARRAY]; if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) { delete TypedArrayConstructor[KEY]; } } if (!TypedArray[KEY] || forced) { try { return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property); } catch (error) { } } else return; } for (ARRAY in TypedArrayConstructorsList) { TypedArrayConstructor = global[ARRAY]; if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) { redefine(TypedArrayConstructor, KEY, property); } } }; for (NAME in TypedArrayConstructorsList) { if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false; } if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) { TypedArray = function TypedArray() { throw TypeError('Incorrect invocation'); }; if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) { if (global[NAME]) setPrototypeOf(global[NAME], TypedArray); } } if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) { TypedArrayPrototype = TypedArray.prototype; if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) { if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype); } } if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) { setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype); } if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) { TYPED_ARRAY_TAG_REQIRED = true; defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () { return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined; } }); for (NAME in TypedArrayConstructorsList) if (global[NAME]) { createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME); } } module.exports = { NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS, TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG, aTypedArray: aTypedArray, aTypedArrayConstructor: aTypedArrayConstructor, exportTypedArrayMethod: exportTypedArrayMethod, exportTypedArrayStaticMethod: exportTypedArrayStaticMethod, isView: isView, isTypedArray: isTypedArray, TypedArray: TypedArray, TypedArrayPrototype: TypedArrayPrototype };
/***/ }),
/* 112 */
/***/ (function(module, exports) {
module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';
/***/ }),
/* 113 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var anObject = __w_pdfjs_require__(28); var aFunction = __w_pdfjs_require__(63); var wellKnownSymbol = __w_pdfjs_require__(57); var SPECIES = wellKnownSymbol('species'); module.exports = function (O, defaultConstructor) { var C = anObject(O).constructor; var S; return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S); };
/***/ }),
/* 114 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(115); __w_pdfjs_require__(117); __w_pdfjs_require__(119); __w_pdfjs_require__(134); __w_pdfjs_require__(135); __w_pdfjs_require__(136); __w_pdfjs_require__(77); __w_pdfjs_require__(137); var path = __w_pdfjs_require__(43); module.exports = path.Promise;
/***/ }),
/* 115 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var getPrototypeOf = __w_pdfjs_require__(82); var setPrototypeOf = __w_pdfjs_require__(87); var create = __w_pdfjs_require__(71); var createNonEnumerableProperty = __w_pdfjs_require__(26); var createPropertyDescriptor = __w_pdfjs_require__(16); var iterate = __w_pdfjs_require__(116); var $AggregateError = function AggregateError(errors, message) { var that = this; if (!(that instanceof $AggregateError)) return new $AggregateError(errors, message); if (setPrototypeOf) { that = setPrototypeOf(new Error(undefined), getPrototypeOf(that)); } if (message !== undefined) createNonEnumerableProperty(that, 'message', String(message)); var errorsArray = []; iterate(errors, errorsArray.push, { that: errorsArray }); createNonEnumerableProperty(that, 'errors', errorsArray); return that; }; $AggregateError.prototype = create(Error.prototype, { constructor: createPropertyDescriptor(5, $AggregateError), message: createPropertyDescriptor(5, ''), name: createPropertyDescriptor(5, 'AggregateError') }); $({ global: true }, { AggregateError: $AggregateError });
/***/ }),
/* 116 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var anObject = __w_pdfjs_require__(28); var isArrayIteratorMethod = __w_pdfjs_require__(93); var toLength = __w_pdfjs_require__(47); var bind = __w_pdfjs_require__(62); var getIteratorMethod = __w_pdfjs_require__(95); var iteratorClose = __w_pdfjs_require__(92); var Result = function (stopped, result) { this.stopped = stopped; this.result = result; }; module.exports = function (iterable, unboundFunction, options) { var that = options && options.that; var AS_ENTRIES = !!(options && options.AS_ENTRIES); var IS_ITERATOR = !!(options && options.IS_ITERATOR); var INTERRUPTED = !!(options && options.INTERRUPTED); var fn = bind(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED); var iterator, iterFn, index, length, result, next, step; var stop = function (condition) { if (iterator) iteratorClose(iterator); return new Result(true, condition); }; var callFn = function (value) { if (AS_ENTRIES) { anObject(value); return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]); } return INTERRUPTED ? fn(value, stop) : fn(value); }; if (IS_ITERATOR) { iterator = iterable; } else { iterFn = getIteratorMethod(iterable); if (typeof iterFn != 'function') throw TypeError('Target is not iterable'); if (isArrayIteratorMethod(iterFn)) { for (index = 0, length = toLength(iterable.length); length > index; index++) { result = callFn(iterable[index]); if (result && result instanceof Result) return result; } return new Result(false); } iterator = iterFn.call(iterable); } next = iterator.next; while (!(step = next.call(iterator)).done) { try { result = callFn(step.value); } catch (error) { iteratorClose(iterator); throw error; } if (typeof result == 'object' && result && result instanceof Result) return result; } return new Result(false); };
/***/ }),
/* 117 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(97); var redefine = __w_pdfjs_require__(29); var toString = __w_pdfjs_require__(118); if (!TO_STRING_TAG_SUPPORT) { redefine(Object.prototype, 'toString', toString, { unsafe: true }); }
/***/ }),
/* 118 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(97); var classof = __w_pdfjs_require__(96); module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() { return '[object ' + classof(this) + ']'; };
/***/ }),
/* 119 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var IS_PURE = __w_pdfjs_require__(37); var global = __w_pdfjs_require__(11); var getBuiltIn = __w_pdfjs_require__(42); var NativePromise = __w_pdfjs_require__(120); var redefine = __w_pdfjs_require__(29); var redefineAll = __w_pdfjs_require__(121); var setToStringTag = __w_pdfjs_require__(85); var setSpecies = __w_pdfjs_require__(122); var isObject = __w_pdfjs_require__(22); var aFunction = __w_pdfjs_require__(63); var anInstance = __w_pdfjs_require__(123); var inspectSource = __w_pdfjs_require__(31); var iterate = __w_pdfjs_require__(116); var checkCorrectnessOfIteration = __w_pdfjs_require__(98); var speciesConstructor = __w_pdfjs_require__(113); var task = __w_pdfjs_require__(124).set; var microtask = __w_pdfjs_require__(128); var promiseResolve = __w_pdfjs_require__(129); var hostReportErrors = __w_pdfjs_require__(131); var newPromiseCapabilityModule = __w_pdfjs_require__(130); var perform = __w_pdfjs_require__(132); var InternalStateModule = __w_pdfjs_require__(33); var isForced = __w_pdfjs_require__(52); var wellKnownSymbol = __w_pdfjs_require__(57); var IS_NODE = __w_pdfjs_require__(127); var V8_VERSION = __w_pdfjs_require__(133); var SPECIES = wellKnownSymbol('species'); var PROMISE = 'Promise'; var getInternalState = InternalStateModule.get; var setInternalState = InternalStateModule.set; var getInternalPromiseState = InternalStateModule.getterFor(PROMISE); var PromiseConstructor = NativePromise; var TypeError = global.TypeError; var document = global.document; var process = global.process; var $fetch = getBuiltIn('fetch'); var newPromiseCapability = newPromiseCapabilityModule.f; var newGenericPromiseCapability = newPromiseCapability; var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent); var NATIVE_REJECTION_EVENT = typeof PromiseRejectionEvent == 'function'; var UNHANDLED_REJECTION = 'unhandledrejection'; var REJECTION_HANDLED = 'rejectionhandled'; var PENDING = 0; var FULFILLED = 1; var REJECTED = 2; var HANDLED = 1; var UNHANDLED = 2; var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen; var FORCED = isForced(PROMISE, function () { var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor); if (!GLOBAL_CORE_JS_PROMISE) { if (V8_VERSION === 66) return true; if (!IS_NODE && !NATIVE_REJECTION_EVENT) return true; } if (IS_PURE && !PromiseConstructor.prototype['finally']) return true; if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false; var promise = PromiseConstructor.resolve(1); var FakePromise = function (exec) { exec(function () { }, function () { }); }; var constructor = promise.constructor = {}; constructor[SPECIES] = FakePromise; return !(promise.then(function () { }) instanceof FakePromise); }); var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) { PromiseConstructor.all(iterable)['catch'](function () { }); }); var isThenable = function (it) { var then; return isObject(it) && typeof (then = it.then) == 'function' ? then : false; }; var notify = function (state, isReject) { if (state.notified) return; state.notified = true; var chain = state.reactions; microtask(function () { var value = state.value; var ok = state.state == FULFILLED; var index = 0; while (chain.length > index) { var reaction = chain[index++]; var handler = ok ? reaction.ok : reaction.fail; var resolve = reaction.resolve; var reject = reaction.reject; var domain = reaction.domain; var result, then, exited; try { if (handler) { if (!ok) { if (state.rejection === UNHANDLED) onHandleUnhandled(state); state.rejection = HANDLED; } if (handler === true) result = value; else { if (domain) domain.enter(); result = handler(value); if (domain) { domain.exit(); exited = true; } } if (result === reaction.promise) { reject(TypeError('Promise-chain cycle')); } else if (then = isThenable(result)) { then.call(result, resolve, reject); } else resolve(result); } else reject(value); } catch (error) { if (domain && !exited) domain.exit(); reject(error); } } state.reactions = []; state.notified = false; if (isReject && !state.rejection) onUnhandled(state); }); }; var dispatchEvent = function (name, promise, reason) { var event, handler; if (DISPATCH_EVENT) { event = document.createEvent('Event'); event.promise = promise; event.reason = reason; event.initEvent(name, false, true); global.dispatchEvent(event); } else event = { promise: promise, reason: reason }; if (!NATIVE_REJECTION_EVENT && (handler = global['on' + name])) handler(event); else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason); }; var onUnhandled = function (state) { task.call(global, function () { var promise = state.facade; var value = state.value; var IS_UNHANDLED = isUnhandled(state); var result; if (IS_UNHANDLED) { result = perform(function () { if (IS_NODE) { process.emit('unhandledRejection', value, promise); } else dispatchEvent(UNHANDLED_REJECTION, promise, value); }); state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED; if (result.error) throw result.value; } }); }; var isUnhandled = function (state) { return state.rejection !== HANDLED && !state.parent; }; var onHandleUnhandled = function (state) { task.call(global, function () { var promise = state.facade; if (IS_NODE) { process.emit('rejectionHandled', promise); } else dispatchEvent(REJECTION_HANDLED, promise, state.value); }); }; var bind = function (fn, state, unwrap) { return function (value) { fn(state, value, unwrap); }; }; var internalReject = function (state, value, unwrap) { if (state.done) return; state.done = true; if (unwrap) state = unwrap; state.value = value; state.state = REJECTED; notify(state, true); }; var internalResolve = function (state, value, unwrap) { if (state.done) return; state.done = true; if (unwrap) state = unwrap; try { if (state.facade === value) throw TypeError("Promise can't be resolved itself"); var then = isThenable(value); if (then) { microtask(function () { var wrapper = { done: false }; try { then.call(value, bind(internalResolve, wrapper, state), bind(internalReject, wrapper, state)); } catch (error) { internalReject(wrapper, error, state); } }); } else { state.value = value; state.state = FULFILLED; notify(state, false); } } catch (error) { internalReject({ done: false }, error, state); } }; if (FORCED) { PromiseConstructor = function Promise(executor) { anInstance(this, PromiseConstructor, PROMISE); aFunction(executor); Internal.call(this); var state = getInternalState(this); try { executor(bind(internalResolve, state), bind(internalReject, state)); } catch (error) { internalReject(state, error); } }; Internal = function Promise(executor) { setInternalState(this, { type: PROMISE, done: false, notified: false, parent: false, reactions: [], rejection: false, state: PENDING, value: undefined }); }; Internal.prototype = redefineAll(PromiseConstructor.prototype, { then: function then(onFulfilled, onRejected) { var state = getInternalPromiseState(this); var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor)); reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true; reaction.fail = typeof onRejected == 'function' && onRejected; reaction.domain = IS_NODE ? process.domain : undefined; state.parent = true; state.reactions.push(reaction); if (state.state != PENDING) notify(state, false); return reaction.promise; }, 'catch': function (onRejected) { return this.then(undefined, onRejected); } }); OwnPromiseCapability = function () { var promise = new Internal(); var state = getInternalState(promise); this.promise = promise; this.resolve = bind(internalResolve, state); this.reject = bind(internalReject, state); }; newPromiseCapabilityModule.f = newPromiseCapability = function (C) { return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C); }; if (!IS_PURE && typeof NativePromise == 'function') { nativeThen = NativePromise.prototype.then; redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) { var that = this; return new PromiseConstructor(function (resolve, reject) { nativeThen.call(that, resolve, reject); }).then(onFulfilled, onRejected); }, { unsafe: true }); if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, { fetch: function fetch(input) { return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments)); } }); } } $({ global: true, wrap: true, forced: FORCED }, { Promise: PromiseConstructor }); setToStringTag(PromiseConstructor, PROMISE, false, true); setSpecies(PROMISE); PromiseWrapper = getBuiltIn(PROMISE); $({ target: PROMISE, stat: true, forced: FORCED }, { reject: function reject(r) { var capability = newPromiseCapability(this); capability.reject.call(undefined, r); return capability.promise; } }); $({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, { resolve: function resolve(x) { return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x); } }); $({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, { all: function all(iterable) { var C = this; var capability = newPromiseCapability(C); var resolve = capability.resolve; var reject = capability.reject; var result = perform(function () { var $promiseResolve = aFunction(C.resolve); var values = []; var counter = 0; var remaining = 1; iterate(iterable, function (promise) { var index = counter++; var alreadyCalled = false; values.push(undefined); remaining++; $promiseResolve.call(C, promise).then(function (value) { if (alreadyCalled) return; alreadyCalled = true; values[index] = value; --remaining || resolve(values); }, reject); }); --remaining || resolve(values); }); if (result.error) reject(result.value); return capability.promise; }, race: function race(iterable) { var C = this; var capability = newPromiseCapability(C); var reject = capability.reject; var result = perform(function () { var $promiseResolve = aFunction(C.resolve); iterate(iterable, function (promise) { $promiseResolve.call(C, promise).then(capability.resolve, reject); }); }); if (result.error) reject(result.value); return capability.promise; } });
/***/ }),
/* 120 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); module.exports = global.Promise;
/***/ }),
/* 121 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var redefine = __w_pdfjs_require__(29); module.exports = function (target, src, options) { for (var key in src) redefine(target, key, src[key], options); return target; };
/***/ }),
/* 122 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var getBuiltIn = __w_pdfjs_require__(42); var definePropertyModule = __w_pdfjs_require__(27); var wellKnownSymbol = __w_pdfjs_require__(57); var DESCRIPTORS = __w_pdfjs_require__(13); var SPECIES = wellKnownSymbol('species'); module.exports = function (CONSTRUCTOR_NAME) { var Constructor = getBuiltIn(CONSTRUCTOR_NAME); var defineProperty = definePropertyModule.f; if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) { defineProperty(Constructor, SPECIES, { configurable: true, get: function () { return this; } }); } };
/***/ }),
/* 123 */
/***/ (function(module, exports) {
module.exports = function (it, Constructor, name) { if (!(it instanceof Constructor)) { throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation'); } return it; };
/***/ }),
/* 124 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var fails = __w_pdfjs_require__(14); var bind = __w_pdfjs_require__(62); var html = __w_pdfjs_require__(74); var createElement = __w_pdfjs_require__(25); var IS_IOS = __w_pdfjs_require__(125); var IS_NODE = __w_pdfjs_require__(127); var location = global.location; var set = global.setImmediate; var clear = global.clearImmediate; var process = global.process; var MessageChannel = global.MessageChannel; var Dispatch = global.Dispatch; var counter = 0; var queue = {}; var ONREADYSTATECHANGE = 'onreadystatechange'; var defer, channel, port; var run = function (id) { if (queue.hasOwnProperty(id)) { var fn = queue[id]; delete queue[id]; fn(); } }; var runner = function (id) { return function () { run(id); }; }; var listener = function (event) { run(event.data); }; var post = function (id) {
global.postMessage(id + '', location.protocol + '//' + location.host);
}; if (!set || !clear) { set = function setImmediate(fn) { var args = []; var i = 1; while (arguments.length > i) args.push(arguments[i++]); queue[++counter] = function () { (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args); }; defer(counter); return counter; }; clear = function clearImmediate(id) { delete queue[id]; }; if (IS_NODE) { defer = function (id) { process.nextTick(runner(id)); }; } else if (Dispatch && Dispatch.now) { defer = function (id) { Dispatch.now(runner(id)); }; } else if (MessageChannel && !IS_IOS) { channel = new MessageChannel(); port = channel.port2; channel.port1.onmessage = listener; defer = bind(port.postMessage, port, 1); } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && location && location.protocol !== 'file:' && !fails(post)) { defer = post; global.addEventListener('message', listener, false); } else if (ONREADYSTATECHANGE in createElement('script')) { defer = function (id) { html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () { html.removeChild(this); run(id); }; }; } else { defer = function (id) { setTimeout(runner(id), 0); }; } } module.exports = { set: set, clear: clear };
/***/ }),
/* 125 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var userAgent = __w_pdfjs_require__(126); module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);
/***/ }),
/* 126 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var getBuiltIn = __w_pdfjs_require__(42); module.exports = getBuiltIn('navigator', 'userAgent') || '';
/***/ }),
/* 127 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var classof = __w_pdfjs_require__(19); var global = __w_pdfjs_require__(11); module.exports = classof(global.process) == 'process';
/***/ }),
/* 128 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var getOwnPropertyDescriptor = __w_pdfjs_require__(12).f; var macrotask = __w_pdfjs_require__(124).set; var IS_IOS = __w_pdfjs_require__(125); var IS_NODE = __w_pdfjs_require__(127); var MutationObserver = global.MutationObserver || global.WebKitMutationObserver; var document = global.document; var process = global.process; var Promise = global.Promise; var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask'); var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value; var flush, head, last, notify, toggle, node, promise, then; if (!queueMicrotask) { flush = function () { var parent, fn; if (IS_NODE && (parent = process.domain)) parent.exit(); while (head) { fn = head.fn; head = head.next; try { fn(); } catch (error) { if (head) notify(); else last = undefined; throw error; } } last = undefined; if (parent) parent.enter(); }; if (!IS_IOS && !IS_NODE && MutationObserver && document) { toggle = true; node = document.createTextNode(''); new MutationObserver(flush).observe(node, { characterData: true }); notify = function () { node.data = toggle = !toggle; }; } else if (Promise && Promise.resolve) { promise = Promise.resolve(undefined); then = promise.then; notify = function () { then.call(promise, flush); }; } else if (IS_NODE) { notify = function () { process.nextTick(flush); }; } else { notify = function () { macrotask.call(global, flush); }; } } module.exports = queueMicrotask || function (fn) { var task = { fn: fn, next: undefined }; if (last) last.next = task; if (!head) { head = task; notify(); } last = task; };
/***/ }),
/* 129 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var anObject = __w_pdfjs_require__(28); var isObject = __w_pdfjs_require__(22); var newPromiseCapability = __w_pdfjs_require__(130); module.exports = function (C, x) { anObject(C); if (isObject(x) && x.constructor === C) return x; var promiseCapability = newPromiseCapability.f(C); var resolve = promiseCapability.resolve; resolve(x); return promiseCapability.promise; };
/***/ }),
/* 130 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var aFunction = __w_pdfjs_require__(63); var PromiseCapability = function (C) { var resolve, reject; this.promise = new C(function ($$resolve, $$reject) { if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor'); resolve = $$resolve; reject = $$reject; }); this.resolve = aFunction(resolve); this.reject = aFunction(reject); }; module.exports.f = function (C) { return new PromiseCapability(C); };
/***/ }),
/* 131 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); module.exports = function (a, b) { var console = global.console; if (console && console.error) { arguments.length === 1 ? console.error(a) : console.error(a, b); } };
/***/ }),
/* 132 */
/***/ (function(module, exports) {
module.exports = function (exec) { try { return { error: false, value: exec() }; } catch (error) { return { error: true, value: error }; } };
/***/ }),
/* 133 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var userAgent = __w_pdfjs_require__(126); var process = global.process; var versions = process && process.versions; var v8 = versions && versions.v8; var match, version; if (v8) { match = v8.split('.'); version = match[0] + match[1]; } else if (userAgent) { match = userAgent.match(/Edge\/(\d+)/); if (!match || match[1] >= 74) { match = userAgent.match(/Chrome\/(\d+)/); if (match) version = match[1]; } } module.exports = version && +version;
/***/ }),
/* 134 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var aFunction = __w_pdfjs_require__(63); var newPromiseCapabilityModule = __w_pdfjs_require__(130); var perform = __w_pdfjs_require__(132); var iterate = __w_pdfjs_require__(116); $({ target: 'Promise', stat: true }, { allSettled: function allSettled(iterable) { var C = this; var capability = newPromiseCapabilityModule.f(C); var resolve = capability.resolve; var reject = capability.reject; var result = perform(function () { var promiseResolve = aFunction(C.resolve); var values = []; var counter = 0; var remaining = 1; iterate(iterable, function (promise) { var index = counter++; var alreadyCalled = false; values.push(undefined); remaining++; promiseResolve.call(C, promise).then(function (value) { if (alreadyCalled) return; alreadyCalled = true; values[index] = { status: 'fulfilled', value: value }; --remaining || resolve(values); }, function (error) { if (alreadyCalled) return; alreadyCalled = true; values[index] = { status: 'rejected', reason: error }; --remaining || resolve(values); }); }); --remaining || resolve(values); }); if (result.error) reject(result.value); return capability.promise; } });
/***/ }),
/* 135 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var aFunction = __w_pdfjs_require__(63); var getBuiltIn = __w_pdfjs_require__(42); var newPromiseCapabilityModule = __w_pdfjs_require__(130); var perform = __w_pdfjs_require__(132); var iterate = __w_pdfjs_require__(116); var PROMISE_ANY_ERROR = 'No one promise resolved'; $({ target: 'Promise', stat: true }, { any: function any(iterable) { var C = this; var capability = newPromiseCapabilityModule.f(C); var resolve = capability.resolve; var reject = capability.reject; var result = perform(function () { var promiseResolve = aFunction(C.resolve); var errors = []; var counter = 0; var remaining = 1; var alreadyResolved = false; iterate(iterable, function (promise) { var index = counter++; var alreadyRejected = false; errors.push(undefined); remaining++; promiseResolve.call(C, promise).then(function (value) { if (alreadyRejected || alreadyResolved) return; alreadyResolved = true; resolve(value); }, function (error) { if (alreadyRejected || alreadyResolved) return; alreadyRejected = true; errors[index] = error; --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR)); }); }); --remaining || reject(new (getBuiltIn('AggregateError'))(errors, PROMISE_ANY_ERROR)); }); if (result.error) reject(result.value); return capability.promise; } });
/***/ }),
/* 136 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var IS_PURE = __w_pdfjs_require__(37); var NativePromise = __w_pdfjs_require__(120); var fails = __w_pdfjs_require__(14); var getBuiltIn = __w_pdfjs_require__(42); var speciesConstructor = __w_pdfjs_require__(113); var promiseResolve = __w_pdfjs_require__(129); var redefine = __w_pdfjs_require__(29); var NON_GENERIC = !!NativePromise && fails(function () { NativePromise.prototype['finally'].call({ then: function () { } }, function () { }); }); $({ target: 'Promise', proto: true, real: true, forced: NON_GENERIC }, { 'finally': function (onFinally) { var C = speciesConstructor(this, getBuiltIn('Promise')); var isFunction = typeof onFinally == 'function'; return this.then(isFunction ? function (x) { return promiseResolve(C, onFinally()).then(function () { return x; }); } : onFinally, isFunction ? function (e) { return promiseResolve(C, onFinally()).then(function () { throw e; }); } : onFinally); } }); if (!IS_PURE && typeof NativePromise == 'function' && !NativePromise.prototype['finally']) { redefine(NativePromise.prototype, 'finally', getBuiltIn('Promise').prototype['finally']); }
/***/ }),
/* 137 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var DOMIterables = __w_pdfjs_require__(138); var ArrayIteratorMethods = __w_pdfjs_require__(139); var createNonEnumerableProperty = __w_pdfjs_require__(26); var wellKnownSymbol = __w_pdfjs_require__(57); var ITERATOR = wellKnownSymbol('iterator'); var TO_STRING_TAG = wellKnownSymbol('toStringTag'); var ArrayValues = ArrayIteratorMethods.values; for (var COLLECTION_NAME in DOMIterables) { var Collection = global[COLLECTION_NAME]; var CollectionPrototype = Collection && Collection.prototype; if (CollectionPrototype) { if (CollectionPrototype[ITERATOR] !== ArrayValues) try { createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues); } catch (error) { CollectionPrototype[ITERATOR] = ArrayValues; } if (!CollectionPrototype[TO_STRING_TAG]) { createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME); } if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) { if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try { createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]); } catch (error) { CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME]; } } } }
/***/ }),
/* 138 */
/***/ (function(module, exports) {
module.exports = { CSSRuleList: 0, CSSStyleDeclaration: 0, CSSValueList: 0, ClientRectList: 0, DOMRectList: 0, DOMStringList: 0, DOMTokenList: 1, DataTransferItemList: 0, FileList: 0, HTMLAllCollection: 0, HTMLCollection: 0, HTMLFormElement: 0, HTMLSelectElement: 0, MediaList: 0, MimeTypeArray: 0, NamedNodeMap: 0, NodeList: 1, PaintRequestList: 0, Plugin: 0, PluginArray: 0, SVGLengthList: 0, SVGNumberList: 0, SVGPathSegList: 0, SVGPointList: 0, SVGStringList: 0, SVGTransformList: 0, SourceBufferList: 0, StyleSheetList: 0, TextTrackCueList: 0, TextTrackList: 0, TouchList: 0 };
/***/ }),
/* 139 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var toIndexedObject = __w_pdfjs_require__(17); var addToUnscopables = __w_pdfjs_require__(70); var Iterators = __w_pdfjs_require__(86); var InternalStateModule = __w_pdfjs_require__(33); var defineIterator = __w_pdfjs_require__(79); var ARRAY_ITERATOR = 'Array Iterator'; var setInternalState = InternalStateModule.set; var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR); module.exports = defineIterator(Array, 'Array', function (iterated, kind) { setInternalState(this, { type: ARRAY_ITERATOR, target: toIndexedObject(iterated), index: 0, kind: kind }); }, function () { var state = getInternalState(this); var target = state.target; var kind = state.kind; var index = state.index++; if (!target || index >= target.length) { state.target = undefined; return { value: undefined, done: true }; } if (kind == 'keys') return { value: index, done: false }; if (kind == 'values') return { value: target[index], done: false }; return { value: [ index, target[index] ], done: false }; }, 'values'); Iterators.Arguments = Iterators.Array; addToUnscopables('keys'); addToUnscopables('values'); addToUnscopables('entries');
/***/ }),
/* 140 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(141); __w_pdfjs_require__(146); __w_pdfjs_require__(144); var path = __w_pdfjs_require__(43); module.exports = path.URL;
/***/ }),
/* 141 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; __w_pdfjs_require__(77); var $ = __w_pdfjs_require__(10); var DESCRIPTORS = __w_pdfjs_require__(13); var USE_NATIVE_URL = __w_pdfjs_require__(142); var global = __w_pdfjs_require__(11); var defineProperties = __w_pdfjs_require__(72); var redefine = __w_pdfjs_require__(29); var anInstance = __w_pdfjs_require__(123); var has = __w_pdfjs_require__(23); var assign = __w_pdfjs_require__(101); var arrayFrom = __w_pdfjs_require__(90); var codeAt = __w_pdfjs_require__(78).codeAt; var toASCII = __w_pdfjs_require__(143); var setToStringTag = __w_pdfjs_require__(85); var URLSearchParamsModule = __w_pdfjs_require__(144); var InternalStateModule = __w_pdfjs_require__(33); var NativeURL = global.URL; var URLSearchParams = URLSearchParamsModule.URLSearchParams; var getInternalSearchParamsState = URLSearchParamsModule.getState; var setInternalState = InternalStateModule.set; var getInternalURLState = InternalStateModule.getterFor('URL'); var floor = Math.floor; var pow = Math.pow; var INVALID_AUTHORITY = 'Invalid authority'; var INVALID_SCHEME = 'Invalid scheme'; var INVALID_HOST = 'Invalid host'; var INVALID_PORT = 'Invalid port'; var ALPHA = /[A-Za-z]/; var ALPHANUMERIC = /[\d+-.A-Za-z]/; var DIGIT = /\d/; var HEX_START = /^(0x|0X)/; var OCT = /^[0-7]+$/; var DEC = /^\d+$/; var HEX = /^[\dA-Fa-f]+$/; var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/; var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/; var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g; var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g; var EOF; var parseHost = function (url, input) { var result, codePoints, index; if (input.charAt(0) == '[') { if (input.charAt(input.length - 1) != ']') return INVALID_HOST; result = parseIPv6(input.slice(1, -1)); if (!result) return INVALID_HOST; url.host = result; } else if (!isSpecial(url)) { if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST; result = ''; codePoints = arrayFrom(input); for (index = 0; index < codePoints.length; index++) { result += percentEncode(codePoints[index], C0ControlPercentEncodeSet); } url.host = result; } else { input = toASCII(input); if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST; result = parseIPv4(input); if (result === null) return INVALID_HOST; url.host = result; } }; var parseIPv4 = function (input) { var parts = input.split('.'); var partsLength, numbers, index, part, radix, number, ipv4; if (parts.length && parts[parts.length - 1] == '') { parts.pop(); } partsLength = parts.length; if (partsLength > 4) return input; numbers = []; for (index = 0; index < partsLength; index++) { part = parts[index]; if (part == '') return input; radix = 10; if (part.length > 1 && part.charAt(0) == '0') { radix = HEX_START.test(part) ? 16 : 8; part = part.slice(radix == 8 ? 1 : 2); } if (part === '') { number = 0; } else { if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input; number = parseInt(part, radix); } numbers.push(number); } for (index = 0; index < partsLength; index++) { number = numbers[index]; if (index == partsLength - 1) { if (number >= pow(256, 5 - partsLength)) return null; } else if (number > 255) return null; } ipv4 = numbers.pop(); for (index = 0; index < numbers.length; index++) { ipv4 += numbers[index] * pow(256, 3 - index); } return ipv4; }; var parseIPv6 = function (input) { var address = [ 0, 0, 0, 0, 0, 0, 0, 0 ]; var pieceIndex = 0; var compress = null; var pointer = 0; var value, length, numbersSeen, ipv4Piece, number, swaps, swap; var char = function () { return input.charAt(pointer); }; if (char() == ':') { if (input.charAt(1) != ':') return; pointer += 2; pieceIndex++; compress = pieceIndex; } while (char()) { if (pieceIndex == 8) return; if (char() == ':') { if (compress !== null) return; pointer++; pieceIndex++; compress = pieceIndex; continue; } value = length = 0; while (length < 4 && HEX.test(char())) { value = value * 16 + parseInt(char(), 16); pointer++; length++; } if (char() == '.') { if (length == 0) return; pointer -= length; if (pieceIndex > 6) return; numbersSeen = 0; while (char()) { ipv4Piece = null; if (numbersSeen > 0) { if (char() == '.' && numbersSeen < 4) pointer++; else return; } if (!DIGIT.test(char())) return; while (DIGIT.test(char())) { number = parseInt(char(), 10); if (ipv4Piece === null) ipv4Piece = number; else if (ipv4Piece == 0) return; else ipv4Piece = ipv4Piece * 10 + number; if (ipv4Piece > 255) return; pointer++; } address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece; numbersSeen++; if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++; } if (numbersSeen != 4) return; break; } else if (char() == ':') { pointer++; if (!char()) return; } else if (char()) return; address[pieceIndex++] = value; } if (compress !== null) { swaps = pieceIndex - compress; pieceIndex = 7; while (pieceIndex != 0 && swaps > 0) { swap = address[pieceIndex]; address[pieceIndex--] = address[compress + swaps - 1]; address[compress + --swaps] = swap; } } else if (pieceIndex != 8) return; return address; }; var findLongestZeroSequence = function (ipv6) { var maxIndex = null; var maxLength = 1; var currStart = null; var currLength = 0; var index = 0; for (; index < 8; index++) { if (ipv6[index] !== 0) { if (currLength > maxLength) { maxIndex = currStart; maxLength = currLength; } currStart = null; currLength = 0; } else { if (currStart === null) currStart = index; ++currLength; } } if (currLength > maxLength) { maxIndex = currStart; maxLength = currLength; } return maxIndex; }; var serializeHost = function (host) { var result, index, compress, ignore0; if (typeof host == 'number') { result = []; for (index = 0; index < 4; index++) { result.unshift(host % 256); host = floor(host / 256); } return result.join('.'); } else if (typeof host == 'object') { result = ''; compress = findLongestZeroSequence(host); for (index = 0; index < 8; index++) { if (ignore0 && host[index] === 0) continue; if (ignore0) ignore0 = false; if (compress === index) { result += index ? ':' : '::'; ignore0 = true; } else { result += host[index].toString(16); if (index < 7) result += ':'; } } return '[' + result + ']'; } return host; }; var C0ControlPercentEncodeSet = {}; var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, { ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1 }); var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, { '#': 1, '?': 1, '{': 1, '}': 1 }); var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, { '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1 }); var percentEncode = function (char, set) { var code = codeAt(char, 0); return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char); }; var specialSchemes = { ftp: 21, file: null, http: 80, https: 443, ws: 80, wss: 443 }; var isSpecial = function (url) { return has(specialSchemes, url.scheme); }; var includesCredentials = function (url) { return url.username != '' || url.password != ''; }; var cannotHaveUsernamePasswordPort = function (url) { return !url.host || url.cannotBeABaseURL || url.scheme == 'file'; }; var isWindowsDriveLetter = function (string, normalized) { var second; return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ':' || !normalized && second == '|'); }; var startsWithWindowsDriveLetter = function (string) { var third; return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')); }; var shortenURLsPath = function (url) { var path = url.path; var pathSize = path.length; if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) { path.pop(); } }; var isSingleDot = function (segment) { return segment === '.' || segment.toLowerCase() === '%2e'; }; var isDoubleDot = function (segment) { segment = segment.toLowerCase(); return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e'; }; var SCHEME_START = {}; var SCHEME = {}; var NO_SCHEME = {}; var SPECIAL_RELATIVE_OR_AUTHORITY = {}; var PATH_OR_AUTHORITY = {}; var RELATIVE = {}; var RELATIVE_SLASH = {}; var SPECIAL_AUTHORITY_SLASHES = {}; var SPECIAL_AUTHORITY_IGNORE_SLASHES = {}; var AUTHORITY = {}; var HOST = {}; var HOSTNAME = {}; var PORT = {}; var FILE = {}; var FILE_SLASH = {}; var FILE_HOST = {}; var PATH_START = {}; var PATH = {}; var CANNOT_BE_A_BASE_URL_PATH = {}; var QUERY = {}; var FRAGMENT = {}; var parseURL = function (url, input, stateOverride, base) { var state = stateOverride || SCHEME_START; var pointer = 0; var buffer = ''; var seenAt = false; var seenBracket = false; var seenPasswordToken = false; var codePoints, char, bufferCodePoints, failure; if (!stateOverride) { url.scheme = ''; url.username = ''; url.password = ''; url.host = null; url.port = null; url.path = []; url.query = null; url.fragment = null; url.cannotBeABaseURL = false; input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, ''); } input = input.replace(TAB_AND_NEW_LINE, ''); codePoints = arrayFrom(input); while (pointer <= codePoints.length) { char = codePoints[pointer]; switch (state) { case SCHEME_START: if (char && ALPHA.test(char)) { buffer += char.toLowerCase(); state = SCHEME; } else if (!stateOverride) { state = NO_SCHEME; continue; } else return INVALID_SCHEME; break; case SCHEME: if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) { buffer += char.toLowerCase(); } else if (char == ':') { if (stateOverride && (isSpecial(url) != has(specialSchemes, buffer) || buffer == 'file' && (includesCredentials(url) || url.port !== null) || url.scheme == 'file' && !url.host)) return; url.scheme = buffer; if (stateOverride) { if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null; return; } buffer = ''; if (url.scheme == 'file') { state = FILE; } else if (isSpecial(url) && base && base.scheme == url.scheme) { state = SPECIAL_RELATIVE_OR_AUTHORITY; } else if (isSpecial(url)) { state = SPECIAL_AUTHORITY_SLASHES; } else if (codePoints[pointer + 1] == '/') { state = PATH_OR_AUTHORITY; pointer++; } else { url.cannotBeABaseURL = true; url.path.push(''); state = CANNOT_BE_A_BASE_URL_PATH; } } else if (!stateOverride) { buffer = ''; state = NO_SCHEME; pointer = 0; continue; } else return INVALID_SCHEME; break; case NO_SCHEME: if (!base || base.cannotBeABaseURL && char != '#') return INVALID_SCHEME; if (base.cannotBeABaseURL && char == '#') { url.scheme = base.scheme; url.path = base.path.slice(); url.query = base.query; url.fragment = ''; url.cannotBeABaseURL = true; state = FRAGMENT; break; } state = base.scheme == 'file' ? FILE : RELATIVE; continue; case SPECIAL_RELATIVE_OR_AUTHORITY: if (char == '/' && codePoints[pointer + 1] == '/') { state = SPECIAL_AUTHORITY_IGNORE_SLASHES; pointer++; } else { state = RELATIVE; continue; } break; case PATH_OR_AUTHORITY: if (char == '/') { state = AUTHORITY; break; } else { state = PATH; continue; } case RELATIVE: url.scheme = base.scheme; if (char == EOF) { url.username = base.username; url.password = base.password; url.host = base.host; url.port = base.port; url.path = base.path.slice(); url.query = base.query; } else if (char == '/' || char == '\\' && isSpecial(url)) { state = RELATIVE_SLASH; } else if (char == '?') { url.username = base.username; url.password = base.password; url.host = base.host; url.port = base.port; url.path = base.path.slice(); url.query = ''; state = QUERY; } else if (char == '#') { url.username = base.username; url.password = base.password; url.host = base.host; url.port = base.port; url.path = base.path.slice(); url.query = base.query; url.fragment = ''; state = FRAGMENT; } else { url.username = base.username; url.password = base.password; url.host = base.host; url.port = base.port; url.path = base.path.slice(); url.path.pop(); state = PATH; continue; } break; case RELATIVE_SLASH: if (isSpecial(url) && (char == '/' || char == '\\')) { state = SPECIAL_AUTHORITY_IGNORE_SLASHES; } else if (char == '/') { state = AUTHORITY; } else { url.username = base.username; url.password = base.password; url.host = base.host; url.port = base.port; state = PATH; continue; } break; case SPECIAL_AUTHORITY_SLASHES: state = SPECIAL_AUTHORITY_IGNORE_SLASHES; if (char != '/' || buffer.charAt(pointer + 1) != '/') continue; pointer++; break; case SPECIAL_AUTHORITY_IGNORE_SLASHES: if (char != '/' && char != '\\') { state = AUTHORITY; continue; } break; case AUTHORITY: if (char == '@') { if (seenAt) buffer = '%40' + buffer; seenAt = true; bufferCodePoints = arrayFrom(buffer); for (var i = 0; i < bufferCodePoints.length; i++) { var codePoint = bufferCodePoints[i]; if (codePoint == ':' && !seenPasswordToken) { seenPasswordToken = true; continue; } var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet); if (seenPasswordToken) url.password += encodedCodePoints; else url.username += encodedCodePoints; } buffer = ''; } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) { if (seenAt && buffer == '') return INVALID_AUTHORITY; pointer -= arrayFrom(buffer).length + 1; buffer = ''; state = HOST; } else buffer += char; break; case HOST: case HOSTNAME: if (stateOverride && url.scheme == 'file') { state = FILE_HOST; continue; } else if (char == ':' && !seenBracket) { if (buffer == '') return INVALID_HOST; failure = parseHost(url, buffer); if (failure) return failure; buffer = ''; state = PORT; if (stateOverride == HOSTNAME) return; } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url)) { if (isSpecial(url) && buffer == '') return INVALID_HOST; if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return; failure = parseHost(url, buffer); if (failure) return failure; buffer = ''; state = PATH_START; if (stateOverride) return; continue; } else { if (char == '[') seenBracket = true; else if (char == ']') seenBracket = false; buffer += char; } break; case PORT: if (DIGIT.test(char)) { buffer += char; } else if (char == EOF || char == '/' || char == '?' || char == '#' || char == '\\' && isSpecial(url) || stateOverride) { if (buffer != '') { var port = parseInt(buffer, 10); if (port > 0xFFFF) return INVALID_PORT; url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port; buffer = ''; } if (stateOverride) return; state = PATH_START; continue; } else return INVALID_PORT; break; case FILE: url.scheme = 'file'; if (char == '/' || char == '\\') state = FILE_SLASH; else if (base && base.scheme == 'file') { if (char == EOF) { url.host = base.host; url.path = base.path.slice(); url.query = base.query; } else if (char == '?') { url.host = base.host; url.path = base.path.slice(); url.query = ''; state = QUERY; } else if (char == '#') { url.host = base.host; url.path = base.path.slice(); url.query = base.query; url.fragment = ''; state = FRAGMENT; } else { if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) { url.host = base.host; url.path = base.path.slice(); shortenURLsPath(url); } state = PATH; continue; } } else { state = PATH; continue; } break; case FILE_SLASH: if (char == '/' || char == '\\') { state = FILE_HOST; break; } if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) { if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]); else url.host = base.host; } state = PATH; continue; case FILE_HOST: if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') { if (!stateOverride && isWindowsDriveLetter(buffer)) { state = PATH; } else if (buffer == '') { url.host = ''; if (stateOverride) return; state = PATH_START; } else { failure = parseHost(url, buffer); if (failure) return failure; if (url.host == 'localhost') url.host = ''; if (stateOverride) return; buffer = ''; state = PATH_START; } continue; } else buffer += char; break; case PATH_START: if (isSpecial(url)) { state = PATH; if (char != '/' && char != '\\') continue; } else if (!stateOverride && char == '?') { url.query = ''; state = QUERY; } else if (!stateOverride && char == '#') { url.fragment = ''; state = FRAGMENT; } else if (char != EOF) { state = PATH; if (char != '/') continue; } break; case PATH: if (char == EOF || char == '/' || char == '\\' && isSpecial(url) || !stateOverride && (char == '?' || char == '#')) { if (isDoubleDot(buffer)) { shortenURLsPath(url); if (char != '/' && !(char == '\\' && isSpecial(url))) { url.path.push(''); } } else if (isSingleDot(buffer)) { if (char != '/' && !(char == '\\' && isSpecial(url))) { url.path.push(''); } } else { if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) { if (url.host) url.host = ''; buffer = buffer.charAt(0) + ':'; } url.path.push(buffer); } buffer = ''; if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) { while (url.path.length > 1 && url.path[0] === '') { url.path.shift(); } } if (char == '?') { url.query = ''; state = QUERY; } else if (char == '#') { url.fragment = ''; state = FRAGMENT; } } else { buffer += percentEncode(char, pathPercentEncodeSet); } break; case CANNOT_BE_A_BASE_URL_PATH: if (char == '?') { url.query = ''; state = QUERY; } else if (char == '#') { url.fragment = ''; state = FRAGMENT; } else if (char != EOF) { url.path[0] += percentEncode(char, C0ControlPercentEncodeSet); } break; case QUERY: if (!stateOverride && char == '#') { url.fragment = ''; state = FRAGMENT; } else if (char != EOF) { if (char == "'" && isSpecial(url)) url.query += '%27'; else if (char == '#') url.query += '%23'; else url.query += percentEncode(char, C0ControlPercentEncodeSet); } break; case FRAGMENT: if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet); break; } pointer++; } }; var URLConstructor = function URL(url) { var that = anInstance(this, URLConstructor, 'URL'); var base = arguments.length > 1 ? arguments[1] : undefined; var urlString = String(url); var state = setInternalState(that, { type: 'URL' }); var baseState, failure; if (base !== undefined) { if (base instanceof URLConstructor) baseState = getInternalURLState(base); else { failure = parseURL(baseState = {}, String(base)); if (failure) throw TypeError(failure); } } failure = parseURL(state, urlString, null, baseState); if (failure) throw TypeError(failure); var searchParams = state.searchParams = new URLSearchParams(); var searchParamsState = getInternalSearchParamsState(searchParams); searchParamsState.updateSearchParams(state.query); searchParamsState.updateURL = function () { state.query = String(searchParams) || null; }; if (!DESCRIPTORS) { that.href = serializeURL.call(that); that.origin = getOrigin.call(that); that.protocol = getProtocol.call(that); that.username = getUsername.call(that); that.password = getPassword.call(that); that.host = getHost.call(that); that.hostname = getHostname.call(that); that.port = getPort.call(that); that.pathname = getPathname.call(that); that.search = getSearch.call(that); that.searchParams = getSearchParams.call(that); that.hash = getHash.call(that); } }; var URLPrototype = URLConstructor.prototype; var serializeURL = function () { var url = getInternalURLState(this); var scheme = url.scheme; var username = url.username; var password = url.password; var host = url.host; var port = url.port; var path = url.path; var query = url.query; var fragment = url.fragment; var output = scheme + ':'; if (host !== null) {
output += '//';
if (includesCredentials(url)) { output += username + (password ? ':' + password : '') + '@'; } output += serializeHost(host); if (port !== null) output += ':' + port; } else if (scheme == 'file')
output += '//';
output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : ''; if (query !== null) output += '?' + query; if (fragment !== null) output += '#' + fragment; return output; }; var getOrigin = function () { var url = getInternalURLState(this); var scheme = url.scheme; var port = url.port; if (scheme == 'blob') try { return new URL(scheme.path[0]).origin; } catch (error) { return 'null'; } if (scheme == 'file' || !isSpecial(url)) return 'null';
return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
}; var getProtocol = function () { return getInternalURLState(this).scheme + ':'; }; var getUsername = function () { return getInternalURLState(this).username; }; var getPassword = function () { return getInternalURLState(this).password; }; var getHost = function () { var url = getInternalURLState(this); var host = url.host; var port = url.port; return host === null ? '' : port === null ? serializeHost(host) : serializeHost(host) + ':' + port; }; var getHostname = function () { var host = getInternalURLState(this).host; return host === null ? '' : serializeHost(host); }; var getPort = function () { var port = getInternalURLState(this).port; return port === null ? '' : String(port); }; var getPathname = function () { var url = getInternalURLState(this); var path = url.path; return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : ''; }; var getSearch = function () { var query = getInternalURLState(this).query; return query ? '?' + query : ''; }; var getSearchParams = function () { return getInternalURLState(this).searchParams; }; var getHash = function () { var fragment = getInternalURLState(this).fragment; return fragment ? '#' + fragment : ''; }; var accessorDescriptor = function (getter, setter) { return { get: getter, set: setter, configurable: true, enumerable: true }; }; if (DESCRIPTORS) { defineProperties(URLPrototype, { href: accessorDescriptor(serializeURL, function (href) { var url = getInternalURLState(this); var urlString = String(href); var failure = parseURL(url, urlString); if (failure) throw TypeError(failure); getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query); }), origin: accessorDescriptor(getOrigin), protocol: accessorDescriptor(getProtocol, function (protocol) { var url = getInternalURLState(this); parseURL(url, String(protocol) + ':', SCHEME_START); }), username: accessorDescriptor(getUsername, function (username) { var url = getInternalURLState(this); var codePoints = arrayFrom(String(username)); if (cannotHaveUsernamePasswordPort(url)) return; url.username = ''; for (var i = 0; i < codePoints.length; i++) { url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet); } }), password: accessorDescriptor(getPassword, function (password) { var url = getInternalURLState(this); var codePoints = arrayFrom(String(password)); if (cannotHaveUsernamePasswordPort(url)) return; url.password = ''; for (var i = 0; i < codePoints.length; i++) { url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet); } }), host: accessorDescriptor(getHost, function (host) { var url = getInternalURLState(this); if (url.cannotBeABaseURL) return; parseURL(url, String(host), HOST); }), hostname: accessorDescriptor(getHostname, function (hostname) { var url = getInternalURLState(this); if (url.cannotBeABaseURL) return; parseURL(url, String(hostname), HOSTNAME); }), port: accessorDescriptor(getPort, function (port) { var url = getInternalURLState(this); if (cannotHaveUsernamePasswordPort(url)) return; port = String(port); if (port == '') url.port = null; else parseURL(url, port, PORT); }), pathname: accessorDescriptor(getPathname, function (pathname) { var url = getInternalURLState(this); if (url.cannotBeABaseURL) return; url.path = []; parseURL(url, pathname + '', PATH_START); }), search: accessorDescriptor(getSearch, function (search) { var url = getInternalURLState(this); search = String(search); if (search == '') { url.query = null; } else { if ('?' == search.charAt(0)) search = search.slice(1); url.query = ''; parseURL(url, search, QUERY); } getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query); }), searchParams: accessorDescriptor(getSearchParams), hash: accessorDescriptor(getHash, function (hash) { var url = getInternalURLState(this); hash = String(hash); if (hash == '') { url.fragment = null; return; } if ('#' == hash.charAt(0)) hash = hash.slice(1); url.fragment = ''; parseURL(url, hash, FRAGMENT); }) }); } redefine(URLPrototype, 'toJSON', function toJSON() { return serializeURL.call(this); }, { enumerable: true }); redefine(URLPrototype, 'toString', function toString() { return serializeURL.call(this); }, { enumerable: true }); if (NativeURL) { var nativeCreateObjectURL = NativeURL.createObjectURL; var nativeRevokeObjectURL = NativeURL.revokeObjectURL; if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) { return nativeCreateObjectURL.apply(NativeURL, arguments); }); if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) { return nativeRevokeObjectURL.apply(NativeURL, arguments); }); } setToStringTag(URLConstructor, 'URL'); $({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, { URL: URLConstructor });
/***/ }),
/* 142 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var fails = __w_pdfjs_require__(14); var wellKnownSymbol = __w_pdfjs_require__(57); var IS_PURE = __w_pdfjs_require__(37); var ITERATOR = wellKnownSymbol('iterator'); module.exports = !fails(function () {
var url = new URL('b?a=1&b=2&c=3', 'http://a');
var searchParams = url.searchParams; var result = ''; url.pathname = 'c%20d'; searchParams.forEach(function (value, key) { searchParams['delete']('b'); result += key + value; });
return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== 'http://a/c%20d?a=1&c=3' || searchParams.get('c') !== '3' || String(new URLSearchParams('?a=1')) !== 'a=1' || !searchParams[ITERATOR] || new URL('https://a@b').username !== 'a' || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b' || new URL('http://').host !== 'xn--e1aybc' || new URL('http://a#').hash !== '#%D0%B1' || result !== 'a1c3' || new URL('http://x', undefined).host !== 'x';
});
/***/ }),
/* 143 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var maxInt = 2147483647; var base = 36; var tMin = 1; var tMax = 26; var skew = 38; var damp = 700; var initialBias = 72; var initialN = 128; var delimiter = '-'; var regexNonASCII = /[^\0-\u007E]/; var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process'; var baseMinusTMin = base - tMin; var floor = Math.floor; var stringFromCharCode = String.fromCharCode; var ucs2decode = function (string) { var output = []; var counter = 0; var length = string.length; while (counter < length) { var value = string.charCodeAt(counter++); if (value >= 0xD800 && value <= 0xDBFF && counter < length) { var extra = string.charCodeAt(counter++); if ((extra & 0xFC00) == 0xDC00) { output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000); } else { output.push(value); counter--; } } else { output.push(value); } } return output; }; var digitToBasic = function (digit) { return digit + 22 + 75 * (digit < 26); }; var adapt = function (delta, numPoints, firstTime) { var k = 0; delta = firstTime ? floor(delta / damp) : delta >> 1; delta += floor(delta / numPoints); for (; delta > baseMinusTMin * tMax >> 1; k += base) { delta = floor(delta / baseMinusTMin); } return floor(k + (baseMinusTMin + 1) * delta / (delta + skew)); }; var encode = function (input) { var output = []; input = ucs2decode(input); var inputLength = input.length; var n = initialN; var delta = 0; var bias = initialBias; var i, currentValue; for (i = 0; i < input.length; i++) { currentValue = input[i]; if (currentValue < 0x80) { output.push(stringFromCharCode(currentValue)); } } var basicLength = output.length; var handledCPCount = basicLength; if (basicLength) { output.push(delimiter); } while (handledCPCount < inputLength) { var m = maxInt; for (i = 0; i < input.length; i++) { currentValue = input[i]; if (currentValue >= n && currentValue < m) { m = currentValue; } } var handledCPCountPlusOne = handledCPCount + 1; if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) { throw RangeError(OVERFLOW_ERROR); } delta += (m - n) * handledCPCountPlusOne; n = m; for (i = 0; i < input.length; i++) { currentValue = input[i]; if (currentValue < n && ++delta > maxInt) { throw RangeError(OVERFLOW_ERROR); } if (currentValue == n) { var q = delta; for (var k = base;; k += base) { var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias; if (q < t) break; var qMinusT = q - t; var baseMinusT = base - t; output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT))); q = floor(qMinusT / baseMinusT); } output.push(stringFromCharCode(digitToBasic(q))); bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength); delta = 0; ++handledCPCount; } } ++delta; ++n; } return output.join(''); }; module.exports = function (input) { var encoded = []; var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.'); var i, label; for (i = 0; i < labels.length; i++) { label = labels[i]; encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label); } return encoded.join('.'); };
/***/ }),
/* 144 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; __w_pdfjs_require__(139); var $ = __w_pdfjs_require__(10); var getBuiltIn = __w_pdfjs_require__(42); var USE_NATIVE_URL = __w_pdfjs_require__(142); var redefine = __w_pdfjs_require__(29); var redefineAll = __w_pdfjs_require__(121); var setToStringTag = __w_pdfjs_require__(85); var createIteratorConstructor = __w_pdfjs_require__(80); var InternalStateModule = __w_pdfjs_require__(33); var anInstance = __w_pdfjs_require__(123); var hasOwn = __w_pdfjs_require__(23); var bind = __w_pdfjs_require__(62); var classof = __w_pdfjs_require__(96); var anObject = __w_pdfjs_require__(28); var isObject = __w_pdfjs_require__(22); var create = __w_pdfjs_require__(71); var createPropertyDescriptor = __w_pdfjs_require__(16); var getIterator = __w_pdfjs_require__(145); var getIteratorMethod = __w_pdfjs_require__(95); var wellKnownSymbol = __w_pdfjs_require__(57); var $fetch = getBuiltIn('fetch'); var Headers = getBuiltIn('Headers'); var ITERATOR = wellKnownSymbol('iterator'); var URL_SEARCH_PARAMS = 'URLSearchParams'; var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator'; var setInternalState = InternalStateModule.set; var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS); var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR); var plus = /\+/g; var sequences = Array(4); var percentSequence = function (bytes) { return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi')); }; var percentDecode = function (sequence) { try { return decodeURIComponent(sequence); } catch (error) { return sequence; } }; var deserialize = function (it) { var result = it.replace(plus, ' '); var bytes = 4; try { return decodeURIComponent(result); } catch (error) { while (bytes) { result = result.replace(percentSequence(bytes--), percentDecode); } return result; } }; var find = /[!'()~]|%20/g; var replace = { '!': '%21', "'": '%27', '(': '%28', ')': '%29', '~': '%7E', '%20': '+' }; var replacer = function (match) { return replace[match]; }; var serialize = function (it) { return encodeURIComponent(it).replace(find, replacer); }; var parseSearchParams = function (result, query) { if (query) { var attributes = query.split('&'); var index = 0; var attribute, entry; while (index < attributes.length) { attribute = attributes[index++]; if (attribute.length) { entry = attribute.split('='); result.push({ key: deserialize(entry.shift()), value: deserialize(entry.join('=')) }); } } } }; var updateSearchParams = function (query) { this.entries.length = 0; parseSearchParams(this.entries, query); }; var validateArgumentsLength = function (passed, required) { if (passed < required) throw TypeError('Not enough arguments'); }; var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) { setInternalState(this, { type: URL_SEARCH_PARAMS_ITERATOR, iterator: getIterator(getInternalParamsState(params).entries), kind: kind }); }, 'Iterator', function next() { var state = getInternalIteratorState(this); var kind = state.kind; var step = state.iterator.next(); var entry = step.value; if (!step.done) { step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [ entry.key, entry.value ]; } return step; }); var URLSearchParamsConstructor = function URLSearchParams() { anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS); var init = arguments.length > 0 ? arguments[0] : undefined; var that = this; var entries = []; var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key; setInternalState(that, { type: URL_SEARCH_PARAMS, entries: entries, updateURL: function () { }, updateSearchParams: updateSearchParams }); if (init !== undefined) { if (isObject(init)) { iteratorMethod = getIteratorMethod(init); if (typeof iteratorMethod === 'function') { iterator = iteratorMethod.call(init); next = iterator.next; while (!(step = next.call(iterator)).done) { entryIterator = getIterator(anObject(step.value)); entryNext = entryIterator.next; if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done) throw TypeError('Expected sequence with length 2'); entries.push({ key: first.value + '', value: second.value + '' }); } } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: init[key] + '' }); } else { parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + ''); } } }; var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype; redefineAll(URLSearchParamsPrototype, { append: function append(name, value) { validateArgumentsLength(arguments.length, 2); var state = getInternalParamsState(this); state.entries.push({ key: name + '', value: value + '' }); state.updateURL(); }, 'delete': function (name) { validateArgumentsLength(arguments.length, 1); var state = getInternalParamsState(this); var entries = state.entries; var key = name + ''; var index = 0; while (index < entries.length) { if (entries[index].key === key) entries.splice(index, 1); else index++; } state.updateURL(); }, get: function get(name) { validateArgumentsLength(arguments.length, 1); var entries = getInternalParamsState(this).entries; var key = name + ''; var index = 0; for (; index < entries.length; index++) { if (entries[index].key === key) return entries[index].value; } return null; }, getAll: function getAll(name) { validateArgumentsLength(arguments.length, 1); var entries = getInternalParamsState(this).entries; var key = name + ''; var result = []; var index = 0; for (; index < entries.length; index++) { if (entries[index].key === key) result.push(entries[index].value); } return result; }, has: function has(name) { validateArgumentsLength(arguments.length, 1); var entries = getInternalParamsState(this).entries; var key = name + ''; var index = 0; while (index < entries.length) { if (entries[index++].key === key) return true; } return false; }, set: function set(name, value) { validateArgumentsLength(arguments.length, 1); var state = getInternalParamsState(this); var entries = state.entries; var found = false; var key = name + ''; var val = value + ''; var index = 0; var entry; for (; index < entries.length; index++) { entry = entries[index]; if (entry.key === key) { if (found) entries.splice(index--, 1); else { found = true; entry.value = val; } } } if (!found) entries.push({ key: key, value: val }); state.updateURL(); }, sort: function sort() { var state = getInternalParamsState(this); var entries = state.entries; var slice = entries.slice(); var entry, entriesIndex, sliceIndex; entries.length = 0; for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) { entry = slice[sliceIndex]; for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) { if (entries[entriesIndex].key > entry.key) { entries.splice(entriesIndex, 0, entry); break; } } if (entriesIndex === sliceIndex) entries.push(entry); } state.updateURL(); }, forEach: function forEach(callback) { var entries = getInternalParamsState(this).entries; var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3); var index = 0; var entry; while (index < entries.length) { entry = entries[index++]; boundFunction(entry.value, entry.key, this); } }, keys: function keys() { return new URLSearchParamsIterator(this, 'keys'); }, values: function values() { return new URLSearchParamsIterator(this, 'values'); }, entries: function entries() { return new URLSearchParamsIterator(this, 'entries'); } }, { enumerable: true }); redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries); redefine(URLSearchParamsPrototype, 'toString', function toString() { var entries = getInternalParamsState(this).entries; var result = []; var index = 0; var entry; while (index < entries.length) { entry = entries[index++]; result.push(serialize(entry.key) + '=' + serialize(entry.value)); } return result.join('&'); }, { enumerable: true }); setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS); $({ global: true, forced: !USE_NATIVE_URL }, { URLSearchParams: URLSearchParamsConstructor }); if (!USE_NATIVE_URL && typeof $fetch == 'function' && typeof Headers == 'function') { $({ global: true, enumerable: true, forced: true }, { fetch: function fetch(input) { var args = [input]; var init, body, headers; if (arguments.length > 1) { init = arguments[1]; if (isObject(init)) { body = init.body; if (classof(body) === URL_SEARCH_PARAMS) { headers = init.headers ? new Headers(init.headers) : new Headers(); if (!headers.has('content-type')) { headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8'); } init = create(init, { body: createPropertyDescriptor(0, String(body)), headers: createPropertyDescriptor(0, headers) }); } } args.push(init); } return $fetch.apply(this, args); } }); } module.exports = { URLSearchParams: URLSearchParamsConstructor, getState: getInternalParamsState };
/***/ }),
/* 145 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var anObject = __w_pdfjs_require__(28); var getIteratorMethod = __w_pdfjs_require__(95); module.exports = function (it) { var iteratorMethod = getIteratorMethod(it); if (typeof iteratorMethod != 'function') { throw TypeError(String(it) + ' is not iterable'); } return anObject(iteratorMethod.call(it)); };
/***/ }),
/* 146 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); $({ target: 'URL', proto: true, enumerable: true }, { toJSON: function toJSON() { return URL.prototype.toString.call(this); } });
/***/ }),
/* 147 */
/***/ (function(module, exports, __w_pdfjs_require__) {
(function (global, factory) { true ? factory(exports) : undefined; }(this, function (exports) { 'use strict'; var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) { return "Symbol(" + description + ")"; }; function noop() { } var NumberIsNaN = Number.isNaN || function (x) { return x !== x; }; var rethrowAssertionErrorRejection = noop; function typeIsObject(x) { return typeof x === 'object' && x !== null || typeof x === 'function'; } function createArrayFromList(elements) { return elements.slice(); } function ArrayBufferCopy(dest, destOffset, src, srcOffset, n) { new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset); } function IsFiniteNonNegativeNumber(v) { if (IsNonNegativeNumber(v) === false) { return false; } if (v === Infinity) { return false; } return true; } function IsNonNegativeNumber(v) { if (typeof v !== 'number') { return false; } if (NumberIsNaN(v)) { return false; } if (v < 0) { return false; } return true; } function Call(F, V, args) { if (typeof F !== 'function') { throw new TypeError('Argument is not a function'); } return Function.prototype.apply.call(F, V, args); } function CreateAlgorithmFromUnderlyingMethod(underlyingObject, methodName, algoArgCount, extraArgs) { var method = underlyingObject[methodName]; if (method !== undefined) { if (typeof method !== 'function') { throw new TypeError(method + " is not a method"); } switch (algoArgCount) { case 0: { return function () { return PromiseCall(method, underlyingObject, extraArgs); }; } case 1: { return function (arg) { var fullArgs = [arg].concat(extraArgs); return PromiseCall(method, underlyingObject, fullArgs); }; } } } return function () { return promiseResolvedWith(undefined); }; } function InvokeOrNoop(O, P, args) { var method = O[P]; if (method === undefined) { return undefined; } return Call(method, O, args); } function PromiseCall(F, V, args) { try { return promiseResolvedWith(Call(F, V, args)); } catch (value) { return promiseRejectedWith(value); } } function TransferArrayBuffer(O) { return O; } function IsDetachedBuffer(O) { return false; } function ValidateAndNormalizeHighWaterMark(highWaterMark) { highWaterMark = Number(highWaterMark); if (NumberIsNaN(highWaterMark) || highWaterMark < 0) { throw new RangeError('highWaterMark property of a queuing strategy must be non-negative and non-NaN'); } return highWaterMark; } function MakeSizeAlgorithmFromSizeFunction(size) { if (size === undefined) { return function () { return 1; }; } if (typeof size !== 'function') { throw new TypeError('size property of a queuing strategy must be a function'); } return function (chunk) { return size(chunk); }; } var originalPromise = Promise; var originalPromiseThen = Promise.prototype.then; var originalPromiseResolve = Promise.resolve.bind(originalPromise); var originalPromiseReject = Promise.reject.bind(originalPromise); function newPromise(executor) { return new originalPromise(executor); } function promiseResolvedWith(value) { return originalPromiseResolve(value); } function promiseRejectedWith(reason) { return originalPromiseReject(reason); } function PerformPromiseThen(promise, onFulfilled, onRejected) { return originalPromiseThen.call(promise, onFulfilled, onRejected); } function uponPromise(promise, onFulfilled, onRejected) { PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection); } function uponFulfillment(promise, onFulfilled) { uponPromise(promise, onFulfilled); } function uponRejection(promise, onRejected) { uponPromise(promise, undefined, onRejected); } function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) { return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler); } function setPromiseIsHandledToTrue(promise) { PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection); } var QUEUE_MAX_ARRAY_SIZE = 16384; var SimpleQueue = function () { function SimpleQueue() { this._cursor = 0; this._size = 0; this._front = { _elements: [], _next: undefined }; this._back = this._front; this._cursor = 0; this._size = 0; } Object.defineProperty(SimpleQueue.prototype, "length", { get: function () { return this._size; }, enumerable: true, configurable: true }); SimpleQueue.prototype.push = function (element) { var oldBack = this._back; var newBack = oldBack; if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) { newBack = { _elements: [], _next: undefined }; } oldBack._elements.push(element); if (newBack !== oldBack) { this._back = newBack; oldBack._next = newBack; } ++this._size; }; SimpleQueue.prototype.shift = function () { var oldFront = this._front; var newFront = oldFront; var oldCursor = this._cursor; var newCursor = oldCursor + 1; var elements = oldFront._elements; var element = elements[oldCursor]; if (newCursor === QUEUE_MAX_ARRAY_SIZE) { newFront = oldFront._next; newCursor = 0; } --this._size; this._cursor = newCursor; if (oldFront !== newFront) { this._front = newFront; } elements[oldCursor] = undefined; return element; }; SimpleQueue.prototype.forEach = function (callback) { var i = this._cursor; var node = this._front; var elements = node._elements; while (i !== elements.length || node._next !== undefined) { if (i === elements.length) { node = node._next; elements = node._elements; i = 0; if (elements.length === 0) { break; } } callback(elements[i]); ++i; } }; SimpleQueue.prototype.peek = function () { var front = this._front; var cursor = this._cursor; return front._elements[cursor]; }; return SimpleQueue; }(); function ReadableStreamCreateReadResult(value, done, forAuthorCode) { var prototype = null; if (forAuthorCode === true) { prototype = Object.prototype; } var obj = Object.create(prototype); obj.value = value; obj.done = done; return obj; } function ReadableStreamReaderGenericInitialize(reader, stream) { reader._forAuthorCode = true; reader._ownerReadableStream = stream; stream._reader = reader; if (stream._state === 'readable') { defaultReaderClosedPromiseInitialize(reader); } else if (stream._state === 'closed') { defaultReaderClosedPromiseInitializeAsResolved(reader); } else { defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError); } } function ReadableStreamReaderGenericCancel(reader, reason) { var stream = reader._ownerReadableStream; return ReadableStreamCancel(stream, reason); } function ReadableStreamReaderGenericRelease(reader) { if (reader._ownerReadableStream._state === 'readable') { defaultReaderClosedPromiseReject(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness')); } else { defaultReaderClosedPromiseResetToRejected(reader, new TypeError('Reader was released and can no longer be used to monitor the stream\'s closedness')); } reader._ownerReadableStream._reader = undefined; reader._ownerReadableStream = undefined; } function readerLockException(name) { return new TypeError('Cannot ' + name + ' a stream using a released reader'); } function defaultReaderClosedPromiseInitialize(reader) { reader._closedPromise = newPromise(function (resolve, reject) { reader._closedPromise_resolve = resolve; reader._closedPromise_reject = reject; }); } function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) { defaultReaderClosedPromiseInitialize(reader); defaultReaderClosedPromiseReject(reader, reason); } function defaultReaderClosedPromiseInitializeAsResolved(reader) { defaultReaderClosedPromiseInitialize(reader); defaultReaderClosedPromiseResolve(reader); } function defaultReaderClosedPromiseReject(reader, reason) { setPromiseIsHandledToTrue(reader._closedPromise); reader._closedPromise_reject(reason); reader._closedPromise_resolve = undefined; reader._closedPromise_reject = undefined; } function defaultReaderClosedPromiseResetToRejected(reader, reason) { defaultReaderClosedPromiseInitializeAsRejected(reader, reason); } function defaultReaderClosedPromiseResolve(reader) { reader._closedPromise_resolve(undefined); reader._closedPromise_resolve = undefined; reader._closedPromise_reject = undefined; } var CancelSteps = SymbolPolyfill('[[CancelSteps]]'); var PullSteps = SymbolPolyfill('[[PullSteps]]'); function AcquireReadableStreamDefaultReader(stream, forAuthorCode) { if (forAuthorCode === void 0) { forAuthorCode = false; } var reader = new ReadableStreamDefaultReader(stream); reader._forAuthorCode = forAuthorCode; return reader; } function ReadableStreamAddReadRequest(stream) { var promise = newPromise(function (resolve, reject) { var readRequest = { _resolve: resolve, _reject: reject }; stream._reader._readRequests.push(readRequest); }); return promise; } function ReadableStreamFulfillReadRequest(stream, chunk, done) { var reader = stream._reader; var readRequest = reader._readRequests.shift(); readRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode)); } function ReadableStreamGetNumReadRequests(stream) { return stream._reader._readRequests.length; } function ReadableStreamHasDefaultReader(stream) { var reader = stream._reader; if (reader === undefined) { return false; } if (!IsReadableStreamDefaultReader(reader)) { return false; } return true; } var ReadableStreamDefaultReader = function () { function ReadableStreamDefaultReader(stream) { if (IsReadableStream(stream) === false) { throw new TypeError('ReadableStreamDefaultReader can only be constructed with a ReadableStream instance'); } if (IsReadableStreamLocked(stream) === true) { throw new TypeError('This stream has already been locked for exclusive reading by another reader'); } ReadableStreamReaderGenericInitialize(this, stream); this._readRequests = new SimpleQueue(); } Object.defineProperty(ReadableStreamDefaultReader.prototype, "closed", { get: function () { if (!IsReadableStreamDefaultReader(this)) { return promiseRejectedWith(defaultReaderBrandCheckException('closed')); } return this._closedPromise; }, enumerable: true, configurable: true }); ReadableStreamDefaultReader.prototype.cancel = function (reason) { if (!IsReadableStreamDefaultReader(this)) { return promiseRejectedWith(defaultReaderBrandCheckException('cancel')); } if (this._ownerReadableStream === undefined) { return promiseRejectedWith(readerLockException('cancel')); } return ReadableStreamReaderGenericCancel(this, reason); }; ReadableStreamDefaultReader.prototype.read = function () { if (!IsReadableStreamDefaultReader(this)) { return promiseRejectedWith(defaultReaderBrandCheckException('read')); } if (this._ownerReadableStream === undefined) { return promiseRejectedWith(readerLockException('read from')); } return ReadableStreamDefaultReaderRead(this); }; ReadableStreamDefaultReader.prototype.releaseLock = function () { if (!IsReadableStreamDefaultReader(this)) { throw defaultReaderBrandCheckException('releaseLock'); } if (this._ownerReadableStream === undefined) { return; } if (this._readRequests.length > 0) { throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled'); } ReadableStreamReaderGenericRelease(this); }; return ReadableStreamDefaultReader; }(); function IsReadableStreamDefaultReader(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) { return false; } return true; } function ReadableStreamDefaultReaderRead(reader) { var stream = reader._ownerReadableStream; stream._disturbed = true; if (stream._state === 'closed') { return promiseResolvedWith(ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode)); } if (stream._state === 'errored') { return promiseRejectedWith(stream._storedError); } return stream._readableStreamController[PullSteps](); } function defaultReaderBrandCheckException(name) { return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader"); } var _a; var AsyncIteratorPrototype; if (typeof SymbolPolyfill.asyncIterator === 'symbol') { AsyncIteratorPrototype = (_a = {}, _a[SymbolPolyfill.asyncIterator] = function () { return this; }, _a); Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false }); } var ReadableStreamAsyncIteratorPrototype = { next: function () { if (IsReadableStreamAsyncIterator(this) === false) { return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next')); } var reader = this._asyncIteratorReader; if (reader._ownerReadableStream === undefined) { return promiseRejectedWith(readerLockException('iterate')); } return transformPromiseWith(ReadableStreamDefaultReaderRead(reader), function (result) { var done = result.done; if (done) { ReadableStreamReaderGenericRelease(reader); } var value = result.value; return ReadableStreamCreateReadResult(value, done, true); }); }, return: function (value) { if (IsReadableStreamAsyncIterator(this) === false) { return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next')); } var reader = this._asyncIteratorReader; if (reader._ownerReadableStream === undefined) { return promiseRejectedWith(readerLockException('finish iterating')); } if (reader._readRequests.length > 0) { return promiseRejectedWith(new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled')); } if (this._preventCancel === false) { var result = ReadableStreamReaderGenericCancel(reader, value); ReadableStreamReaderGenericRelease(reader); return transformPromiseWith(result, function () { return ReadableStreamCreateReadResult(value, true, true); }); } ReadableStreamReaderGenericRelease(reader); return promiseResolvedWith(ReadableStreamCreateReadResult(value, true, true)); } }; if (AsyncIteratorPrototype !== undefined) { Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype); } Object.defineProperty(ReadableStreamAsyncIteratorPrototype, 'next', { enumerable: false }); Object.defineProperty(ReadableStreamAsyncIteratorPrototype, 'return', { enumerable: false }); function AcquireReadableStreamAsyncIterator(stream, preventCancel) { if (preventCancel === void 0) { preventCancel = false; } var reader = AcquireReadableStreamDefaultReader(stream); var iterator = Object.create(ReadableStreamAsyncIteratorPrototype); iterator._asyncIteratorReader = reader; iterator._preventCancel = Boolean(preventCancel); return iterator; } function IsReadableStreamAsyncIterator(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorReader')) { return false; } return true; } function streamAsyncIteratorBrandCheckException(name) { return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator"); } function DequeueValue(container) { var pair = container._queue.shift(); container._queueTotalSize -= pair.size; if (container._queueTotalSize < 0) { container._queueTotalSize = 0; } return pair.value; } function EnqueueValueWithSize(container, value, size) { size = Number(size); if (!IsFiniteNonNegativeNumber(size)) { throw new RangeError('Size must be a finite, non-NaN, non-negative number.'); } container._queue.push({ value: value, size: size }); container._queueTotalSize += size; } function PeekQueueValue(container) { var pair = container._queue.peek(); return pair.value; } function ResetQueue(container) { container._queue = new SimpleQueue(); container._queueTotalSize = 0; } var AbortSteps = SymbolPolyfill('[[AbortSteps]]'); var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]'); var WritableStream = function () { function WritableStream(underlyingSink, strategy) { if (underlyingSink === void 0) { underlyingSink = {}; } if (strategy === void 0) { strategy = {}; } InitializeWritableStream(this); var size = strategy.size; var highWaterMark = strategy.highWaterMark; var type = underlyingSink.type; if (type !== undefined) { throw new RangeError('Invalid type is specified'); } var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size); if (highWaterMark === undefined) { highWaterMark = 1; } highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark); SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm); } Object.defineProperty(WritableStream.prototype, "locked", { get: function () { if (IsWritableStream(this) === false) { throw streamBrandCheckException('locked'); } return IsWritableStreamLocked(this); }, enumerable: true, configurable: true }); WritableStream.prototype.abort = function (reason) { if (IsWritableStream(this) === false) { return promiseRejectedWith(streamBrandCheckException('abort')); } if (IsWritableStreamLocked(this) === true) { return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer')); } return WritableStreamAbort(this, reason); }; WritableStream.prototype.close = function () { if (IsWritableStream(this) === false) { return promiseRejectedWith(streamBrandCheckException('close')); } if (IsWritableStreamLocked(this) === true) { return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer')); } if (WritableStreamCloseQueuedOrInFlight(this) === true) { return promiseRejectedWith(new TypeError('Cannot close an already-closing stream')); } return WritableStreamClose(this); }; WritableStream.prototype.getWriter = function () { if (IsWritableStream(this) === false) { throw streamBrandCheckException('getWriter'); } return AcquireWritableStreamDefaultWriter(this); }; return WritableStream; }(); function AcquireWritableStreamDefaultWriter(stream) { return new WritableStreamDefaultWriter(stream); } function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) { if (highWaterMark === void 0) { highWaterMark = 1; } if (sizeAlgorithm === void 0) { sizeAlgorithm = function () { return 1; }; } var stream = Object.create(WritableStream.prototype); InitializeWritableStream(stream); var controller = Object.create(WritableStreamDefaultController.prototype); SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm); return stream; } function InitializeWritableStream(stream) { stream._state = 'writable'; stream._storedError = undefined; stream._writer = undefined; stream._writableStreamController = undefined; stream._writeRequests = new SimpleQueue(); stream._inFlightWriteRequest = undefined; stream._closeRequest = undefined; stream._inFlightCloseRequest = undefined; stream._pendingAbortRequest = undefined; stream._backpressure = false; } function IsWritableStream(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) { return false; } return true; } function IsWritableStreamLocked(stream) { if (stream._writer === undefined) { return false; } return true; } function WritableStreamAbort(stream, reason) { var state = stream._state; if (state === 'closed' || state === 'errored') { return promiseResolvedWith(undefined); } if (stream._pendingAbortRequest !== undefined) { return stream._pendingAbortRequest._promise; } var wasAlreadyErroring = false; if (state === 'erroring') { wasAlreadyErroring = true; reason = undefined; } var promise = newPromise(function (resolve, reject) { stream._pendingAbortRequest = { _promise: undefined, _resolve: resolve, _reject: reject, _reason: reason, _wasAlreadyErroring: wasAlreadyErroring }; }); stream._pendingAbortRequest._promise = promise; if (wasAlreadyErroring === false) { WritableStreamStartErroring(stream, reason); } return promise; } function WritableStreamClose(stream) { var state = stream._state; if (state === 'closed' || state === 'errored') { return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed")); } var promise = newPromise(function (resolve, reject) { var closeRequest = { _resolve: resolve, _reject: reject }; stream._closeRequest = closeRequest; }); var writer = stream._writer; if (writer !== undefined && stream._backpressure === true && state === 'writable') { defaultWriterReadyPromiseResolve(writer); } WritableStreamDefaultControllerClose(stream._writableStreamController); return promise; } function WritableStreamAddWriteRequest(stream) { var promise = newPromise(function (resolve, reject) { var writeRequest = { _resolve: resolve, _reject: reject }; stream._writeRequests.push(writeRequest); }); return promise; } function WritableStreamDealWithRejection(stream, error) { var state = stream._state; if (state === 'writable') { WritableStreamStartErroring(stream, error); return; } WritableStreamFinishErroring(stream); } function WritableStreamStartErroring(stream, reason) { var controller = stream._writableStreamController; stream._state = 'erroring'; stream._storedError = reason; var writer = stream._writer; if (writer !== undefined) { WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason); } if (WritableStreamHasOperationMarkedInFlight(stream) === false && controller._started === true) { WritableStreamFinishErroring(stream); } } function WritableStreamFinishErroring(stream) { stream._state = 'errored'; stream._writableStreamController[ErrorSteps](); var storedError = stream._storedError; stream._writeRequests.forEach(function (writeRequest) { writeRequest._reject(storedError); }); stream._writeRequests = new SimpleQueue(); if (stream._pendingAbortRequest === undefined) { WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream); return; } var abortRequest = stream._pendingAbortRequest; stream._pendingAbortRequest = undefined; if (abortRequest._wasAlreadyErroring === true) { abortRequest._reject(storedError); WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream); return; } var promise = stream._writableStreamController[AbortSteps](abortRequest._reason); uponPromise(promise, function () { abortRequest._resolve(); WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream); }, function (reason) { abortRequest._reject(reason); WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream); }); } function WritableStreamFinishInFlightWrite(stream) { stream._inFlightWriteRequest._resolve(undefined); stream._inFlightWriteRequest = undefined; } function WritableStreamFinishInFlightWriteWithError(stream, error) { stream._inFlightWriteRequest._reject(error); stream._inFlightWriteRequest = undefined; WritableStreamDealWithRejection(stream, error); } function WritableStreamFinishInFlightClose(stream) { stream._inFlightCloseRequest._resolve(undefined); stream._inFlightCloseRequest = undefined; var state = stream._state; if (state === 'erroring') { stream._storedError = undefined; if (stream._pendingAbortRequest !== undefined) { stream._pendingAbortRequest._resolve(); stream._pendingAbortRequest = undefined; } } stream._state = 'closed'; var writer = stream._writer; if (writer !== undefined) { defaultWriterClosedPromiseResolve(writer); } } function WritableStreamFinishInFlightCloseWithError(stream, error) { stream._inFlightCloseRequest._reject(error); stream._inFlightCloseRequest = undefined; if (stream._pendingAbortRequest !== undefined) { stream._pendingAbortRequest._reject(error); stream._pendingAbortRequest = undefined; } WritableStreamDealWithRejection(stream, error); } function WritableStreamCloseQueuedOrInFlight(stream) { if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) { return false; } return true; } function WritableStreamHasOperationMarkedInFlight(stream) { if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) { return false; } return true; } function WritableStreamMarkCloseRequestInFlight(stream) { stream._inFlightCloseRequest = stream._closeRequest; stream._closeRequest = undefined; } function WritableStreamMarkFirstWriteRequestInFlight(stream) { stream._inFlightWriteRequest = stream._writeRequests.shift(); } function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) { if (stream._closeRequest !== undefined) { stream._closeRequest._reject(stream._storedError); stream._closeRequest = undefined; } var writer = stream._writer; if (writer !== undefined) { defaultWriterClosedPromiseReject(writer, stream._storedError); } } function WritableStreamUpdateBackpressure(stream, backpressure) { var writer = stream._writer; if (writer !== undefined && backpressure !== stream._backpressure) { if (backpressure === true) { defaultWriterReadyPromiseReset(writer); } else { defaultWriterReadyPromiseResolve(writer); } } stream._backpressure = backpressure; } var WritableStreamDefaultWriter = function () { function WritableStreamDefaultWriter(stream) { if (IsWritableStream(stream) === false) { throw new TypeError('WritableStreamDefaultWriter can only be constructed with a WritableStream instance'); } if (IsWritableStreamLocked(stream) === true) { throw new TypeError('This stream has already been locked for exclusive writing by another writer'); } this._ownerWritableStream = stream; stream._writer = this; var state = stream._state; if (state === 'writable') { if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._backpressure === true) { defaultWriterReadyPromiseInitialize(this); } else { defaultWriterReadyPromiseInitializeAsResolved(this); } defaultWriterClosedPromiseInitialize(this); } else if (state === 'erroring') { defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError); defaultWriterClosedPromiseInitialize(this); } else if (state === 'closed') { defaultWriterReadyPromiseInitializeAsResolved(this); defaultWriterClosedPromiseInitializeAsResolved(this); } else { var storedError = stream._storedError; defaultWriterReadyPromiseInitializeAsRejected(this, storedError); defaultWriterClosedPromiseInitializeAsRejected(this, storedError); } } Object.defineProperty(WritableStreamDefaultWriter.prototype, "closed", { get: function () { if (IsWritableStreamDefaultWriter(this) === false) { return promiseRejectedWith(defaultWriterBrandCheckException('closed')); } return this._closedPromise; }, enumerable: true, configurable: true }); Object.defineProperty(WritableStreamDefaultWriter.prototype, "desiredSize", { get: function () { if (IsWritableStreamDefaultWriter(this) === false) { throw defaultWriterBrandCheckException('desiredSize'); } if (this._ownerWritableStream === undefined) { throw defaultWriterLockException('desiredSize'); } return WritableStreamDefaultWriterGetDesiredSize(this); }, enumerable: true, configurable: true }); Object.defineProperty(WritableStreamDefaultWriter.prototype, "ready", { get: function () { if (IsWritableStreamDefaultWriter(this) === false) { return promiseRejectedWith(defaultWriterBrandCheckException('ready')); } return this._readyPromise; }, enumerable: true, configurable: true }); WritableStreamDefaultWriter.prototype.abort = function (reason) { if (IsWritableStreamDefaultWriter(this) === false) { return promiseRejectedWith(defaultWriterBrandCheckException('abort')); } if (this._ownerWritableStream === undefined) { return promiseRejectedWith(defaultWriterLockException('abort')); } return WritableStreamDefaultWriterAbort(this, reason); }; WritableStreamDefaultWriter.prototype.close = function () { if (IsWritableStreamDefaultWriter(this) === false) { return promiseRejectedWith(defaultWriterBrandCheckException('close')); } var stream = this._ownerWritableStream; if (stream === undefined) { return promiseRejectedWith(defaultWriterLockException('close')); } if (WritableStreamCloseQueuedOrInFlight(stream) === true) { return promiseRejectedWith(new TypeError('Cannot close an already-closing stream')); } return WritableStreamDefaultWriterClose(this); }; WritableStreamDefaultWriter.prototype.releaseLock = function () { if (IsWritableStreamDefaultWriter(this) === false) { throw defaultWriterBrandCheckException('releaseLock'); } var stream = this._ownerWritableStream; if (stream === undefined) { return; } WritableStreamDefaultWriterRelease(this); }; WritableStreamDefaultWriter.prototype.write = function (chunk) { if (IsWritableStreamDefaultWriter(this) === false) { return promiseRejectedWith(defaultWriterBrandCheckException('write')); } if (this._ownerWritableStream === undefined) { return promiseRejectedWith(defaultWriterLockException('write to')); } return WritableStreamDefaultWriterWrite(this, chunk); }; return WritableStreamDefaultWriter; }(); function IsWritableStreamDefaultWriter(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) { return false; } return true; } function WritableStreamDefaultWriterAbort(writer, reason) { var stream = writer._ownerWritableStream; return WritableStreamAbort(stream, reason); } function WritableStreamDefaultWriterClose(writer) { var stream = writer._ownerWritableStream; return WritableStreamClose(stream); } function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) { var stream = writer._ownerWritableStream; var state = stream._state; if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') { return promiseResolvedWith(undefined); } if (state === 'errored') { return promiseRejectedWith(stream._storedError); } return WritableStreamDefaultWriterClose(writer); } function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) { if (writer._closedPromiseState === 'pending') { defaultWriterClosedPromiseReject(writer, error); } else { defaultWriterClosedPromiseResetToRejected(writer, error); } } function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) { if (writer._readyPromiseState === 'pending') { defaultWriterReadyPromiseReject(writer, error); } else { defaultWriterReadyPromiseResetToRejected(writer, error); } } function WritableStreamDefaultWriterGetDesiredSize(writer) { var stream = writer._ownerWritableStream; var state = stream._state; if (state === 'errored' || state === 'erroring') { return null; } if (state === 'closed') { return 0; } return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController); } function WritableStreamDefaultWriterRelease(writer) { var stream = writer._ownerWritableStream; var releasedError = new TypeError('Writer was released and can no longer be used to monitor the stream\'s closedness'); WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError); WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError); stream._writer = undefined; writer._ownerWritableStream = undefined; } function WritableStreamDefaultWriterWrite(writer, chunk) { var stream = writer._ownerWritableStream; var controller = stream._writableStreamController; var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk); if (stream !== writer._ownerWritableStream) { return promiseRejectedWith(defaultWriterLockException('write to')); } var state = stream._state; if (state === 'errored') { return promiseRejectedWith(stream._storedError); } if (WritableStreamCloseQueuedOrInFlight(stream) === true || state === 'closed') { return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to')); } if (state === 'erroring') { return promiseRejectedWith(stream._storedError); } var promise = WritableStreamAddWriteRequest(stream); WritableStreamDefaultControllerWrite(controller, chunk, chunkSize); return promise; } var WritableStreamDefaultController = function () { function WritableStreamDefaultController() { throw new TypeError('WritableStreamDefaultController cannot be constructed explicitly'); } WritableStreamDefaultController.prototype.error = function (e) { if (IsWritableStreamDefaultController(this) === false) { throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController'); } var state = this._controlledWritableStream._state; if (state !== 'writable') { return; } WritableStreamDefaultControllerError(this, e); }; WritableStreamDefaultController.prototype[AbortSteps] = function (reason) { var result = this._abortAlgorithm(reason); WritableStreamDefaultControllerClearAlgorithms(this); return result; }; WritableStreamDefaultController.prototype[ErrorSteps] = function () { ResetQueue(this); }; return WritableStreamDefaultController; }(); function IsWritableStreamDefaultController(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) { return false; } return true; } function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) { controller._controlledWritableStream = stream; stream._writableStreamController = controller; controller._queue = undefined; controller._queueTotalSize = undefined; ResetQueue(controller); controller._started = false; controller._strategySizeAlgorithm = sizeAlgorithm; controller._strategyHWM = highWaterMark; controller._writeAlgorithm = writeAlgorithm; controller._closeAlgorithm = closeAlgorithm; controller._abortAlgorithm = abortAlgorithm; var backpressure = WritableStreamDefaultControllerGetBackpressure(controller); WritableStreamUpdateBackpressure(stream, backpressure); var startResult = startAlgorithm(); var startPromise = promiseResolvedWith(startResult); uponPromise(startPromise, function () { controller._started = true; WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller); }, function (r) { controller._started = true; WritableStreamDealWithRejection(stream, r); }); } function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) { var controller = Object.create(WritableStreamDefaultController.prototype); function startAlgorithm() { return InvokeOrNoop(underlyingSink, 'start', [controller]); } var writeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'write', 1, [controller]); var closeAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'close', 0, []); var abortAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSink, 'abort', 1, []); SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm); } function WritableStreamDefaultControllerClearAlgorithms(controller) { controller._writeAlgorithm = undefined; controller._closeAlgorithm = undefined; controller._abortAlgorithm = undefined; controller._strategySizeAlgorithm = undefined; } function WritableStreamDefaultControllerClose(controller) { EnqueueValueWithSize(controller, 'close', 0); WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller); } function WritableStreamDefaultControllerGetChunkSize(controller, chunk) { try { return controller._strategySizeAlgorithm(chunk); } catch (chunkSizeE) { WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE); return 1; } } function WritableStreamDefaultControllerGetDesiredSize(controller) { return controller._strategyHWM - controller._queueTotalSize; } function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) { var writeRecord = { chunk: chunk }; try { EnqueueValueWithSize(controller, writeRecord, chunkSize); } catch (enqueueE) { WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE); return; } var stream = controller._controlledWritableStream; if (WritableStreamCloseQueuedOrInFlight(stream) === false && stream._state === 'writable') { var backpressure = WritableStreamDefaultControllerGetBackpressure(controller); WritableStreamUpdateBackpressure(stream, backpressure); } WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller); } function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) { var stream = controller._controlledWritableStream; if (controller._started === false) { return; } if (stream._inFlightWriteRequest !== undefined) { return; } var state = stream._state; if (state === 'erroring') { WritableStreamFinishErroring(stream); return; } if (controller._queue.length === 0) { return; } var writeRecord = PeekQueueValue(controller); if (writeRecord === 'close') { WritableStreamDefaultControllerProcessClose(controller); } else { WritableStreamDefaultControllerProcessWrite(controller, writeRecord.chunk); } } function WritableStreamDefaultControllerErrorIfNeeded(controller, error) { if (controller._controlledWritableStream._state === 'writable') { WritableStreamDefaultControllerError(controller, error); } } function WritableStreamDefaultControllerProcessClose(controller) { var stream = controller._controlledWritableStream; WritableStreamMarkCloseRequestInFlight(stream); DequeueValue(controller); var sinkClosePromise = controller._closeAlgorithm(); WritableStreamDefaultControllerClearAlgorithms(controller); uponPromise(sinkClosePromise, function () { WritableStreamFinishInFlightClose(stream); }, function (reason) { WritableStreamFinishInFlightCloseWithError(stream, reason); }); } function WritableStreamDefaultControllerProcessWrite(controller, chunk) { var stream = controller._controlledWritableStream; WritableStreamMarkFirstWriteRequestInFlight(stream); var sinkWritePromise = controller._writeAlgorithm(chunk); uponPromise(sinkWritePromise, function () { WritableStreamFinishInFlightWrite(stream); var state = stream._state; DequeueValue(controller); if (WritableStreamCloseQueuedOrInFlight(stream) === false && state === 'writable') { var backpressure = WritableStreamDefaultControllerGetBackpressure(controller); WritableStreamUpdateBackpressure(stream, backpressure); } WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller); }, function (reason) { if (stream._state === 'writable') { WritableStreamDefaultControllerClearAlgorithms(controller); } WritableStreamFinishInFlightWriteWithError(stream, reason); }); } function WritableStreamDefaultControllerGetBackpressure(controller) { var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller); return desiredSize <= 0; } function WritableStreamDefaultControllerError(controller, error) { var stream = controller._controlledWritableStream; WritableStreamDefaultControllerClearAlgorithms(controller); WritableStreamStartErroring(stream, error); } function streamBrandCheckException(name) { return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream"); } function defaultWriterBrandCheckException(name) { return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter"); } function defaultWriterLockException(name) { return new TypeError('Cannot ' + name + ' a stream using a released writer'); } function defaultWriterClosedPromiseInitialize(writer) { writer._closedPromise = newPromise(function (resolve, reject) { writer._closedPromise_resolve = resolve; writer._closedPromise_reject = reject; writer._closedPromiseState = 'pending'; }); } function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) { defaultWriterClosedPromiseInitialize(writer); defaultWriterClosedPromiseReject(writer, reason); } function defaultWriterClosedPromiseInitializeAsResolved(writer) { defaultWriterClosedPromiseInitialize(writer); defaultWriterClosedPromiseResolve(writer); } function defaultWriterClosedPromiseReject(writer, reason) { setPromiseIsHandledToTrue(writer._closedPromise); writer._closedPromise_reject(reason); writer._closedPromise_resolve = undefined; writer._closedPromise_reject = undefined; writer._closedPromiseState = 'rejected'; } function defaultWriterClosedPromiseResetToRejected(writer, reason) { defaultWriterClosedPromiseInitializeAsRejected(writer, reason); } function defaultWriterClosedPromiseResolve(writer) { writer._closedPromise_resolve(undefined); writer._closedPromise_resolve = undefined; writer._closedPromise_reject = undefined; writer._closedPromiseState = 'resolved'; } function defaultWriterReadyPromiseInitialize(writer) { writer._readyPromise = newPromise(function (resolve, reject) { writer._readyPromise_resolve = resolve; writer._readyPromise_reject = reject; }); writer._readyPromiseState = 'pending'; } function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) { defaultWriterReadyPromiseInitialize(writer); defaultWriterReadyPromiseReject(writer, reason); } function defaultWriterReadyPromiseInitializeAsResolved(writer) { defaultWriterReadyPromiseInitialize(writer); defaultWriterReadyPromiseResolve(writer); } function defaultWriterReadyPromiseReject(writer, reason) { setPromiseIsHandledToTrue(writer._readyPromise); writer._readyPromise_reject(reason); writer._readyPromise_resolve = undefined; writer._readyPromise_reject = undefined; writer._readyPromiseState = 'rejected'; } function defaultWriterReadyPromiseReset(writer) { defaultWriterReadyPromiseInitialize(writer); } function defaultWriterReadyPromiseResetToRejected(writer, reason) { defaultWriterReadyPromiseInitializeAsRejected(writer, reason); } function defaultWriterReadyPromiseResolve(writer) { writer._readyPromise_resolve(undefined); writer._readyPromise_resolve = undefined; writer._readyPromise_reject = undefined; writer._readyPromiseState = 'fulfilled'; } function isAbortSignal(value) { if (typeof value !== 'object' || value === null) { return false; } try { return typeof value.aborted === 'boolean'; } catch (_a) { return false; } } var NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined; function isDOMExceptionConstructor(ctor) { if (!(typeof ctor === 'function' || typeof ctor === 'object')) { return false; } try { new ctor(); return true; } catch (_a) { return false; } } function createDOMExceptionPolyfill() { var ctor = function DOMException(message, name) { this.message = message || ''; this.name = name || 'Error'; if (Error.captureStackTrace) { Error.captureStackTrace(this, this.constructor); } }; ctor.prototype = Object.create(Error.prototype); Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true }); return ctor; } var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill(); function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) { var reader = AcquireReadableStreamDefaultReader(source); var writer = AcquireWritableStreamDefaultWriter(dest); source._disturbed = true; var shuttingDown = false; var currentWrite = promiseResolvedWith(undefined); return newPromise(function (resolve, reject) { var abortAlgorithm; if (signal !== undefined) { abortAlgorithm = function () { var error = new DOMException$1('Aborted', 'AbortError'); var actions = []; if (preventAbort === false) { actions.push(function () { if (dest._state === 'writable') { return WritableStreamAbort(dest, error); } return promiseResolvedWith(undefined); }); } if (preventCancel === false) { actions.push(function () { if (source._state === 'readable') { return ReadableStreamCancel(source, error); } return promiseResolvedWith(undefined); }); } shutdownWithAction(function () { return Promise.all(actions.map(function (action) { return action(); })); }, true, error); }; if (signal.aborted === true) { abortAlgorithm(); return; } signal.addEventListener('abort', abortAlgorithm); } function pipeLoop() { return newPromise(function (resolveLoop, rejectLoop) { function next(done) { if (done) { resolveLoop(); } else { PerformPromiseThen(pipeStep(), next, rejectLoop); } } next(false); }); } function pipeStep() { if (shuttingDown === true) { return promiseResolvedWith(true); } return PerformPromiseThen(writer._readyPromise, function () { return PerformPromiseThen(ReadableStreamDefaultReaderRead(reader), function (result) { if (result.done === true) { return true; } currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, result.value), undefined, noop); return false; }); }); } isOrBecomesErrored(source, reader._closedPromise, function (storedError) { if (preventAbort === false) { shutdownWithAction(function () { return WritableStreamAbort(dest, storedError); }, true, storedError); } else { shutdown(true, storedError); } }); isOrBecomesErrored(dest, writer._closedPromise, function (storedError) { if (preventCancel === false) { shutdownWithAction(function () { return ReadableStreamCancel(source, storedError); }, true, storedError); } else { shutdown(true, storedError); } }); isOrBecomesClosed(source, reader._closedPromise, function () { if (preventClose === false) { shutdownWithAction(function () { return WritableStreamDefaultWriterCloseWithErrorPropagation(writer); }); } else { shutdown(); } }); if (WritableStreamCloseQueuedOrInFlight(dest) === true || dest._state === 'closed') { var destClosed_1 = new TypeError('the destination writable stream closed before all data could be piped to it'); if (preventCancel === false) { shutdownWithAction(function () { return ReadableStreamCancel(source, destClosed_1); }, true, destClosed_1); } else { shutdown(true, destClosed_1); } } setPromiseIsHandledToTrue(pipeLoop()); function waitForWritesToFinish() { var oldCurrentWrite = currentWrite; return PerformPromiseThen(currentWrite, function () { return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined; }); } function isOrBecomesErrored(stream, promise, action) { if (stream._state === 'errored') { action(stream._storedError); } else { uponRejection(promise, action); } } function isOrBecomesClosed(stream, promise, action) { if (stream._state === 'closed') { action(); } else { uponFulfillment(promise, action); } } function shutdownWithAction(action, originalIsError, originalError) { if (shuttingDown === true) { return; } shuttingDown = true; if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) { uponFulfillment(waitForWritesToFinish(), doTheRest); } else { doTheRest(); } function doTheRest() { uponPromise(action(), function () { return finalize(originalIsError, originalError); }, function (newError) { return finalize(true, newError); }); } } function shutdown(isError, error) { if (shuttingDown === true) { return; } shuttingDown = true; if (dest._state === 'writable' && WritableStreamCloseQueuedOrInFlight(dest) === false) { uponFulfillment(waitForWritesToFinish(), function () { return finalize(isError, error); }); } else { finalize(isError, error); } } function finalize(isError, error) { WritableStreamDefaultWriterRelease(writer); ReadableStreamReaderGenericRelease(reader); if (signal !== undefined) { signal.removeEventListener('abort', abortAlgorithm); } if (isError) { reject(error); } else { resolve(undefined); } } }); } var ReadableStreamDefaultController = function () { function ReadableStreamDefaultController() { throw new TypeError(); } Object.defineProperty(ReadableStreamDefaultController.prototype, "desiredSize", { get: function () { if (IsReadableStreamDefaultController(this) === false) { throw defaultControllerBrandCheckException('desiredSize'); } return ReadableStreamDefaultControllerGetDesiredSize(this); }, enumerable: true, configurable: true }); ReadableStreamDefaultController.prototype.close = function () { if (IsReadableStreamDefaultController(this) === false) { throw defaultControllerBrandCheckException('close'); } if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) { throw new TypeError('The stream is not in a state that permits close'); } ReadableStreamDefaultControllerClose(this); }; ReadableStreamDefaultController.prototype.enqueue = function (chunk) { if (IsReadableStreamDefaultController(this) === false) { throw defaultControllerBrandCheckException('enqueue'); } if (ReadableStreamDefaultControllerCanCloseOrEnqueue(this) === false) { throw new TypeError('The stream is not in a state that permits enqueue'); } return ReadableStreamDefaultControllerEnqueue(this, chunk); }; ReadableStreamDefaultController.prototype.error = function (e) { if (IsReadableStreamDefaultController(this) === false) { throw defaultControllerBrandCheckException('error'); } ReadableStreamDefaultControllerError(this, e); }; ReadableStreamDefaultController.prototype[CancelSteps] = function (reason) { ResetQueue(this); var result = this._cancelAlgorithm(reason); ReadableStreamDefaultControllerClearAlgorithms(this); return result; }; ReadableStreamDefaultController.prototype[PullSteps] = function () { var stream = this._controlledReadableStream; if (this._queue.length > 0) { var chunk = DequeueValue(this); if (this._closeRequested === true && this._queue.length === 0) { ReadableStreamDefaultControllerClearAlgorithms(this); ReadableStreamClose(stream); } else { ReadableStreamDefaultControllerCallPullIfNeeded(this); } return promiseResolvedWith(ReadableStreamCreateReadResult(chunk, false, stream._reader._forAuthorCode)); } var pendingPromise = ReadableStreamAddReadRequest(stream); ReadableStreamDefaultControllerCallPullIfNeeded(this); return pendingPromise; }; return ReadableStreamDefaultController; }(); function IsReadableStreamDefaultController(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) { return false; } return true; } function ReadableStreamDefaultControllerCallPullIfNeeded(controller) { var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller); if (shouldPull === false) { return; } if (controller._pulling === true) { controller._pullAgain = true; return; } controller._pulling = true; var pullPromise = controller._pullAlgorithm(); uponPromise(pullPromise, function () { controller._pulling = false; if (controller._pullAgain === true) { controller._pullAgain = false; ReadableStreamDefaultControllerCallPullIfNeeded(controller); } }, function (e) { ReadableStreamDefaultControllerError(controller, e); }); } function ReadableStreamDefaultControllerShouldCallPull(controller) { var stream = controller._controlledReadableStream; if (ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) === false) { return false; } if (controller._started === false) { return false; } if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) { return true; } var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller); if (desiredSize > 0) { return true; } return false; } function ReadableStreamDefaultControllerClearAlgorithms(controller) { controller._pullAlgorithm = undefined; controller._cancelAlgorithm = undefined; controller._strategySizeAlgorithm = undefined; } function ReadableStreamDefaultControllerClose(controller) { var stream = controller._controlledReadableStream; controller._closeRequested = true; if (controller._queue.length === 0) { ReadableStreamDefaultControllerClearAlgorithms(controller); ReadableStreamClose(stream); } } function ReadableStreamDefaultControllerEnqueue(controller, chunk) { var stream = controller._controlledReadableStream; if (IsReadableStreamLocked(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) { ReadableStreamFulfillReadRequest(stream, chunk, false); } else { var chunkSize = void 0; try { chunkSize = controller._strategySizeAlgorithm(chunk); } catch (chunkSizeE) { ReadableStreamDefaultControllerError(controller, chunkSizeE); throw chunkSizeE; } try { EnqueueValueWithSize(controller, chunk, chunkSize); } catch (enqueueE) { ReadableStreamDefaultControllerError(controller, enqueueE); throw enqueueE; } } ReadableStreamDefaultControllerCallPullIfNeeded(controller); } function ReadableStreamDefaultControllerError(controller, e) { var stream = controller._controlledReadableStream; if (stream._state !== 'readable') { return; } ResetQueue(controller); ReadableStreamDefaultControllerClearAlgorithms(controller); ReadableStreamError(stream, e); } function ReadableStreamDefaultControllerGetDesiredSize(controller) { var stream = controller._controlledReadableStream; var state = stream._state; if (state === 'errored') { return null; } if (state === 'closed') { return 0; } return controller._strategyHWM - controller._queueTotalSize; } function ReadableStreamDefaultControllerHasBackpressure(controller) { if (ReadableStreamDefaultControllerShouldCallPull(controller) === true) { return false; } return true; } function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) { var state = controller._controlledReadableStream._state; if (controller._closeRequested === false && state === 'readable') { return true; } return false; } function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) { controller._controlledReadableStream = stream; controller._queue = undefined; controller._queueTotalSize = undefined; ResetQueue(controller); controller._started = false; controller._closeRequested = false; controller._pullAgain = false; controller._pulling = false; controller._strategySizeAlgorithm = sizeAlgorithm; controller._strategyHWM = highWaterMark; controller._pullAlgorithm = pullAlgorithm; controller._cancelAlgorithm = cancelAlgorithm; stream._readableStreamController = controller; var startResult = startAlgorithm(); uponPromise(promiseResolvedWith(startResult), function () { controller._started = true; ReadableStreamDefaultControllerCallPullIfNeeded(controller); }, function (r) { ReadableStreamDefaultControllerError(controller, r); }); } function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) { var controller = Object.create(ReadableStreamDefaultController.prototype); function startAlgorithm() { return InvokeOrNoop(underlyingSource, 'start', [controller]); } var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'pull', 0, [controller]); var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingSource, 'cancel', 1, []); SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm); } function defaultControllerBrandCheckException(name) { return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController"); } function ReadableStreamTee(stream, cloneForBranch2) { var reader = AcquireReadableStreamDefaultReader(stream); var reading = false; var canceled1 = false; var canceled2 = false; var reason1; var reason2; var branch1; var branch2; var resolveCancelPromise; var cancelPromise = newPromise(function (resolve) { resolveCancelPromise = resolve; }); function pullAlgorithm() { if (reading === true) { return promiseResolvedWith(undefined); } reading = true; var readPromise = transformPromiseWith(ReadableStreamDefaultReaderRead(reader), function (result) { reading = false; var done = result.done; if (done === true) { if (canceled1 === false) { ReadableStreamDefaultControllerClose(branch1._readableStreamController); } if (canceled2 === false) { ReadableStreamDefaultControllerClose(branch2._readableStreamController); } return; } var value = result.value; var value1 = value; var value2 = value; if (canceled1 === false) { ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1); } if (canceled2 === false) { ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2); } }); setPromiseIsHandledToTrue(readPromise); return promiseResolvedWith(undefined); } function cancel1Algorithm(reason) { canceled1 = true; reason1 = reason; if (canceled2 === true) { var compositeReason = createArrayFromList([ reason1, reason2 ]); var cancelResult = ReadableStreamCancel(stream, compositeReason); resolveCancelPromise(cancelResult); } return cancelPromise; } function cancel2Algorithm(reason) { canceled2 = true; reason2 = reason; if (canceled1 === true) { var compositeReason = createArrayFromList([ reason1, reason2 ]); var cancelResult = ReadableStreamCancel(stream, compositeReason); resolveCancelPromise(cancelResult); } return cancelPromise; } function startAlgorithm() { } branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm); branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm); uponRejection(reader._closedPromise, function (r) { ReadableStreamDefaultControllerError(branch1._readableStreamController, r); ReadableStreamDefaultControllerError(branch2._readableStreamController, r); }); return [ branch1, branch2 ]; } var NumberIsInteger = Number.isInteger || function (value) { return typeof value === 'number' && isFinite(value) && Math.floor(value) === value; }; var ReadableStreamBYOBRequest = function () { function ReadableStreamBYOBRequest() { throw new TypeError('ReadableStreamBYOBRequest cannot be used directly'); } Object.defineProperty(ReadableStreamBYOBRequest.prototype, "view", { get: function () { if (IsReadableStreamBYOBRequest(this) === false) { throw byobRequestBrandCheckException('view'); } return this._view; }, enumerable: true, configurable: true }); ReadableStreamBYOBRequest.prototype.respond = function (bytesWritten) { if (IsReadableStreamBYOBRequest(this) === false) { throw byobRequestBrandCheckException('respond'); } if (this._associatedReadableByteStreamController === undefined) { throw new TypeError('This BYOB request has been invalidated'); } if (IsDetachedBuffer(this._view.buffer) === true); ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten); }; ReadableStreamBYOBRequest.prototype.respondWithNewView = function (view) { if (IsReadableStreamBYOBRequest(this) === false) { throw byobRequestBrandCheckException('respond'); } if (this._associatedReadableByteStreamController === undefined) { throw new TypeError('This BYOB request has been invalidated'); } if (!ArrayBuffer.isView(view)) { throw new TypeError('You can only respond with array buffer views'); } if (IsDetachedBuffer(view.buffer) === true); ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view); }; return ReadableStreamBYOBRequest; }(); var ReadableByteStreamController = function () { function ReadableByteStreamController() { throw new TypeError('ReadableByteStreamController constructor cannot be used directly'); } Object.defineProperty(ReadableByteStreamController.prototype, "byobRequest", { get: function () { if (IsReadableByteStreamController(this) === false) { throw byteStreamControllerBrandCheckException('byobRequest'); } if (this._byobRequest === undefined && this._pendingPullIntos.length > 0) { var firstDescriptor = this._pendingPullIntos.peek(); var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled); var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype); SetUpReadableStreamBYOBRequest(byobRequest, this, view); this._byobRequest = byobRequest; } return this._byobRequest; }, enumerable: true, configurable: true }); Object.defineProperty(ReadableByteStreamController.prototype, "desiredSize", { get: function () { if (IsReadableByteStreamController(this) === false) { throw byteStreamControllerBrandCheckException('desiredSize'); } return ReadableByteStreamControllerGetDesiredSize(this); }, enumerable: true, configurable: true }); ReadableByteStreamController.prototype.close = function () { if (IsReadableByteStreamController(this) === false) { throw byteStreamControllerBrandCheckException('close'); } if (this._closeRequested === true) { throw new TypeError('The stream has already been closed; do not close it again!'); } var state = this._controlledReadableByteStream._state; if (state !== 'readable') { throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed"); } ReadableByteStreamControllerClose(this); }; ReadableByteStreamController.prototype.enqueue = function (chunk) { if (IsReadableByteStreamController(this) === false) { throw byteStreamControllerBrandCheckException('enqueue'); } if (this._closeRequested === true) { throw new TypeError('stream is closed or draining'); } var state = this._controlledReadableByteStream._state; if (state !== 'readable') { throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to"); } if (!ArrayBuffer.isView(chunk)) { throw new TypeError('You can only enqueue array buffer views when using a ReadableByteStreamController'); } if (IsDetachedBuffer(chunk.buffer) === true); ReadableByteStreamControllerEnqueue(this, chunk); }; ReadableByteStreamController.prototype.error = function (e) { if (IsReadableByteStreamController(this) === false) { throw byteStreamControllerBrandCheckException('error'); } ReadableByteStreamControllerError(this, e); }; ReadableByteStreamController.prototype[CancelSteps] = function (reason) { if (this._pendingPullIntos.length > 0) { var firstDescriptor = this._pendingPullIntos.peek(); firstDescriptor.bytesFilled = 0; } ResetQueue(this); var result = this._cancelAlgorithm(reason); ReadableByteStreamControllerClearAlgorithms(this); return result; }; ReadableByteStreamController.prototype[PullSteps] = function () { var stream = this._controlledReadableByteStream; if (this._queueTotalSize > 0) { var entry = this._queue.shift(); this._queueTotalSize -= entry.byteLength; ReadableByteStreamControllerHandleQueueDrain(this); var view = void 0; try { view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength); } catch (viewE) { return promiseRejectedWith(viewE); } return promiseResolvedWith(ReadableStreamCreateReadResult(view, false, stream._reader._forAuthorCode)); } var autoAllocateChunkSize = this._autoAllocateChunkSize; if (autoAllocateChunkSize !== undefined) { var buffer = void 0; try { buffer = new ArrayBuffer(autoAllocateChunkSize); } catch (bufferE) { return promiseRejectedWith(bufferE); } var pullIntoDescriptor = { buffer: buffer, byteOffset: 0, byteLength: autoAllocateChunkSize, bytesFilled: 0, elementSize: 1, ctor: Uint8Array, readerType: 'default' }; this._pendingPullIntos.push(pullIntoDescriptor); } var promise = ReadableStreamAddReadRequest(stream); ReadableByteStreamControllerCallPullIfNeeded(this); return promise; }; return ReadableByteStreamController; }(); function IsReadableByteStreamController(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) { return false; } return true; } function IsReadableStreamBYOBRequest(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) { return false; } return true; } function ReadableByteStreamControllerCallPullIfNeeded(controller) { var shouldPull = ReadableByteStreamControllerShouldCallPull(controller); if (shouldPull === false) { return; } if (controller._pulling === true) { controller._pullAgain = true; return; } controller._pulling = true; var pullPromise = controller._pullAlgorithm(); uponPromise(pullPromise, function () { controller._pulling = false; if (controller._pullAgain === true) { controller._pullAgain = false; ReadableByteStreamControllerCallPullIfNeeded(controller); } }, function (e) { ReadableByteStreamControllerError(controller, e); }); } function ReadableByteStreamControllerClearPendingPullIntos(controller) { ReadableByteStreamControllerInvalidateBYOBRequest(controller); controller._pendingPullIntos = new SimpleQueue(); } function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) { var done = false; if (stream._state === 'closed') { done = true; } var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor); if (pullIntoDescriptor.readerType === 'default') { ReadableStreamFulfillReadRequest(stream, filledView, done); } else { ReadableStreamFulfillReadIntoRequest(stream, filledView, done); } } function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) { var bytesFilled = pullIntoDescriptor.bytesFilled; var elementSize = pullIntoDescriptor.elementSize; return new pullIntoDescriptor.ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize); } function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) { controller._queue.push({ buffer: buffer, byteOffset: byteOffset, byteLength: byteLength }); controller._queueTotalSize += byteLength; } function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) { var elementSize = pullIntoDescriptor.elementSize; var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize; var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled); var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy; var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize; var totalBytesToCopyRemaining = maxBytesToCopy; var ready = false; if (maxAlignedBytes > currentAlignedBytes) { totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled; ready = true; } var queue = controller._queue; while (totalBytesToCopyRemaining > 0) { var headOfQueue = queue.peek(); var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength); var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled; ArrayBufferCopy(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy); if (headOfQueue.byteLength === bytesToCopy) { queue.shift(); } else { headOfQueue.byteOffset += bytesToCopy; headOfQueue.byteLength -= bytesToCopy; } controller._queueTotalSize -= bytesToCopy; ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor); totalBytesToCopyRemaining -= bytesToCopy; } return ready; } function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) { ReadableByteStreamControllerInvalidateBYOBRequest(controller); pullIntoDescriptor.bytesFilled += size; } function ReadableByteStreamControllerHandleQueueDrain(controller) { if (controller._queueTotalSize === 0 && controller._closeRequested === true) { ReadableByteStreamControllerClearAlgorithms(controller); ReadableStreamClose(controller._controlledReadableByteStream); } else { ReadableByteStreamControllerCallPullIfNeeded(controller); } } function ReadableByteStreamControllerInvalidateBYOBRequest(controller) { if (controller._byobRequest === undefined) { return; } controller._byobRequest._associatedReadableByteStreamController = undefined; controller._byobRequest._view = undefined; controller._byobRequest = undefined; } function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) { while (controller._pendingPullIntos.length > 0) { if (controller._queueTotalSize === 0) { return; } var pullIntoDescriptor = controller._pendingPullIntos.peek(); if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) { ReadableByteStreamControllerShiftPendingPullInto(controller); ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor); } } } function ReadableByteStreamControllerPullInto(controller, view) { var stream = controller._controlledReadableByteStream; var elementSize = 1; if (view.constructor !== DataView) { elementSize = view.constructor.BYTES_PER_ELEMENT; } var ctor = view.constructor; var buffer = TransferArrayBuffer(view.buffer); var pullIntoDescriptor = { buffer: buffer, byteOffset: view.byteOffset, byteLength: view.byteLength, bytesFilled: 0, elementSize: elementSize, ctor: ctor, readerType: 'byob' }; if (controller._pendingPullIntos.length > 0) { controller._pendingPullIntos.push(pullIntoDescriptor); return ReadableStreamAddReadIntoRequest(stream); } if (stream._state === 'closed') { var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0); return promiseResolvedWith(ReadableStreamCreateReadResult(emptyView, true, stream._reader._forAuthorCode)); } if (controller._queueTotalSize > 0) { if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) === true) { var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor); ReadableByteStreamControllerHandleQueueDrain(controller); return promiseResolvedWith(ReadableStreamCreateReadResult(filledView, false, stream._reader._forAuthorCode)); } if (controller._closeRequested === true) { var e = new TypeError('Insufficient bytes to fill elements in the given buffer'); ReadableByteStreamControllerError(controller, e); return promiseRejectedWith(e); } } controller._pendingPullIntos.push(pullIntoDescriptor); var promise = ReadableStreamAddReadIntoRequest(stream); ReadableByteStreamControllerCallPullIfNeeded(controller); return promise; } function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) { firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer); var stream = controller._controlledReadableByteStream; if (ReadableStreamHasBYOBReader(stream) === true) { while (ReadableStreamGetNumReadIntoRequests(stream) > 0) { var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller); ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor); } } } function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) { if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) { throw new RangeError('bytesWritten out of range'); } ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor); if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) { return; } ReadableByteStreamControllerShiftPendingPullInto(controller); var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize; if (remainderSize > 0) { var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled; var remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end); ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength); } pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer); pullIntoDescriptor.bytesFilled -= remainderSize; ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor); ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller); } function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) { var firstDescriptor = controller._pendingPullIntos.peek(); var stream = controller._controlledReadableByteStream; if (stream._state === 'closed') { if (bytesWritten !== 0) { throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream'); } ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor); } else { ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor); } ReadableByteStreamControllerCallPullIfNeeded(controller); } function ReadableByteStreamControllerShiftPendingPullInto(controller) { var descriptor = controller._pendingPullIntos.shift(); ReadableByteStreamControllerInvalidateBYOBRequest(controller); return descriptor; } function ReadableByteStreamControllerShouldCallPull(controller) { var stream = controller._controlledReadableByteStream; if (stream._state !== 'readable') { return false; } if (controller._closeRequested === true) { return false; } if (controller._started === false) { return false; } if (ReadableStreamHasDefaultReader(stream) === true && ReadableStreamGetNumReadRequests(stream) > 0) { return true; } if (ReadableStreamHasBYOBReader(stream) === true && ReadableStreamGetNumReadIntoRequests(stream) > 0) { return true; } var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller); if (desiredSize > 0) { return true; } return false; } function ReadableByteStreamControllerClearAlgorithms(controller) { controller._pullAlgorithm = undefined; controller._cancelAlgorithm = undefined; } function ReadableByteStreamControllerClose(controller) { var stream = controller._controlledReadableByteStream; if (controller._queueTotalSize > 0) { controller._closeRequested = true; return; } if (controller._pendingPullIntos.length > 0) { var firstPendingPullInto = controller._pendingPullIntos.peek(); if (firstPendingPullInto.bytesFilled > 0) { var e = new TypeError('Insufficient bytes to fill elements in the given buffer'); ReadableByteStreamControllerError(controller, e); throw e; } } ReadableByteStreamControllerClearAlgorithms(controller); ReadableStreamClose(stream); } function ReadableByteStreamControllerEnqueue(controller, chunk) { var stream = controller._controlledReadableByteStream; var buffer = chunk.buffer; var byteOffset = chunk.byteOffset; var byteLength = chunk.byteLength; var transferredBuffer = TransferArrayBuffer(buffer); if (ReadableStreamHasDefaultReader(stream) === true) { if (ReadableStreamGetNumReadRequests(stream) === 0) { ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength); } else { var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength); ReadableStreamFulfillReadRequest(stream, transferredView, false); } } else if (ReadableStreamHasBYOBReader(stream) === true) { ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength); ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller); } else { ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength); } ReadableByteStreamControllerCallPullIfNeeded(controller); } function ReadableByteStreamControllerError(controller, e) { var stream = controller._controlledReadableByteStream; if (stream._state !== 'readable') { return; } ReadableByteStreamControllerClearPendingPullIntos(controller); ResetQueue(controller); ReadableByteStreamControllerClearAlgorithms(controller); ReadableStreamError(stream, e); } function ReadableByteStreamControllerGetDesiredSize(controller) { var stream = controller._controlledReadableByteStream; var state = stream._state; if (state === 'errored') { return null; } if (state === 'closed') { return 0; } return controller._strategyHWM - controller._queueTotalSize; } function ReadableByteStreamControllerRespond(controller, bytesWritten) { bytesWritten = Number(bytesWritten); if (IsFiniteNonNegativeNumber(bytesWritten) === false) { throw new RangeError('bytesWritten must be a finite'); } ReadableByteStreamControllerRespondInternal(controller, bytesWritten); } function ReadableByteStreamControllerRespondWithNewView(controller, view) { var firstDescriptor = controller._pendingPullIntos.peek(); if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) { throw new RangeError('The region specified by view does not match byobRequest'); } if (firstDescriptor.byteLength !== view.byteLength) { throw new RangeError('The buffer of view has different capacity than byobRequest'); } firstDescriptor.buffer = view.buffer; ReadableByteStreamControllerRespondInternal(controller, view.byteLength); } function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) { controller._controlledReadableByteStream = stream; controller._pullAgain = false; controller._pulling = false; controller._byobRequest = undefined; controller._queue = controller._queueTotalSize = undefined; ResetQueue(controller); controller._closeRequested = false; controller._started = false; controller._strategyHWM = ValidateAndNormalizeHighWaterMark(highWaterMark); controller._pullAlgorithm = pullAlgorithm; controller._cancelAlgorithm = cancelAlgorithm; controller._autoAllocateChunkSize = autoAllocateChunkSize; controller._pendingPullIntos = new SimpleQueue(); stream._readableStreamController = controller; var startResult = startAlgorithm(); uponPromise(promiseResolvedWith(startResult), function () { controller._started = true; ReadableByteStreamControllerCallPullIfNeeded(controller); }, function (r) { ReadableByteStreamControllerError(controller, r); }); } function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) { var controller = Object.create(ReadableByteStreamController.prototype); function startAlgorithm() { return InvokeOrNoop(underlyingByteSource, 'start', [controller]); } var pullAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'pull', 0, [controller]); var cancelAlgorithm = CreateAlgorithmFromUnderlyingMethod(underlyingByteSource, 'cancel', 1, []); var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize; if (autoAllocateChunkSize !== undefined) { autoAllocateChunkSize = Number(autoAllocateChunkSize); if (NumberIsInteger(autoAllocateChunkSize) === false || autoAllocateChunkSize <= 0) { throw new RangeError('autoAllocateChunkSize must be a positive integer'); } } SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize); } function SetUpReadableStreamBYOBRequest(request, controller, view) { request._associatedReadableByteStreamController = controller; request._view = view; } function byobRequestBrandCheckException(name) { return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest"); } function byteStreamControllerBrandCheckException(name) { return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController"); } function AcquireReadableStreamBYOBReader(stream, forAuthorCode) { if (forAuthorCode === void 0) { forAuthorCode = false; } var reader = new ReadableStreamBYOBReader(stream); reader._forAuthorCode = forAuthorCode; return reader; } function ReadableStreamAddReadIntoRequest(stream) { var promise = newPromise(function (resolve, reject) { var readIntoRequest = { _resolve: resolve, _reject: reject }; stream._reader._readIntoRequests.push(readIntoRequest); }); return promise; } function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) { var reader = stream._reader; var readIntoRequest = reader._readIntoRequests.shift(); readIntoRequest._resolve(ReadableStreamCreateReadResult(chunk, done, reader._forAuthorCode)); } function ReadableStreamGetNumReadIntoRequests(stream) { return stream._reader._readIntoRequests.length; } function ReadableStreamHasBYOBReader(stream) { var reader = stream._reader; if (reader === undefined) { return false; } if (!IsReadableStreamBYOBReader(reader)) { return false; } return true; } var ReadableStreamBYOBReader = function () { function ReadableStreamBYOBReader(stream) { if (!IsReadableStream(stream)) { throw new TypeError('ReadableStreamBYOBReader can only be constructed with a ReadableStream instance given a ' + 'byte source'); } if (IsReadableByteStreamController(stream._readableStreamController) === false) { throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source'); } if (IsReadableStreamLocked(stream)) { throw new TypeError('This stream has already been locked for exclusive reading by another reader'); } ReadableStreamReaderGenericInitialize(this, stream); this._readIntoRequests = new SimpleQueue(); } Object.defineProperty(ReadableStreamBYOBReader.prototype, "closed", { get: function () { if (!IsReadableStreamBYOBReader(this)) { return promiseRejectedWith(byobReaderBrandCheckException('closed')); } return this._closedPromise; }, enumerable: true, configurable: true }); ReadableStreamBYOBReader.prototype.cancel = function (reason) { if (!IsReadableStreamBYOBReader(this)) { return promiseRejectedWith(byobReaderBrandCheckException('cancel')); } if (this._ownerReadableStream === undefined) { return promiseRejectedWith(readerLockException('cancel')); } return ReadableStreamReaderGenericCancel(this, reason); }; ReadableStreamBYOBReader.prototype.read = function (view) { if (!IsReadableStreamBYOBReader(this)) { return promiseRejectedWith(byobReaderBrandCheckException('read')); } if (this._ownerReadableStream === undefined) { return promiseRejectedWith(readerLockException('read from')); } if (!ArrayBuffer.isView(view)) { return promiseRejectedWith(new TypeError('view must be an array buffer view')); } if (IsDetachedBuffer(view.buffer) === true); if (view.byteLength === 0) { return promiseRejectedWith(new TypeError('view must have non-zero byteLength')); } return ReadableStreamBYOBReaderRead(this, view); }; ReadableStreamBYOBReader.prototype.releaseLock = function () { if (!IsReadableStreamBYOBReader(this)) { throw byobReaderBrandCheckException('releaseLock'); } if (this._ownerReadableStream === undefined) { return; } if (this._readIntoRequests.length > 0) { throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled'); } ReadableStreamReaderGenericRelease(this); }; return ReadableStreamBYOBReader; }(); function IsReadableStreamBYOBReader(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) { return false; } return true; } function ReadableStreamBYOBReaderRead(reader, view) { var stream = reader._ownerReadableStream; stream._disturbed = true; if (stream._state === 'errored') { return promiseRejectedWith(stream._storedError); } return ReadableByteStreamControllerPullInto(stream._readableStreamController, view); } function byobReaderBrandCheckException(name) { return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader"); } var ReadableStream = function () { function ReadableStream(underlyingSource, strategy) { if (underlyingSource === void 0) { underlyingSource = {}; } if (strategy === void 0) { strategy = {}; } InitializeReadableStream(this); var size = strategy.size; var highWaterMark = strategy.highWaterMark; var type = underlyingSource.type; var typeString = String(type); if (typeString === 'bytes') { if (size !== undefined) { throw new RangeError('The strategy for a byte stream cannot have a size function'); } if (highWaterMark === undefined) { highWaterMark = 0; } highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark); SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark); } else if (type === undefined) { var sizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(size); if (highWaterMark === undefined) { highWaterMark = 1; } highWaterMark = ValidateAndNormalizeHighWaterMark(highWaterMark); SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm); } else { throw new RangeError('Invalid type is specified'); } } Object.defineProperty(ReadableStream.prototype, "locked", { get: function () { if (IsReadableStream(this) === false) { throw streamBrandCheckException$1('locked'); } return IsReadableStreamLocked(this); }, enumerable: true, configurable: true }); ReadableStream.prototype.cancel = function (reason) { if (IsReadableStream(this) === false) { return promiseRejectedWith(streamBrandCheckException$1('cancel')); } if (IsReadableStreamLocked(this) === true) { return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader')); } return ReadableStreamCancel(this, reason); }; ReadableStream.prototype.getReader = function (_a) { var mode = (_a === void 0 ? {} : _a).mode; if (IsReadableStream(this) === false) { throw streamBrandCheckException$1('getReader'); } if (mode === undefined) { return AcquireReadableStreamDefaultReader(this, true); } mode = String(mode); if (mode === 'byob') { return AcquireReadableStreamBYOBReader(this, true); } throw new RangeError('Invalid mode is specified'); }; ReadableStream.prototype.pipeThrough = function (_a, _b) { var writable = _a.writable, readable = _a.readable; var _c = _b === void 0 ? {} : _b, preventClose = _c.preventClose, preventAbort = _c.preventAbort, preventCancel = _c.preventCancel, signal = _c.signal; if (IsReadableStream(this) === false) { throw streamBrandCheckException$1('pipeThrough'); } if (IsWritableStream(writable) === false) { throw new TypeError('writable argument to pipeThrough must be a WritableStream'); } if (IsReadableStream(readable) === false) { throw new TypeError('readable argument to pipeThrough must be a ReadableStream'); } preventClose = Boolean(preventClose); preventAbort = Boolean(preventAbort); preventCancel = Boolean(preventCancel); if (signal !== undefined && !isAbortSignal(signal)) { throw new TypeError('ReadableStream.prototype.pipeThrough\'s signal option must be an AbortSignal'); } if (IsReadableStreamLocked(this) === true) { throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream'); } if (IsWritableStreamLocked(writable) === true) { throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream'); } var promise = ReadableStreamPipeTo(this, writable, preventClose, preventAbort, preventCancel, signal); setPromiseIsHandledToTrue(promise); return readable; }; ReadableStream.prototype.pipeTo = function (dest, _a) { var _b = _a === void 0 ? {} : _a, preventClose = _b.preventClose, preventAbort = _b.preventAbort, preventCancel = _b.preventCancel, signal = _b.signal; if (IsReadableStream(this) === false) { return promiseRejectedWith(streamBrandCheckException$1('pipeTo')); } if (IsWritableStream(dest) === false) { return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo\'s first argument must be a WritableStream')); } preventClose = Boolean(preventClose); preventAbort = Boolean(preventAbort); preventCancel = Boolean(preventCancel); if (signal !== undefined && !isAbortSignal(signal)) { return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo\'s signal option must be an AbortSignal')); } if (IsReadableStreamLocked(this) === true) { return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream')); } if (IsWritableStreamLocked(dest) === true) { return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream')); } return ReadableStreamPipeTo(this, dest, preventClose, preventAbort, preventCancel, signal); }; ReadableStream.prototype.tee = function () { if (IsReadableStream(this) === false) { throw streamBrandCheckException$1('tee'); } var branches = ReadableStreamTee(this); return createArrayFromList(branches); }; ReadableStream.prototype.getIterator = function (_a) { var _b = (_a === void 0 ? {} : _a).preventCancel, preventCancel = _b === void 0 ? false : _b; if (IsReadableStream(this) === false) { throw streamBrandCheckException$1('getIterator'); } return AcquireReadableStreamAsyncIterator(this, preventCancel); }; return ReadableStream; }(); if (typeof SymbolPolyfill.asyncIterator === 'symbol') { Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, { value: ReadableStream.prototype.getIterator, enumerable: false, writable: true, configurable: true }); } function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) { if (highWaterMark === void 0) { highWaterMark = 1; } if (sizeAlgorithm === void 0) { sizeAlgorithm = function () { return 1; }; } var stream = Object.create(ReadableStream.prototype); InitializeReadableStream(stream); var controller = Object.create(ReadableStreamDefaultController.prototype); SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm); return stream; } function InitializeReadableStream(stream) { stream._state = 'readable'; stream._reader = undefined; stream._storedError = undefined; stream._disturbed = false; } function IsReadableStream(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) { return false; } return true; } function IsReadableStreamLocked(stream) { if (stream._reader === undefined) { return false; } return true; } function ReadableStreamCancel(stream, reason) { stream._disturbed = true; if (stream._state === 'closed') { return promiseResolvedWith(undefined); } if (stream._state === 'errored') { return promiseRejectedWith(stream._storedError); } ReadableStreamClose(stream); var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason); return transformPromiseWith(sourceCancelPromise, noop); } function ReadableStreamClose(stream) { stream._state = 'closed'; var reader = stream._reader; if (reader === undefined) { return; } if (IsReadableStreamDefaultReader(reader)) { reader._readRequests.forEach(function (readRequest) { readRequest._resolve(ReadableStreamCreateReadResult(undefined, true, reader._forAuthorCode)); }); reader._readRequests = new SimpleQueue(); } defaultReaderClosedPromiseResolve(reader); } function ReadableStreamError(stream, e) { stream._state = 'errored'; stream._storedError = e; var reader = stream._reader; if (reader === undefined) { return; } if (IsReadableStreamDefaultReader(reader)) { reader._readRequests.forEach(function (readRequest) { readRequest._reject(e); }); reader._readRequests = new SimpleQueue(); } else { reader._readIntoRequests.forEach(function (readIntoRequest) { readIntoRequest._reject(e); }); reader._readIntoRequests = new SimpleQueue(); } defaultReaderClosedPromiseReject(reader, e); } function streamBrandCheckException$1(name) { return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream"); } var ByteLengthQueuingStrategy = function () { function ByteLengthQueuingStrategy(_a) { var highWaterMark = _a.highWaterMark; this.highWaterMark = highWaterMark; } ByteLengthQueuingStrategy.prototype.size = function (chunk) { return chunk.byteLength; }; return ByteLengthQueuingStrategy; }(); var CountQueuingStrategy = function () { function CountQueuingStrategy(_a) { var highWaterMark = _a.highWaterMark; this.highWaterMark = highWaterMark; } CountQueuingStrategy.prototype.size = function () { return 1; }; return CountQueuingStrategy; }(); var TransformStream = function () { function TransformStream(transformer, writableStrategy, readableStrategy) { if (transformer === void 0) { transformer = {}; } if (writableStrategy === void 0) { writableStrategy = {}; } if (readableStrategy === void 0) { readableStrategy = {}; } var writableSizeFunction = writableStrategy.size; var writableHighWaterMark = writableStrategy.highWaterMark; var readableSizeFunction = readableStrategy.size; var readableHighWaterMark = readableStrategy.highWaterMark; var writableType = transformer.writableType; if (writableType !== undefined) { throw new RangeError('Invalid writable type specified'); } var writableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(writableSizeFunction); if (writableHighWaterMark === undefined) { writableHighWaterMark = 1; } writableHighWaterMark = ValidateAndNormalizeHighWaterMark(writableHighWaterMark); var readableType = transformer.readableType; if (readableType !== undefined) { throw new RangeError('Invalid readable type specified'); } var readableSizeAlgorithm = MakeSizeAlgorithmFromSizeFunction(readableSizeFunction); if (readableHighWaterMark === undefined) { readableHighWaterMark = 0; } readableHighWaterMark = ValidateAndNormalizeHighWaterMark(readableHighWaterMark); var startPromise_resolve; var startPromise = newPromise(function (resolve) { startPromise_resolve = resolve; }); InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm); SetUpTransformStreamDefaultControllerFromTransformer(this, transformer); var startResult = InvokeOrNoop(transformer, 'start', [this._transformStreamController]); startPromise_resolve(startResult); } Object.defineProperty(TransformStream.prototype, "readable", { get: function () { if (IsTransformStream(this) === false) { throw streamBrandCheckException$2('readable'); } return this._readable; }, enumerable: true, configurable: true }); Object.defineProperty(TransformStream.prototype, "writable", { get: function () { if (IsTransformStream(this) === false) { throw streamBrandCheckException$2('writable'); } return this._writable; }, enumerable: true, configurable: true }); return TransformStream; }(); function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) { function startAlgorithm() { return startPromise; } function writeAlgorithm(chunk) { return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk); } function abortAlgorithm(reason) { return TransformStreamDefaultSinkAbortAlgorithm(stream, reason); } function closeAlgorithm() { return TransformStreamDefaultSinkCloseAlgorithm(stream); } stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm); function pullAlgorithm() { return TransformStreamDefaultSourcePullAlgorithm(stream); } function cancelAlgorithm(reason) { TransformStreamErrorWritableAndUnblockWrite(stream, reason); return promiseResolvedWith(undefined); } stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm); stream._backpressure = undefined; stream._backpressureChangePromise = undefined; stream._backpressureChangePromise_resolve = undefined; TransformStreamSetBackpressure(stream, true); stream._transformStreamController = undefined; } function IsTransformStream(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) { return false; } return true; } function TransformStreamError(stream, e) { ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e); TransformStreamErrorWritableAndUnblockWrite(stream, e); } function TransformStreamErrorWritableAndUnblockWrite(stream, e) { TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController); WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e); if (stream._backpressure === true) { TransformStreamSetBackpressure(stream, false); } } function TransformStreamSetBackpressure(stream, backpressure) { if (stream._backpressureChangePromise !== undefined) { stream._backpressureChangePromise_resolve(); } stream._backpressureChangePromise = newPromise(function (resolve) { stream._backpressureChangePromise_resolve = resolve; }); stream._backpressure = backpressure; } var TransformStreamDefaultController = function () { function TransformStreamDefaultController() { throw new TypeError('TransformStreamDefaultController instances cannot be created directly'); } Object.defineProperty(TransformStreamDefaultController.prototype, "desiredSize", { get: function () { if (IsTransformStreamDefaultController(this) === false) { throw defaultControllerBrandCheckException$1('desiredSize'); } var readableController = this._controlledTransformStream._readable._readableStreamController; return ReadableStreamDefaultControllerGetDesiredSize(readableController); }, enumerable: true, configurable: true }); TransformStreamDefaultController.prototype.enqueue = function (chunk) { if (IsTransformStreamDefaultController(this) === false) { throw defaultControllerBrandCheckException$1('enqueue'); } TransformStreamDefaultControllerEnqueue(this, chunk); }; TransformStreamDefaultController.prototype.error = function (reason) { if (IsTransformStreamDefaultController(this) === false) { throw defaultControllerBrandCheckException$1('error'); } TransformStreamDefaultControllerError(this, reason); }; TransformStreamDefaultController.prototype.terminate = function () { if (IsTransformStreamDefaultController(this) === false) { throw defaultControllerBrandCheckException$1('terminate'); } TransformStreamDefaultControllerTerminate(this); }; return TransformStreamDefaultController; }(); function IsTransformStreamDefaultController(x) { if (!typeIsObject(x)) { return false; } if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) { return false; } return true; } function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) { controller._controlledTransformStream = stream; stream._transformStreamController = controller; controller._transformAlgorithm = transformAlgorithm; controller._flushAlgorithm = flushAlgorithm; } function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) { var controller = Object.create(TransformStreamDefaultController.prototype); var transformAlgorithm = function (chunk) { try { TransformStreamDefaultControllerEnqueue(controller, chunk); return promiseResolvedWith(undefined); } catch (transformResultE) { return promiseRejectedWith(transformResultE); } }; var transformMethod = transformer.transform; if (transformMethod !== undefined) { if (typeof transformMethod !== 'function') { throw new TypeError('transform is not a method'); } transformAlgorithm = function (chunk) { return PromiseCall(transformMethod, transformer, [ chunk, controller ]); }; } var flushAlgorithm = CreateAlgorithmFromUnderlyingMethod(transformer, 'flush', 0, [controller]); SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm); } function TransformStreamDefaultControllerClearAlgorithms(controller) { controller._transformAlgorithm = undefined; controller._flushAlgorithm = undefined; } function TransformStreamDefaultControllerEnqueue(controller, chunk) { var stream = controller._controlledTransformStream; var readableController = stream._readable._readableStreamController; if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === false) { throw new TypeError('Readable side is not in a state that permits enqueue'); } try { ReadableStreamDefaultControllerEnqueue(readableController, chunk); } catch (e) { TransformStreamErrorWritableAndUnblockWrite(stream, e); throw stream._readable._storedError; } var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController); if (backpressure !== stream._backpressure) { TransformStreamSetBackpressure(stream, true); } } function TransformStreamDefaultControllerError(controller, e) { TransformStreamError(controller._controlledTransformStream, e); } function TransformStreamDefaultControllerPerformTransform(controller, chunk) { var transformPromise = controller._transformAlgorithm(chunk); return transformPromiseWith(transformPromise, undefined, function (r) { TransformStreamError(controller._controlledTransformStream, r); throw r; }); } function TransformStreamDefaultControllerTerminate(controller) { var stream = controller._controlledTransformStream; var readableController = stream._readable._readableStreamController; if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) { ReadableStreamDefaultControllerClose(readableController); } var error = new TypeError('TransformStream terminated'); TransformStreamErrorWritableAndUnblockWrite(stream, error); } function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) { var controller = stream._transformStreamController; if (stream._backpressure === true) { var backpressureChangePromise = stream._backpressureChangePromise; return transformPromiseWith(backpressureChangePromise, function () { var writable = stream._writable; var state = writable._state; if (state === 'erroring') { throw writable._storedError; } return TransformStreamDefaultControllerPerformTransform(controller, chunk); }); } return TransformStreamDefaultControllerPerformTransform(controller, chunk); } function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) { TransformStreamError(stream, reason); return promiseResolvedWith(undefined); } function TransformStreamDefaultSinkCloseAlgorithm(stream) { var readable = stream._readable; var controller = stream._transformStreamController; var flushPromise = controller._flushAlgorithm(); TransformStreamDefaultControllerClearAlgorithms(controller); return transformPromiseWith(flushPromise, function () { if (readable._state === 'errored') { throw readable._storedError; } var readableController = readable._readableStreamController; if (ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController) === true) { ReadableStreamDefaultControllerClose(readableController); } }, function (r) { TransformStreamError(stream, r); throw readable._storedError; }); } function TransformStreamDefaultSourcePullAlgorithm(stream) { TransformStreamSetBackpressure(stream, false); return stream._backpressureChangePromise; } function defaultControllerBrandCheckException$1(name) { return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController"); } function streamBrandCheckException$2(name) { return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream"); } exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy; exports.CountQueuingStrategy = CountQueuingStrategy; exports.ReadableStream = ReadableStream; exports.TransformStream = TransformStream; exports.WritableStream = WritableStream; Object.defineProperty(exports, '__esModule', { value: true }); }));
/***/ }),
/* 148 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(149); __w_pdfjs_require__(117); __w_pdfjs_require__(77); __w_pdfjs_require__(137); var path = __w_pdfjs_require__(43); module.exports = path.Map;
/***/ }),
/* 149 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var collection = __w_pdfjs_require__(150); var collectionStrong = __w_pdfjs_require__(154); module.exports = collection('Map', function (init) { return function Map() { return init(this, arguments.length ? arguments[0] : undefined); }; }, collectionStrong);
/***/ }),
/* 150 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var global = __w_pdfjs_require__(11); var isForced = __w_pdfjs_require__(52); var redefine = __w_pdfjs_require__(29); var InternalMetadataModule = __w_pdfjs_require__(151); var iterate = __w_pdfjs_require__(116); var anInstance = __w_pdfjs_require__(123); var isObject = __w_pdfjs_require__(22); var fails = __w_pdfjs_require__(14); var checkCorrectnessOfIteration = __w_pdfjs_require__(98); var setToStringTag = __w_pdfjs_require__(85); var inheritIfRequired = __w_pdfjs_require__(153); module.exports = function (CONSTRUCTOR_NAME, wrapper, common) { var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1; var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1; var ADDER = IS_MAP ? 'set' : 'add'; var NativeConstructor = global[CONSTRUCTOR_NAME]; var NativePrototype = NativeConstructor && NativeConstructor.prototype; var Constructor = NativeConstructor; var exported = {}; var fixMethod = function (KEY) { var nativeMethod = NativePrototype[KEY]; redefine(NativePrototype, KEY, KEY == 'add' ? function add(value) { nativeMethod.call(this, value === 0 ? 0 : value); return this; } : KEY == 'delete' ? function (key) { return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key); } : KEY == 'get' ? function get(key) { return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key); } : KEY == 'has' ? function has(key) { return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key); } : function set(key, value) { nativeMethod.call(this, key === 0 ? 0 : key, value); return this; }); }; if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () { new NativeConstructor().entries().next(); })))) { Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER); InternalMetadataModule.REQUIRED = true; } else if (isForced(CONSTRUCTOR_NAME, true)) { var instance = new Constructor(); var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); }); var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); }); var BUGGY_ZERO = !IS_WEAK && fails(function () { var $instance = new NativeConstructor(); var index = 5; while (index--) $instance[ADDER](index, index); return !$instance.has(-0); }); if (!ACCEPT_ITERABLES) { Constructor = wrapper(function (dummy, iterable) { anInstance(dummy, Constructor, CONSTRUCTOR_NAME); var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor); if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP }); return that; }); Constructor.prototype = NativePrototype; NativePrototype.constructor = Constructor; } if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) { fixMethod('delete'); fixMethod('has'); IS_MAP && fixMethod('get'); } if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear; } exported[CONSTRUCTOR_NAME] = Constructor; $({ global: true, forced: Constructor != NativeConstructor }, exported); setToStringTag(Constructor, CONSTRUCTOR_NAME); if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP); return Constructor; };
/***/ }),
/* 151 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var hiddenKeys = __w_pdfjs_require__(39); var isObject = __w_pdfjs_require__(22); var has = __w_pdfjs_require__(23); var defineProperty = __w_pdfjs_require__(27).f; var uid = __w_pdfjs_require__(38); var FREEZING = __w_pdfjs_require__(152); var METADATA = uid('meta'); var id = 0; var isExtensible = Object.isExtensible || function () { return true; }; var setMetadata = function (it) { defineProperty(it, METADATA, { value: { objectID: 'O' + ++id, weakData: {} } }); }; var fastKey = function (it, create) { if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it; if (!has(it, METADATA)) { if (!isExtensible(it)) return 'F'; if (!create) return 'E'; setMetadata(it); } return it[METADATA].objectID; }; var getWeakData = function (it, create) { if (!has(it, METADATA)) { if (!isExtensible(it)) return true; if (!create) return false; setMetadata(it); } return it[METADATA].weakData; }; var onFreeze = function (it) { if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it); return it; }; var meta = module.exports = { REQUIRED: false, fastKey: fastKey, getWeakData: getWeakData, onFreeze: onFreeze }; hiddenKeys[METADATA] = true;
/***/ }),
/* 152 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var fails = __w_pdfjs_require__(14); module.exports = !fails(function () { return Object.isExtensible(Object.preventExtensions({})); });
/***/ }),
/* 153 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var isObject = __w_pdfjs_require__(22); var setPrototypeOf = __w_pdfjs_require__(87); module.exports = function ($this, dummy, Wrapper) { var NewTarget, NewTargetPrototype; if (setPrototypeOf && typeof (NewTarget = dummy.constructor) == 'function' && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype) setPrototypeOf($this, NewTargetPrototype); return $this; };
/***/ }),
/* 154 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var defineProperty = __w_pdfjs_require__(27).f; var create = __w_pdfjs_require__(71); var redefineAll = __w_pdfjs_require__(121); var bind = __w_pdfjs_require__(62); var anInstance = __w_pdfjs_require__(123); var iterate = __w_pdfjs_require__(116); var defineIterator = __w_pdfjs_require__(79); var setSpecies = __w_pdfjs_require__(122); var DESCRIPTORS = __w_pdfjs_require__(13); var fastKey = __w_pdfjs_require__(151).fastKey; var InternalStateModule = __w_pdfjs_require__(33); var setInternalState = InternalStateModule.set; var internalStateGetterFor = InternalStateModule.getterFor; module.exports = { getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) { var C = wrapper(function (that, iterable) { anInstance(that, C, CONSTRUCTOR_NAME); setInternalState(that, { type: CONSTRUCTOR_NAME, index: create(null), first: undefined, last: undefined, size: 0 }); if (!DESCRIPTORS) that.size = 0; if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP }); }); var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME); var define = function (that, key, value) { var state = getInternalState(that); var entry = getEntry(that, key); var previous, index; if (entry) { entry.value = value; } else { state.last = entry = { index: index = fastKey(key, true), key: key, value: value, previous: previous = state.last, next: undefined, removed: false }; if (!state.first) state.first = entry; if (previous) previous.next = entry; if (DESCRIPTORS) state.size++; else that.size++; if (index !== 'F') state.index[index] = entry; } return that; }; var getEntry = function (that, key) { var state = getInternalState(that); var index = fastKey(key); var entry; if (index !== 'F') return state.index[index]; for (entry = state.first; entry; entry = entry.next) { if (entry.key == key) return entry; } }; redefineAll(C.prototype, { clear: function clear() { var that = this; var state = getInternalState(that); var data = state.index; var entry = state.first; while (entry) { entry.removed = true; if (entry.previous) entry.previous = entry.previous.next = undefined; delete data[entry.index]; entry = entry.next; } state.first = state.last = undefined; if (DESCRIPTORS) state.size = 0; else that.size = 0; }, 'delete': function (key) { var that = this; var state = getInternalState(that); var entry = getEntry(that, key); if (entry) { var next = entry.next; var prev = entry.previous; delete state.index[entry.index]; entry.removed = true; if (prev) prev.next = next; if (next) next.previous = prev; if (state.first == entry) state.first = next; if (state.last == entry) state.last = prev; if (DESCRIPTORS) state.size--; else that.size--; } return !!entry; }, forEach: function forEach(callbackfn) { var state = getInternalState(this); var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3); var entry; while (entry = entry ? entry.next : state.first) { boundFunction(entry.value, entry.key, this); while (entry && entry.removed) entry = entry.previous; } }, has: function has(key) { return !!getEntry(this, key); } }); redefineAll(C.prototype, IS_MAP ? { get: function get(key) { var entry = getEntry(this, key); return entry && entry.value; }, set: function set(key, value) { return define(this, key === 0 ? 0 : key, value); } } : { add: function add(value) { return define(this, value = value === 0 ? 0 : value, value); } }); if (DESCRIPTORS) defineProperty(C.prototype, 'size', { get: function () { return getInternalState(this).size; } }); return C; }, setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) { var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator'; var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME); var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME); defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) { setInternalState(this, { type: ITERATOR_NAME, target: iterated, state: getInternalCollectionState(iterated), kind: kind, last: undefined }); }, function () { var state = getInternalIteratorState(this); var kind = state.kind; var entry = state.last; while (entry && entry.removed) entry = entry.previous; if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) { state.target = undefined; return { value: undefined, done: true }; } if (kind == 'keys') return { value: entry.key, done: false }; if (kind == 'values') return { value: entry.value, done: false }; return { value: [ entry.key, entry.value ], done: false }; }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); setSpecies(CONSTRUCTOR_NAME); } };
/***/ }),
/* 155 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(156); __w_pdfjs_require__(117); __w_pdfjs_require__(77); __w_pdfjs_require__(137); var path = __w_pdfjs_require__(43); module.exports = path.Set;
/***/ }),
/* 156 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var collection = __w_pdfjs_require__(150); var collectionStrong = __w_pdfjs_require__(154); module.exports = collection('Set', function (init) { return function Set() { return init(this, arguments.length ? arguments[0] : undefined); }; }, collectionStrong);
/***/ }),
/* 157 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(117); __w_pdfjs_require__(158); __w_pdfjs_require__(137); var path = __w_pdfjs_require__(43); module.exports = path.WeakMap;
/***/ }),
/* 158 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var global = __w_pdfjs_require__(11); var redefineAll = __w_pdfjs_require__(121); var InternalMetadataModule = __w_pdfjs_require__(151); var collection = __w_pdfjs_require__(150); var collectionWeak = __w_pdfjs_require__(159); var isObject = __w_pdfjs_require__(22); var enforceIternalState = __w_pdfjs_require__(33).enforce; var NATIVE_WEAK_MAP = __w_pdfjs_require__(34); var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global; var isExtensible = Object.isExtensible; var InternalWeakMap; var wrapper = function (init) { return function WeakMap() { return init(this, arguments.length ? arguments[0] : undefined); }; }; var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak); if (NATIVE_WEAK_MAP && IS_IE11) { InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true); InternalMetadataModule.REQUIRED = true; var WeakMapPrototype = $WeakMap.prototype; var nativeDelete = WeakMapPrototype['delete']; var nativeHas = WeakMapPrototype.has; var nativeGet = WeakMapPrototype.get; var nativeSet = WeakMapPrototype.set; redefineAll(WeakMapPrototype, { 'delete': function (key) { if (isObject(key) && !isExtensible(key)) { var state = enforceIternalState(this); if (!state.frozen) state.frozen = new InternalWeakMap(); return nativeDelete.call(this, key) || state.frozen['delete'](key); } return nativeDelete.call(this, key); }, has: function has(key) { if (isObject(key) && !isExtensible(key)) { var state = enforceIternalState(this); if (!state.frozen) state.frozen = new InternalWeakMap(); return nativeHas.call(this, key) || state.frozen.has(key); } return nativeHas.call(this, key); }, get: function get(key) { if (isObject(key) && !isExtensible(key)) { var state = enforceIternalState(this); if (!state.frozen) state.frozen = new InternalWeakMap(); return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key); } return nativeGet.call(this, key); }, set: function set(key, value) { if (isObject(key) && !isExtensible(key)) { var state = enforceIternalState(this); if (!state.frozen) state.frozen = new InternalWeakMap(); nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value); } else nativeSet.call(this, key, value); return this; } }); }
/***/ }),
/* 159 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var redefineAll = __w_pdfjs_require__(121); var getWeakData = __w_pdfjs_require__(151).getWeakData; var anObject = __w_pdfjs_require__(28); var isObject = __w_pdfjs_require__(22); var anInstance = __w_pdfjs_require__(123); var iterate = __w_pdfjs_require__(116); var ArrayIterationModule = __w_pdfjs_require__(160); var $has = __w_pdfjs_require__(23); var InternalStateModule = __w_pdfjs_require__(33); var setInternalState = InternalStateModule.set; var internalStateGetterFor = InternalStateModule.getterFor; var find = ArrayIterationModule.find; var findIndex = ArrayIterationModule.findIndex; var id = 0; var uncaughtFrozenStore = function (store) { return store.frozen || (store.frozen = new UncaughtFrozenStore()); }; var UncaughtFrozenStore = function () { this.entries = []; }; var findUncaughtFrozen = function (store, key) { return find(store.entries, function (it) { return it[0] === key; }); }; UncaughtFrozenStore.prototype = { get: function (key) { var entry = findUncaughtFrozen(this, key); if (entry) return entry[1]; }, has: function (key) { return !!findUncaughtFrozen(this, key); }, set: function (key, value) { var entry = findUncaughtFrozen(this, key); if (entry) entry[1] = value; else this.entries.push([ key, value ]); }, 'delete': function (key) { var index = findIndex(this.entries, function (it) { return it[0] === key; }); if (~index) this.entries.splice(index, 1); return !!~index; } }; module.exports = { getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) { var C = wrapper(function (that, iterable) { anInstance(that, C, CONSTRUCTOR_NAME); setInternalState(that, { type: CONSTRUCTOR_NAME, id: id++, frozen: undefined }); if (iterable != undefined) iterate(iterable, that[ADDER], { that: that, AS_ENTRIES: IS_MAP }); }); var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME); var define = function (that, key, value) { var state = getInternalState(that); var data = getWeakData(anObject(key), true); if (data === true) uncaughtFrozenStore(state).set(key, value); else data[state.id] = value; return that; }; redefineAll(C.prototype, { 'delete': function (key) { var state = getInternalState(this); if (!isObject(key)) return false; var data = getWeakData(key); if (data === true) return uncaughtFrozenStore(state)['delete'](key); return data && $has(data, state.id) && delete data[state.id]; }, has: function has(key) { var state = getInternalState(this); if (!isObject(key)) return false; var data = getWeakData(key); if (data === true) return uncaughtFrozenStore(state).has(key); return data && $has(data, state.id); } }); redefineAll(C.prototype, IS_MAP ? { get: function get(key) { var state = getInternalState(this); if (isObject(key)) { var data = getWeakData(key); if (data === true) return uncaughtFrozenStore(state).get(key); return data ? data[state.id] : undefined; } }, set: function set(key, value) { return define(this, key, value); } } : { add: function add(value) { return define(this, value, true); } }); return C; } };
/***/ }),
/* 160 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var bind = __w_pdfjs_require__(62); var IndexedObject = __w_pdfjs_require__(18); var toObject = __w_pdfjs_require__(83); var toLength = __w_pdfjs_require__(47); var arraySpeciesCreate = __w_pdfjs_require__(161); var push = [].push; var createMethod = function (TYPE) { var IS_MAP = TYPE == 1; var IS_FILTER = TYPE == 2; var IS_SOME = TYPE == 3; var IS_EVERY = TYPE == 4; var IS_FIND_INDEX = TYPE == 6; var NO_HOLES = TYPE == 5 || IS_FIND_INDEX; return function ($this, callbackfn, that, specificCreate) { var O = toObject($this); var self = IndexedObject(O); var boundFunction = bind(callbackfn, that, 3); var length = toLength(self.length); var index = 0; var create = specificCreate || arraySpeciesCreate; var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined; var value, result; for (; length > index; index++) if (NO_HOLES || index in self) { value = self[index]; result = boundFunction(value, index, O); if (TYPE) { if (IS_MAP) target[index] = result; else if (result) switch (TYPE) { case 3: return true; case 5: return value; case 6: return index; case 2: push.call(target, value); } else if (IS_EVERY) return false; } } return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target; }; }; module.exports = { forEach: createMethod(0), map: createMethod(1), filter: createMethod(2), some: createMethod(3), every: createMethod(4), find: createMethod(5), findIndex: createMethod(6) };
/***/ }),
/* 161 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var isObject = __w_pdfjs_require__(22); var isArray = __w_pdfjs_require__(162); var wellKnownSymbol = __w_pdfjs_require__(57); var SPECIES = wellKnownSymbol('species'); module.exports = function (originalArray, length) { var C; if (isArray(originalArray)) { C = originalArray.constructor; if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined; else if (isObject(C)) { C = C[SPECIES]; if (C === null) C = undefined; } } return new (C === undefined ? Array : C)(length === 0 ? 0 : length); };
/***/ }),
/* 162 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var classof = __w_pdfjs_require__(19); module.exports = Array.isArray || function isArray(arg) { return classof(arg) == 'Array'; };
/***/ }),
/* 163 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(117); __w_pdfjs_require__(164); __w_pdfjs_require__(137); var path = __w_pdfjs_require__(43); module.exports = path.WeakSet;
/***/ }),
/* 164 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var collection = __w_pdfjs_require__(150); var collectionWeak = __w_pdfjs_require__(159); collection('WeakSet', function (init) { return function WeakSet() { return init(this, arguments.length ? arguments[0] : undefined); }; }, collectionWeak);
/***/ }),
/* 165 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(166); var entryUnbind = __w_pdfjs_require__(61); module.exports = entryUnbind('String', 'codePointAt');
/***/ }),
/* 166 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var codeAt = __w_pdfjs_require__(78).codeAt; $({ target: 'String', proto: true }, { codePointAt: function codePointAt(pos) { return codeAt(this, pos); } });
/***/ }),
/* 167 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(168); var path = __w_pdfjs_require__(43); module.exports = path.String.fromCodePoint;
/***/ }),
/* 168 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); var toAbsoluteIndex = __w_pdfjs_require__(49); var fromCharCode = String.fromCharCode; var nativeFromCodePoint = String.fromCodePoint; var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1; $({ target: 'String', stat: true, forced: INCORRECT_LENGTH }, { fromCodePoint: function fromCodePoint(x) { var elements = []; var length = arguments.length; var i = 0; var code; while (length > i) { code = +arguments[i++]; if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point'); elements.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00)); } return elements.join(''); } });
/***/ }),
/* 169 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(170); __w_pdfjs_require__(117); __w_pdfjs_require__(172); __w_pdfjs_require__(176); __w_pdfjs_require__(177); __w_pdfjs_require__(178); __w_pdfjs_require__(179); __w_pdfjs_require__(180); __w_pdfjs_require__(181); __w_pdfjs_require__(182); __w_pdfjs_require__(183); __w_pdfjs_require__(184); __w_pdfjs_require__(185); __w_pdfjs_require__(186); __w_pdfjs_require__(187); __w_pdfjs_require__(188); __w_pdfjs_require__(189); __w_pdfjs_require__(190); __w_pdfjs_require__(191); __w_pdfjs_require__(192); var path = __w_pdfjs_require__(43); module.exports = path.Symbol;
/***/ }),
/* 170 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var fails = __w_pdfjs_require__(14); var isArray = __w_pdfjs_require__(162); var isObject = __w_pdfjs_require__(22); var toObject = __w_pdfjs_require__(83); var toLength = __w_pdfjs_require__(47); var createProperty = __w_pdfjs_require__(94); var arraySpeciesCreate = __w_pdfjs_require__(161); var arrayMethodHasSpeciesSupport = __w_pdfjs_require__(171); var wellKnownSymbol = __w_pdfjs_require__(57); var V8_VERSION = __w_pdfjs_require__(133); var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable'); var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF; var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded'; var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () { var array = []; array[IS_CONCAT_SPREADABLE] = false; return array.concat()[0] !== array; }); var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat'); var isConcatSpreadable = function (O) { if (!isObject(O)) return false; var spreadable = O[IS_CONCAT_SPREADABLE]; return spreadable !== undefined ? !!spreadable : isArray(O); }; var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT; $({ target: 'Array', proto: true, forced: FORCED }, { concat: function concat(arg) { var O = toObject(this); var A = arraySpeciesCreate(O, 0); var n = 0; var i, k, length, len, E; for (i = -1, length = arguments.length; i < length; i++) { E = i === -1 ? O : arguments[i]; if (isConcatSpreadable(E)) { len = toLength(E.length); if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED); for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]); } else { if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED); createProperty(A, n++, E); } } A.length = n; return A; } });
/***/ }),
/* 171 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var fails = __w_pdfjs_require__(14); var wellKnownSymbol = __w_pdfjs_require__(57); var V8_VERSION = __w_pdfjs_require__(133); var SPECIES = wellKnownSymbol('species'); module.exports = function (METHOD_NAME) { return V8_VERSION >= 51 || !fails(function () { var array = []; var constructor = array.constructor = {}; constructor[SPECIES] = function () { return { foo: 1 }; }; return array[METHOD_NAME](Boolean).foo !== 1; }); };
/***/ }),
/* 172 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var global = __w_pdfjs_require__(11); var getBuiltIn = __w_pdfjs_require__(42); var IS_PURE = __w_pdfjs_require__(37); var DESCRIPTORS = __w_pdfjs_require__(13); var NATIVE_SYMBOL = __w_pdfjs_require__(58); var USE_SYMBOL_AS_UID = __w_pdfjs_require__(59); var fails = __w_pdfjs_require__(14); var has = __w_pdfjs_require__(23); var isArray = __w_pdfjs_require__(162); var isObject = __w_pdfjs_require__(22); var anObject = __w_pdfjs_require__(28); var toObject = __w_pdfjs_require__(83); var toIndexedObject = __w_pdfjs_require__(17); var toPrimitive = __w_pdfjs_require__(21); var createPropertyDescriptor = __w_pdfjs_require__(16); var nativeObjectCreate = __w_pdfjs_require__(71); var objectKeys = __w_pdfjs_require__(73); var getOwnPropertyNamesModule = __w_pdfjs_require__(44); var getOwnPropertyNamesExternal = __w_pdfjs_require__(173); var getOwnPropertySymbolsModule = __w_pdfjs_require__(51); var getOwnPropertyDescriptorModule = __w_pdfjs_require__(12); var definePropertyModule = __w_pdfjs_require__(27); var propertyIsEnumerableModule = __w_pdfjs_require__(15); var createNonEnumerableProperty = __w_pdfjs_require__(26); var redefine = __w_pdfjs_require__(29); var shared = __w_pdfjs_require__(36); var sharedKey = __w_pdfjs_require__(35); var hiddenKeys = __w_pdfjs_require__(39); var uid = __w_pdfjs_require__(38); var wellKnownSymbol = __w_pdfjs_require__(57); var wrappedWellKnownSymbolModule = __w_pdfjs_require__(174); var defineWellKnownSymbol = __w_pdfjs_require__(175); var setToStringTag = __w_pdfjs_require__(85); var InternalStateModule = __w_pdfjs_require__(33); var $forEach = __w_pdfjs_require__(160).forEach; var HIDDEN = sharedKey('hidden'); var SYMBOL = 'Symbol'; var PROTOTYPE = 'prototype'; var TO_PRIMITIVE = wellKnownSymbol('toPrimitive'); var setInternalState = InternalStateModule.set; var getInternalState = InternalStateModule.getterFor(SYMBOL); var ObjectPrototype = Object[PROTOTYPE]; var $Symbol = global.Symbol; var $stringify = getBuiltIn('JSON', 'stringify'); var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f; var nativeDefineProperty = definePropertyModule.f; var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f; var nativePropertyIsEnumerable = propertyIsEnumerableModule.f; var AllSymbols = shared('symbols'); var ObjectPrototypeSymbols = shared('op-symbols'); var StringToSymbolRegistry = shared('string-to-symbol-registry'); var SymbolToStringRegistry = shared('symbol-to-string-registry'); var WellKnownSymbolsStore = shared('wks'); var QObject = global.QObject; var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; var setSymbolDescriptor = DESCRIPTORS && fails(function () { return nativeObjectCreate(nativeDefineProperty({}, 'a', { get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; } })).a != 7; }) ? function (O, P, Attributes) { var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P); if (ObjectPrototypeDescriptor) delete ObjectPrototype[P]; nativeDefineProperty(O, P, Attributes); if (ObjectPrototypeDescriptor && O !== ObjectPrototype) { nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor); } } : nativeDefineProperty; var wrap = function (tag, description) { var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]); setInternalState(symbol, { type: SYMBOL, tag: tag, description: description }); if (!DESCRIPTORS) symbol.description = description; return symbol; }; var isSymbol = USE_SYMBOL_AS_UID ? function (it) { return typeof it == 'symbol'; } : function (it) { return Object(it) instanceof $Symbol; }; var $defineProperty = function defineProperty(O, P, Attributes) { if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes); anObject(O); var key = toPrimitive(P, true); anObject(Attributes); if (has(AllSymbols, key)) { if (!Attributes.enumerable) { if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {})); O[HIDDEN][key] = true; } else { if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false; Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) }); } return setSymbolDescriptor(O, key, Attributes); } return nativeDefineProperty(O, key, Attributes); }; var $defineProperties = function defineProperties(O, Properties) { anObject(O); var properties = toIndexedObject(Properties); var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties)); $forEach(keys, function (key) { if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]); }); return O; }; var $create = function create(O, Properties) { return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties); }; var $propertyIsEnumerable = function propertyIsEnumerable(V) { var P = toPrimitive(V, true); var enumerable = nativePropertyIsEnumerable.call(this, P); if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false; return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true; }; var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) { var it = toIndexedObject(O); var key = toPrimitive(P, true); if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return; var descriptor = nativeGetOwnPropertyDescriptor(it, key); if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) { descriptor.enumerable = true; } return descriptor; }; var $getOwnPropertyNames = function getOwnPropertyNames(O) { var names = nativeGetOwnPropertyNames(toIndexedObject(O)); var result = []; $forEach(names, function (key) { if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key); }); return result; }; var $getOwnPropertySymbols = function getOwnPropertySymbols(O) { var IS_OBJECT_PROTOTYPE = O === ObjectPrototype; var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O)); var result = []; $forEach(names, function (key) { if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) { result.push(AllSymbols[key]); } }); return result; }; if (!NATIVE_SYMBOL) { $Symbol = function Symbol() { if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor'); var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]); var tag = uid(description); var setter = function (value) { if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value); if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false; setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value)); }; if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter }); return wrap(tag, description); }; redefine($Symbol[PROTOTYPE], 'toString', function toString() { return getInternalState(this).tag; }); redefine($Symbol, 'withoutSetter', function (description) { return wrap(uid(description), description); }); propertyIsEnumerableModule.f = $propertyIsEnumerable; definePropertyModule.f = $defineProperty; getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor; getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames; getOwnPropertySymbolsModule.f = $getOwnPropertySymbols; wrappedWellKnownSymbolModule.f = function (name) { return wrap(wellKnownSymbol(name), name); }; if (DESCRIPTORS) { nativeDefineProperty($Symbol[PROTOTYPE], 'description', { configurable: true, get: function description() { return getInternalState(this).description; } }); if (!IS_PURE) { redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true }); } } } $({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, { Symbol: $Symbol }); $forEach(objectKeys(WellKnownSymbolsStore), function (name) { defineWellKnownSymbol(name); }); $({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, { 'for': function (key) { var string = String(key); if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string]; var symbol = $Symbol(string); StringToSymbolRegistry[string] = symbol; SymbolToStringRegistry[symbol] = string; return symbol; }, keyFor: function keyFor(sym) { if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol'); if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym]; }, useSetter: function () { USE_SETTER = true; }, useSimple: function () { USE_SETTER = false; } }); $({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, { create: $create, defineProperty: $defineProperty, defineProperties: $defineProperties, getOwnPropertyDescriptor: $getOwnPropertyDescriptor }); $({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, { getOwnPropertyNames: $getOwnPropertyNames, getOwnPropertySymbols: $getOwnPropertySymbols }); $({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, { getOwnPropertySymbols: function getOwnPropertySymbols(it) { return getOwnPropertySymbolsModule.f(toObject(it)); } }); if ($stringify) { var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () { var symbol = $Symbol(); return $stringify([symbol]) != '[null]' || $stringify({ a: symbol }) != '{}' || $stringify(Object(symbol)) != '{}'; }); $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, { stringify: function stringify(it, replacer, space) { var args = [it]; var index = 1; var $replacer; while (arguments.length > index) args.push(arguments[index++]); $replacer = replacer; if (!isObject(replacer) && it === undefined || isSymbol(it)) return; if (!isArray(replacer)) replacer = function (key, value) { if (typeof $replacer == 'function') value = $replacer.call(this, key, value); if (!isSymbol(value)) return value; }; args[1] = replacer; return $stringify.apply(null, args); } }); } if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) { createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); } setToStringTag($Symbol, SYMBOL); hiddenKeys[HIDDEN] = true;
/***/ }),
/* 173 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var toIndexedObject = __w_pdfjs_require__(17); var nativeGetOwnPropertyNames = __w_pdfjs_require__(44).f; var toString = {}.toString; var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []; var getWindowNames = function (it) { try { return nativeGetOwnPropertyNames(it); } catch (error) { return windowNames.slice(); } }; module.exports.f = function getOwnPropertyNames(it) { return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : nativeGetOwnPropertyNames(toIndexedObject(it)); };
/***/ }),
/* 174 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var wellKnownSymbol = __w_pdfjs_require__(57); exports.f = wellKnownSymbol;
/***/ }),
/* 175 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var path = __w_pdfjs_require__(43); var has = __w_pdfjs_require__(23); var wrappedWellKnownSymbolModule = __w_pdfjs_require__(174); var defineProperty = __w_pdfjs_require__(27).f; module.exports = function (NAME) { var Symbol = path.Symbol || (path.Symbol = {}); if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, { value: wrappedWellKnownSymbolModule.f(NAME) }); };
/***/ }),
/* 176 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('asyncIterator');
/***/ }),
/* 177 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var DESCRIPTORS = __w_pdfjs_require__(13); var global = __w_pdfjs_require__(11); var has = __w_pdfjs_require__(23); var isObject = __w_pdfjs_require__(22); var defineProperty = __w_pdfjs_require__(27).f; var copyConstructorProperties = __w_pdfjs_require__(40); var NativeSymbol = global.Symbol; if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) || NativeSymbol().description !== undefined)) { var EmptyStringDescriptionStore = {}; var SymbolWrapper = function Symbol() { var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]); var result = this instanceof SymbolWrapper ? new NativeSymbol(description) : description === undefined ? NativeSymbol() : NativeSymbol(description); if (description === '') EmptyStringDescriptionStore[result] = true; return result; }; copyConstructorProperties(SymbolWrapper, NativeSymbol); var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype; symbolPrototype.constructor = SymbolWrapper; var symbolToString = symbolPrototype.toString; var native = String(NativeSymbol('test')) == 'Symbol(test)'; var regexp = /^Symbol\((.*)\)[^)]+$/; defineProperty(symbolPrototype, 'description', { configurable: true, get: function description() { var symbol = isObject(this) ? this.valueOf() : this; var string = symbolToString.call(symbol); if (has(EmptyStringDescriptionStore, symbol)) return ''; var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1'); return desc === '' ? undefined : desc; } }); $({ global: true, forced: true }, { Symbol: SymbolWrapper }); }
/***/ }),
/* 178 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('hasInstance');
/***/ }),
/* 179 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('isConcatSpreadable');
/***/ }),
/* 180 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('iterator');
/***/ }),
/* 181 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('match');
/***/ }),
/* 182 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('matchAll');
/***/ }),
/* 183 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('replace');
/***/ }),
/* 184 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('search');
/***/ }),
/* 185 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('species');
/***/ }),
/* 186 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('split');
/***/ }),
/* 187 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('toPrimitive');
/***/ }),
/* 188 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('toStringTag');
/***/ }),
/* 189 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var defineWellKnownSymbol = __w_pdfjs_require__(175); defineWellKnownSymbol('unscopables');
/***/ }),
/* 190 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var global = __w_pdfjs_require__(11); var setToStringTag = __w_pdfjs_require__(85); setToStringTag(global.JSON, 'JSON', true);
/***/ }),
/* 191 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var setToStringTag = __w_pdfjs_require__(85); setToStringTag(Math, 'Math', true);
/***/ }),
/* 192 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); var global = __w_pdfjs_require__(11); var setToStringTag = __w_pdfjs_require__(85); $({ global: true }, { Reflect: {} }); setToStringTag(global.Reflect, 'Reflect', true);
/***/ }),
/* 193 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(194); var entryUnbind = __w_pdfjs_require__(61); module.exports = entryUnbind('String', 'padStart');
/***/ }),
/* 194 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var $padStart = __w_pdfjs_require__(195).start; var WEBKIT_BUG = __w_pdfjs_require__(197); $({ target: 'String', proto: true, forced: WEBKIT_BUG }, { padStart: function padStart(maxLength) { return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined); } });
/***/ }),
/* 195 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var toLength = __w_pdfjs_require__(47); var repeat = __w_pdfjs_require__(196); var requireObjectCoercible = __w_pdfjs_require__(20); var ceil = Math.ceil; var createMethod = function (IS_END) { return function ($this, maxLength, fillString) { var S = String(requireObjectCoercible($this)); var stringLength = S.length; var fillStr = fillString === undefined ? ' ' : String(fillString); var intMaxLength = toLength(maxLength); var fillLen, stringFiller; if (intMaxLength <= stringLength || fillStr == '') return S; fillLen = intMaxLength - stringLength; stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length)); if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen); return IS_END ? S + stringFiller : stringFiller + S; }; }; module.exports = { start: createMethod(false), end: createMethod(true) };
/***/ }),
/* 196 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var toInteger = __w_pdfjs_require__(48); var requireObjectCoercible = __w_pdfjs_require__(20); module.exports = ''.repeat || function repeat(count) { var str = String(requireObjectCoercible(this)); var result = ''; var n = toInteger(count); if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions'); for (; n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str; return result; };
/***/ }),
/* 197 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var userAgent = __w_pdfjs_require__(126);
module.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
/***/ }),
/* 198 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(199); var entryUnbind = __w_pdfjs_require__(61); module.exports = entryUnbind('String', 'padEnd');
/***/ }),
/* 199 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var $ = __w_pdfjs_require__(10); var $padEnd = __w_pdfjs_require__(195).end; var WEBKIT_BUG = __w_pdfjs_require__(197); $({ target: 'String', proto: true, forced: WEBKIT_BUG }, { padEnd: function padEnd(maxLength) { return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined); } });
/***/ }),
/* 200 */
/***/ (function(module, exports, __w_pdfjs_require__) {
__w_pdfjs_require__(201); var path = __w_pdfjs_require__(43); module.exports = path.Object.values;
/***/ }),
/* 201 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var $ = __w_pdfjs_require__(10); var $values = __w_pdfjs_require__(202).values; $({ target: 'Object', stat: true }, { values: function values(O) { return $values(O); } });
/***/ }),
/* 202 */
/***/ (function(module, exports, __w_pdfjs_require__) {
var DESCRIPTORS = __w_pdfjs_require__(13); var objectKeys = __w_pdfjs_require__(73); var toIndexedObject = __w_pdfjs_require__(17); var propertyIsEnumerable = __w_pdfjs_require__(15).f; var createMethod = function (TO_ENTRIES) { return function (it) { var O = toIndexedObject(it); var keys = objectKeys(O); var length = keys.length; var i = 0; var result = []; var key; while (length > i) { key = keys[i++]; if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) { result.push(TO_ENTRIES ? [ key, O[key] ] : O[key]); } } return result; }; }; module.exports = { entries: createMethod(true), values: createMethod(false) };
/***/ }),
/* 203 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.getDocument = getDocument; exports.setPDFNetworkStreamFactory = setPDFNetworkStreamFactory; exports.build = exports.version = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFWorker = exports.PDFDataRangeTransport = exports.LoopbackPort = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2)); var _util = __w_pdfjs_require__(5); var _display_utils = __w_pdfjs_require__(1); var _font_loader = __w_pdfjs_require__(204); var _api_compatibility = __w_pdfjs_require__(205); var _canvas = __w_pdfjs_require__(206); var _worker_options = __w_pdfjs_require__(208); var _is_node = __w_pdfjs_require__(7); var _message_handler = __w_pdfjs_require__(209); var _metadata = __w_pdfjs_require__(210); var _transport_stream = __w_pdfjs_require__(212); var _webgl = __w_pdfjs_require__(213); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); } function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); } function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
var DEFAULT_RANGE_CHUNK_SIZE = 65536; var RENDERING_CANCELLED_TIMEOUT = 100; var createPDFNetworkStream; function setPDFNetworkStreamFactory(pdfNetworkStreamFactory) { createPDFNetworkStream = pdfNetworkStreamFactory; } function getDocument(src) { var task = new PDFDocumentLoadingTask(); var source; if (typeof src === "string") { source = { url: src }; } else if ((0, _util.isArrayBuffer)(src)) { source = { data: src }; } else if (src instanceof PDFDataRangeTransport) { source = { range: src }; } else { if (_typeof(src) !== "object") { throw new Error("Invalid parameter in getDocument, " + "need either Uint8Array, string or a parameter object"); } if (!src.url && !src.data && !src.range) { throw new Error("Invalid parameter object: need either .data, .range or .url"); } source = src; } var params = Object.create(null); var rangeTransport = null, worker = null; for (var key in source) { if (key === "url" && typeof window !== "undefined") { params[key] = new URL(source[key], window.location).href; continue; } else if (key === "range") { rangeTransport = source[key]; continue; } else if (key === "worker") { worker = source[key]; continue; } else if (key === "data" && !(source[key] instanceof Uint8Array)) { var pdfBytes = source[key]; if (typeof pdfBytes === "string") { params[key] = (0, _util.stringToBytes)(pdfBytes); } else if (_typeof(pdfBytes) === "object" && pdfBytes !== null && !isNaN(pdfBytes.length)) { params[key] = new Uint8Array(pdfBytes); } else if ((0, _util.isArrayBuffer)(pdfBytes)) { params[key] = new Uint8Array(pdfBytes); } else { throw new Error("Invalid PDF binary data: either typed array, " + "string or array-like object is expected in the " + "data property."); } continue; } params[key] = source[key]; } params.rangeChunkSize = params.rangeChunkSize || DEFAULT_RANGE_CHUNK_SIZE; params.CMapReaderFactory = params.CMapReaderFactory || _display_utils.DOMCMapReaderFactory; params.ignoreErrors = params.stopAtErrors !== true; params.fontExtraProperties = params.fontExtraProperties === true; params.pdfBug = params.pdfBug === true; if (!Number.isInteger(params.maxImageSize)) { params.maxImageSize = -1; } if (typeof params.isEvalSupported !== "boolean") { params.isEvalSupported = true; } if (typeof params.disableFontFace !== "boolean") { params.disableFontFace = _api_compatibility.apiCompatibilityParams.disableFontFace || false; } if (typeof params.disableRange !== "boolean") { params.disableRange = false; } if (typeof params.disableStream !== "boolean") { params.disableStream = false; } if (typeof params.disableAutoFetch !== "boolean") { params.disableAutoFetch = false; } (0, _util.setVerbosityLevel)(params.verbosity); if (!worker) { var workerParams = { verbosity: params.verbosity, port: _worker_options.GlobalWorkerOptions.workerPort }; worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams); task._worker = worker; } var docId = task.docId; worker.promise.then(function () { if (task.destroyed) { throw new Error("Loading aborted"); } var workerIdPromise = _fetchDocument(worker, params, rangeTransport, docId); var networkStreamPromise = new Promise(function (resolve) { var networkStream; if (rangeTransport) { networkStream = new _transport_stream.PDFDataTransportStream({ length: params.length, initialData: params.initialData, progressiveDone: params.progressiveDone, disableRange: params.disableRange, disableStream: params.disableStream }, rangeTransport); } else if (!params.data) { networkStream = createPDFNetworkStream({ url: params.url, length: params.length, httpHeaders: params.httpHeaders, withCredentials: params.withCredentials, rangeChunkSize: params.rangeChunkSize, disableRange: params.disableRange, disableStream: params.disableStream }); } resolve(networkStream); }); return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) { var _ref2 = _slicedToArray(_ref, 2), workerId = _ref2[0], networkStream = _ref2[1]; if (task.destroyed) { throw new Error("Loading aborted"); } var messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port); messageHandler.postMessageTransfers = worker.postMessageTransfers; var transport = new WorkerTransport(messageHandler, task, networkStream, params); task._transport = transport; messageHandler.send("Ready", null); }); })["catch"](task._capability.reject); return task; } function _fetchDocument(worker, source, pdfDataRangeTransport, docId) { if (worker.destroyed) { return Promise.reject(new Error("Worker was destroyed")); } if (pdfDataRangeTransport) { source.length = pdfDataRangeTransport.length; source.initialData = pdfDataRangeTransport.initialData; source.progressiveDone = pdfDataRangeTransport.progressiveDone; } return worker.messageHandler.sendWithPromise("GetDocRequest", { docId: docId, apiVersion: '2.5.207', source: { data: source.data, url: source.url, password: source.password, disableAutoFetch: source.disableAutoFetch, rangeChunkSize: source.rangeChunkSize, length: source.length }, maxImageSize: source.maxImageSize, disableFontFace: source.disableFontFace, postMessageTransfers: worker.postMessageTransfers, docBaseUrl: source.docBaseUrl, ignoreErrors: source.ignoreErrors, isEvalSupported: source.isEvalSupported, fontExtraProperties: source.fontExtraProperties }).then(function (workerId) { if (worker.destroyed) { throw new Error("Worker was destroyed"); } return workerId; }); } var PDFDocumentLoadingTask = function PDFDocumentLoadingTaskClosure() { var nextDocumentId = 0;
var PDFDocumentLoadingTask = /*#__PURE__*/function () {
function PDFDocumentLoadingTask() { _classCallCheck(this, PDFDocumentLoadingTask); this._capability = (0, _util.createPromiseCapability)(); this._transport = null; this._worker = null; this.docId = "d" + nextDocumentId++; this.destroyed = false; this.onPassword = null; this.onProgress = null; this.onUnsupportedFeature = null; } _createClass(PDFDocumentLoadingTask, [{ key: "destroy", value: function destroy() { var _this = this; this.destroyed = true; var transportDestroyed = !this._transport ? Promise.resolve() : this._transport.destroy(); return transportDestroyed.then(function () { _this._transport = null; if (_this._worker) { _this._worker.destroy(); _this._worker = null; } }); } }, { key: "promise", get: function get() { return this._capability.promise; } }]); return PDFDocumentLoadingTask; }(); return PDFDocumentLoadingTask; }();
var PDFDataRangeTransport = /*#__PURE__*/function () {
function PDFDataRangeTransport(length, initialData) { var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; _classCallCheck(this, PDFDataRangeTransport); this.length = length; this.initialData = initialData; this.progressiveDone = progressiveDone; this._rangeListeners = []; this._progressListeners = []; this._progressiveReadListeners = []; this._progressiveDoneListeners = []; this._readyCapability = (0, _util.createPromiseCapability)(); } _createClass(PDFDataRangeTransport, [{ key: "addRangeListener", value: function addRangeListener(listener) { this._rangeListeners.push(listener); } }, { key: "addProgressListener", value: function addProgressListener(listener) { this._progressListeners.push(listener); } }, { key: "addProgressiveReadListener", value: function addProgressiveReadListener(listener) { this._progressiveReadListeners.push(listener); } }, { key: "addProgressiveDoneListener", value: function addProgressiveDoneListener(listener) { this._progressiveDoneListeners.push(listener); } }, { key: "onDataRange", value: function onDataRange(begin, chunk) { var _iterator = _createForOfIteratorHelper(this._rangeListeners), _step; try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var listener = _step.value; listener(begin, chunk); } } catch (err) { _iterator.e(err); } finally { _iterator.f(); } } }, { key: "onDataProgress", value: function onDataProgress(loaded, total) { var _this2 = this; this._readyCapability.promise.then(function () { var _iterator2 = _createForOfIteratorHelper(_this2._progressListeners), _step2; try { for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) { var listener = _step2.value; listener(loaded, total); } } catch (err) { _iterator2.e(err); } finally { _iterator2.f(); } }); } }, { key: "onDataProgressiveRead", value: function onDataProgressiveRead(chunk) { var _this3 = this; this._readyCapability.promise.then(function () { var _iterator3 = _createForOfIteratorHelper(_this3._progressiveReadListeners), _step3; try { for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) { var listener = _step3.value; listener(chunk); } } catch (err) { _iterator3.e(err); } finally { _iterator3.f(); } }); } }, { key: "onDataProgressiveDone", value: function onDataProgressiveDone() { var _this4 = this; this._readyCapability.promise.then(function () { var _iterator4 = _createForOfIteratorHelper(_this4._progressiveDoneListeners), _step4; try { for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) { var listener = _step4.value; listener(); } } catch (err) { _iterator4.e(err); } finally { _iterator4.f(); } }); } }, { key: "transportReady", value: function transportReady() { this._readyCapability.resolve(); } }, { key: "requestDataRange", value: function requestDataRange(begin, end) { (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange"); } }, { key: "abort", value: function abort() {} }]); return PDFDataRangeTransport; }(); exports.PDFDataRangeTransport = PDFDataRangeTransport;
var PDFDocumentProxy = /*#__PURE__*/function () {
function PDFDocumentProxy(pdfInfo, transport) { _classCallCheck(this, PDFDocumentProxy); this._pdfInfo = pdfInfo; this._transport = transport; } _createClass(PDFDocumentProxy, [{ key: "getPage", value: function getPage(pageNumber) { return this._transport.getPage(pageNumber); } }, { key: "getPageIndex", value: function getPageIndex(ref) { return this._transport.getPageIndex(ref); } }, { key: "getDestinations", value: function getDestinations() { return this._transport.getDestinations(); } }, { key: "getDestination", value: function getDestination(id) { return this._transport.getDestination(id); } }, { key: "getPageLabels", value: function getPageLabels() { return this._transport.getPageLabels(); } }, { key: "getPageLayout", value: function getPageLayout() { return this._transport.getPageLayout(); } }, { key: "getPageMode", value: function getPageMode() { return this._transport.getPageMode(); } }, { key: "getViewerPreferences", value: function getViewerPreferences() { return this._transport.getViewerPreferences(); } }, { key: "getOpenAction", value: function getOpenAction() { return this._transport.getOpenAction(); } }, { key: "getOpenActionDestination", value: function getOpenActionDestination() { (0, _display_utils.deprecated)("getOpenActionDestination, use getOpenAction instead."); return this.getOpenAction().then(function (openAction) { return openAction && openAction.dest ? openAction.dest : null; }); } }, { key: "getAttachments", value: function getAttachments() { return this._transport.getAttachments(); } }, { key: "getJavaScript", value: function getJavaScript() { return this._transport.getJavaScript(); } }, { key: "getOutline", value: function getOutline() { return this._transport.getOutline(); } }, { key: "getPermissions", value: function getPermissions() { return this._transport.getPermissions(); } }, { key: "getMetadata", value: function getMetadata() { return this._transport.getMetadata(); } }, { key: "getData", value: function getData() { return this._transport.getData(); } }, { key: "getDownloadInfo", value: function getDownloadInfo() { return this._transport.downloadInfoCapability.promise; } }, { key: "getStats", value: function getStats() { return this._transport.getStats(); } }, { key: "cleanup", value: function cleanup() { return this._transport.startCleanup(); } }, { key: "destroy", value: function destroy() { return this.loadingTask.destroy(); } }, { key: "numPages", get: function get() { return this._pdfInfo.numPages; } }, { key: "fingerprint", get: function get() { return this._pdfInfo.fingerprint; } }, { key: "loadingParams", get: function get() { return this._transport.loadingParams; } }, { key: "loadingTask", get: function get() { return this._transport.loadingTask; } }]); return PDFDocumentProxy; }(); exports.PDFDocumentProxy = PDFDocumentProxy;
var PDFPageProxy = /*#__PURE__*/function () {
function PDFPageProxy(pageIndex, pageInfo, transport) { var pdfBug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; _classCallCheck(this, PDFPageProxy); this._pageIndex = pageIndex; this._pageInfo = pageInfo; this._transport = transport; this._stats = pdfBug ? new _display_utils.StatTimer() : null; this._pdfBug = pdfBug; this.commonObjs = transport.commonObjs; this.objs = new PDFObjects(); this.cleanupAfterRender = false; this.pendingCleanup = false; this.intentStates = Object.create(null); this.destroyed = false; } _createClass(PDFPageProxy, [{ key: "getViewport", value: function getViewport() { var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, scale = _ref3.scale, _ref3$rotation = _ref3.rotation, rotation = _ref3$rotation === void 0 ? this.rotate : _ref3$rotation, _ref3$offsetX = _ref3.offsetX, offsetX = _ref3$offsetX === void 0 ? 0 : _ref3$offsetX, _ref3$offsetY = _ref3.offsetY, offsetY = _ref3$offsetY === void 0 ? 0 : _ref3$offsetY, _ref3$dontFlip = _ref3.dontFlip, dontFlip = _ref3$dontFlip === void 0 ? false : _ref3$dontFlip; return new _display_utils.PageViewport({ viewBox: this.view, scale: scale, rotation: rotation, offsetX: offsetX, offsetY: offsetY, dontFlip: dontFlip }); } }, { key: "getAnnotations", value: function getAnnotations() { var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref4$intent = _ref4.intent, intent = _ref4$intent === void 0 ? null : _ref4$intent; if (!this.annotationsPromise || this.annotationsIntent !== intent) { this.annotationsPromise = this._transport.getAnnotations(this._pageIndex, intent); this.annotationsIntent = intent; } return this.annotationsPromise; } }, { key: "render", value: function render(_ref5) { var _this5 = this; var canvasContext = _ref5.canvasContext, viewport = _ref5.viewport, _ref5$intent = _ref5.intent, intent = _ref5$intent === void 0 ? "display" : _ref5$intent, _ref5$enableWebGL = _ref5.enableWebGL, enableWebGL = _ref5$enableWebGL === void 0 ? false : _ref5$enableWebGL, _ref5$renderInteracti = _ref5.renderInteractiveForms, renderInteractiveForms = _ref5$renderInteracti === void 0 ? false : _ref5$renderInteracti, _ref5$transform = _ref5.transform, transform = _ref5$transform === void 0 ? null : _ref5$transform, _ref5$imageLayer = _ref5.imageLayer, imageLayer = _ref5$imageLayer === void 0 ? null : _ref5$imageLayer, _ref5$canvasFactory = _ref5.canvasFactory, canvasFactory = _ref5$canvasFactory === void 0 ? null : _ref5$canvasFactory, _ref5$background = _ref5.background, background = _ref5$background === void 0 ? null : _ref5$background; if (this._stats) { this._stats.time("Overall"); } var renderingIntent = intent === "print" ? "print" : "display"; this.pendingCleanup = false; if (!this.intentStates[renderingIntent]) { this.intentStates[renderingIntent] = Object.create(null); } var intentState = this.intentStates[renderingIntent]; if (intentState.streamReaderCancelTimeout) { clearTimeout(intentState.streamReaderCancelTimeout); intentState.streamReaderCancelTimeout = null; } var canvasFactoryInstance = canvasFactory || new _display_utils.DOMCanvasFactory(); var webGLContext = new _webgl.WebGLContext({ enable: enableWebGL }); if (!intentState.displayReadyCapability) { intentState.displayReadyCapability = (0, _util.createPromiseCapability)(); intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false }; if (this._stats) { this._stats.time("Page Request"); } this._pumpOperatorList({ pageIndex: this._pageIndex, intent: renderingIntent, renderInteractiveForms: renderInteractiveForms === true }); } var complete = function complete(error) { var i = intentState.renderTasks.indexOf(internalRenderTask); if (i >= 0) { intentState.renderTasks.splice(i, 1); } if (_this5.cleanupAfterRender || renderingIntent === "print") { _this5.pendingCleanup = true; } _this5._tryCleanup(); if (error) { internalRenderTask.capability.reject(error); _this5._abortOperatorList({ intentState: intentState, reason: error }); } else { internalRenderTask.capability.resolve(); } if (_this5._stats) { _this5._stats.timeEnd("Rendering"); _this5._stats.timeEnd("Overall"); } }; var internalRenderTask = new InternalRenderTask({ callback: complete, params: { canvasContext: canvasContext, viewport: viewport, transform: transform, imageLayer: imageLayer, background: background }, objs: this.objs, commonObjs: this.commonObjs, operatorList: intentState.operatorList, pageIndex: this._pageIndex, canvasFactory: canvasFactoryInstance, webGLContext: webGLContext, useRequestAnimationFrame: renderingIntent !== "print", pdfBug: this._pdfBug }); if (!intentState.renderTasks) { intentState.renderTasks = []; } intentState.renderTasks.push(internalRenderTask); var renderTask = internalRenderTask.task; intentState.displayReadyCapability.promise.then(function (transparency) { if (_this5.pendingCleanup) { complete(); return; } if (_this5._stats) { _this5._stats.time("Rendering"); } internalRenderTask.initializeGraphics(transparency); internalRenderTask.operatorListChanged(); })["catch"](complete); return renderTask; } }, { key: "getOperatorList", value: function getOperatorList() { function operatorListChanged() { if (intentState.operatorList.lastChunk) { intentState.opListReadCapability.resolve(intentState.operatorList); var i = intentState.renderTasks.indexOf(opListTask); if (i >= 0) { intentState.renderTasks.splice(i, 1); } } } var renderingIntent = "oplist"; if (!this.intentStates[renderingIntent]) { this.intentStates[renderingIntent] = Object.create(null); } var intentState = this.intentStates[renderingIntent]; var opListTask; if (!intentState.opListReadCapability) { opListTask = {}; opListTask.operatorListChanged = operatorListChanged; intentState.opListReadCapability = (0, _util.createPromiseCapability)(); intentState.renderTasks = []; intentState.renderTasks.push(opListTask); intentState.operatorList = { fnArray: [], argsArray: [], lastChunk: false }; if (this._stats) { this._stats.time("Page Request"); } this._pumpOperatorList({ pageIndex: this._pageIndex, intent: renderingIntent }); } return intentState.opListReadCapability.promise; } }, { key: "streamTextContent", value: function streamTextContent() { var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref6$normalizeWhites = _ref6.normalizeWhitespace, normalizeWhitespace = _ref6$normalizeWhites === void 0 ? false : _ref6$normalizeWhites, _ref6$disableCombineT = _ref6.disableCombineTextItems, disableCombineTextItems = _ref6$disableCombineT === void 0 ? false : _ref6$disableCombineT; var TEXT_CONTENT_CHUNK_SIZE = 100; return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, normalizeWhitespace: normalizeWhitespace === true, combineTextItems: disableCombineTextItems !== true }, { highWaterMark: TEXT_CONTENT_CHUNK_SIZE, size: function size(textContent) { return textContent.items.length; } }); } }, { key: "getTextContent", value: function getTextContent() { var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; var readableStream = this.streamTextContent(params); return new Promise(function (resolve, reject) { function pump() { reader.read().then(function (_ref7) { var _textContent$items; var value = _ref7.value, done = _ref7.done; if (done) { resolve(textContent); return; } Object.assign(textContent.styles, value.styles); (_textContent$items = textContent.items).push.apply(_textContent$items, _toConsumableArray(value.items)); pump(); }, reject); } var reader = readableStream.getReader(); var textContent = { items: [], styles: Object.create(null) }; pump(); }); } }, { key: "_destroy", value: function _destroy() { var _this6 = this; this.destroyed = true; this._transport.pageCache[this._pageIndex] = null; var waitOn = []; Object.keys(this.intentStates).forEach(function (intent) { var intentState = _this6.intentStates[intent]; _this6._abortOperatorList({ intentState: intentState, reason: new Error("Page was destroyed."), force: true }); if (intent === "oplist") { return; } intentState.renderTasks.forEach(function (renderTask) { var renderCompleted = renderTask.capability.promise["catch"](function () {}); waitOn.push(renderCompleted); renderTask.cancel(); }); }); this.objs.clear(); this.annotationsPromise = null; this.pendingCleanup = false; return Promise.all(waitOn); } }, { key: "cleanup", value: function cleanup() { var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; this.pendingCleanup = true; return this._tryCleanup(resetStats); } }, { key: "_tryCleanup", value: function _tryCleanup() { var _this7 = this; var resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; if (!this.pendingCleanup || Object.keys(this.intentStates).some(function (intent) { var intentState = _this7.intentStates[intent]; return intentState.renderTasks.length !== 0 || !intentState.operatorList.lastChunk; })) { return false; } Object.keys(this.intentStates).forEach(function (intent) { delete _this7.intentStates[intent]; }); this.objs.clear(); this.annotationsPromise = null; if (resetStats && this._stats) { this._stats = new _display_utils.StatTimer(); } this.pendingCleanup = false; return true; } }, { key: "_startRenderPage", value: function _startRenderPage(transparency, intent) { var intentState = this.intentStates[intent]; if (!intentState) { return; } if (this._stats) { this._stats.timeEnd("Page Request"); } if (intentState.displayReadyCapability) { intentState.displayReadyCapability.resolve(transparency); } } }, { key: "_renderPageChunk", value: function _renderPageChunk(operatorListChunk, intentState) { for (var i = 0, ii = operatorListChunk.length; i < ii; i++) { intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]); intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]); } intentState.operatorList.lastChunk = operatorListChunk.lastChunk; for (var _i2 = 0; _i2 < intentState.renderTasks.length; _i2++) { intentState.renderTasks[_i2].operatorListChanged(); } if (operatorListChunk.lastChunk) { this._tryCleanup(); } } }, { key: "_pumpOperatorList", value: function _pumpOperatorList(args) { var _this8 = this; (0, _util.assert)(args.intent, 'PDFPageProxy._pumpOperatorList: Expected "intent" argument.'); var readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", args); var reader = readableStream.getReader(); var intentState = this.intentStates[args.intent]; intentState.streamReader = reader; var pump = function pump() { reader.read().then(function (_ref8) { var value = _ref8.value, done = _ref8.done; if (done) { intentState.streamReader = null; return; } if (_this8._transport.destroyed) { return; } _this8._renderPageChunk(value, intentState); pump(); }, function (reason) { intentState.streamReader = null; if (_this8._transport.destroyed) { return; } if (intentState.operatorList) { intentState.operatorList.lastChunk = true; for (var i = 0; i < intentState.renderTasks.length; i++) { intentState.renderTasks[i].operatorListChanged(); } _this8._tryCleanup(); } if (intentState.displayReadyCapability) { intentState.displayReadyCapability.reject(reason); } else if (intentState.opListReadCapability) { intentState.opListReadCapability.reject(reason); } else { throw reason; } }); }; pump(); } }, { key: "_abortOperatorList", value: function _abortOperatorList(_ref9) { var _this9 = this; var intentState = _ref9.intentState, reason = _ref9.reason, _ref9$force = _ref9.force, force = _ref9$force === void 0 ? false : _ref9$force; (0, _util.assert)(reason instanceof Error || _typeof(reason) === "object" && reason !== null, 'PDFPageProxy._abortOperatorList: Expected "reason" argument.'); if (!intentState.streamReader) { return; } if (!force) { if (intentState.renderTasks.length !== 0) { return; } if (reason instanceof _display_utils.RenderingCancelledException) { intentState.streamReaderCancelTimeout = setTimeout(function () { _this9._abortOperatorList({ intentState: intentState, reason: reason, force: true }); intentState.streamReaderCancelTimeout = null; }, RENDERING_CANCELLED_TIMEOUT); return; } } intentState.streamReader.cancel(new _util.AbortException(reason && reason.message)); intentState.streamReader = null; if (this._transport.destroyed) { return; } Object.keys(this.intentStates).some(function (intent) { if (_this9.intentStates[intent] === intentState) { delete _this9.intentStates[intent]; return true; } return false; }); this.cleanup(); } }, { key: "pageNumber", get: function get() { return this._pageIndex + 1; } }, { key: "rotate", get: function get() { return this._pageInfo.rotate; } }, { key: "ref", get: function get() { return this._pageInfo.ref; } }, { key: "userUnit", get: function get() { return this._pageInfo.userUnit; } }, { key: "view", get: function get() { return this._pageInfo.view; } }, { key: "stats", get: function get() { return this._stats; } }]); return PDFPageProxy; }(); exports.PDFPageProxy = PDFPageProxy;
var LoopbackPort = /*#__PURE__*/function () {
function LoopbackPort() { var defer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true; _classCallCheck(this, LoopbackPort); this._listeners = []; this._defer = defer; this._deferred = Promise.resolve(undefined); } _createClass(LoopbackPort, [{ key: "postMessage", value: function postMessage(obj, transfers) { var _this10 = this; function cloneValue(value) { if (_typeof(value) !== "object" || value === null) { return value; } if (cloned.has(value)) { return cloned.get(value); } var buffer, result; if ((buffer = value.buffer) && (0, _util.isArrayBuffer)(buffer)) { var transferable = transfers && transfers.includes(buffer); if (transferable) { result = new value.constructor(buffer, value.byteOffset, value.byteLength); } else { result = new value.constructor(value); } cloned.set(value, result); return result; } result = Array.isArray(value) ? [] : {}; cloned.set(value, result); for (var i in value) { var desc = void 0, p = value; while (!(desc = Object.getOwnPropertyDescriptor(p, i))) { p = Object.getPrototypeOf(p); } if (typeof desc.value === "undefined") { continue; } if (typeof desc.value === "function") { if (value.hasOwnProperty && value.hasOwnProperty(i)) { throw new Error("LoopbackPort.postMessage - cannot clone: ".concat(value[i])); } continue; } result[i] = cloneValue(desc.value); } return result; } if (!this._defer) { this._listeners.forEach(function (listener) { listener.call(_this10, { data: obj }); }); return; } var cloned = new WeakMap(); var e = { data: cloneValue(obj) }; this._deferred.then(function () { _this10._listeners.forEach(function (listener) { listener.call(_this10, e); }); }); } }, { key: "addEventListener", value: function addEventListener(name, listener) { this._listeners.push(listener); } }, { key: "removeEventListener", value: function removeEventListener(name, listener) { var i = this._listeners.indexOf(listener); this._listeners.splice(i, 1); } }, { key: "terminate", value: function terminate() { this._listeners.length = 0; } }]); return LoopbackPort; }(); exports.LoopbackPort = LoopbackPort; var PDFWorker = function PDFWorkerClosure() { var pdfWorkerPorts = new WeakMap(); var isWorkerDisabled = false; var fallbackWorkerSrc; var nextFakeWorkerId = 0; var fakeWorkerCapability; if (_is_node.isNodeJS && typeof require === "function") { isWorkerDisabled = true; fallbackWorkerSrc = "./pdf.worker.js"; } else if ((typeof document === "undefined" ? "undefined" : _typeof(document)) === "object" && "currentScript" in document) { var pdfjsFilePath = document.currentScript && document.currentScript.src; if (pdfjsFilePath) { fallbackWorkerSrc = pdfjsFilePath.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2"); } } function _getWorkerSrc() { if (_worker_options.GlobalWorkerOptions.workerSrc) { return _worker_options.GlobalWorkerOptions.workerSrc; } if (typeof fallbackWorkerSrc !== "undefined") { if (!_is_node.isNodeJS) { (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'); } return fallbackWorkerSrc; } throw new Error('No "GlobalWorkerOptions.workerSrc" specified.'); } function getMainThreadWorkerMessageHandler() { var mainWorkerMessageHandler; try { mainWorkerMessageHandler = globalThis.pdfjsWorker && globalThis.pdfjsWorker.WorkerMessageHandler; } catch (ex) {} return mainWorkerMessageHandler || null; } function setupFakeWorkerGlobal() { if (fakeWorkerCapability) { return fakeWorkerCapability.promise; } fakeWorkerCapability = (0, _util.createPromiseCapability)();
var loader = /*#__PURE__*/function () {
var _ref10 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
var mainWorkerMessageHandler, worker; return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: mainWorkerMessageHandler = getMainThreadWorkerMessageHandler(); if (!mainWorkerMessageHandler) { _context.next = 3; break; } return _context.abrupt("return", mainWorkerMessageHandler); case 3: if (!(_is_node.isNodeJS && typeof require === "function")) { _context.next = 6; break; } worker = eval("require")(_getWorkerSrc()); return _context.abrupt("return", worker.WorkerMessageHandler); case 6: _context.next = 8; return (0, _display_utils.loadScript)(_getWorkerSrc()); case 8: return _context.abrupt("return", window.pdfjsWorker.WorkerMessageHandler); case 9: case "end": return _context.stop(); } } }, _callee); })); return function loader() { return _ref10.apply(this, arguments); }; }(); loader().then(fakeWorkerCapability.resolve, fakeWorkerCapability.reject); return fakeWorkerCapability.promise; } function createCDNWrapper(url) { var wrapper = "importScripts('" + url + "');"; return URL.createObjectURL(new Blob([wrapper])); }
var PDFWorker = /*#__PURE__*/function () {
function PDFWorker() { var _ref11 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, _ref11$name = _ref11.name, name = _ref11$name === void 0 ? null : _ref11$name, _ref11$port = _ref11.port, port = _ref11$port === void 0 ? null : _ref11$port, _ref11$verbosity = _ref11.verbosity, verbosity = _ref11$verbosity === void 0 ? (0, _util.getVerbosityLevel)() : _ref11$verbosity; _classCallCheck(this, PDFWorker); if (port && pdfWorkerPorts.has(port)) { throw new Error("Cannot use more than one PDFWorker per port"); } this.name = name; this.destroyed = false; this.postMessageTransfers = true; this.verbosity = verbosity; this._readyCapability = (0, _util.createPromiseCapability)(); this._port = null; this._webWorker = null; this._messageHandler = null; if (port) { pdfWorkerPorts.set(port, this); this._initializeFromPort(port); return; } this._initialize(); } _createClass(PDFWorker, [{ key: "_initializeFromPort", value: function _initializeFromPort(port) { this._port = port; this._messageHandler = new _message_handler.MessageHandler("main", "worker", port); this._messageHandler.on("ready", function () {}); this._readyCapability.resolve(); } }, { key: "_initialize", value: function _initialize() { var _this11 = this; if (typeof Worker !== "undefined" && !isWorkerDisabled && !getMainThreadWorkerMessageHandler()) { var workerSrc = _getWorkerSrc(); try { if (!(0, _util.isSameOrigin)(window.location.href, workerSrc)) { workerSrc = createCDNWrapper(new URL(workerSrc, window.location).href); } var worker = new Worker(workerSrc); var messageHandler = new _message_handler.MessageHandler("main", "worker", worker); var terminateEarly = function terminateEarly() { worker.removeEventListener("error", onWorkerError); messageHandler.destroy(); worker.terminate(); if (_this11.destroyed) { _this11._readyCapability.reject(new Error("Worker was destroyed")); } else { _this11._setupFakeWorker(); } }; var onWorkerError = function onWorkerError() { if (!_this11._webWorker) { terminateEarly(); } }; worker.addEventListener("error", onWorkerError); messageHandler.on("test", function (data) { worker.removeEventListener("error", onWorkerError); if (_this11.destroyed) { terminateEarly(); return; } if (data) { _this11._messageHandler = messageHandler; _this11._port = worker; _this11._webWorker = worker; if (!data.supportTransfers) { _this11.postMessageTransfers = false; } _this11._readyCapability.resolve(); messageHandler.send("configure", { verbosity: _this11.verbosity }); } else { _this11._setupFakeWorker(); messageHandler.destroy(); worker.terminate(); } }); messageHandler.on("ready", function (data) { worker.removeEventListener("error", onWorkerError); if (_this11.destroyed) { terminateEarly(); return; } try { sendTest(); } catch (e) { _this11._setupFakeWorker(); } }); var sendTest = function sendTest() { var testObj = new Uint8Array([_this11.postMessageTransfers ? 255 : 0]); try { messageHandler.send("test", testObj, [testObj.buffer]); } catch (ex) { (0, _util.warn)("Cannot use postMessage transfers."); testObj[0] = 0; messageHandler.send("test", testObj); } }; sendTest(); return; } catch (e) { (0, _util.info)("The worker has been disabled."); } } this._setupFakeWorker(); } }, { key: "_setupFakeWorker", value: function _setupFakeWorker() { var _this12 = this; if (!isWorkerDisabled) { (0, _util.warn)("Setting up fake worker."); isWorkerDisabled = true; } setupFakeWorkerGlobal().then(function (WorkerMessageHandler) { if (_this12.destroyed) { _this12._readyCapability.reject(new Error("Worker was destroyed")); return; } var port = new LoopbackPort(); _this12._port = port; var id = "fake" + nextFakeWorkerId++; var workerHandler = new _message_handler.MessageHandler(id + "_worker", id, port); WorkerMessageHandler.setup(workerHandler, port); var messageHandler = new _message_handler.MessageHandler(id, id + "_worker", port); _this12._messageHandler = messageHandler; _this12._readyCapability.resolve(); messageHandler.send("configure", { verbosity: _this12.verbosity }); })["catch"](function (reason) { _this12._readyCapability.reject(new Error("Setting up fake worker failed: \"".concat(reason.message, "\"."))); }); } }, { key: "destroy", value: function destroy() { this.destroyed = true; if (this._webWorker) { this._webWorker.terminate(); this._webWorker = null; } pdfWorkerPorts["delete"](this._port); this._port = null; if (this._messageHandler) { this._messageHandler.destroy(); this._messageHandler = null; } } }, { key: "promise", get: function get() { return this._readyCapability.promise; } }, { key: "port", get: function get() { return this._port; } }, { key: "messageHandler", get: function get() { return this._messageHandler; } }], [{ key: "fromPort", value: function fromPort(params) { if (!params || !params.port) { throw new Error("PDFWorker.fromPort - invalid method signature."); } if (pdfWorkerPorts.has(params.port)) { return pdfWorkerPorts.get(params.port); } return new PDFWorker(params); } }, { key: "getWorkerSrc", value: function getWorkerSrc() { return _getWorkerSrc(); } }]); return PDFWorker; }(); return PDFWorker; }(); exports.PDFWorker = PDFWorker;
var WorkerTransport = /*#__PURE__*/function () {
function WorkerTransport(messageHandler, loadingTask, networkStream, params) { _classCallCheck(this, WorkerTransport); this.messageHandler = messageHandler; this.loadingTask = loadingTask; this.commonObjs = new PDFObjects(); this.fontLoader = new _font_loader.FontLoader({ docId: loadingTask.docId, onUnsupportedFeature: this._onUnsupportedFeature.bind(this) }); this._params = params; this.CMapReaderFactory = new params.CMapReaderFactory({ baseUrl: params.cMapUrl, isCompressed: params.cMapPacked }); this.destroyed = false; this.destroyCapability = null; this._passwordCapability = null; this._networkStream = networkStream; this._fullReader = null; this._lastProgress = null; this.pageCache = []; this.pagePromises = []; this.downloadInfoCapability = (0, _util.createPromiseCapability)(); this.setupMessageHandler(); } _createClass(WorkerTransport, [{ key: "destroy", value: function destroy() { var _this13 = this; if (this.destroyCapability) { return this.destroyCapability.promise; } this.destroyed = true; this.destroyCapability = (0, _util.createPromiseCapability)(); if (this._passwordCapability) { this._passwordCapability.reject(new Error("Worker was destroyed during onPassword callback")); } var waitOn = []; this.pageCache.forEach(function (page) { if (page) { waitOn.push(page._destroy()); } }); this.pageCache.length = 0; this.pagePromises.length = 0; var terminated = this.messageHandler.sendWithPromise("Terminate", null); waitOn.push(terminated); Promise.all(waitOn).then(function () { _this13.fontLoader.clear(); if (_this13._networkStream) { _this13._networkStream.cancelAllRequests(new _util.AbortException("Worker was terminated.")); } if (_this13.messageHandler) { _this13.messageHandler.destroy(); _this13.messageHandler = null; } _this13.destroyCapability.resolve(); }, this.destroyCapability.reject); return this.destroyCapability.promise; } }, { key: "setupMessageHandler", value: function setupMessageHandler() { var _this14 = this; var messageHandler = this.messageHandler, loadingTask = this.loadingTask; messageHandler.on("GetReader", function (data, sink) { (0, _util.assert)(_this14._networkStream, "GetReader - no `IPDFStream` instance available."); _this14._fullReader = _this14._networkStream.getFullReader(); _this14._fullReader.onProgress = function (evt) { _this14._lastProgress = { loaded: evt.loaded, total: evt.total }; }; sink.onPull = function () { _this14._fullReader.read().then(function (_ref12) { var value = _ref12.value, done = _ref12.done; if (done) { sink.close(); return; } (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetReader - expected an ArrayBuffer."); sink.enqueue(new Uint8Array(value), 1, [value]); })["catch"](function (reason) { sink.error(reason); }); }; sink.onCancel = function (reason) { _this14._fullReader.cancel(reason); }; }); messageHandler.on("ReaderHeadersReady", function (data) { var headersCapability = (0, _util.createPromiseCapability)(); var fullReader = _this14._fullReader; fullReader.headersReady.then(function () { if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) { if (_this14._lastProgress && loadingTask.onProgress) { loadingTask.onProgress(_this14._lastProgress); } fullReader.onProgress = function (evt) { if (loadingTask.onProgress) { loadingTask.onProgress({ loaded: evt.loaded, total: evt.total }); } }; } headersCapability.resolve({ isStreamingSupported: fullReader.isStreamingSupported, isRangeSupported: fullReader.isRangeSupported, contentLength: fullReader.contentLength }); }, headersCapability.reject); return headersCapability.promise; }); messageHandler.on("GetRangeReader", function (data, sink) { (0, _util.assert)(_this14._networkStream, "GetRangeReader - no `IPDFStream` instance available."); var rangeReader = _this14._networkStream.getRangeReader(data.begin, data.end); if (!rangeReader) { sink.close(); return; } sink.onPull = function () { rangeReader.read().then(function (_ref13) { var value = _ref13.value, done = _ref13.done; if (done) { sink.close(); return; } (0, _util.assert)((0, _util.isArrayBuffer)(value), "GetRangeReader - expected an ArrayBuffer."); sink.enqueue(new Uint8Array(value), 1, [value]); })["catch"](function (reason) { sink.error(reason); }); }; sink.onCancel = function (reason) { rangeReader.cancel(reason); }; }); messageHandler.on("GetDoc", function (_ref14) { var pdfInfo = _ref14.pdfInfo; _this14._numPages = pdfInfo.numPages; loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, _this14)); }); messageHandler.on("DocException", function (ex) { var reason; switch (ex.name) { case "PasswordException": reason = new _util.PasswordException(ex.message, ex.code); break; case "InvalidPDFException": reason = new _util.InvalidPDFException(ex.message); break; case "MissingPDFException": reason = new _util.MissingPDFException(ex.message); break; case "UnexpectedResponseException": reason = new _util.UnexpectedResponseException(ex.message, ex.status); break; case "UnknownErrorException": reason = new _util.UnknownErrorException(ex.message, ex.details); break; } loadingTask._capability.reject(reason); }); messageHandler.on("PasswordRequest", function (exception) { _this14._passwordCapability = (0, _util.createPromiseCapability)(); if (loadingTask.onPassword) { var updatePassword = function updatePassword(password) { _this14._passwordCapability.resolve({ password: password }); }; try { loadingTask.onPassword(updatePassword, exception.code); } catch (ex) { _this14._passwordCapability.reject(ex); } } else { _this14._passwordCapability.reject(new _util.PasswordException(exception.message, exception.code)); } return _this14._passwordCapability.promise; }); messageHandler.on("DataLoaded", function (data) { if (loadingTask.onProgress) { loadingTask.onProgress({ loaded: data.length, total: data.length }); } _this14.downloadInfoCapability.resolve(data); }); messageHandler.on("StartRenderPage", function (data) { if (_this14.destroyed) { return; } var page = _this14.pageCache[data.pageIndex]; page._startRenderPage(data.transparency, data.intent); }); messageHandler.on("commonobj", function (data) { if (_this14.destroyed) { return; } var _data = _slicedToArray(data, 3), id = _data[0], type = _data[1], exportedData = _data[2]; if (_this14.commonObjs.has(id)) { return; } switch (type) { case "Font": var params = _this14._params; if ("error" in exportedData) { var exportedError = exportedData.error; (0, _util.warn)("Error during font loading: ".concat(exportedError)); _this14.commonObjs.resolve(id, exportedError); break; } var fontRegistry = null; if (params.pdfBug && globalThis.FontInspector && globalThis.FontInspector.enabled) { fontRegistry = { registerFont: function registerFont(font, url) { globalThis.FontInspector.fontAdded(font, url); } }; } var font = new _font_loader.FontFaceObject(exportedData, { isEvalSupported: params.isEvalSupported, disableFontFace: params.disableFontFace, ignoreErrors: params.ignoreErrors, onUnsupportedFeature: _this14._onUnsupportedFeature.bind(_this14), fontRegistry: fontRegistry }); _this14.fontLoader.bind(font)["catch"](function (reason) { return messageHandler.sendWithPromise("FontFallback", { id: id }); })["finally"](function () { if (!params.fontExtraProperties && font.data) { font.data = null; } _this14.commonObjs.resolve(id, font); }); break; case "FontPath": case "FontType3Res": case "Image": _this14.commonObjs.resolve(id, exportedData); break; default: throw new Error("Got unknown common object type ".concat(type)); } }); messageHandler.on("obj", function (data) { if (_this14.destroyed) { return undefined; } var _data2 = _slicedToArray(data, 4), id = _data2[0], pageIndex = _data2[1], type = _data2[2], imageData = _data2[3]; var pageProxy = _this14.pageCache[pageIndex]; if (pageProxy.objs.has(id)) { return undefined; } switch (type) { case "Image": pageProxy.objs.resolve(id, imageData); var MAX_IMAGE_SIZE_TO_STORE = 8000000; if (imageData && "data" in imageData && imageData.data.length > MAX_IMAGE_SIZE_TO_STORE) { pageProxy.cleanupAfterRender = true; } break; default: throw new Error("Got unknown object type ".concat(type)); } return undefined; }); messageHandler.on("DocProgress", function (data) { if (_this14.destroyed) { return; } if (loadingTask.onProgress) { loadingTask.onProgress({ loaded: data.loaded, total: data.total }); } }); messageHandler.on("UnsupportedFeature", this._onUnsupportedFeature.bind(this)); messageHandler.on("FetchBuiltInCMap", function (data, sink) { if (_this14.destroyed) { sink.error(new Error("Worker was destroyed")); return; } var fetched = false; sink.onPull = function () { if (fetched) { sink.close(); return; } fetched = true; _this14.CMapReaderFactory.fetch(data).then(function (builtInCMap) { sink.enqueue(builtInCMap, 1, [builtInCMap.cMapData.buffer]); })["catch"](function (reason) { sink.error(reason); }); }; }); } }, { key: "_onUnsupportedFeature", value: function _onUnsupportedFeature(_ref15) { var featureId = _ref15.featureId; if (this.destroyed) { return; } if (this.loadingTask.onUnsupportedFeature) { this.loadingTask.onUnsupportedFeature(featureId); } } }, { key: "getData", value: function getData() { return this.messageHandler.sendWithPromise("GetData", null); } }, { key: "getPage", value: function getPage(pageNumber) { var _this15 = this; if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) { return Promise.reject(new Error("Invalid page request")); } var pageIndex = pageNumber - 1; if (pageIndex in this.pagePromises) { return this.pagePromises[pageIndex]; } var promise = this.messageHandler.sendWithPromise("GetPage", { pageIndex: pageIndex }).then(function (pageInfo) { if (_this15.destroyed) { throw new Error("Transport destroyed"); } var page = new PDFPageProxy(pageIndex, pageInfo, _this15, _this15._params.pdfBug); _this15.pageCache[pageIndex] = page; return page; }); this.pagePromises[pageIndex] = promise; return promise; } }, { key: "getPageIndex", value: function getPageIndex(ref) { return this.messageHandler.sendWithPromise("GetPageIndex", { ref: ref })["catch"](function (reason) { return Promise.reject(new Error(reason)); }); } }, { key: "getAnnotations", value: function getAnnotations(pageIndex, intent) { return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: pageIndex, intent: intent }); } }, { key: "getDestinations", value: function getDestinations() { return this.messageHandler.sendWithPromise("GetDestinations", null); } }, { key: "getDestination", value: function getDestination(id) { if (typeof id !== "string") { return Promise.reject(new Error("Invalid destination request.")); } return this.messageHandler.sendWithPromise("GetDestination", { id: id }); } }, { key: "getPageLabels", value: function getPageLabels() { return this.messageHandler.sendWithPromise("GetPageLabels", null); } }, { key: "getPageLayout", value: function getPageLayout() { return this.messageHandler.sendWithPromise("GetPageLayout", null); } }, { key: "getPageMode", value: function getPageMode() { return this.messageHandler.sendWithPromise("GetPageMode", null); } }, { key: "getViewerPreferences", value: function getViewerPreferences() { return this.messageHandler.sendWithPromise("GetViewerPreferences", null); } }, { key: "getOpenAction", value: function getOpenAction() { return this.messageHandler.sendWithPromise("GetOpenAction", null); } }, { key: "getAttachments", value: function getAttachments() { return this.messageHandler.sendWithPromise("GetAttachments", null); } }, { key: "getJavaScript", value: function getJavaScript() { return this.messageHandler.sendWithPromise("GetJavaScript", null); } }, { key: "getOutline", value: function getOutline() { return this.messageHandler.sendWithPromise("GetOutline", null); } }, { key: "getPermissions", value: function getPermissions() { return this.messageHandler.sendWithPromise("GetPermissions", null); } }, { key: "getMetadata", value: function getMetadata() { var _this16 = this; return this.messageHandler.sendWithPromise("GetMetadata", null).then(function (results) { return { info: results[0], metadata: results[1] ? new _metadata.Metadata(results[1]) : null, contentDispositionFilename: _this16._fullReader ? _this16._fullReader.filename : null }; }); } }, { key: "getStats", value: function getStats() { return this.messageHandler.sendWithPromise("GetStats", null); } }, { key: "startCleanup", value: function startCleanup() { var _this17 = this; return this.messageHandler.sendWithPromise("Cleanup", null).then(function () { for (var i = 0, ii = _this17.pageCache.length; i < ii; i++) { var page = _this17.pageCache[i]; if (page) { var cleanupSuccessful = page.cleanup(); if (!cleanupSuccessful) { throw new Error("startCleanup: Page ".concat(i + 1, " is currently rendering.")); } } } _this17.commonObjs.clear(); _this17.fontLoader.clear(); }); } }, { key: "loadingParams", get: function get() { var params = this._params; return (0, _util.shadow)(this, "loadingParams", { disableAutoFetch: params.disableAutoFetch, disableFontFace: params.disableFontFace }); } }]); return WorkerTransport; }();
var PDFObjects = /*#__PURE__*/function () {
function PDFObjects() { _classCallCheck(this, PDFObjects); this._objs = Object.create(null); } _createClass(PDFObjects, [{ key: "_ensureObj", value: function _ensureObj(objId) { if (this._objs[objId]) { return this._objs[objId]; } return this._objs[objId] = { capability: (0, _util.createPromiseCapability)(), data: null, resolved: false }; } }, { key: "get", value: function get(objId) { var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; if (callback) { this._ensureObj(objId).capability.promise.then(callback); return null; } var obj = this._objs[objId]; if (!obj || !obj.resolved) { throw new Error("Requesting object that isn't resolved yet ".concat(objId, ".")); } return obj.data; } }, { key: "has", value: function has(objId) { var obj = this._objs[objId]; return obj ? obj.resolved : false; } }, { key: "resolve", value: function resolve(objId, data) { var obj = this._ensureObj(objId); obj.resolved = true; obj.data = data; obj.capability.resolve(data); } }, { key: "clear", value: function clear() { this._objs = Object.create(null); } }]); return PDFObjects; }();
var RenderTask = /*#__PURE__*/function () {
function RenderTask(internalRenderTask) { _classCallCheck(this, RenderTask); this._internalRenderTask = internalRenderTask; this.onContinue = null; } _createClass(RenderTask, [{ key: "cancel", value: function cancel() { this._internalRenderTask.cancel(); } }, { key: "promise", get: function get() { return this._internalRenderTask.capability.promise; } }]); return RenderTask; }(); var InternalRenderTask = function InternalRenderTaskClosure() { var canvasInRendering = new WeakSet();
var InternalRenderTask = /*#__PURE__*/function () {
function InternalRenderTask(_ref16) { var callback = _ref16.callback, params = _ref16.params, objs = _ref16.objs, commonObjs = _ref16.commonObjs, operatorList = _ref16.operatorList, pageIndex = _ref16.pageIndex, canvasFactory = _ref16.canvasFactory, webGLContext = _ref16.webGLContext, _ref16$useRequestAnim = _ref16.useRequestAnimationFrame, useRequestAnimationFrame = _ref16$useRequestAnim === void 0 ? false : _ref16$useRequestAnim, _ref16$pdfBug = _ref16.pdfBug, pdfBug = _ref16$pdfBug === void 0 ? false : _ref16$pdfBug; _classCallCheck(this, InternalRenderTask); this.callback = callback; this.params = params; this.objs = objs; this.commonObjs = commonObjs; this.operatorListIdx = null; this.operatorList = operatorList; this._pageIndex = pageIndex; this.canvasFactory = canvasFactory; this.webGLContext = webGLContext; this._pdfBug = pdfBug; this.running = false; this.graphicsReadyCallback = null; this.graphicsReady = false; this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined"; this.cancelled = false; this.capability = (0, _util.createPromiseCapability)(); this.task = new RenderTask(this); this._continueBound = this._continue.bind(this); this._scheduleNextBound = this._scheduleNext.bind(this); this._nextBound = this._next.bind(this); this._canvas = params.canvasContext.canvas; } _createClass(InternalRenderTask, [{ key: "initializeGraphics", value: function initializeGraphics() { var transparency = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; if (this.cancelled) { return; } if (this._canvas) { if (canvasInRendering.has(this._canvas)) { throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed."); } canvasInRendering.add(this._canvas); } if (this._pdfBug && globalThis.StepperManager && globalThis.StepperManager.enabled) { this.stepper = globalThis.StepperManager.create(this._pageIndex); this.stepper.init(this.operatorList); this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint(); } var _this$params = this.params, canvasContext = _this$params.canvasContext, viewport = _this$params.viewport, transform = _this$params.transform, imageLayer = _this$params.imageLayer, background = _this$params.background; this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.webGLContext, imageLayer); this.gfx.beginDrawing({ transform: transform, viewport: viewport, transparency: transparency, background: background }); this.operatorListIdx = 0; this.graphicsReady = true; if (this.graphicsReadyCallback) { this.graphicsReadyCallback(); } } }, { key: "cancel", value: function cancel() { var error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null; this.running = false; this.cancelled = true; if (this.gfx) { this.gfx.endDrawing(); } if (this._canvas) { canvasInRendering["delete"](this._canvas); } this.callback(error || new _display_utils.RenderingCancelledException("Rendering cancelled, page ".concat(this._pageIndex + 1), "canvas")); } }, { key: "operatorListChanged", value: function operatorListChanged() { if (!this.graphicsReady) { if (!this.graphicsReadyCallback) { this.graphicsReadyCallback = this._continueBound; } return; } if (this.stepper) { this.stepper.updateOperatorList(this.operatorList); } if (this.running) { return; } this._continue(); } }, { key: "_continue", value: function _continue() { this.running = true; if (this.cancelled) { return; } if (this.task.onContinue) { this.task.onContinue(this._scheduleNextBound); } else { this._scheduleNext(); } } }, { key: "_scheduleNext", value: function _scheduleNext() { var _this18 = this; if (this._useRequestAnimationFrame) { window.requestAnimationFrame(function () { _this18._nextBound()["catch"](_this18.cancel.bind(_this18)); }); } else { Promise.resolve().then(this._nextBound)["catch"](this.cancel.bind(this)); } } }, { key: "_next", value: function () {
var _next2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
return _regenerator["default"].wrap(function _callee2$(_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0: if (!this.cancelled) { _context2.next = 2; break; } return _context2.abrupt("return"); case 2: this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper); if (this.operatorListIdx === this.operatorList.argsArray.length) { this.running = false; if (this.operatorList.lastChunk) { this.gfx.endDrawing(); if (this._canvas) { canvasInRendering["delete"](this._canvas); } this.callback(); } } case 4: case "end": return _context2.stop(); } } }, _callee2, this); })); function _next() { return _next2.apply(this, arguments); } return _next; }() }]); return InternalRenderTask; }(); return InternalRenderTask; }(); var version = '2.5.207'; exports.version = version; var build = '0974d6052'; exports.build = build;
/***/ }),
/* 204 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.FontLoader = exports.FontFaceObject = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2)); var _util = __w_pdfjs_require__(5); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); } function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var BaseFontLoader = /*#__PURE__*/function () {
function BaseFontLoader(_ref) { var docId = _ref.docId, onUnsupportedFeature = _ref.onUnsupportedFeature; _classCallCheck(this, BaseFontLoader); if (this.constructor === BaseFontLoader) { (0, _util.unreachable)("Cannot initialize BaseFontLoader."); } this.docId = docId; this._onUnsupportedFeature = onUnsupportedFeature; this.nativeFontFaces = []; this.styleElement = null; } _createClass(BaseFontLoader, [{ key: "addNativeFontFace", value: function addNativeFontFace(nativeFontFace) { this.nativeFontFaces.push(nativeFontFace); document.fonts.add(nativeFontFace); } }, { key: "insertRule", value: function insertRule(rule) { var styleElement = this.styleElement; if (!styleElement) { styleElement = this.styleElement = document.createElement("style"); styleElement.id = "PDFJS_FONT_STYLE_TAG_".concat(this.docId); document.documentElement.getElementsByTagName("head")[0].appendChild(styleElement); } var styleSheet = styleElement.sheet; styleSheet.insertRule(rule, styleSheet.cssRules.length); } }, { key: "clear", value: function clear() { this.nativeFontFaces.forEach(function (nativeFontFace) { document.fonts["delete"](nativeFontFace); }); this.nativeFontFaces.length = 0; if (this.styleElement) { this.styleElement.remove(); this.styleElement = null; } } }, { key: "bind", value: function () {
var _bind = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(font) {
var _this = this; var nativeFontFace, rule; return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: if (!(font.attached || font.missingFile)) { _context.next = 2; break; } return _context.abrupt("return"); case 2: font.attached = true; if (!this.isFontLoadingAPISupported) { _context.next = 19; break; } nativeFontFace = font.createNativeFontFace(); if (!nativeFontFace) { _context.next = 18; break; } this.addNativeFontFace(nativeFontFace); _context.prev = 7; _context.next = 10; return nativeFontFace.loaded; case 10: _context.next = 18; break; case 12: _context.prev = 12; _context.t0 = _context["catch"](7); this._onUnsupportedFeature({ featureId: _util.UNSUPPORTED_FEATURES.errorFontLoadNative }); (0, _util.warn)("Failed to load font '".concat(nativeFontFace.family, "': '").concat(_context.t0, "'.")); font.disableFontFace = true; throw _context.t0; case 18: return _context.abrupt("return"); case 19: rule = font.createFontFaceRule(); if (!rule) { _context.next = 26; break; } this.insertRule(rule); if (!this.isSyncFontLoadingSupported) { _context.next = 24; break; } return _context.abrupt("return"); case 24: _context.next = 26; return new Promise(function (resolve) { var request = _this._queueLoadingCallback(resolve); _this._prepareFontLoadEvent([rule], [font], request); }); case 26: case "end": return _context.stop(); } } }, _callee, this, [[7, 12]]); })); function bind(_x) { return _bind.apply(this, arguments); } return bind; }() }, { key: "_queueLoadingCallback", value: function _queueLoadingCallback(callback) { (0, _util.unreachable)("Abstract method `_queueLoadingCallback`."); } }, { key: "_prepareFontLoadEvent", value: function _prepareFontLoadEvent(rules, fontsToLoad, request) { (0, _util.unreachable)("Abstract method `_prepareFontLoadEvent`."); } }, { key: "isFontLoadingAPISupported", get: function get() { var supported = typeof document !== "undefined" && !!document.fonts; return (0, _util.shadow)(this, "isFontLoadingAPISupported", supported); } }, { key: "isSyncFontLoadingSupported", get: function get() { (0, _util.unreachable)("Abstract method `isSyncFontLoadingSupported`."); } }, { key: "_loadTestFont", get: function get() { (0, _util.unreachable)("Abstract method `_loadTestFont`."); } }]); return BaseFontLoader; }(); var FontLoader; exports.FontLoader = FontLoader; {
exports.FontLoader = FontLoader = /*#__PURE__*/function (_BaseFontLoader) {
_inherits(GenericFontLoader, _BaseFontLoader); var _super = _createSuper(GenericFontLoader); function GenericFontLoader(docId) { var _this2; _classCallCheck(this, GenericFontLoader); _this2 = _super.call(this, docId); _this2.loadingContext = { requests: [], nextRequestId: 0 }; _this2.loadTestFontId = 0; return _this2; } _createClass(GenericFontLoader, [{ key: "_queueLoadingCallback", value: function _queueLoadingCallback(callback) { function completeRequest() { (0, _util.assert)(!request.done, "completeRequest() cannot be called twice."); request.done = true; while (context.requests.length > 0 && context.requests[0].done) { var otherRequest = context.requests.shift(); setTimeout(otherRequest.callback, 0); } } var context = this.loadingContext; var request = { id: "pdfjs-font-loading-".concat(context.nextRequestId++), done: false, complete: completeRequest, callback: callback }; context.requests.push(request); return request; } }, { key: "_prepareFontLoadEvent", value: function _prepareFontLoadEvent(rules, fonts, request) { function int32(data, offset) { return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff; } function spliceString(s, offset, remove, insert) { var chunk1 = s.substring(0, offset); var chunk2 = s.substring(offset + remove); return chunk1 + insert + chunk2; } var i, ii; var canvas = document.createElement("canvas"); canvas.width = 1; canvas.height = 1; var ctx = canvas.getContext("2d"); var called = 0; function isFontReady(name, callback) { called++; if (called > 30) { (0, _util.warn)("Load test font never loaded."); callback(); return; } ctx.font = "30px " + name; ctx.fillText(".", 0, 20); var imageData = ctx.getImageData(0, 0, 1, 1); if (imageData.data[3] > 0) { callback(); return; } setTimeout(isFontReady.bind(null, name, callback)); } var loadTestFontId = "lt".concat(Date.now()).concat(this.loadTestFontId++); var data = this._loadTestFont; var COMMENT_OFFSET = 976; data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId); var CFF_CHECKSUM_OFFSET = 16; var XXXX_VALUE = 0x58585858; var checksum = int32(data, CFF_CHECKSUM_OFFSET); for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) { checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0; } if (i < loadTestFontId.length) { checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0; } data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum)); var url = "url(data:font/opentype;base64,".concat(btoa(data), ");"); var rule = "@font-face {font-family:\"".concat(loadTestFontId, "\";src:").concat(url, "}"); this.insertRule(rule); var names = []; for (i = 0, ii = fonts.length; i < ii; i++) { names.push(fonts[i].loadedName); } names.push(loadTestFontId); var div = document.createElement("div"); div.style.visibility = "hidden"; div.style.width = div.style.height = "10px"; div.style.position = "absolute"; div.style.top = div.style.left = "0px"; for (i = 0, ii = names.length; i < ii; ++i) { var span = document.createElement("span"); span.textContent = "Hi"; span.style.fontFamily = names[i]; div.appendChild(span); } document.body.appendChild(div); isFontReady(loadTestFontId, function () { document.body.removeChild(div); request.complete(); }); } }, { key: "isSyncFontLoadingSupported", get: function get() { var supported = false; if (typeof navigator === "undefined") { supported = true; } else { var m = /Mozilla\/5.0.*?rv:(\d+).*? Gecko/.exec(navigator.userAgent); if (m && m[1] >= 14) { supported = true; } } return (0, _util.shadow)(this, "isSyncFontLoadingSupported", supported); } }, { key: "_loadTestFont", get: function get() { var getLoadTestFont = function getLoadTestFont() {
return atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
}; return (0, _util.shadow)(this, "_loadTestFont", getLoadTestFont()); } }]); return GenericFontLoader; }(BaseFontLoader); }
var FontFaceObject = /*#__PURE__*/function () {
function FontFaceObject(translatedData, _ref2) { var _ref2$isEvalSupported = _ref2.isEvalSupported, isEvalSupported = _ref2$isEvalSupported === void 0 ? true : _ref2$isEvalSupported, _ref2$disableFontFace = _ref2.disableFontFace, disableFontFace = _ref2$disableFontFace === void 0 ? false : _ref2$disableFontFace, _ref2$ignoreErrors = _ref2.ignoreErrors, ignoreErrors = _ref2$ignoreErrors === void 0 ? false : _ref2$ignoreErrors, _ref2$onUnsupportedFe = _ref2.onUnsupportedFeature, onUnsupportedFeature = _ref2$onUnsupportedFe === void 0 ? null : _ref2$onUnsupportedFe, _ref2$fontRegistry = _ref2.fontRegistry, fontRegistry = _ref2$fontRegistry === void 0 ? null : _ref2$fontRegistry; _classCallCheck(this, FontFaceObject); this.compiledGlyphs = Object.create(null); for (var i in translatedData) { this[i] = translatedData[i]; } this.isEvalSupported = isEvalSupported !== false; this.disableFontFace = disableFontFace === true; this.ignoreErrors = ignoreErrors === true; this._onUnsupportedFeature = onUnsupportedFeature; this.fontRegistry = fontRegistry; } _createClass(FontFaceObject, [{ key: "createNativeFontFace", value: function createNativeFontFace() { if (!this.data || this.disableFontFace) { return null; } var nativeFontFace = new FontFace(this.loadedName, this.data, {}); if (this.fontRegistry) { this.fontRegistry.registerFont(this); } return nativeFontFace; } }, { key: "createFontFaceRule", value: function createFontFaceRule() { if (!this.data || this.disableFontFace) { return null; } var data = (0, _util.bytesToString)(new Uint8Array(this.data)); var url = "url(data:".concat(this.mimetype, ";base64,").concat(btoa(data), ");"); var rule = "@font-face {font-family:\"".concat(this.loadedName, "\";src:").concat(url, "}"); if (this.fontRegistry) { this.fontRegistry.registerFont(this, url); } return rule; } }, { key: "getPathGenerator", value: function getPathGenerator(objs, character) { if (this.compiledGlyphs[character] !== undefined) { return this.compiledGlyphs[character]; } var cmds, current; try { cmds = objs.get(this.loadedName + "_path_" + character); } catch (ex) { if (!this.ignoreErrors) { throw ex; } if (this._onUnsupportedFeature) { this._onUnsupportedFeature({ featureId: _util.UNSUPPORTED_FEATURES.errorFontGetPath }); } (0, _util.warn)("getPathGenerator - ignoring character: \"".concat(ex, "\".")); return this.compiledGlyphs[character] = function (c, size) {}; } if (this.isEvalSupported && _util.IsEvalSupportedCached.value) { var args, js = ""; for (var i = 0, ii = cmds.length; i < ii; i++) { current = cmds[i]; if (current.args !== undefined) { args = current.args.join(","); } else { args = ""; } js += "c." + current.cmd + "(" + args + ");\n"; } return this.compiledGlyphs[character] = new Function("c", "size", js); } return this.compiledGlyphs[character] = function (c, size) { for (var _i = 0, _ii = cmds.length; _i < _ii; _i++) { current = cmds[_i]; if (current.cmd === "scale") { current.args = [size, -size]; } c[current.cmd].apply(c, current.args); } }; } }]); return FontFaceObject; }(); exports.FontFaceObject = FontFaceObject;
/***/ }),
/* 205 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.apiCompatibilityParams = void 0; var _is_node = __w_pdfjs_require__(7); var compatibilityParams = Object.create(null); { (function checkFontFace() { if (_is_node.isNodeJS) { compatibilityParams.disableFontFace = true; } })(); } var apiCompatibilityParams = Object.freeze(compatibilityParams); exports.apiCompatibilityParams = apiCompatibilityParams;
/***/ }),
/* 206 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.CanvasGraphics = void 0; var _util = __w_pdfjs_require__(5); var _pattern_helper = __w_pdfjs_require__(207);
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; } var MIN_FONT_SIZE = 16; var MAX_FONT_SIZE = 100; var MAX_GROUP_SIZE = 4096; var MIN_WIDTH_FACTOR = 0.65; var COMPILE_TYPE3_GLYPHS = true; var MAX_SIZE_TO_COMPILE = 1000; var FULL_CHUNK_HEIGHT = 16; function addContextCurrentTransform(ctx) { if (!ctx.mozCurrentTransform) { ctx._originalSave = ctx.save; ctx._originalRestore = ctx.restore; ctx._originalRotate = ctx.rotate; ctx._originalScale = ctx.scale; ctx._originalTranslate = ctx.translate; ctx._originalTransform = ctx.transform; ctx._originalSetTransform = ctx.setTransform; ctx._transformMatrix = ctx._transformMatrix || [1, 0, 0, 1, 0, 0]; ctx._transformStack = []; Object.defineProperty(ctx, "mozCurrentTransform", { get: function getCurrentTransform() { return this._transformMatrix; } }); Object.defineProperty(ctx, "mozCurrentTransformInverse", { get: function getCurrentTransformInverse() { var m = this._transformMatrix; var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5]; var ad_bc = a * d - b * c; var bc_ad = b * c - a * d; return [d / ad_bc, b / bc_ad, c / bc_ad, a / ad_bc, (d * e - c * f) / bc_ad, (b * e - a * f) / ad_bc]; } }); ctx.save = function ctxSave() { var old = this._transformMatrix; this._transformStack.push(old); this._transformMatrix = old.slice(0, 6); this._originalSave(); }; ctx.restore = function ctxRestore() { var prev = this._transformStack.pop(); if (prev) { this._transformMatrix = prev; this._originalRestore(); } }; ctx.translate = function ctxTranslate(x, y) { var m = this._transformMatrix; m[4] = m[0] * x + m[2] * y + m[4]; m[5] = m[1] * x + m[3] * y + m[5]; this._originalTranslate(x, y); }; ctx.scale = function ctxScale(x, y) { var m = this._transformMatrix; m[0] = m[0] * x; m[1] = m[1] * x; m[2] = m[2] * y; m[3] = m[3] * y; this._originalScale(x, y); }; ctx.transform = function ctxTransform(a, b, c, d, e, f) { var m = this._transformMatrix; this._transformMatrix = [m[0] * a + m[2] * b, m[1] * a + m[3] * b, m[0] * c + m[2] * d, m[1] * c + m[3] * d, m[0] * e + m[2] * f + m[4], m[1] * e + m[3] * f + m[5]]; ctx._originalTransform(a, b, c, d, e, f); }; ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) { this._transformMatrix = [a, b, c, d, e, f]; ctx._originalSetTransform(a, b, c, d, e, f); }; ctx.rotate = function ctxRotate(angle) { var cosValue = Math.cos(angle); var sinValue = Math.sin(angle); var m = this._transformMatrix; this._transformMatrix = [m[0] * cosValue + m[2] * sinValue, m[1] * cosValue + m[3] * sinValue, m[0] * -sinValue + m[2] * cosValue, m[1] * -sinValue + m[3] * cosValue, m[4], m[5]]; this._originalRotate(angle); }; } } var CachedCanvases = function CachedCanvasesClosure() { function CachedCanvases(canvasFactory) { this.canvasFactory = canvasFactory; this.cache = Object.create(null); } CachedCanvases.prototype = { getCanvas: function CachedCanvases_getCanvas(id, width, height, trackTransform) { var canvasEntry; if (this.cache[id] !== undefined) { canvasEntry = this.cache[id]; this.canvasFactory.reset(canvasEntry, width, height); canvasEntry.context.setTransform(1, 0, 0, 1, 0, 0); } else { canvasEntry = this.canvasFactory.create(width, height); this.cache[id] = canvasEntry; } if (trackTransform) { addContextCurrentTransform(canvasEntry.context); } return canvasEntry; }, clear: function clear() { for (var id in this.cache) { var canvasEntry = this.cache[id]; this.canvasFactory.destroy(canvasEntry); delete this.cache[id]; } } }; return CachedCanvases; }(); function compileType3Glyph(imgData) { var POINT_TO_PROCESS_LIMIT = 1000; var width = imgData.width, height = imgData.height; var i, j, j0, width1 = width + 1; var points = new Uint8Array(width1 * (height + 1)); var POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]); var lineSize = width + 7 & ~7, data0 = imgData.data; var data = new Uint8Array(lineSize * height), pos = 0, ii; for (i = 0, ii = data0.length; i < ii; i++) { var mask = 128, elem = data0[i]; while (mask > 0) { data[pos++] = elem & mask ? 0 : 255; mask >>= 1; } } var count = 0; pos = 0; if (data[pos] !== 0) { points[0] = 1; ++count; } for (j = 1; j < width; j++) { if (data[pos] !== data[pos + 1]) { points[j] = data[pos] ? 2 : 1; ++count; } pos++; } if (data[pos] !== 0) { points[j] = 2; ++count; } for (i = 1; i < height; i++) { pos = i * lineSize; j0 = i * width1; if (data[pos - lineSize] !== data[pos]) { points[j0] = data[pos] ? 1 : 8; ++count; } var sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0); for (j = 1; j < width; j++) { sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0); if (POINT_TYPES[sum]) { points[j0 + j] = POINT_TYPES[sum]; ++count; } pos++; } if (data[pos - lineSize] !== data[pos]) { points[j0 + j] = data[pos] ? 2 : 4; ++count; } if (count > POINT_TO_PROCESS_LIMIT) { return null; } } pos = lineSize * (height - 1); j0 = i * width1; if (data[pos] !== 0) { points[j0] = 8; ++count; } for (j = 1; j < width; j++) { if (data[pos] !== data[pos + 1]) { points[j0 + j] = data[pos] ? 4 : 8; ++count; } pos++; } if (data[pos] !== 0) { points[j0 + j] = 4; ++count; } if (count > POINT_TO_PROCESS_LIMIT) { return null; } var steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]); var outlines = []; for (i = 0; count && i <= height; i++) { var p = i * width1; var end = p + width; while (p < end && !points[p]) { p++; } if (p === end) { continue; } var coords = [p % width1, i]; var type = points[p], p0 = p, pp; do { var step = steps[type]; do { p += step; } while (!points[p]); pp = points[p]; if (pp !== 5 && pp !== 10) { type = pp; points[p] = 0; } else { type = pp & 0x33 * type >> 4; points[p] &= type >> 2 | type << 2; } coords.push(p % width1); coords.push(p / width1 | 0); if (!points[p]) { --count; } } while (p0 !== p); outlines.push(coords); --i; } var drawOutline = function drawOutline(c) { c.save(); c.scale(1 / width, -1 / height); c.translate(0, -height); c.beginPath(); for (var k = 0, kk = outlines.length; k < kk; k++) { var o = outlines[k]; c.moveTo(o[0], o[1]); for (var l = 2, ll = o.length; l < ll; l += 2) { c.lineTo(o[l], o[l + 1]); } } c.fill(); c.beginPath(); c.restore(); }; return drawOutline; } var CanvasExtraState = function CanvasExtraStateClosure() { function CanvasExtraState() { this.alphaIsShape = false; this.fontSize = 0; this.fontSizeScale = 1; this.textMatrix = _util.IDENTITY_MATRIX; this.textMatrixScale = 1; this.fontMatrix = _util.FONT_IDENTITY_MATRIX; this.leading = 0; this.x = 0; this.y = 0; this.lineX = 0; this.lineY = 0; this.charSpacing = 0; this.wordSpacing = 0; this.textHScale = 1; this.textRenderingMode = _util.TextRenderingMode.FILL; this.textRise = 0; this.fillColor = "#000000"; this.strokeColor = "#000000"; this.patternFill = false; this.fillAlpha = 1; this.strokeAlpha = 1; this.lineWidth = 1; this.activeSMask = null; this.resumeSMaskCtx = null; } CanvasExtraState.prototype = { clone: function CanvasExtraState_clone() { return Object.create(this); }, setCurrentPoint: function CanvasExtraState_setCurrentPoint(x, y) { this.x = x; this.y = y; } }; return CanvasExtraState; }(); var CanvasGraphics = function CanvasGraphicsClosure() { var EXECUTION_TIME = 15; var EXECUTION_STEPS = 10; function CanvasGraphics(canvasCtx, commonObjs, objs, canvasFactory, webGLContext, imageLayer) { this.ctx = canvasCtx; this.current = new CanvasExtraState(); this.stateStack = []; this.pendingClip = null; this.pendingEOFill = false; this.res = null; this.xobjs = null; this.commonObjs = commonObjs; this.objs = objs; this.canvasFactory = canvasFactory; this.webGLContext = webGLContext; this.imageLayer = imageLayer; this.groupStack = []; this.processingType3 = null; this.baseTransform = null; this.baseTransformStack = []; this.groupLevel = 0; this.smaskStack = []; this.smaskCounter = 0; this.tempSMask = null; this.cachedCanvases = new CachedCanvases(this.canvasFactory); if (canvasCtx) { addContextCurrentTransform(canvasCtx); } this._cachedGetSinglePixelWidth = null; } function putBinaryImageData(ctx, imgData) { if (typeof ImageData !== "undefined" && imgData instanceof ImageData) { ctx.putImageData(imgData, 0, 0); return; } var height = imgData.height, width = imgData.width; var partialChunkHeight = height % FULL_CHUNK_HEIGHT; var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT; var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1; var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT); var srcPos = 0, destPos; var src = imgData.data; var dest = chunkImgData.data; var i, j, thisChunkHeight, elemsInThisChunk; if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) { var srcLength = src.byteLength; var dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2); var dest32DataLength = dest32.length; var fullSrcDiff = width + 7 >> 3; var white = 0xffffffff; var black = _util.IsLittleEndianCached.value ? 0xff000000 : 0x000000ff; for (i = 0; i < totalChunks; i++) { thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight; destPos = 0; for (j = 0; j < thisChunkHeight; j++) { var srcDiff = srcLength - srcPos; var k = 0; var kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7; var kEndUnrolled = kEnd & ~7; var mask = 0; var srcByte = 0; for (; k < kEndUnrolled; k += 8) { srcByte = src[srcPos++]; dest32[destPos++] = srcByte & 128 ? white : black; dest32[destPos++] = srcByte & 64 ? white : black; dest32[destPos++] = srcByte & 32 ? white : black; dest32[destPos++] = srcByte & 16 ? white : black; dest32[destPos++] = srcByte & 8 ? white : black; dest32[destPos++] = srcByte & 4 ? white : black; dest32[destPos++] = srcByte & 2 ? white : black; dest32[destPos++] = srcByte & 1 ? white : black; } for (; k < kEnd; k++) { if (mask === 0) { srcByte = src[srcPos++]; mask = 128; } dest32[destPos++] = srcByte & mask ? white : black; mask >>= 1; } } while (destPos < dest32DataLength) { dest32[destPos++] = 0; } ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) { j = 0; elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4; for (i = 0; i < fullChunks; i++) { dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk)); srcPos += elemsInThisChunk; ctx.putImageData(chunkImgData, 0, j); j += FULL_CHUNK_HEIGHT; } if (i < totalChunks) { elemsInThisChunk = width * partialChunkHeight * 4; dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk)); ctx.putImageData(chunkImgData, 0, j); } } else if (imgData.kind === _util.ImageKind.RGB_24BPP) { thisChunkHeight = FULL_CHUNK_HEIGHT; elemsInThisChunk = width * thisChunkHeight; for (i = 0; i < totalChunks; i++) { if (i >= fullChunks) { thisChunkHeight = partialChunkHeight; elemsInThisChunk = width * thisChunkHeight; } destPos = 0; for (j = elemsInThisChunk; j--;) { dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++]; dest[destPos++] = src[srcPos++]; dest[destPos++] = 255; } ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } else { throw new Error("bad image kind: ".concat(imgData.kind)); } } function putBinaryImageMask(ctx, imgData) { var height = imgData.height, width = imgData.width; var partialChunkHeight = height % FULL_CHUNK_HEIGHT; var fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT; var totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1; var chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT); var srcPos = 0; var src = imgData.data; var dest = chunkImgData.data; for (var i = 0; i < totalChunks; i++) { var thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight; var destPos = 3; for (var j = 0; j < thisChunkHeight; j++) { var mask = 0; for (var k = 0; k < width; k++) { if (!mask) { var elem = src[srcPos++]; mask = 128; } dest[destPos] = elem & mask ? 0 : 255; destPos += 4; mask >>= 1; } } ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT); } } function copyCtxState(sourceCtx, destCtx) { var properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font"]; for (var i = 0, ii = properties.length; i < ii; i++) { var property = properties[i]; if (sourceCtx[property] !== undefined) { destCtx[property] = sourceCtx[property]; } } if (sourceCtx.setLineDash !== undefined) { destCtx.setLineDash(sourceCtx.getLineDash()); destCtx.lineDashOffset = sourceCtx.lineDashOffset; } } function resetCtxToDefault(ctx) { ctx.strokeStyle = "#000000"; ctx.fillStyle = "#000000"; ctx.fillRule = "nonzero"; ctx.globalAlpha = 1; ctx.lineWidth = 1; ctx.lineCap = "butt"; ctx.lineJoin = "miter"; ctx.miterLimit = 10; ctx.globalCompositeOperation = "source-over"; ctx.font = "10px sans-serif"; if (ctx.setLineDash !== undefined) { ctx.setLineDash([]); ctx.lineDashOffset = 0; } } function composeSMaskBackdrop(bytes, r0, g0, b0) { var length = bytes.length; for (var i = 3; i < length; i += 4) { var alpha = bytes[i]; if (alpha === 0) { bytes[i - 3] = r0; bytes[i - 2] = g0; bytes[i - 1] = b0; } else if (alpha < 255) { var alpha_ = 255 - alpha; bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8; bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8; bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8; } } } function composeSMaskAlpha(maskData, layerData, transferMap) { var length = maskData.length; var scale = 1 / 255; for (var i = 3; i < length; i += 4) { var alpha = transferMap ? transferMap[maskData[i]] : maskData[i]; layerData[i] = layerData[i] * alpha * scale | 0; } } function composeSMaskLuminosity(maskData, layerData, transferMap) { var length = maskData.length; for (var i = 3; i < length; i += 4) { var y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28; layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16; } } function genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap) { var hasBackdrop = !!backdrop; var r0 = hasBackdrop ? backdrop[0] : 0; var g0 = hasBackdrop ? backdrop[1] : 0; var b0 = hasBackdrop ? backdrop[2] : 0; var composeFn; if (subtype === "Luminosity") { composeFn = composeSMaskLuminosity; } else { composeFn = composeSMaskAlpha; } var PIXELS_TO_PROCESS = 1048576; var chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width)); for (var row = 0; row < height; row += chunkSize) { var chunkHeight = Math.min(chunkSize, height - row); var maskData = maskCtx.getImageData(0, row, width, chunkHeight); var layerData = layerCtx.getImageData(0, row, width, chunkHeight); if (hasBackdrop) { composeSMaskBackdrop(maskData.data, r0, g0, b0); } composeFn(maskData.data, layerData.data, transferMap); maskCtx.putImageData(layerData, 0, row); } } function composeSMask(ctx, smask, layerCtx, webGLContext) { var mask = smask.canvas; var maskCtx = smask.context; ctx.setTransform(smask.scaleX, 0, 0, smask.scaleY, smask.offsetX, smask.offsetY); var backdrop = smask.backdrop || null; if (!smask.transferMap && webGLContext.isEnabled) { var composed = webGLContext.composeSMask({ layer: layerCtx.canvas, mask: mask, properties: { subtype: smask.subtype, backdrop: backdrop } }); ctx.setTransform(1, 0, 0, 1, 0, 0); ctx.drawImage(composed, smask.offsetX, smask.offsetY); return; } genericComposeSMask(maskCtx, layerCtx, mask.width, mask.height, smask.subtype, backdrop, smask.transferMap); ctx.drawImage(mask, 0, 0); } var LINE_CAP_STYLES = ["butt", "round", "square"]; var LINE_JOIN_STYLES = ["miter", "round", "bevel"]; var NORMAL_CLIP = {}; var EO_CLIP = {}; CanvasGraphics.prototype = { beginDrawing: function beginDrawing(_ref) { var transform = _ref.transform, viewport = _ref.viewport, _ref$transparency = _ref.transparency, transparency = _ref$transparency === void 0 ? false : _ref$transparency, _ref$background = _ref.background, background = _ref$background === void 0 ? null : _ref$background; var width = this.ctx.canvas.width; var height = this.ctx.canvas.height; this.ctx.save(); this.ctx.fillStyle = background || "rgb(255, 255, 255)"; this.ctx.fillRect(0, 0, width, height); this.ctx.restore(); if (transparency) { var transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height, true); this.compositeCtx = this.ctx; this.transparentCanvas = transparentCanvas.canvas; this.ctx = transparentCanvas.context; this.ctx.save(); this.ctx.transform.apply(this.ctx, this.compositeCtx.mozCurrentTransform); } this.ctx.save(); resetCtxToDefault(this.ctx); if (transform) { this.ctx.transform.apply(this.ctx, transform); } this.ctx.transform.apply(this.ctx, viewport.transform); this.baseTransform = this.ctx.mozCurrentTransform.slice(); if (this.imageLayer) { this.imageLayer.beginLayout(); } }, executeOperatorList: function CanvasGraphics_executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) { var argsArray = operatorList.argsArray; var fnArray = operatorList.fnArray; var i = executionStartIdx || 0; var argsArrayLen = argsArray.length; if (argsArrayLen === i) { return i; } var chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function"; var endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0; var steps = 0; var commonObjs = this.commonObjs; var objs = this.objs; var fnId; while (true) { if (stepper !== undefined && i === stepper.nextBreakPoint) { stepper.breakIt(i, continueCallback); return i; } fnId = fnArray[i]; if (fnId !== _util.OPS.dependency) { this[fnId].apply(this, argsArray[i]); } else { var _iterator = _createForOfIteratorHelper(argsArray[i]), _step; try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var depObjId = _step.value; var objsPool = depObjId.startsWith("g_") ? commonObjs : objs; if (!objsPool.has(depObjId)) { objsPool.get(depObjId, continueCallback); return i; } } } catch (err) { _iterator.e(err); } finally { _iterator.f(); } } i++; if (i === argsArrayLen) { return i; } if (chunkOperations && ++steps > EXECUTION_STEPS) { if (Date.now() > endTime) { continueCallback(); return i; } steps = 0; } } }, endDrawing: function CanvasGraphics_endDrawing() { if (this.current.activeSMask !== null) { this.endSMaskGroup(); } this.ctx.restore(); if (this.transparentCanvas) { this.ctx = this.compositeCtx; this.ctx.save(); this.ctx.setTransform(1, 0, 0, 1, 0, 0); this.ctx.drawImage(this.transparentCanvas, 0, 0); this.ctx.restore(); this.transparentCanvas = null; } this.cachedCanvases.clear(); this.webGLContext.clear(); if (this.imageLayer) { this.imageLayer.endLayout(); } }, setLineWidth: function CanvasGraphics_setLineWidth(width) { this.current.lineWidth = width; this.ctx.lineWidth = width; }, setLineCap: function CanvasGraphics_setLineCap(style) { this.ctx.lineCap = LINE_CAP_STYLES[style]; }, setLineJoin: function CanvasGraphics_setLineJoin(style) { this.ctx.lineJoin = LINE_JOIN_STYLES[style]; }, setMiterLimit: function CanvasGraphics_setMiterLimit(limit) { this.ctx.miterLimit = limit; }, setDash: function CanvasGraphics_setDash(dashArray, dashPhase) { var ctx = this.ctx; if (ctx.setLineDash !== undefined) { ctx.setLineDash(dashArray); ctx.lineDashOffset = dashPhase; } }, setRenderingIntent: function setRenderingIntent(intent) {}, setFlatness: function setFlatness(flatness) {}, setGState: function CanvasGraphics_setGState(states) { for (var i = 0, ii = states.length; i < ii; i++) { var state = states[i]; var key = state[0]; var value = state[1]; switch (key) { case "LW": this.setLineWidth(value); break; case "LC": this.setLineCap(value); break; case "LJ": this.setLineJoin(value); break; case "ML": this.setMiterLimit(value); break; case "D": this.setDash(value[0], value[1]); break; case "RI": this.setRenderingIntent(value); break; case "FL": this.setFlatness(value); break; case "Font": this.setFont(value[0], value[1]); break; case "CA": this.current.strokeAlpha = state[1]; break; case "ca": this.current.fillAlpha = state[1]; this.ctx.globalAlpha = state[1]; break; case "BM": this.ctx.globalCompositeOperation = value; break; case "SMask": if (this.current.activeSMask) { if (this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1].activeSMask === this.current.activeSMask) { this.suspendSMaskGroup(); } else { this.endSMaskGroup(); } } this.current.activeSMask = value ? this.tempSMask : null; if (this.current.activeSMask) { this.beginSMaskGroup(); } this.tempSMask = null; break; } } }, beginSMaskGroup: function CanvasGraphics_beginSMaskGroup() { var activeSMask = this.current.activeSMask; var drawnWidth = activeSMask.canvas.width; var drawnHeight = activeSMask.canvas.height; var cacheId = "smaskGroupAt" + this.groupLevel; var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true); var currentCtx = this.ctx; var currentTransform = currentCtx.mozCurrentTransform; this.ctx.save(); var groupCtx = scratchCanvas.context; groupCtx.scale(1 / activeSMask.scaleX, 1 / activeSMask.scaleY); groupCtx.translate(-activeSMask.offsetX, -activeSMask.offsetY); groupCtx.transform.apply(groupCtx, currentTransform); activeSMask.startTransformInverse = groupCtx.mozCurrentTransformInverse; copyCtxState(currentCtx, groupCtx); this.ctx = groupCtx; this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]); this.groupStack.push(currentCtx); this.groupLevel++; }, suspendSMaskGroup: function CanvasGraphics_endSMaskGroup() { var groupCtx = this.ctx; this.groupLevel--; this.ctx = this.groupStack.pop(); composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext); this.ctx.restore(); this.ctx.save(); copyCtxState(groupCtx, this.ctx); this.current.resumeSMaskCtx = groupCtx; var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform); this.ctx.transform.apply(this.ctx, deltaTransform); groupCtx.save(); groupCtx.setTransform(1, 0, 0, 1, 0, 0); groupCtx.clearRect(0, 0, groupCtx.canvas.width, groupCtx.canvas.height); groupCtx.restore(); }, resumeSMaskGroup: function CanvasGraphics_endSMaskGroup() { var groupCtx = this.current.resumeSMaskCtx; var currentCtx = this.ctx; this.ctx = groupCtx; this.groupStack.push(currentCtx); this.groupLevel++; }, endSMaskGroup: function CanvasGraphics_endSMaskGroup() { var groupCtx = this.ctx; this.groupLevel--; this.ctx = this.groupStack.pop(); composeSMask(this.ctx, this.current.activeSMask, groupCtx, this.webGLContext); this.ctx.restore(); copyCtxState(groupCtx, this.ctx); var deltaTransform = _util.Util.transform(this.current.activeSMask.startTransformInverse, groupCtx.mozCurrentTransform); this.ctx.transform.apply(this.ctx, deltaTransform); }, save: function CanvasGraphics_save() { this.ctx.save(); var old = this.current; this.stateStack.push(old); this.current = old.clone(); this.current.resumeSMaskCtx = null; }, restore: function CanvasGraphics_restore() { if (this.current.resumeSMaskCtx) { this.resumeSMaskGroup(); } if (this.current.activeSMask !== null && (this.stateStack.length === 0 || this.stateStack[this.stateStack.length - 1].activeSMask !== this.current.activeSMask)) { this.endSMaskGroup(); } if (this.stateStack.length !== 0) { this.current = this.stateStack.pop(); this.ctx.restore(); this.pendingClip = null; this._cachedGetSinglePixelWidth = null; } }, transform: function CanvasGraphics_transform(a, b, c, d, e, f) { this.ctx.transform(a, b, c, d, e, f); this._cachedGetSinglePixelWidth = null; }, constructPath: function CanvasGraphics_constructPath(ops, args) { var ctx = this.ctx; var current = this.current; var x = current.x, y = current.y; for (var i = 0, j = 0, ii = ops.length; i < ii; i++) { switch (ops[i] | 0) { case _util.OPS.rectangle: x = args[j++]; y = args[j++]; var width = args[j++]; var height = args[j++]; if (width === 0) { width = this.getSinglePixelWidth(); } if (height === 0) { height = this.getSinglePixelWidth(); } var xw = x + width; var yh = y + height; this.ctx.moveTo(x, y); this.ctx.lineTo(xw, y); this.ctx.lineTo(xw, yh); this.ctx.lineTo(x, yh); this.ctx.lineTo(x, y); this.ctx.closePath(); break; case _util.OPS.moveTo: x = args[j++]; y = args[j++]; ctx.moveTo(x, y); break; case _util.OPS.lineTo: x = args[j++]; y = args[j++]; ctx.lineTo(x, y); break; case _util.OPS.curveTo: x = args[j + 4]; y = args[j + 5]; ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y); j += 6; break; case _util.OPS.curveTo2: ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]); x = args[j + 2]; y = args[j + 3]; j += 4; break; case _util.OPS.curveTo3: x = args[j + 2]; y = args[j + 3]; ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y); j += 4; break; case _util.OPS.closePath: ctx.closePath(); break; } } current.setCurrentPoint(x, y); }, closePath: function CanvasGraphics_closePath() { this.ctx.closePath(); }, stroke: function CanvasGraphics_stroke(consumePath) { consumePath = typeof consumePath !== "undefined" ? consumePath : true; var ctx = this.ctx; var strokeColor = this.current.strokeColor; ctx.globalAlpha = this.current.strokeAlpha; if (strokeColor && strokeColor.hasOwnProperty("type") && strokeColor.type === "Pattern") { ctx.save(); var transform = ctx.mozCurrentTransform; var scale = _util.Util.singularValueDecompose2dScale(transform)[0]; ctx.strokeStyle = strokeColor.getPattern(ctx, this); ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth * scale); ctx.stroke(); ctx.restore(); } else { ctx.lineWidth = Math.max(this.getSinglePixelWidth() * MIN_WIDTH_FACTOR, this.current.lineWidth); ctx.stroke(); } if (consumePath) { this.consumePath(); } ctx.globalAlpha = this.current.fillAlpha; }, closeStroke: function CanvasGraphics_closeStroke() { this.closePath(); this.stroke(); }, fill: function CanvasGraphics_fill(consumePath) { consumePath = typeof consumePath !== "undefined" ? consumePath : true; var ctx = this.ctx; var fillColor = this.current.fillColor; var isPatternFill = this.current.patternFill; var needRestore = false; if (isPatternFill) { ctx.save(); if (this.baseTransform) { ctx.setTransform.apply(ctx, this.baseTransform); } ctx.fillStyle = fillColor.getPattern(ctx, this); needRestore = true; } if (this.pendingEOFill) { ctx.fill("evenodd"); this.pendingEOFill = false; } else { ctx.fill(); } if (needRestore) { ctx.restore(); } if (consumePath) { this.consumePath(); } }, eoFill: function CanvasGraphics_eoFill() { this.pendingEOFill = true; this.fill(); }, fillStroke: function CanvasGraphics_fillStroke() { this.fill(false); this.stroke(false); this.consumePath(); }, eoFillStroke: function CanvasGraphics_eoFillStroke() { this.pendingEOFill = true; this.fillStroke(); }, closeFillStroke: function CanvasGraphics_closeFillStroke() { this.closePath(); this.fillStroke(); }, closeEOFillStroke: function CanvasGraphics_closeEOFillStroke() { this.pendingEOFill = true; this.closePath(); this.fillStroke(); }, endPath: function CanvasGraphics_endPath() { this.consumePath(); }, clip: function CanvasGraphics_clip() { this.pendingClip = NORMAL_CLIP; }, eoClip: function CanvasGraphics_eoClip() { this.pendingClip = EO_CLIP; }, beginText: function CanvasGraphics_beginText() { this.current.textMatrix = _util.IDENTITY_MATRIX; this.current.textMatrixScale = 1; this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0; }, endText: function CanvasGraphics_endText() { var paths = this.pendingTextPaths; var ctx = this.ctx; if (paths === undefined) { ctx.beginPath(); return; } ctx.save(); ctx.beginPath(); for (var i = 0; i < paths.length; i++) { var path = paths[i]; ctx.setTransform.apply(ctx, path.transform); ctx.translate(path.x, path.y); path.addToPath(ctx, path.fontSize); } ctx.restore(); ctx.clip(); ctx.beginPath(); delete this.pendingTextPaths; }, setCharSpacing: function CanvasGraphics_setCharSpacing(spacing) { this.current.charSpacing = spacing; }, setWordSpacing: function CanvasGraphics_setWordSpacing(spacing) { this.current.wordSpacing = spacing; }, setHScale: function CanvasGraphics_setHScale(scale) { this.current.textHScale = scale / 100; }, setLeading: function CanvasGraphics_setLeading(leading) { this.current.leading = -leading; }, setFont: function CanvasGraphics_setFont(fontRefName, size) { var fontObj = this.commonObjs.get(fontRefName); var current = this.current; if (!fontObj) { throw new Error("Can't find font for ".concat(fontRefName)); } current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX; if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) { (0, _util.warn)("Invalid font matrix for font " + fontRefName); } if (size < 0) { size = -size; current.fontDirection = -1; } else { current.fontDirection = 1; } this.current.font = fontObj; this.current.fontSize = size; if (fontObj.isType3Font) { return; } var name = fontObj.loadedName || "sans-serif"; var bold = "normal"; if (fontObj.black) { bold = "900"; } else if (fontObj.bold) { bold = "bold"; } var italic = fontObj.italic ? "italic" : "normal"; var typeface = "\"".concat(name, "\", ").concat(fontObj.fallbackName); var browserFontSize = size; if (size < MIN_FONT_SIZE) { browserFontSize = MIN_FONT_SIZE; } else if (size > MAX_FONT_SIZE) { browserFontSize = MAX_FONT_SIZE; } this.current.fontSizeScale = size / browserFontSize; this.ctx.font = "".concat(italic, " ").concat(bold, " ").concat(browserFontSize, "px ").concat(typeface); }, setTextRenderingMode: function CanvasGraphics_setTextRenderingMode(mode) { this.current.textRenderingMode = mode; }, setTextRise: function CanvasGraphics_setTextRise(rise) { this.current.textRise = rise; }, moveText: function CanvasGraphics_moveText(x, y) { this.current.x = this.current.lineX += x; this.current.y = this.current.lineY += y; }, setLeadingMoveText: function CanvasGraphics_setLeadingMoveText(x, y) { this.setLeading(-y); this.moveText(x, y); }, setTextMatrix: function CanvasGraphics_setTextMatrix(a, b, c, d, e, f) { this.current.textMatrix = [a, b, c, d, e, f]; this.current.textMatrixScale = Math.sqrt(a * a + b * b); this.current.x = this.current.lineX = 0; this.current.y = this.current.lineY = 0; }, nextLine: function CanvasGraphics_nextLine() { this.moveText(0, this.current.leading); }, paintChar: function paintChar(character, x, y, patternTransform) { var ctx = this.ctx; var current = this.current; var font = current.font; var textRenderingMode = current.textRenderingMode; var fontSize = current.fontSize / current.fontSizeScale; var fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; var isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG); var patternFill = current.patternFill && !font.missingFile; var addToPath; if (font.disableFontFace || isAddToPathSet || patternFill) { addToPath = font.getPathGenerator(this.commonObjs, character); } if (font.disableFontFace || patternFill) { ctx.save(); ctx.translate(x, y); ctx.beginPath(); addToPath(ctx, fontSize); if (patternTransform) { ctx.setTransform.apply(ctx, patternTransform); } if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.fill(); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.stroke(); } ctx.restore(); } else { if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.fillText(character, x, y); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { ctx.strokeText(character, x, y); } } if (isAddToPathSet) { var paths = this.pendingTextPaths || (this.pendingTextPaths = []); paths.push({ transform: ctx.mozCurrentTransform, x: x, y: y, fontSize: fontSize, addToPath: addToPath }); } }, get isFontSubpixelAAEnabled() { var _this$cachedCanvases$ = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10), ctx = _this$cachedCanvases$.context; ctx.scale(1.5, 1); ctx.fillText("I", 0, 10); var data = ctx.getImageData(0, 0, 10, 10).data; var enabled = false; for (var i = 3; i < data.length; i += 4) { if (data[i] > 0 && data[i] < 255) { enabled = true; break; } } return (0, _util.shadow)(this, "isFontSubpixelAAEnabled", enabled); }, showText: function CanvasGraphics_showText(glyphs) { var current = this.current; var font = current.font; if (font.isType3Font) { return this.showType3Text(glyphs); } var fontSize = current.fontSize; if (fontSize === 0) { return undefined; } var ctx = this.ctx; var fontSizeScale = current.fontSizeScale; var charSpacing = current.charSpacing; var wordSpacing = current.wordSpacing; var fontDirection = current.fontDirection; var textHScale = current.textHScale * fontDirection; var glyphsLength = glyphs.length; var vertical = font.vertical; var spacingDir = vertical ? 1 : -1; var defaultVMetrics = font.defaultVMetrics; var widthAdvanceScale = fontSize * current.fontMatrix[0]; var simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill; ctx.save(); var patternTransform; if (current.patternFill) { ctx.save(); var pattern = current.fillColor.getPattern(ctx, this); patternTransform = ctx.mozCurrentTransform; ctx.restore(); ctx.fillStyle = pattern; } ctx.transform.apply(ctx, current.textMatrix); ctx.translate(current.x, current.y + current.textRise); if (fontDirection > 0) { ctx.scale(textHScale, -1); } else { ctx.scale(textHScale, 1); } var lineWidth = current.lineWidth; var scale = current.textMatrixScale; if (scale === 0 || lineWidth === 0) { var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { this._cachedGetSinglePixelWidth = null; lineWidth = this.getSinglePixelWidth() * MIN_WIDTH_FACTOR; } } else { lineWidth /= scale; } if (fontSizeScale !== 1.0) { ctx.scale(fontSizeScale, fontSizeScale); lineWidth /= fontSizeScale; } ctx.lineWidth = lineWidth; var x = 0, i; for (i = 0; i < glyphsLength; ++i) { var glyph = glyphs[i]; if ((0, _util.isNum)(glyph)) { x += spacingDir * glyph * fontSize / 1000; continue; } var restoreNeeded = false; var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; var character = glyph.fontChar; var accent = glyph.accent; var scaledX, scaledY, scaledAccentX, scaledAccentY; var width = glyph.width; if (vertical) { var vmetric, vx, vy; vmetric = glyph.vmetric || defaultVMetrics; vx = glyph.vmetric ? vmetric[1] : width * 0.5; vx = -vx * widthAdvanceScale; vy = vmetric[2] * widthAdvanceScale; width = vmetric ? -vmetric[0] : width; scaledX = vx / fontSizeScale; scaledY = (x + vy) / fontSizeScale; } else { scaledX = x / fontSizeScale; scaledY = 0; } if (font.remeasure && width > 0) { var measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale; if (width < measuredWidth && this.isFontSubpixelAAEnabled) { var characterScaleX = width / measuredWidth; restoreNeeded = true; ctx.save(); ctx.scale(characterScaleX, 1); scaledX /= characterScaleX; } else if (width !== measuredWidth) { scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale; } } if (glyph.isInFont || font.missingFile) { if (simpleFillText && !accent) { ctx.fillText(character, scaledX, scaledY); } else { this.paintChar(character, scaledX, scaledY, patternTransform); if (accent) { scaledAccentX = scaledX + accent.offset.x / fontSizeScale; scaledAccentY = scaledY - accent.offset.y / fontSizeScale; this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform); } } } var charWidth; if (vertical) { charWidth = width * widthAdvanceScale - spacing * fontDirection; } else { charWidth = width * widthAdvanceScale + spacing * fontDirection; } x += charWidth; if (restoreNeeded) { ctx.restore(); } } if (vertical) { current.y -= x; } else { current.x += x * textHScale; } ctx.restore(); }, showType3Text: function CanvasGraphics_showType3Text(glyphs) { var ctx = this.ctx; var current = this.current; var font = current.font; var fontSize = current.fontSize; var fontDirection = current.fontDirection; var spacingDir = font.vertical ? 1 : -1; var charSpacing = current.charSpacing; var wordSpacing = current.wordSpacing; var textHScale = current.textHScale * fontDirection; var fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX; var glyphsLength = glyphs.length; var isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE; var i, glyph, width, spacingLength; if (isTextInvisible || fontSize === 0) { return; } this._cachedGetSinglePixelWidth = null; ctx.save(); ctx.transform.apply(ctx, current.textMatrix); ctx.translate(current.x, current.y); ctx.scale(textHScale, fontDirection); for (i = 0; i < glyphsLength; ++i) { glyph = glyphs[i]; if ((0, _util.isNum)(glyph)) { spacingLength = spacingDir * glyph * fontSize / 1000; this.ctx.translate(spacingLength, 0); current.x += spacingLength * textHScale; continue; } var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; var operatorList = font.charProcOperatorList[glyph.operatorListId]; if (!operatorList) { (0, _util.warn)("Type3 character \"".concat(glyph.operatorListId, "\" is not available.")); continue; } this.processingType3 = glyph; this.save(); ctx.scale(fontSize, fontSize); ctx.transform.apply(ctx, fontMatrix); this.executeOperatorList(operatorList); this.restore(); var transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix); width = transformed[0] * fontSize + spacing; ctx.translate(width, 0); current.x += width * textHScale; } ctx.restore(); this.processingType3 = null; }, setCharWidth: function CanvasGraphics_setCharWidth(xWidth, yWidth) {}, setCharWidthAndBounds: function CanvasGraphics_setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) { this.ctx.rect(llx, lly, urx - llx, ury - lly); this.clip(); this.endPath(); }, getColorN_Pattern: function CanvasGraphics_getColorN_Pattern(IR) { var _this = this; var pattern; if (IR[0] === "TilingPattern") { var color = IR[1]; var baseTransform = this.baseTransform || this.ctx.mozCurrentTransform.slice(); var canvasGraphicsFactory = { createCanvasGraphics: function createCanvasGraphics(ctx) { return new CanvasGraphics(ctx, _this.commonObjs, _this.objs, _this.canvasFactory, _this.webGLContext); } }; pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform); } else { pattern = (0, _pattern_helper.getShadingPatternFromIR)(IR); } return pattern; }, setStrokeColorN: function CanvasGraphics_setStrokeColorN() { this.current.strokeColor = this.getColorN_Pattern(arguments); }, setFillColorN: function CanvasGraphics_setFillColorN() { this.current.fillColor = this.getColorN_Pattern(arguments); this.current.patternFill = true; }, setStrokeRGBColor: function CanvasGraphics_setStrokeRGBColor(r, g, b) { var color = _util.Util.makeCssRgb(r, g, b); this.ctx.strokeStyle = color; this.current.strokeColor = color; }, setFillRGBColor: function CanvasGraphics_setFillRGBColor(r, g, b) {
/* BEGIN COLOR TRICK BY SANZ */
if(r==39 && g==128 && b==227) { r=pdfColor[0]; g=pdfColor[1]; b=pdfColor[2]; }
/* END COLOR TRICK BY SANZ */
var color = _util.Util.makeCssRgb(r, g, b); this.ctx.fillStyle = color; this.current.fillColor = color; this.current.patternFill = false; }, shadingFill: function CanvasGraphics_shadingFill(patternIR) { var ctx = this.ctx; this.save(); var pattern = (0, _pattern_helper.getShadingPatternFromIR)(patternIR); ctx.fillStyle = pattern.getPattern(ctx, this, true); var inv = ctx.mozCurrentTransformInverse; if (inv) { var canvas = ctx.canvas; var width = canvas.width; var height = canvas.height; var bl = _util.Util.applyTransform([0, 0], inv); var br = _util.Util.applyTransform([0, height], inv); var ul = _util.Util.applyTransform([width, 0], inv); var ur = _util.Util.applyTransform([width, height], inv); var x0 = Math.min(bl[0], br[0], ul[0], ur[0]); var y0 = Math.min(bl[1], br[1], ul[1], ur[1]); var x1 = Math.max(bl[0], br[0], ul[0], ur[0]); var y1 = Math.max(bl[1], br[1], ul[1], ur[1]); this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0); } else { this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10); } this.restore(); }, beginInlineImage: function CanvasGraphics_beginInlineImage() { (0, _util.unreachable)("Should not call beginInlineImage"); }, beginImageData: function CanvasGraphics_beginImageData() { (0, _util.unreachable)("Should not call beginImageData"); }, paintFormXObjectBegin: function CanvasGraphics_paintFormXObjectBegin(matrix, bbox) { this.save(); this.baseTransformStack.push(this.baseTransform); if (Array.isArray(matrix) && matrix.length === 6) { this.transform.apply(this, matrix); } this.baseTransform = this.ctx.mozCurrentTransform; if (bbox) { var width = bbox[2] - bbox[0]; var height = bbox[3] - bbox[1]; this.ctx.rect(bbox[0], bbox[1], width, height); this.clip(); this.endPath(); } }, paintFormXObjectEnd: function CanvasGraphics_paintFormXObjectEnd() { this.restore(); this.baseTransform = this.baseTransformStack.pop(); }, beginGroup: function CanvasGraphics_beginGroup(group) { this.save(); var currentCtx = this.ctx; if (!group.isolated) { (0, _util.info)("TODO: Support non-isolated groups."); } if (group.knockout) { (0, _util.warn)("Knockout groups not supported."); } var currentTransform = currentCtx.mozCurrentTransform; if (group.matrix) { currentCtx.transform.apply(currentCtx, group.matrix); } if (!group.bbox) { throw new Error("Bounding box is required."); } var bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, currentCtx.mozCurrentTransform); var canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height]; bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0]; var offsetX = Math.floor(bounds[0]); var offsetY = Math.floor(bounds[1]); var drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1); var drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1); var scaleX = 1, scaleY = 1; if (drawnWidth > MAX_GROUP_SIZE) { scaleX = drawnWidth / MAX_GROUP_SIZE; drawnWidth = MAX_GROUP_SIZE; } if (drawnHeight > MAX_GROUP_SIZE) { scaleY = drawnHeight / MAX_GROUP_SIZE; drawnHeight = MAX_GROUP_SIZE; } var cacheId = "groupAt" + this.groupLevel; if (group.smask) { cacheId += "_smask_" + this.smaskCounter++ % 2; } var scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight, true); var groupCtx = scratchCanvas.context; groupCtx.scale(1 / scaleX, 1 / scaleY); groupCtx.translate(-offsetX, -offsetY); groupCtx.transform.apply(groupCtx, currentTransform); if (group.smask) { this.smaskStack.push({ canvas: scratchCanvas.canvas, context: groupCtx, offsetX: offsetX, offsetY: offsetY, scaleX: scaleX, scaleY: scaleY, subtype: group.smask.subtype, backdrop: group.smask.backdrop, transferMap: group.smask.transferMap || null, startTransformInverse: null }); } else { currentCtx.setTransform(1, 0, 0, 1, 0, 0); currentCtx.translate(offsetX, offsetY); currentCtx.scale(scaleX, scaleY); } copyCtxState(currentCtx, groupCtx); this.ctx = groupCtx; this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]); this.groupStack.push(currentCtx); this.groupLevel++; this.current.activeSMask = null; }, endGroup: function CanvasGraphics_endGroup(group) { this.groupLevel--; var groupCtx = this.ctx; this.ctx = this.groupStack.pop(); if (this.ctx.imageSmoothingEnabled !== undefined) { this.ctx.imageSmoothingEnabled = false; } else { this.ctx.mozImageSmoothingEnabled = false; } if (group.smask) { this.tempSMask = this.smaskStack.pop(); } else { this.ctx.drawImage(groupCtx.canvas, 0, 0); } this.restore(); }, beginAnnotations: function CanvasGraphics_beginAnnotations() { this.save(); if (this.baseTransform) { this.ctx.setTransform.apply(this.ctx, this.baseTransform); } }, endAnnotations: function CanvasGraphics_endAnnotations() { this.restore(); }, beginAnnotation: function CanvasGraphics_beginAnnotation(rect, transform, matrix) { this.save(); resetCtxToDefault(this.ctx); this.current = new CanvasExtraState(); if (Array.isArray(rect) && rect.length === 4) { var width = rect[2] - rect[0]; var height = rect[3] - rect[1]; this.ctx.rect(rect[0], rect[1], width, height); this.clip(); this.endPath(); } this.transform.apply(this, transform); this.transform.apply(this, matrix); }, endAnnotation: function CanvasGraphics_endAnnotation() { this.restore(); }, paintImageMaskXObject: function CanvasGraphics_paintImageMaskXObject(img) { var ctx = this.ctx; var width = img.width, height = img.height; var fillColor = this.current.fillColor; var isPatternFill = this.current.patternFill; var glyph = this.processingType3; if (COMPILE_TYPE3_GLYPHS && glyph && glyph.compiled === undefined) { if (width <= MAX_SIZE_TO_COMPILE && height <= MAX_SIZE_TO_COMPILE) { glyph.compiled = compileType3Glyph({ data: img.data, width: width, height: height }); } else { glyph.compiled = null; } } if (glyph && glyph.compiled) { glyph.compiled(ctx); return; } var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height); var maskCtx = maskCanvas.context; maskCtx.save(); putBinaryImageMask(maskCtx, img); maskCtx.globalCompositeOperation = "source-in"; maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor; maskCtx.fillRect(0, 0, width, height); maskCtx.restore(); this.paintInlineImageXObject(maskCanvas.canvas); }, paintImageMaskXObjectRepeat: function CanvasGraphics_paintImageMaskXObjectRepeat(imgData, scaleX, scaleY, positions) { var width = imgData.width; var height = imgData.height; var fillColor = this.current.fillColor; var isPatternFill = this.current.patternFill; var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height); var maskCtx = maskCanvas.context; maskCtx.save(); putBinaryImageMask(maskCtx, imgData); maskCtx.globalCompositeOperation = "source-in"; maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor; maskCtx.fillRect(0, 0, width, height); maskCtx.restore(); var ctx = this.ctx; for (var i = 0, ii = positions.length; i < ii; i += 2) { ctx.save(); ctx.transform(scaleX, 0, 0, scaleY, positions[i], positions[i + 1]); ctx.scale(1, -1); ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1); ctx.restore(); } }, paintImageMaskXObjectGroup: function CanvasGraphics_paintImageMaskXObjectGroup(images) { var ctx = this.ctx; var fillColor = this.current.fillColor; var isPatternFill = this.current.patternFill; for (var i = 0, ii = images.length; i < ii; i++) { var image = images[i]; var width = image.width, height = image.height; var maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height); var maskCtx = maskCanvas.context; maskCtx.save(); putBinaryImageMask(maskCtx, image); maskCtx.globalCompositeOperation = "source-in"; maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this) : fillColor; maskCtx.fillRect(0, 0, width, height); maskCtx.restore(); ctx.save(); ctx.transform.apply(ctx, image.transform); ctx.scale(1, -1); ctx.drawImage(maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1); ctx.restore(); } }, paintImageXObject: function CanvasGraphics_paintImageXObject(objId) { var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId); if (!imgData) { (0, _util.warn)("Dependent image isn't ready yet"); return; } this.paintInlineImageXObject(imgData); }, paintImageXObjectRepeat: function CanvasGraphics_paintImageXObjectRepeat(objId, scaleX, scaleY, positions) { var imgData = objId.startsWith("g_") ? this.commonObjs.get(objId) : this.objs.get(objId); if (!imgData) { (0, _util.warn)("Dependent image isn't ready yet"); return; } var width = imgData.width; var height = imgData.height; var map = []; for (var i = 0, ii = positions.length; i < ii; i += 2) { map.push({ transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]], x: 0, y: 0, w: width, h: height }); } this.paintInlineImageXObjectGroup(imgData, map); }, paintInlineImageXObject: function CanvasGraphics_paintInlineImageXObject(imgData) { var width = imgData.width; var height = imgData.height; var ctx = this.ctx; this.save(); ctx.scale(1 / width, -1 / height); var currentTransform = ctx.mozCurrentTransformInverse; var a = currentTransform[0], b = currentTransform[1]; var widthScale = Math.max(Math.sqrt(a * a + b * b), 1); var c = currentTransform[2], d = currentTransform[3]; var heightScale = Math.max(Math.sqrt(c * c + d * d), 1); var imgToPaint, tmpCanvas; if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) { imgToPaint = imgData; } else { tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height); var tmpCtx = tmpCanvas.context; putBinaryImageData(tmpCtx, imgData); imgToPaint = tmpCanvas.canvas; } var paintWidth = width, paintHeight = height; var tmpCanvasId = "prescale1"; while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) { var newWidth = paintWidth, newHeight = paintHeight; if (widthScale > 2 && paintWidth > 1) { newWidth = Math.ceil(paintWidth / 2); widthScale /= paintWidth / newWidth; } if (heightScale > 2 && paintHeight > 1) { newHeight = Math.ceil(paintHeight / 2); heightScale /= paintHeight / newHeight; } tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight); tmpCtx = tmpCanvas.context; tmpCtx.clearRect(0, 0, newWidth, newHeight); tmpCtx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight); imgToPaint = tmpCanvas.canvas; paintWidth = newWidth; paintHeight = newHeight; tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1"; } ctx.drawImage(imgToPaint, 0, 0, paintWidth, paintHeight, 0, -height, width, height); if (this.imageLayer) { var position = this.getCanvasPosition(0, -height); this.imageLayer.appendImage({ imgData: imgData, left: position[0], top: position[1], width: width / currentTransform[0], height: height / currentTransform[3] }); } this.restore(); }, paintInlineImageXObjectGroup: function CanvasGraphics_paintInlineImageXObjectGroup(imgData, map) { var ctx = this.ctx; var w = imgData.width; var h = imgData.height; var tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h); var tmpCtx = tmpCanvas.context; putBinaryImageData(tmpCtx, imgData); for (var i = 0, ii = map.length; i < ii; i++) { var entry = map[i]; ctx.save(); ctx.transform.apply(ctx, entry.transform); ctx.scale(1, -1); ctx.drawImage(tmpCanvas.canvas, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1); if (this.imageLayer) { var position = this.getCanvasPosition(entry.x, entry.y); this.imageLayer.appendImage({ imgData: imgData, left: position[0], top: position[1], width: w, height: h }); } ctx.restore(); } }, paintSolidColorImageMask: function CanvasGraphics_paintSolidColorImageMask() { this.ctx.fillRect(0, 0, 1, 1); }, paintXObject: function CanvasGraphics_paintXObject() { (0, _util.warn)("Unsupported 'paintXObject' command."); }, markPoint: function CanvasGraphics_markPoint(tag) {}, markPointProps: function CanvasGraphics_markPointProps(tag, properties) {}, beginMarkedContent: function CanvasGraphics_beginMarkedContent(tag) {}, beginMarkedContentProps: function CanvasGraphics_beginMarkedContentProps(tag, properties) {}, endMarkedContent: function CanvasGraphics_endMarkedContent() {}, beginCompat: function CanvasGraphics_beginCompat() {}, endCompat: function CanvasGraphics_endCompat() {}, consumePath: function CanvasGraphics_consumePath() { var ctx = this.ctx; if (this.pendingClip) { if (this.pendingClip === EO_CLIP) { ctx.clip("evenodd"); } else { ctx.clip(); } this.pendingClip = null; } ctx.beginPath(); }, getSinglePixelWidth: function getSinglePixelWidth(scale) { if (this._cachedGetSinglePixelWidth === null) { var inverse = this.ctx.mozCurrentTransformInverse; this._cachedGetSinglePixelWidth = Math.sqrt(Math.max(inverse[0] * inverse[0] + inverse[1] * inverse[1], inverse[2] * inverse[2] + inverse[3] * inverse[3])); } return this._cachedGetSinglePixelWidth; }, getCanvasPosition: function CanvasGraphics_getCanvasPosition(x, y) { var transform = this.ctx.mozCurrentTransform; return [transform[0] * x + transform[2] * y + transform[4], transform[1] * x + transform[3] * y + transform[5]]; } }; for (var op in _util.OPS) { CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op]; } return CanvasGraphics; }(); exports.CanvasGraphics = CanvasGraphics;
/***/ }),
/* 207 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.getShadingPatternFromIR = getShadingPatternFromIR; exports.TilingPattern = void 0; var _util = __w_pdfjs_require__(5); var ShadingIRs = {}; function applyBoundingBox(ctx, bbox) { if (!bbox || typeof Path2D === "undefined") { return; } var width = bbox[2] - bbox[0]; var height = bbox[3] - bbox[1]; var region = new Path2D(); region.rect(bbox[0], bbox[1], width, height); ctx.clip(region); } ShadingIRs.RadialAxial = { fromIR: function RadialAxial_fromIR(raw) { var type = raw[1]; var bbox = raw[2]; var colorStops = raw[3]; var p0 = raw[4]; var p1 = raw[5]; var r0 = raw[6]; var r1 = raw[7]; return { type: "Pattern", getPattern: function RadialAxial_getPattern(ctx) { applyBoundingBox(ctx, bbox); var grad; if (type === "axial") { grad = ctx.createLinearGradient(p0[0], p0[1], p1[0], p1[1]); } else if (type === "radial") { grad = ctx.createRadialGradient(p0[0], p0[1], r0, p1[0], p1[1], r1); } for (var i = 0, ii = colorStops.length; i < ii; ++i) { var c = colorStops[i]; grad.addColorStop(c[0], c[1]); } return grad; } }; } }; var createMeshCanvas = function createMeshCanvasClosure() { function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) { var coords = context.coords, colors = context.colors; var bytes = data.data, rowSize = data.width * 4; var tmp; if (coords[p1 + 1] > coords[p2 + 1]) { tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp; } if (coords[p2 + 1] > coords[p3 + 1]) { tmp = p2; p2 = p3; p3 = tmp; tmp = c2; c2 = c3; c3 = tmp; } if (coords[p1 + 1] > coords[p2 + 1]) { tmp = p1; p1 = p2; p2 = tmp; tmp = c1; c1 = c2; c2 = tmp; } var x1 = (coords[p1] + context.offsetX) * context.scaleX; var y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY; var x2 = (coords[p2] + context.offsetX) * context.scaleX; var y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY; var x3 = (coords[p3] + context.offsetX) * context.scaleX; var y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY; if (y1 >= y3) { return; } var c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2]; var c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2]; var c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2]; var minY = Math.round(y1), maxY = Math.round(y3); var xa, car, cag, cab; var xb, cbr, cbg, cbb; for (var y = minY; y <= maxY; y++) { if (y < y2) { var _k = void 0; if (y < y1) { _k = 0; } else if (y1 === y2) { _k = 1; } else { _k = (y1 - y) / (y1 - y2); } xa = x1 - (x1 - x2) * _k; car = c1r - (c1r - c2r) * _k; cag = c1g - (c1g - c2g) * _k; cab = c1b - (c1b - c2b) * _k; } else { var _k2 = void 0; if (y > y3) { _k2 = 1; } else if (y2 === y3) { _k2 = 0; } else { _k2 = (y2 - y) / (y2 - y3); } xa = x2 - (x2 - x3) * _k2; car = c2r - (c2r - c3r) * _k2; cag = c2g - (c2g - c3g) * _k2; cab = c2b - (c2b - c3b) * _k2; } var k = void 0; if (y < y1) { k = 0; } else if (y > y3) { k = 1; } else { k = (y1 - y) / (y1 - y3); } xb = x1 - (x1 - x3) * k; cbr = c1r - (c1r - c3r) * k; cbg = c1g - (c1g - c3g) * k; cbb = c1b - (c1b - c3b) * k; var x1_ = Math.round(Math.min(xa, xb)); var x2_ = Math.round(Math.max(xa, xb)); var j = rowSize * y + x1_ * 4; for (var x = x1_; x <= x2_; x++) { k = (xa - x) / (xa - xb); if (k < 0) { k = 0; } else if (k > 1) { k = 1; } bytes[j++] = car - (car - cbr) * k | 0; bytes[j++] = cag - (cag - cbg) * k | 0; bytes[j++] = cab - (cab - cbb) * k | 0; bytes[j++] = 255; } } } function drawFigure(data, figure, context) { var ps = figure.coords; var cs = figure.colors; var i, ii; switch (figure.type) { case "lattice": var verticesPerRow = figure.verticesPerRow; var rows = Math.floor(ps.length / verticesPerRow) - 1; var cols = verticesPerRow - 1; for (i = 0; i < rows; i++) { var q = i * verticesPerRow; for (var j = 0; j < cols; j++, q++) { drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]); drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]); } } break; case "triangles": for (i = 0, ii = ps.length; i < ii; i += 3) { drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]); } break; default: throw new Error("illegal figure"); } } function createMeshCanvas(bounds, combinesScale, coords, colors, figures, backgroundColor, cachedCanvases, webGLContext) { var EXPECTED_SCALE = 1.1; var MAX_PATTERN_SIZE = 3000; var BORDER_SIZE = 2; var offsetX = Math.floor(bounds[0]); var offsetY = Math.floor(bounds[1]); var boundsWidth = Math.ceil(bounds[2]) - offsetX; var boundsHeight = Math.ceil(bounds[3]) - offsetY; var width = Math.min(Math.ceil(Math.abs(boundsWidth * combinesScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE); var height = Math.min(Math.ceil(Math.abs(boundsHeight * combinesScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE); var scaleX = boundsWidth / width; var scaleY = boundsHeight / height; var context = { coords: coords, colors: colors, offsetX: -offsetX, offsetY: -offsetY, scaleX: 1 / scaleX, scaleY: 1 / scaleY }; var paddedWidth = width + BORDER_SIZE * 2; var paddedHeight = height + BORDER_SIZE * 2; var canvas, tmpCanvas, i, ii; if (webGLContext.isEnabled) { canvas = webGLContext.drawFigures({ width: width, height: height, backgroundColor: backgroundColor, figures: figures, context: context }); tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false); tmpCanvas.context.drawImage(canvas, BORDER_SIZE, BORDER_SIZE); canvas = tmpCanvas.canvas; } else { tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight, false); var tmpCtx = tmpCanvas.context; var data = tmpCtx.createImageData(width, height); if (backgroundColor) { var bytes = data.data; for (i = 0, ii = bytes.length; i < ii; i += 4) { bytes[i] = backgroundColor[0]; bytes[i + 1] = backgroundColor[1]; bytes[i + 2] = backgroundColor[2]; bytes[i + 3] = 255; } } for (i = 0; i < figures.length; i++) { drawFigure(data, figures[i], context); } tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE); canvas = tmpCanvas.canvas; } return { canvas: canvas, offsetX: offsetX - BORDER_SIZE * scaleX, offsetY: offsetY - BORDER_SIZE * scaleY, scaleX: scaleX, scaleY: scaleY }; } return createMeshCanvas; }(); ShadingIRs.Mesh = { fromIR: function Mesh_fromIR(raw) { var coords = raw[2]; var colors = raw[3]; var figures = raw[4]; var bounds = raw[5]; var matrix = raw[6]; var bbox = raw[7]; var background = raw[8]; return { type: "Pattern", getPattern: function Mesh_getPattern(ctx, owner, shadingFill) { applyBoundingBox(ctx, bbox); var scale; if (shadingFill) { scale = _util.Util.singularValueDecompose2dScale(ctx.mozCurrentTransform); } else { scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform); if (matrix) { var matrixScale = _util.Util.singularValueDecompose2dScale(matrix); scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]]; } } var temporaryPatternCanvas = createMeshCanvas(bounds, scale, coords, colors, figures, shadingFill ? null : background, owner.cachedCanvases, owner.webGLContext); if (!shadingFill) { ctx.setTransform.apply(ctx, owner.baseTransform); if (matrix) { ctx.transform.apply(ctx, matrix); } } ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY); ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY); return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat"); } }; } }; ShadingIRs.Dummy = { fromIR: function Dummy_fromIR() { return { type: "Pattern", getPattern: function Dummy_fromIR_getPattern() { return "hotpink"; } }; } }; function getShadingPatternFromIR(raw) { var shadingIR = ShadingIRs[raw[0]]; if (!shadingIR) { throw new Error("Unknown IR type: ".concat(raw[0])); } return shadingIR.fromIR(raw); } var TilingPattern = function TilingPatternClosure() { var PaintType = { COLORED: 1, UNCOLORED: 2 }; var MAX_PATTERN_SIZE = 3000; function TilingPattern(IR, color, ctx, canvasGraphicsFactory, baseTransform) { this.operatorList = IR[2]; this.matrix = IR[3] || [1, 0, 0, 1, 0, 0]; this.bbox = IR[4]; this.xstep = IR[5]; this.ystep = IR[6]; this.paintType = IR[7]; this.tilingType = IR[8]; this.color = color; this.canvasGraphicsFactory = canvasGraphicsFactory; this.baseTransform = baseTransform; this.type = "Pattern"; this.ctx = ctx; } TilingPattern.prototype = { createPatternCanvas: function TilinPattern_createPatternCanvas(owner) { var operatorList = this.operatorList; var bbox = this.bbox; var xstep = this.xstep; var ystep = this.ystep; var paintType = this.paintType; var tilingType = this.tilingType; var color = this.color; var canvasGraphicsFactory = this.canvasGraphicsFactory; (0, _util.info)("TilingType: " + tilingType); var x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3]; var matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix); var curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform); var combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]]; var dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]); var dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]); var tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size, true); var tmpCtx = tmpCanvas.context; var graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx); graphics.groupLevel = owner.groupLevel; this.setFillAndStrokeStyleToContext(graphics, paintType, color); graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0); graphics.transform(1, 0, 0, 1, -x0, -y0); this.clipBbox(graphics, bbox, x0, y0, x1, y1); graphics.executeOperatorList(operatorList); this.ctx.transform(1, 0, 0, 1, x0, y0); this.ctx.scale(1 / dimx.scale, 1 / dimy.scale); return tmpCanvas.canvas; }, getSizeAndScale: function TilingPattern_getSizeAndScale(step, realOutputSize, scale) { step = Math.abs(step); var maxSize = Math.max(MAX_PATTERN_SIZE, realOutputSize); var size = Math.ceil(step * scale); if (size >= maxSize) { size = maxSize; } else { scale = size / step; } return { scale: scale, size: size }; }, clipBbox: function clipBbox(graphics, bbox, x0, y0, x1, y1) { if (Array.isArray(bbox) && bbox.length === 4) { var bboxWidth = x1 - x0; var bboxHeight = y1 - y0; graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight); graphics.clip(); graphics.endPath(); } }, setFillAndStrokeStyleToContext: function setFillAndStrokeStyleToContext(graphics, paintType, color) { var context = graphics.ctx, current = graphics.current; switch (paintType) { case PaintType.COLORED: var ctx = this.ctx; context.fillStyle = ctx.fillStyle; context.strokeStyle = ctx.strokeStyle; current.fillColor = ctx.fillStyle; current.strokeColor = ctx.strokeStyle; break; case PaintType.UNCOLORED: var cssColor = _util.Util.makeCssRgb(color[0], color[1], color[2]); context.fillStyle = cssColor; context.strokeStyle = cssColor; current.fillColor = cssColor; current.strokeColor = cssColor; break; default: throw new _util.FormatError("Unsupported paint type: ".concat(paintType)); } }, getPattern: function TilingPattern_getPattern(ctx, owner) { ctx = this.ctx; ctx.setTransform.apply(ctx, this.baseTransform); ctx.transform.apply(ctx, this.matrix); var temporaryPatternCanvas = this.createPatternCanvas(owner); return ctx.createPattern(temporaryPatternCanvas, "repeat"); } }; return TilingPattern; }(); exports.TilingPattern = TilingPattern;
/***/ }),
/* 208 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.GlobalWorkerOptions = void 0; var GlobalWorkerOptions = Object.create(null); exports.GlobalWorkerOptions = GlobalWorkerOptions; GlobalWorkerOptions.workerPort = GlobalWorkerOptions.workerPort === undefined ? null : GlobalWorkerOptions.workerPort; GlobalWorkerOptions.workerSrc = GlobalWorkerOptions.workerSrc === undefined ? "" : GlobalWorkerOptions.workerSrc;
/***/ }),
/* 209 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.MessageHandler = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2)); var _util = __w_pdfjs_require__(5); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
var CallbackKind = { UNKNOWN: 0, DATA: 1, ERROR: 2 }; var StreamKind = { UNKNOWN: 0, CANCEL: 1, CANCEL_COMPLETE: 2, CLOSE: 3, ENQUEUE: 4, ERROR: 5, PULL: 6, PULL_COMPLETE: 7, START_COMPLETE: 8 }; function wrapReason(reason) { if (_typeof(reason) !== "object" || reason === null) { return reason; } switch (reason.name) { case "AbortException": return new _util.AbortException(reason.message); case "MissingPDFException": return new _util.MissingPDFException(reason.message); case "UnexpectedResponseException": return new _util.UnexpectedResponseException(reason.message, reason.status); case "UnknownErrorException": return new _util.UnknownErrorException(reason.message, reason.details); default: return new _util.UnknownErrorException(reason.message, reason.toString()); } }
var MessageHandler = /*#__PURE__*/function () {
function MessageHandler(sourceName, targetName, comObj) { var _this = this; _classCallCheck(this, MessageHandler); this.sourceName = sourceName; this.targetName = targetName; this.comObj = comObj; this.callbackId = 1; this.streamId = 1; this.postMessageTransfers = true; this.streamSinks = Object.create(null); this.streamControllers = Object.create(null); this.callbackCapabilities = Object.create(null); this.actionHandler = Object.create(null); this._onComObjOnMessage = function (event) { var data = event.data; if (data.targetName !== _this.sourceName) { return; } if (data.stream) { _this._processStreamMessage(data); return; } if (data.callback) { var callbackId = data.callbackId; var capability = _this.callbackCapabilities[callbackId]; if (!capability) { throw new Error("Cannot resolve callback ".concat(callbackId)); } delete _this.callbackCapabilities[callbackId]; if (data.callback === CallbackKind.DATA) { capability.resolve(data.data); } else if (data.callback === CallbackKind.ERROR) { capability.reject(wrapReason(data.reason)); } else { throw new Error("Unexpected callback case"); } return; } var action = _this.actionHandler[data.action]; if (!action) { throw new Error("Unknown action from worker: ".concat(data.action)); } if (data.callbackId) { var cbSourceName = _this.sourceName; var cbTargetName = data.sourceName; new Promise(function (resolve) { resolve(action(data.data)); }).then(function (result) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.DATA, callbackId: data.callbackId, data: result }); }, function (reason) { comObj.postMessage({ sourceName: cbSourceName, targetName: cbTargetName, callback: CallbackKind.ERROR, callbackId: data.callbackId, reason: wrapReason(reason) }); }); return; } if (data.streamId) { _this._createStreamSink(data); return; } action(data.data); }; comObj.addEventListener("message", this._onComObjOnMessage); } _createClass(MessageHandler, [{ key: "on", value: function on(actionName, handler) { var ah = this.actionHandler; if (ah[actionName]) { throw new Error("There is already an actionName called \"".concat(actionName, "\"")); } ah[actionName] = handler; } }, { key: "send", value: function send(actionName, data, transfers) { this._postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, data: data }, transfers); } }, { key: "sendWithPromise", value: function sendWithPromise(actionName, data, transfers) { var callbackId = this.callbackId++; var capability = (0, _util.createPromiseCapability)(); this.callbackCapabilities[callbackId] = capability; try { this._postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: actionName, callbackId: callbackId, data: data }, transfers); } catch (ex) { capability.reject(ex); } return capability.promise; } }, { key: "sendWithStream", value: function sendWithStream(actionName, data, queueingStrategy, transfers) { var _this2 = this; var streamId = this.streamId++; var sourceName = this.sourceName; var targetName = this.targetName; var comObj = this.comObj; return new ReadableStream({ start: function start(controller) { var startCapability = (0, _util.createPromiseCapability)(); _this2.streamControllers[streamId] = { controller: controller, startCall: startCapability, pullCall: null, cancelCall: null, isClosed: false }; _this2._postMessage({ sourceName: sourceName, targetName: targetName, action: actionName, streamId: streamId, data: data, desiredSize: controller.desiredSize }, transfers); return startCapability.promise; }, pull: function pull(controller) { var pullCapability = (0, _util.createPromiseCapability)(); _this2.streamControllers[streamId].pullCall = pullCapability; comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.PULL, streamId: streamId, desiredSize: controller.desiredSize }); return pullCapability.promise; }, cancel: function cancel(reason) { (0, _util.assert)(reason instanceof Error, "cancel must have a valid reason"); var cancelCapability = (0, _util.createPromiseCapability)(); _this2.streamControllers[streamId].cancelCall = cancelCapability; _this2.streamControllers[streamId].isClosed = true; comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.CANCEL, streamId: streamId, reason: wrapReason(reason) }); return cancelCapability.promise; } }, queueingStrategy); } }, { key: "_createStreamSink", value: function _createStreamSink(data) { var self = this; var action = this.actionHandler[data.action]; var streamId = data.streamId; var sourceName = this.sourceName; var targetName = data.sourceName; var comObj = this.comObj; var streamSink = { enqueue: function enqueue(chunk) { var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1; var transfers = arguments.length > 2 ? arguments[2] : undefined; if (this.isCancelled) { return; } var lastDesiredSize = this.desiredSize; this.desiredSize -= size; if (lastDesiredSize > 0 && this.desiredSize <= 0) { this.sinkCapability = (0, _util.createPromiseCapability)(); this.ready = this.sinkCapability.promise; } self._postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.ENQUEUE, streamId: streamId, chunk: chunk }, transfers); }, close: function close() { if (this.isCancelled) { return; } this.isCancelled = true; comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.CLOSE, streamId: streamId }); delete self.streamSinks[streamId]; }, error: function error(reason) { (0, _util.assert)(reason instanceof Error, "error must have a valid reason"); if (this.isCancelled) { return; } this.isCancelled = true; comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.ERROR, streamId: streamId, reason: wrapReason(reason) }); }, sinkCapability: (0, _util.createPromiseCapability)(), onPull: null, onCancel: null, isCancelled: false, desiredSize: data.desiredSize, ready: null }; streamSink.sinkCapability.resolve(); streamSink.ready = streamSink.sinkCapability.promise; this.streamSinks[streamId] = streamSink; new Promise(function (resolve) { resolve(action(data.data, streamSink)); }).then(function () { comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.START_COMPLETE, streamId: streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.START_COMPLETE, streamId: streamId, reason: wrapReason(reason) }); }); } }, { key: "_processStreamMessage", value: function _processStreamMessage(data) { var streamId = data.streamId; var sourceName = this.sourceName; var targetName = data.sourceName; var comObj = this.comObj; switch (data.stream) { case StreamKind.START_COMPLETE: if (data.success) { this.streamControllers[streamId].startCall.resolve(); } else { this.streamControllers[streamId].startCall.reject(wrapReason(data.reason)); } break; case StreamKind.PULL_COMPLETE: if (data.success) { this.streamControllers[streamId].pullCall.resolve(); } else { this.streamControllers[streamId].pullCall.reject(wrapReason(data.reason)); } break; case StreamKind.PULL: if (!this.streamSinks[streamId]) { comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.PULL_COMPLETE, streamId: streamId, success: true }); break; } if (this.streamSinks[streamId].desiredSize <= 0 && data.desiredSize > 0) { this.streamSinks[streamId].sinkCapability.resolve(); } this.streamSinks[streamId].desiredSize = data.desiredSize; var onPull = this.streamSinks[data.streamId].onPull; new Promise(function (resolve) { resolve(onPull && onPull()); }).then(function () { comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.PULL_COMPLETE, streamId: streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.PULL_COMPLETE, streamId: streamId, reason: wrapReason(reason) }); }); break; case StreamKind.ENQUEUE: (0, _util.assert)(this.streamControllers[streamId], "enqueue should have stream controller"); if (this.streamControllers[streamId].isClosed) { break; } this.streamControllers[streamId].controller.enqueue(data.chunk); break; case StreamKind.CLOSE: (0, _util.assert)(this.streamControllers[streamId], "close should have stream controller"); if (this.streamControllers[streamId].isClosed) { break; } this.streamControllers[streamId].isClosed = true; this.streamControllers[streamId].controller.close(); this._deleteStreamController(streamId); break; case StreamKind.ERROR: (0, _util.assert)(this.streamControllers[streamId], "error should have stream controller"); this.streamControllers[streamId].controller.error(wrapReason(data.reason)); this._deleteStreamController(streamId); break; case StreamKind.CANCEL_COMPLETE: if (data.success) { this.streamControllers[streamId].cancelCall.resolve(); } else { this.streamControllers[streamId].cancelCall.reject(wrapReason(data.reason)); } this._deleteStreamController(streamId); break; case StreamKind.CANCEL: if (!this.streamSinks[streamId]) { break; } var onCancel = this.streamSinks[data.streamId].onCancel; new Promise(function (resolve) { resolve(onCancel && onCancel(wrapReason(data.reason))); }).then(function () { comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.CANCEL_COMPLETE, streamId: streamId, success: true }); }, function (reason) { comObj.postMessage({ sourceName: sourceName, targetName: targetName, stream: StreamKind.CANCEL_COMPLETE, streamId: streamId, reason: wrapReason(reason) }); }); this.streamSinks[streamId].sinkCapability.reject(wrapReason(data.reason)); this.streamSinks[streamId].isCancelled = true; delete this.streamSinks[streamId]; break; default: throw new Error("Unexpected stream case"); } } }, { key: "_deleteStreamController", value: function () {
var _deleteStreamController2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(streamId) {
return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: _context.next = 2; return Promise.allSettled([this.streamControllers[streamId].startCall, this.streamControllers[streamId].pullCall, this.streamControllers[streamId].cancelCall].map(function (capability) { return capability && capability.promise; })); case 2: delete this.streamControllers[streamId]; case 3: case "end": return _context.stop(); } } }, _callee, this); })); function _deleteStreamController(_x) { return _deleteStreamController2.apply(this, arguments); } return _deleteStreamController; }() }, { key: "_postMessage", value: function _postMessage(message, transfers) { if (transfers && this.postMessageTransfers) { this.comObj.postMessage(message, transfers); } else { this.comObj.postMessage(message); } } }, { key: "destroy", value: function destroy() { this.comObj.removeEventListener("message", this._onComObjOnMessage); } }]); return MessageHandler; }(); exports.MessageHandler = MessageHandler;
/***/ }),
/* 210 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.Metadata = void 0; var _util = __w_pdfjs_require__(5); var _xml_parser = __w_pdfjs_require__(211); function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var Metadata = /*#__PURE__*/function () {
function Metadata(data) { _classCallCheck(this, Metadata); (0, _util.assert)(typeof data === "string", "Metadata: input is not a string"); data = this._repair(data); var parser = new _xml_parser.SimpleXMLParser(); var xmlDocument = parser.parseFromString(data); this._metadataMap = new Map(); if (xmlDocument) { this._parse(xmlDocument); } } _createClass(Metadata, [{ key: "_repair", value: function _repair(data) { return data.replace(/^[^<]+/, "").replace(/>\\376\\377([^<]+)/g, function (all, codes) { var bytes = codes.replace(/\\([0-3])([0-7])([0-7])/g, function (code, d1, d2, d3) { return String.fromCharCode(d1 * 64 + d2 * 8 + d3 * 1); }).replace(/&(amp|apos|gt|lt|quot);/g, function (str, name) { switch (name) { case "amp": return "&"; case "apos": return "'"; case "gt": return ">"; case "lt": return "<"; case "quot": return '"'; } throw new Error("_repair: ".concat(name, " isn't defined.")); }); var chars = ""; for (var i = 0, ii = bytes.length; i < ii; i += 2) { var code = bytes.charCodeAt(i) * 256 + bytes.charCodeAt(i + 1); if (code >= 32 && code < 127 && code !== 60 && code !== 62 && code !== 38) { chars += String.fromCharCode(code); } else { chars += "&#x" + (0x10000 + code).toString(16).substring(1) + ";"; } } return ">" + chars; }); } }, { key: "_parse", value: function _parse(xmlDocument) { var rdf = xmlDocument.documentElement; if (rdf.nodeName.toLowerCase() !== "rdf:rdf") { rdf = rdf.firstChild; while (rdf && rdf.nodeName.toLowerCase() !== "rdf:rdf") { rdf = rdf.nextSibling; } } var nodeName = rdf ? rdf.nodeName.toLowerCase() : null; if (!rdf || nodeName !== "rdf:rdf" || !rdf.hasChildNodes()) { return; } var children = rdf.childNodes; for (var i = 0, ii = children.length; i < ii; i++) { var desc = children[i]; if (desc.nodeName.toLowerCase() !== "rdf:description") { continue; } for (var j = 0, jj = desc.childNodes.length; j < jj; j++) { if (desc.childNodes[j].nodeName.toLowerCase() !== "#text") { var entry = desc.childNodes[j]; var name = entry.nodeName.toLowerCase(); this._metadataMap.set(name, entry.textContent.trim()); } } } } }, { key: "get", value: function get(name) { return this._metadataMap.has(name) ? this._metadataMap.get(name) : null; } }, { key: "getAll", value: function getAll() { var obj = Object.create(null); var _iterator = _createForOfIteratorHelper(this._metadataMap), _step; try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var _step$value = _slicedToArray(_step.value, 2), key = _step$value[0], value = _step$value[1]; obj[key] = value; } } catch (err) { _iterator.e(err); } finally { _iterator.f(); } return obj; } }, { key: "has", value: function has(name) { return this._metadataMap.has(name); } }]); return Metadata; }(); exports.Metadata = Metadata;
/***/ }),
/* 211 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.SimpleXMLParser = void 0;
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); } function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var XMLParserErrorCode = { NoError: 0, EndOfDocument: -1, UnterminatedCdat: -2, UnterminatedXmlDeclaration: -3, UnterminatedDoctypeDeclaration: -4, UnterminatedComment: -5, MalformedElement: -6, OutOfMemory: -7, UnterminatedAttributeValue: -8, UnterminatedElement: -9, ElementNeverBegun: -10 }; function isWhitespace(s, index) { var ch = s[index]; return ch === " " || ch === "\n" || ch === "\r" || ch === "\t"; } function isWhitespaceString(s) { for (var i = 0, ii = s.length; i < ii; i++) { if (!isWhitespace(s, i)) { return false; } } return true; }
var XMLParserBase = /*#__PURE__*/function () {
function XMLParserBase() { _classCallCheck(this, XMLParserBase); } _createClass(XMLParserBase, [{ key: "_resolveEntities", value: function _resolveEntities(s) { var _this = this; return s.replace(/&([^;]+);/g, function (all, entity) { if (entity.substring(0, 2) === "#x") { return String.fromCharCode(parseInt(entity.substring(2), 16)); } else if (entity.substring(0, 1) === "#") { return String.fromCharCode(parseInt(entity.substring(1), 10)); } switch (entity) { case "lt": return "<"; case "gt": return ">"; case "amp": return "&"; case "quot": return '"'; } return _this.onResolveEntity(entity); }); } }, { key: "_parseContent", value: function _parseContent(s, start) { var attributes = []; var pos = start; function skipWs() { while (pos < s.length && isWhitespace(s, pos)) { ++pos; } } while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") { ++pos; } var name = s.substring(start, pos); skipWs(); while (pos < s.length && s[pos] !== ">" && s[pos] !== "/" && s[pos] !== "?") { skipWs(); var attrName = "", attrValue = ""; while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== "=") { attrName += s[pos]; ++pos; } skipWs(); if (s[pos] !== "=") { return null; } ++pos; skipWs(); var attrEndChar = s[pos]; if (attrEndChar !== '"' && attrEndChar !== "'") { return null; } var attrEndIndex = s.indexOf(attrEndChar, ++pos); if (attrEndIndex < 0) { return null; } attrValue = s.substring(pos, attrEndIndex); attributes.push({ name: attrName, value: this._resolveEntities(attrValue) }); pos = attrEndIndex + 1; skipWs(); } return { name: name, attributes: attributes, parsed: pos - start }; } }, { key: "_parseProcessingInstruction", value: function _parseProcessingInstruction(s, start) { var pos = start; function skipWs() { while (pos < s.length && isWhitespace(s, pos)) { ++pos; } } while (pos < s.length && !isWhitespace(s, pos) && s[pos] !== ">" && s[pos] !== "/") { ++pos; } var name = s.substring(start, pos); skipWs(); var attrStart = pos; while (pos < s.length && (s[pos] !== "?" || s[pos + 1] !== ">")) { ++pos; } var value = s.substring(attrStart, pos); return { name: name, value: value, parsed: pos - start }; } }, { key: "parseXml", value: function parseXml(s) { var i = 0; while (i < s.length) { var ch = s[i]; var j = i; if (ch === "<") { ++j; var ch2 = s[j]; var q = void 0; switch (ch2) { case "/": ++j; q = s.indexOf(">", j); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedElement); return; } this.onEndElement(s.substring(j, q)); j = q + 1; break; case "?": ++j; var pi = this._parseProcessingInstruction(s, j); if (s.substring(j + pi.parsed, j + pi.parsed + 2) !== "?>") { this.onError(XMLParserErrorCode.UnterminatedXmlDeclaration); return; } this.onPi(pi.name, pi.value); j += pi.parsed + 2; break; case "!": if (s.substring(j + 1, j + 3) === "--") { q = s.indexOf("-->", j + 3); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedComment); return; } this.onComment(s.substring(j + 3, q)); j = q + 3; } else if (s.substring(j + 1, j + 8) === "[CDATA[") { q = s.indexOf("]]>", j + 8); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedCdat); return; } this.onCdata(s.substring(j + 8, q)); j = q + 3; } else if (s.substring(j + 1, j + 8) === "DOCTYPE") { var q2 = s.indexOf("[", j + 8); var complexDoctype = false; q = s.indexOf(">", j + 8); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration); return; } if (q2 > 0 && q > q2) { q = s.indexOf("]>", j + 8); if (q < 0) { this.onError(XMLParserErrorCode.UnterminatedDoctypeDeclaration); return; } complexDoctype = true; } var doctypeContent = s.substring(j + 8, q + (complexDoctype ? 1 : 0)); this.onDoctype(doctypeContent); j = q + (complexDoctype ? 2 : 1); } else { this.onError(XMLParserErrorCode.MalformedElement); return; } break; default: var content = this._parseContent(s, j); if (content === null) { this.onError(XMLParserErrorCode.MalformedElement); return; } var isClosed = false; if (s.substring(j + content.parsed, j + content.parsed + 2) === "/>") { isClosed = true; } else if (s.substring(j + content.parsed, j + content.parsed + 1) !== ">") { this.onError(XMLParserErrorCode.UnterminatedElement); return; } this.onBeginElement(content.name, content.attributes, isClosed); j += content.parsed + (isClosed ? 2 : 1); break; } } else { while (j < s.length && s[j] !== "<") { j++; } var text = s.substring(i, j); this.onText(this._resolveEntities(text)); } i = j; } } }, { key: "onResolveEntity", value: function onResolveEntity(name) { return "&".concat(name, ";"); } }, { key: "onPi", value: function onPi(name, value) {} }, { key: "onComment", value: function onComment(text) {} }, { key: "onCdata", value: function onCdata(text) {} }, { key: "onDoctype", value: function onDoctype(doctypeContent) {} }, { key: "onText", value: function onText(text) {} }, { key: "onBeginElement", value: function onBeginElement(name, attributes, isEmpty) {} }, { key: "onEndElement", value: function onEndElement(name) {} }, { key: "onError", value: function onError(code) {} }]); return XMLParserBase; }();
var SimpleDOMNode = /*#__PURE__*/function () {
function SimpleDOMNode(nodeName, nodeValue) { _classCallCheck(this, SimpleDOMNode); this.nodeName = nodeName; this.nodeValue = nodeValue; Object.defineProperty(this, "parentNode", { value: null, writable: true }); } _createClass(SimpleDOMNode, [{ key: "hasChildNodes", value: function hasChildNodes() { return this.childNodes && this.childNodes.length > 0; } }, { key: "firstChild", get: function get() { return this.childNodes && this.childNodes[0]; } }, { key: "nextSibling", get: function get() { var childNodes = this.parentNode.childNodes; if (!childNodes) { return undefined; } var index = childNodes.indexOf(this); if (index === -1) { return undefined; } return childNodes[index + 1]; } }, { key: "textContent", get: function get() { if (!this.childNodes) { return this.nodeValue || ""; } return this.childNodes.map(function (child) { return child.textContent; }).join(""); } }]); return SimpleDOMNode; }();
var SimpleXMLParser = /*#__PURE__*/function (_XMLParserBase) {
_inherits(SimpleXMLParser, _XMLParserBase); var _super = _createSuper(SimpleXMLParser); function SimpleXMLParser() { var _this2; _classCallCheck(this, SimpleXMLParser); _this2 = _super.call(this); _this2._currentFragment = null; _this2._stack = null; _this2._errorCode = XMLParserErrorCode.NoError; return _this2; } _createClass(SimpleXMLParser, [{ key: "parseFromString", value: function parseFromString(data) { this._currentFragment = []; this._stack = []; this._errorCode = XMLParserErrorCode.NoError; this.parseXml(data); if (this._errorCode !== XMLParserErrorCode.NoError) { return undefined; } var _this$_currentFragmen = _slicedToArray(this._currentFragment, 1), documentElement = _this$_currentFragmen[0]; if (!documentElement) { return undefined; } return { documentElement: documentElement }; } }, { key: "onResolveEntity", value: function onResolveEntity(name) { switch (name) { case "apos": return "'"; } return _get(_getPrototypeOf(SimpleXMLParser.prototype), "onResolveEntity", this).call(this, name); } }, { key: "onText", value: function onText(text) { if (isWhitespaceString(text)) { return; } var node = new SimpleDOMNode("#text", text); this._currentFragment.push(node); } }, { key: "onCdata", value: function onCdata(text) { var node = new SimpleDOMNode("#text", text); this._currentFragment.push(node); } }, { key: "onBeginElement", value: function onBeginElement(name, attributes, isEmpty) { var node = new SimpleDOMNode(name); node.childNodes = []; this._currentFragment.push(node); if (isEmpty) { return; } this._stack.push(this._currentFragment); this._currentFragment = node.childNodes; } }, { key: "onEndElement", value: function onEndElement(name) { this._currentFragment = this._stack.pop() || []; var lastElement = this._currentFragment[this._currentFragment.length - 1]; if (!lastElement) { return; } for (var i = 0, ii = lastElement.childNodes.length; i < ii; i++) { lastElement.childNodes[i].parentNode = lastElement; } } }, { key: "onError", value: function onError(code) { this._errorCode = code; } }]); return SimpleXMLParser; }(XMLParserBase); exports.SimpleXMLParser = SimpleXMLParser;
/***/ }),
/* 212 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFDataTransportStream = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2)); var _util = __w_pdfjs_require__(5); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var PDFDataTransportStream = /*#__PURE__*/function () {
function PDFDataTransportStream(params, pdfDataRangeTransport) { var _this = this; _classCallCheck(this, PDFDataTransportStream); (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'); this._queuedChunks = []; this._progressiveDone = params.progressiveDone || false; var initialData = params.initialData; if (initialData && initialData.length > 0) { var buffer = new Uint8Array(initialData).buffer; this._queuedChunks.push(buffer); } this._pdfDataRangeTransport = pdfDataRangeTransport; this._isStreamingSupported = !params.disableStream; this._isRangeSupported = !params.disableRange; this._contentLength = params.length; this._fullRequestReader = null; this._rangeReaders = []; this._pdfDataRangeTransport.addRangeListener(function (begin, chunk) { _this._onReceiveData({ begin: begin, chunk: chunk }); }); this._pdfDataRangeTransport.addProgressListener(function (loaded, total) { _this._onProgress({ loaded: loaded, total: total }); }); this._pdfDataRangeTransport.addProgressiveReadListener(function (chunk) { _this._onReceiveData({ chunk: chunk }); }); this._pdfDataRangeTransport.addProgressiveDoneListener(function () { _this._onProgressiveDone(); }); this._pdfDataRangeTransport.transportReady(); } _createClass(PDFDataTransportStream, [{ key: "_onReceiveData", value: function _onReceiveData(args) { var buffer = new Uint8Array(args.chunk).buffer; if (args.begin === undefined) { if (this._fullRequestReader) { this._fullRequestReader._enqueue(buffer); } else { this._queuedChunks.push(buffer); } } else { var found = this._rangeReaders.some(function (rangeReader) { if (rangeReader._begin !== args.begin) { return false; } rangeReader._enqueue(buffer); return true; }); (0, _util.assert)(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found."); } } }, { key: "_onProgress", value: function _onProgress(evt) { if (evt.total === undefined) { var firstReader = this._rangeReaders[0]; if (firstReader && firstReader.onProgress) { firstReader.onProgress({ loaded: evt.loaded }); } } else { var fullReader = this._fullRequestReader; if (fullReader && fullReader.onProgress) { fullReader.onProgress({ loaded: evt.loaded, total: evt.total }); } } } }, { key: "_onProgressiveDone", value: function _onProgressiveDone() { if (this._fullRequestReader) { this._fullRequestReader.progressiveDone(); } this._progressiveDone = true; } }, { key: "_removeRangeReader", value: function _removeRangeReader(reader) { var i = this._rangeReaders.indexOf(reader); if (i >= 0) { this._rangeReaders.splice(i, 1); } } }, { key: "getFullReader", value: function getFullReader() { (0, _util.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once."); var queuedChunks = this._queuedChunks; this._queuedChunks = null; return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone); } }, { key: "getRangeReader", value: function getRangeReader(begin, end) { if (end <= this._progressiveDataLength) { return null; } var reader = new PDFDataTransportStreamRangeReader(this, begin, end); this._pdfDataRangeTransport.requestDataRange(begin, end); this._rangeReaders.push(reader); return reader; } }, { key: "cancelAllRequests", value: function cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } var readers = this._rangeReaders.slice(0); readers.forEach(function (rangeReader) { rangeReader.cancel(reason); }); this._pdfDataRangeTransport.abort(); } }, { key: "_progressiveDataLength", get: function get() { return this._fullRequestReader ? this._fullRequestReader._loaded : 0; } }]); return PDFDataTransportStream; }(); exports.PDFDataTransportStream = PDFDataTransportStream;
var PDFDataTransportStreamReader = /*#__PURE__*/function () {
function PDFDataTransportStreamReader(stream, queuedChunks) { var progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; _classCallCheck(this, PDFDataTransportStreamReader); this._stream = stream; this._done = progressiveDone || false; this._filename = null; this._queuedChunks = queuedChunks || []; this._loaded = 0; var _iterator = _createForOfIteratorHelper(this._queuedChunks), _step; try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var chunk = _step.value; this._loaded += chunk.byteLength; } } catch (err) { _iterator.e(err); } finally { _iterator.f(); } this._requests = []; this._headersReady = Promise.resolve(); stream._fullRequestReader = this; this.onProgress = null; } _createClass(PDFDataTransportStreamReader, [{ key: "_enqueue", value: function _enqueue(chunk) { if (this._done) { return; } if (this._requests.length > 0) { var requestCapability = this._requests.shift(); requestCapability.resolve({ value: chunk, done: false }); } else { this._queuedChunks.push(chunk); } this._loaded += chunk.byteLength; } }, { key: "read", value: function () {
var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
var chunk, requestCapability; return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: if (!(this._queuedChunks.length > 0)) { _context.next = 3; break; } chunk = this._queuedChunks.shift(); return _context.abrupt("return", { value: chunk, done: false }); case 3: if (!this._done) { _context.next = 5; break; } return _context.abrupt("return", { value: undefined, done: true }); case 5: requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return _context.abrupt("return", requestCapability.promise); case 8: case "end": return _context.stop(); } } }, _callee, this); })); function read() { return _read.apply(this, arguments); } return read; }() }, { key: "cancel", value: function cancel(reason) { this._done = true; this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; } }, { key: "progressiveDone", value: function progressiveDone() { if (this._done) { return; } this._done = true; } }, { key: "headersReady", get: function get() { return this._headersReady; } }, { key: "filename", get: function get() { return this._filename; } }, { key: "isRangeSupported", get: function get() { return this._stream._isRangeSupported; } }, { key: "isStreamingSupported", get: function get() { return this._stream._isStreamingSupported; } }, { key: "contentLength", get: function get() { return this._stream._contentLength; } }]); return PDFDataTransportStreamReader; }();
var PDFDataTransportStreamRangeReader = /*#__PURE__*/function () {
function PDFDataTransportStreamRangeReader(stream, begin, end) { _classCallCheck(this, PDFDataTransportStreamRangeReader); this._stream = stream; this._begin = begin; this._end = end; this._queuedChunk = null; this._requests = []; this._done = false; this.onProgress = null; } _createClass(PDFDataTransportStreamRangeReader, [{ key: "_enqueue", value: function _enqueue(chunk) { if (this._done) { return; } if (this._requests.length === 0) { this._queuedChunk = chunk; } else { var requestsCapability = this._requests.shift(); requestsCapability.resolve({ value: chunk, done: false }); this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; } this._done = true; this._stream._removeRangeReader(this); } }, { key: "read", value: function () {
var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
var chunk, requestCapability; return _regenerator["default"].wrap(function _callee2$(_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0: if (!this._queuedChunk) { _context2.next = 4; break; } chunk = this._queuedChunk; this._queuedChunk = null; return _context2.abrupt("return", { value: chunk, done: false }); case 4: if (!this._done) { _context2.next = 6; break; } return _context2.abrupt("return", { value: undefined, done: true }); case 6: requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return _context2.abrupt("return", requestCapability.promise); case 9: case "end": return _context2.stop(); } } }, _callee2, this); })); function read() { return _read2.apply(this, arguments); } return read; }() }, { key: "cancel", value: function cancel(reason) { this._done = true; this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; this._stream._removeRangeReader(this); } }, { key: "isStreamingSupported", get: function get() { return false; } }]); return PDFDataTransportStreamRangeReader; }();
/***/ }),
/* 213 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.WebGLContext = void 0; var _util = __w_pdfjs_require__(5); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var WebGLContext = /*#__PURE__*/function () {
function WebGLContext(_ref) { var _ref$enable = _ref.enable, enable = _ref$enable === void 0 ? false : _ref$enable; _classCallCheck(this, WebGLContext); this._enabled = enable === true; } _createClass(WebGLContext, [{ key: "composeSMask", value: function composeSMask(_ref2) { var layer = _ref2.layer, mask = _ref2.mask, properties = _ref2.properties; return WebGLUtils.composeSMask(layer, mask, properties); } }, { key: "drawFigures", value: function drawFigures(_ref3) { var width = _ref3.width, height = _ref3.height, backgroundColor = _ref3.backgroundColor, figures = _ref3.figures, context = _ref3.context; return WebGLUtils.drawFigures(width, height, backgroundColor, figures, context); } }, { key: "clear", value: function clear() { WebGLUtils.cleanup(); } }, { key: "isEnabled", get: function get() { var enabled = this._enabled; if (enabled) { enabled = WebGLUtils.tryInitGL(); } return (0, _util.shadow)(this, "isEnabled", enabled); } }]); return WebGLContext; }(); exports.WebGLContext = WebGLContext; var WebGLUtils = function WebGLUtilsClosure() { function loadShader(gl, code, shaderType) { var shader = gl.createShader(shaderType); gl.shaderSource(shader, code); gl.compileShader(shader); var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS); if (!compiled) { var errorMsg = gl.getShaderInfoLog(shader); throw new Error("Error during shader compilation: " + errorMsg); } return shader; } function createVertexShader(gl, code) { return loadShader(gl, code, gl.VERTEX_SHADER); } function createFragmentShader(gl, code) { return loadShader(gl, code, gl.FRAGMENT_SHADER); } function createProgram(gl, shaders) { var program = gl.createProgram(); for (var i = 0, ii = shaders.length; i < ii; ++i) { gl.attachShader(program, shaders[i]); } gl.linkProgram(program); var linked = gl.getProgramParameter(program, gl.LINK_STATUS); if (!linked) { var errorMsg = gl.getProgramInfoLog(program); throw new Error("Error during program linking: " + errorMsg); } return program; } function createTexture(gl, image, textureId) { gl.activeTexture(textureId); var texture = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, texture); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image); return texture; } var currentGL, currentCanvas; function generateGL() { if (currentGL) { return; } currentCanvas = document.createElement("canvas"); currentGL = currentCanvas.getContext("webgl", { premultipliedalpha: false }); } var smaskVertexShaderCode = "\ attribute vec2 a_position; \ attribute vec2 a_texCoord; \ \ uniform vec2 u_resolution; \ \ varying vec2 v_texCoord; \ \ void main() { \ vec2 clipSpace = (a_position / u_resolution) * 2.0 - 1.0; \ gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); \ \ v_texCoord = a_texCoord; \ } "; var smaskFragmentShaderCode = "\ precision mediump float; \ \ uniform vec4 u_backdrop; \ uniform int u_subtype; \ uniform sampler2D u_image; \ uniform sampler2D u_mask; \ \ varying vec2 v_texCoord; \ \ void main() { \ vec4 imageColor = texture2D(u_image, v_texCoord); \ vec4 maskColor = texture2D(u_mask, v_texCoord); \ if (u_backdrop.a > 0.0) { \ maskColor.rgb = maskColor.rgb * maskColor.a + \ u_backdrop.rgb * (1.0 - maskColor.a); \ } \ float lum; \ if (u_subtype == 0) { \ lum = maskColor.a; \ } else { \ lum = maskColor.r * 0.3 + maskColor.g * 0.59 + \ maskColor.b * 0.11; \ } \ imageColor.a *= lum; \ imageColor.rgb *= imageColor.a; \ gl_FragColor = imageColor; \ } "; var smaskCache = null; function initSmaskGL() { var canvas, gl; generateGL(); canvas = currentCanvas; currentCanvas = null; gl = currentGL; currentGL = null; var vertexShader = createVertexShader(gl, smaskVertexShaderCode); var fragmentShader = createFragmentShader(gl, smaskFragmentShaderCode); var program = createProgram(gl, [vertexShader, fragmentShader]); gl.useProgram(program); var cache = {}; cache.gl = gl; cache.canvas = canvas; cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution"); cache.positionLocation = gl.getAttribLocation(program, "a_position"); cache.backdropLocation = gl.getUniformLocation(program, "u_backdrop"); cache.subtypeLocation = gl.getUniformLocation(program, "u_subtype"); var texCoordLocation = gl.getAttribLocation(program, "a_texCoord"); var texLayerLocation = gl.getUniformLocation(program, "u_image"); var texMaskLocation = gl.getUniformLocation(program, "u_mask"); var texCoordBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 1.0]), gl.STATIC_DRAW); gl.enableVertexAttribArray(texCoordLocation); gl.vertexAttribPointer(texCoordLocation, 2, gl.FLOAT, false, 0, 0); gl.uniform1i(texLayerLocation, 0); gl.uniform1i(texMaskLocation, 1); smaskCache = cache; } function composeSMask(layer, mask, properties) { var width = layer.width, height = layer.height; if (!smaskCache) { initSmaskGL(); } var cache = smaskCache, canvas = cache.canvas, gl = cache.gl; canvas.width = width; canvas.height = height; gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.uniform2f(cache.resolutionLocation, width, height); if (properties.backdrop) { gl.uniform4f(cache.resolutionLocation, properties.backdrop[0], properties.backdrop[1], properties.backdrop[2], 1); } else { gl.uniform4f(cache.resolutionLocation, 0, 0, 0, 0); } gl.uniform1i(cache.subtypeLocation, properties.subtype === "Luminosity" ? 1 : 0); var texture = createTexture(gl, layer, gl.TEXTURE0); var maskTexture = createTexture(gl, mask, gl.TEXTURE1); var buffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, buffer); gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 0, width, 0, 0, height, 0, height, width, 0, width, height]), gl.STATIC_DRAW); gl.enableVertexAttribArray(cache.positionLocation); gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0); gl.clearColor(0, 0, 0, 0); gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); gl.clear(gl.COLOR_BUFFER_BIT); gl.drawArrays(gl.TRIANGLES, 0, 6); gl.flush(); gl.deleteTexture(texture); gl.deleteTexture(maskTexture); gl.deleteBuffer(buffer); return canvas; } var figuresVertexShaderCode = "\ attribute vec2 a_position; \ attribute vec3 a_color; \ \ uniform vec2 u_resolution; \ uniform vec2 u_scale; \ uniform vec2 u_offset; \ \ varying vec4 v_color; \ \ void main() { \ vec2 position = (a_position + u_offset) * u_scale; \ vec2 clipSpace = (position / u_resolution) * 2.0 - 1.0; \ gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1); \ \ v_color = vec4(a_color / 255.0, 1.0); \ } "; var figuresFragmentShaderCode = "\ precision mediump float; \ \ varying vec4 v_color; \ \ void main() { \ gl_FragColor = v_color; \ } "; var figuresCache = null; function initFiguresGL() { var canvas, gl; generateGL(); canvas = currentCanvas; currentCanvas = null; gl = currentGL; currentGL = null; var vertexShader = createVertexShader(gl, figuresVertexShaderCode); var fragmentShader = createFragmentShader(gl, figuresFragmentShaderCode); var program = createProgram(gl, [vertexShader, fragmentShader]); gl.useProgram(program); var cache = {}; cache.gl = gl; cache.canvas = canvas; cache.resolutionLocation = gl.getUniformLocation(program, "u_resolution"); cache.scaleLocation = gl.getUniformLocation(program, "u_scale"); cache.offsetLocation = gl.getUniformLocation(program, "u_offset"); cache.positionLocation = gl.getAttribLocation(program, "a_position"); cache.colorLocation = gl.getAttribLocation(program, "a_color"); figuresCache = cache; } function drawFigures(width, height, backgroundColor, figures, context) { if (!figuresCache) { initFiguresGL(); } var cache = figuresCache, canvas = cache.canvas, gl = cache.gl; canvas.width = width; canvas.height = height; gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight); gl.uniform2f(cache.resolutionLocation, width, height); var count = 0; var i, ii, rows; for (i = 0, ii = figures.length; i < ii; i++) { switch (figures[i].type) { case "lattice": rows = figures[i].coords.length / figures[i].verticesPerRow | 0; count += (rows - 1) * (figures[i].verticesPerRow - 1) * 6; break; case "triangles": count += figures[i].coords.length; break; } } var coords = new Float32Array(count * 2); var colors = new Uint8Array(count * 3); var coordsMap = context.coords, colorsMap = context.colors; var pIndex = 0, cIndex = 0; for (i = 0, ii = figures.length; i < ii; i++) { var figure = figures[i], ps = figure.coords, cs = figure.colors; switch (figure.type) { case "lattice": var cols = figure.verticesPerRow; rows = ps.length / cols | 0; for (var row = 1; row < rows; row++) { var offset = row * cols + 1; for (var col = 1; col < cols; col++, offset++) { coords[pIndex] = coordsMap[ps[offset - cols - 1]]; coords[pIndex + 1] = coordsMap[ps[offset - cols - 1] + 1]; coords[pIndex + 2] = coordsMap[ps[offset - cols]]; coords[pIndex + 3] = coordsMap[ps[offset - cols] + 1]; coords[pIndex + 4] = coordsMap[ps[offset - 1]]; coords[pIndex + 5] = coordsMap[ps[offset - 1] + 1]; colors[cIndex] = colorsMap[cs[offset - cols - 1]]; colors[cIndex + 1] = colorsMap[cs[offset - cols - 1] + 1]; colors[cIndex + 2] = colorsMap[cs[offset - cols - 1] + 2]; colors[cIndex + 3] = colorsMap[cs[offset - cols]]; colors[cIndex + 4] = colorsMap[cs[offset - cols] + 1]; colors[cIndex + 5] = colorsMap[cs[offset - cols] + 2]; colors[cIndex + 6] = colorsMap[cs[offset - 1]]; colors[cIndex + 7] = colorsMap[cs[offset - 1] + 1]; colors[cIndex + 8] = colorsMap[cs[offset - 1] + 2]; coords[pIndex + 6] = coords[pIndex + 2]; coords[pIndex + 7] = coords[pIndex + 3]; coords[pIndex + 8] = coords[pIndex + 4]; coords[pIndex + 9] = coords[pIndex + 5]; coords[pIndex + 10] = coordsMap[ps[offset]]; coords[pIndex + 11] = coordsMap[ps[offset] + 1]; colors[cIndex + 9] = colors[cIndex + 3]; colors[cIndex + 10] = colors[cIndex + 4]; colors[cIndex + 11] = colors[cIndex + 5]; colors[cIndex + 12] = colors[cIndex + 6]; colors[cIndex + 13] = colors[cIndex + 7]; colors[cIndex + 14] = colors[cIndex + 8]; colors[cIndex + 15] = colorsMap[cs[offset]]; colors[cIndex + 16] = colorsMap[cs[offset] + 1]; colors[cIndex + 17] = colorsMap[cs[offset] + 2]; pIndex += 12; cIndex += 18; } } break; case "triangles": for (var j = 0, jj = ps.length; j < jj; j++) { coords[pIndex] = coordsMap[ps[j]]; coords[pIndex + 1] = coordsMap[ps[j] + 1]; colors[cIndex] = colorsMap[cs[j]]; colors[cIndex + 1] = colorsMap[cs[j] + 1]; colors[cIndex + 2] = colorsMap[cs[j] + 2]; pIndex += 2; cIndex += 3; } break; } } if (backgroundColor) { gl.clearColor(backgroundColor[0] / 255, backgroundColor[1] / 255, backgroundColor[2] / 255, 1.0); } else { gl.clearColor(0, 0, 0, 0); } gl.clear(gl.COLOR_BUFFER_BIT); var coordsBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, coordsBuffer); gl.bufferData(gl.ARRAY_BUFFER, coords, gl.STATIC_DRAW); gl.enableVertexAttribArray(cache.positionLocation); gl.vertexAttribPointer(cache.positionLocation, 2, gl.FLOAT, false, 0, 0); var colorsBuffer = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, colorsBuffer); gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW); gl.enableVertexAttribArray(cache.colorLocation); gl.vertexAttribPointer(cache.colorLocation, 3, gl.UNSIGNED_BYTE, false, 0, 0); gl.uniform2f(cache.scaleLocation, context.scaleX, context.scaleY); gl.uniform2f(cache.offsetLocation, context.offsetX, context.offsetY); gl.drawArrays(gl.TRIANGLES, 0, count); gl.flush(); gl.deleteBuffer(coordsBuffer); gl.deleteBuffer(colorsBuffer); return canvas; } return { tryInitGL: function tryInitGL() { try { generateGL(); return !!currentGL; } catch (ex) {} return false; }, composeSMask: composeSMask, drawFigures: drawFigures, cleanup: function cleanup() { if (smaskCache && smaskCache.canvas) { smaskCache.canvas.width = 0; smaskCache.canvas.height = 0; } if (figuresCache && figuresCache.canvas) { figuresCache.canvas.width = 0; figuresCache.canvas.height = 0; } smaskCache = null; figuresCache = null; } }; }();
/***/ }),
/* 214 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.AnnotationLayer = void 0; var _display_utils = __w_pdfjs_require__(1); var _util = __w_pdfjs_require__(5);
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); } function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var AnnotationElementFactory = /*#__PURE__*/function () {
function AnnotationElementFactory() { _classCallCheck(this, AnnotationElementFactory); } _createClass(AnnotationElementFactory, null, [{ key: "create", value: function create(parameters) { var subtype = parameters.data.annotationType; switch (subtype) { case _util.AnnotationType.LINK: return new LinkAnnotationElement(parameters); case _util.AnnotationType.TEXT: return new TextAnnotationElement(parameters); case _util.AnnotationType.WIDGET: var fieldType = parameters.data.fieldType; switch (fieldType) { case "Tx": return new TextWidgetAnnotationElement(parameters); case "Btn": if (parameters.data.radioButton) { return new RadioButtonWidgetAnnotationElement(parameters); } else if (parameters.data.checkBox) { return new CheckboxWidgetAnnotationElement(parameters); } return new PushButtonWidgetAnnotationElement(parameters); case "Ch": return new ChoiceWidgetAnnotationElement(parameters); } return new WidgetAnnotationElement(parameters); case _util.AnnotationType.POPUP: return new PopupAnnotationElement(parameters); case _util.AnnotationType.FREETEXT: return new FreeTextAnnotationElement(parameters); case _util.AnnotationType.LINE: return new LineAnnotationElement(parameters); case _util.AnnotationType.SQUARE: return new SquareAnnotationElement(parameters); case _util.AnnotationType.CIRCLE: return new CircleAnnotationElement(parameters); case _util.AnnotationType.POLYLINE: return new PolylineAnnotationElement(parameters); case _util.AnnotationType.CARET: return new CaretAnnotationElement(parameters); case _util.AnnotationType.INK: return new InkAnnotationElement(parameters); case _util.AnnotationType.POLYGON: return new PolygonAnnotationElement(parameters); case _util.AnnotationType.HIGHLIGHT: return new HighlightAnnotationElement(parameters); case _util.AnnotationType.UNDERLINE: return new UnderlineAnnotationElement(parameters); case _util.AnnotationType.SQUIGGLY: return new SquigglyAnnotationElement(parameters); case _util.AnnotationType.STRIKEOUT: return new StrikeOutAnnotationElement(parameters); case _util.AnnotationType.STAMP: return new StampAnnotationElement(parameters); case _util.AnnotationType.FILEATTACHMENT: return new FileAttachmentAnnotationElement(parameters); default: return new AnnotationElement(parameters); } } }]); return AnnotationElementFactory; }();
var AnnotationElement = /*#__PURE__*/function () {
function AnnotationElement(parameters) { var isRenderable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; var ignoreBorder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; _classCallCheck(this, AnnotationElement); this.isRenderable = isRenderable; this.data = parameters.data; this.layer = parameters.layer; this.page = parameters.page; this.viewport = parameters.viewport; this.linkService = parameters.linkService; this.downloadManager = parameters.downloadManager; this.imageResourcesPath = parameters.imageResourcesPath; this.renderInteractiveForms = parameters.renderInteractiveForms; this.svgFactory = parameters.svgFactory; if (isRenderable) { this.container = this._createContainer(ignoreBorder); } } _createClass(AnnotationElement, [{ key: "_createContainer", value: function _createContainer() { var ignoreBorder = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; var data = this.data, page = this.page, viewport = this.viewport; var container = document.createElement("section"); var width = data.rect[2] - data.rect[0]; var height = data.rect[3] - data.rect[1]; container.setAttribute("data-annotation-id", data.id); var rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]); container.style.transform = "matrix(".concat(viewport.transform.join(","), ")"); container.style.transformOrigin = "-".concat(rect[0], "px -").concat(rect[1], "px"); if (!ignoreBorder && data.borderStyle.width > 0) { container.style.borderWidth = "".concat(data.borderStyle.width, "px"); if (data.borderStyle.style !== _util.AnnotationBorderStyleType.UNDERLINE) { width = width - 2 * data.borderStyle.width; height = height - 2 * data.borderStyle.width; } var horizontalRadius = data.borderStyle.horizontalCornerRadius; var verticalRadius = data.borderStyle.verticalCornerRadius; if (horizontalRadius > 0 || verticalRadius > 0) { var radius = "".concat(horizontalRadius, "px / ").concat(verticalRadius, "px"); container.style.borderRadius = radius; } switch (data.borderStyle.style) { case _util.AnnotationBorderStyleType.SOLID: container.style.borderStyle = "solid"; break; case _util.AnnotationBorderStyleType.DASHED: container.style.borderStyle = "dashed"; break; case _util.AnnotationBorderStyleType.BEVELED: (0, _util.warn)("Unimplemented border style: beveled"); break; case _util.AnnotationBorderStyleType.INSET: (0, _util.warn)("Unimplemented border style: inset"); break; case _util.AnnotationBorderStyleType.UNDERLINE: container.style.borderBottomStyle = "solid"; break; default: break; } if (data.color) { container.style.borderColor = _util.Util.makeCssRgb(data.color[0] | 0, data.color[1] | 0, data.color[2] | 0); } else { container.style.borderWidth = 0; } } container.style.left = "".concat(rect[0], "px"); container.style.top = "".concat(rect[1], "px"); container.style.width = "".concat(width, "px"); container.style.height = "".concat(height, "px"); return container; } }, { key: "_createPopup", value: function _createPopup(container, trigger, data) { if (!trigger) { trigger = document.createElement("div"); trigger.style.height = container.style.height; trigger.style.width = container.style.width; container.appendChild(trigger); } var popupElement = new PopupElement({ container: container, trigger: trigger, color: data.color, title: data.title, modificationDate: data.modificationDate, contents: data.contents, hideWrapper: true }); var popup = popupElement.render(); popup.style.left = container.style.width; container.appendChild(popup); } }, { key: "render", value: function render() { (0, _util.unreachable)("Abstract method `AnnotationElement.render` called"); } }]); return AnnotationElement; }();
var LinkAnnotationElement = /*#__PURE__*/function (_AnnotationElement) {
_inherits(LinkAnnotationElement, _AnnotationElement); var _super = _createSuper(LinkAnnotationElement); function LinkAnnotationElement(parameters) { _classCallCheck(this, LinkAnnotationElement); var isRenderable = !!(parameters.data.url || parameters.data.dest || parameters.data.action); return _super.call(this, parameters, isRenderable); } _createClass(LinkAnnotationElement, [{ key: "render", value: function render() { this.container.className = "linkAnnotation"; var data = this.data, linkService = this.linkService; var link = document.createElement("a"); if (data.url) { (0, _display_utils.addLinkAttributes)(link, { url: data.url, target: data.newWindow ? _display_utils.LinkTarget.BLANK : linkService.externalLinkTarget, rel: linkService.externalLinkRel, enabled: linkService.externalLinkEnabled }); } else if (data.action) { this._bindNamedAction(link, data.action); } else { this._bindLink(link, data.dest); } this.container.appendChild(link); return this.container; } }, { key: "_bindLink", value: function _bindLink(link, destination) { var _this = this; link.href = this.linkService.getDestinationHash(destination); link.onclick = function () { if (destination) { _this.linkService.navigateTo(destination); } return false; }; if (destination) { link.className = "internalLink"; } } }, { key: "_bindNamedAction", value: function _bindNamedAction(link, action) { var _this2 = this; link.href = this.linkService.getAnchorUrl(""); link.onclick = function () { _this2.linkService.executeNamedAction(action); return false; }; link.className = "internalLink"; } }]); return LinkAnnotationElement; }(AnnotationElement);
var TextAnnotationElement = /*#__PURE__*/function (_AnnotationElement2) {
_inherits(TextAnnotationElement, _AnnotationElement2); var _super2 = _createSuper(TextAnnotationElement); function TextAnnotationElement(parameters) { _classCallCheck(this, TextAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super2.call(this, parameters, isRenderable); } _createClass(TextAnnotationElement, [{ key: "render", value: function render() { this.container.className = "textAnnotation"; var image = document.createElement("img"); image.style.height = this.container.style.height; image.style.width = this.container.style.width; image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg"; image.alt = "[{{type}} Annotation]"; image.dataset.l10nId = "text_annotation_type"; image.dataset.l10nArgs = JSON.stringify({ type: this.data.name }); if (!this.data.hasPopup) { this._createPopup(this.container, image, this.data); } this.container.appendChild(image); return this.container; } }]); return TextAnnotationElement; }(AnnotationElement);
var WidgetAnnotationElement = /*#__PURE__*/function (_AnnotationElement3) {
_inherits(WidgetAnnotationElement, _AnnotationElement3); var _super3 = _createSuper(WidgetAnnotationElement); function WidgetAnnotationElement() { _classCallCheck(this, WidgetAnnotationElement); return _super3.apply(this, arguments); } _createClass(WidgetAnnotationElement, [{ key: "render", value: function render() { return this.container; } }]); return WidgetAnnotationElement; }(AnnotationElement);
var TextWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem) {
_inherits(TextWidgetAnnotationElement, _WidgetAnnotationElem); var _super4 = _createSuper(TextWidgetAnnotationElement); function TextWidgetAnnotationElement(parameters) { _classCallCheck(this, TextWidgetAnnotationElement); var isRenderable = parameters.renderInteractiveForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue; return _super4.call(this, parameters, isRenderable); } _createClass(TextWidgetAnnotationElement, [{ key: "render", value: function render() { var TEXT_ALIGNMENT = ["left", "center", "right"]; this.container.className = "textWidgetAnnotation"; var element = null; if (this.renderInteractiveForms) { if (this.data.multiLine) { element = document.createElement("textarea"); element.textContent = this.data.fieldValue; } else { element = document.createElement("input"); element.type = "text"; element.setAttribute("value", this.data.fieldValue); } element.disabled = this.data.readOnly; element.name = this.data.fieldName; if (this.data.maxLen !== null) { element.maxLength = this.data.maxLen; } if (this.data.comb) { var fieldWidth = this.data.rect[2] - this.data.rect[0]; var combWidth = fieldWidth / this.data.maxLen; element.classList.add("comb"); element.style.letterSpacing = "calc(".concat(combWidth, "px - 1ch)"); } } else { element = document.createElement("div"); element.textContent = this.data.fieldValue; element.style.verticalAlign = "middle"; element.style.display = "table-cell"; var font = null; if (this.data.fontRefName && this.page.commonObjs.has(this.data.fontRefName)) { font = this.page.commonObjs.get(this.data.fontRefName); } this._setTextStyle(element, font); } if (this.data.textAlignment !== null) { element.style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment]; } this.container.appendChild(element); return this.container; } }, { key: "_setTextStyle", value: function _setTextStyle(element, font) { var style = element.style; style.fontSize = "".concat(this.data.fontSize, "px"); style.direction = this.data.fontDirection < 0 ? "rtl" : "ltr"; if (!font) { return; } var bold = "normal"; if (font.black) { bold = "900"; } else if (font.bold) { bold = "bold"; } style.fontWeight = bold; style.fontStyle = font.italic ? "italic" : "normal"; var fontFamily = font.loadedName ? "\"".concat(font.loadedName, "\", ") : ""; var fallbackName = font.fallbackName || "Helvetica, sans-serif"; style.fontFamily = fontFamily + fallbackName; } }]); return TextWidgetAnnotationElement; }(WidgetAnnotationElement);
var CheckboxWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem2) {
_inherits(CheckboxWidgetAnnotationElement, _WidgetAnnotationElem2); var _super5 = _createSuper(CheckboxWidgetAnnotationElement); function CheckboxWidgetAnnotationElement(parameters) { _classCallCheck(this, CheckboxWidgetAnnotationElement); return _super5.call(this, parameters, parameters.renderInteractiveForms); } _createClass(CheckboxWidgetAnnotationElement, [{ key: "render", value: function render() { this.container.className = "buttonWidgetAnnotation checkBox"; var element = document.createElement("input"); element.disabled = this.data.readOnly; element.type = "checkbox"; element.name = this.data.fieldName; if (this.data.fieldValue && this.data.fieldValue !== "Off") { element.setAttribute("checked", true); } this.container.appendChild(element); return this.container; } }]); return CheckboxWidgetAnnotationElement; }(WidgetAnnotationElement);
var RadioButtonWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem3) {
_inherits(RadioButtonWidgetAnnotationElement, _WidgetAnnotationElem3); var _super6 = _createSuper(RadioButtonWidgetAnnotationElement); function RadioButtonWidgetAnnotationElement(parameters) { _classCallCheck(this, RadioButtonWidgetAnnotationElement); return _super6.call(this, parameters, parameters.renderInteractiveForms); } _createClass(RadioButtonWidgetAnnotationElement, [{ key: "render", value: function render() { this.container.className = "buttonWidgetAnnotation radioButton"; var element = document.createElement("input"); element.disabled = this.data.readOnly; element.type = "radio"; element.name = this.data.fieldName; if (this.data.fieldValue === this.data.buttonValue) { element.setAttribute("checked", true); } this.container.appendChild(element); return this.container; } }]); return RadioButtonWidgetAnnotationElement; }(WidgetAnnotationElement);
var PushButtonWidgetAnnotationElement = /*#__PURE__*/function (_LinkAnnotationElemen) {
_inherits(PushButtonWidgetAnnotationElement, _LinkAnnotationElemen); var _super7 = _createSuper(PushButtonWidgetAnnotationElement); function PushButtonWidgetAnnotationElement() { _classCallCheck(this, PushButtonWidgetAnnotationElement); return _super7.apply(this, arguments); } _createClass(PushButtonWidgetAnnotationElement, [{ key: "render", value: function render() { var container = _get(_getPrototypeOf(PushButtonWidgetAnnotationElement.prototype), "render", this).call(this); container.className = "buttonWidgetAnnotation pushButton"; return container; } }]); return PushButtonWidgetAnnotationElement; }(LinkAnnotationElement);
var ChoiceWidgetAnnotationElement = /*#__PURE__*/function (_WidgetAnnotationElem4) {
_inherits(ChoiceWidgetAnnotationElement, _WidgetAnnotationElem4); var _super8 = _createSuper(ChoiceWidgetAnnotationElement); function ChoiceWidgetAnnotationElement(parameters) { _classCallCheck(this, ChoiceWidgetAnnotationElement); return _super8.call(this, parameters, parameters.renderInteractiveForms); } _createClass(ChoiceWidgetAnnotationElement, [{ key: "render", value: function render() { this.container.className = "choiceWidgetAnnotation"; var selectElement = document.createElement("select"); selectElement.disabled = this.data.readOnly; selectElement.name = this.data.fieldName; if (!this.data.combo) { selectElement.size = this.data.options.length; if (this.data.multiSelect) { selectElement.multiple = true; } } var _iterator = _createForOfIteratorHelper(this.data.options), _step; try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var option = _step.value; var optionElement = document.createElement("option"); optionElement.textContent = option.displayValue; optionElement.value = option.exportValue; if (this.data.fieldValue.includes(option.displayValue)) { optionElement.setAttribute("selected", true); } selectElement.appendChild(optionElement); } } catch (err) { _iterator.e(err); } finally { _iterator.f(); } this.container.appendChild(selectElement); return this.container; } }]); return ChoiceWidgetAnnotationElement; }(WidgetAnnotationElement);
var PopupAnnotationElement = /*#__PURE__*/function (_AnnotationElement4) {
_inherits(PopupAnnotationElement, _AnnotationElement4); var _super9 = _createSuper(PopupAnnotationElement); function PopupAnnotationElement(parameters) { _classCallCheck(this, PopupAnnotationElement); var isRenderable = !!(parameters.data.title || parameters.data.contents); return _super9.call(this, parameters, isRenderable); } _createClass(PopupAnnotationElement, [{ key: "render", value: function render() { var IGNORE_TYPES = ["Line", "Square", "Circle", "PolyLine", "Polygon", "Ink"]; this.container.className = "popupAnnotation"; if (IGNORE_TYPES.includes(this.data.parentType)) { return this.container; } var selector = "[data-annotation-id=\"".concat(this.data.parentId, "\"]"); var parentElement = this.layer.querySelector(selector); if (!parentElement) { return this.container; } var popup = new PopupElement({ container: this.container, trigger: parentElement, color: this.data.color, title: this.data.title, modificationDate: this.data.modificationDate, contents: this.data.contents }); var parentLeft = parseFloat(parentElement.style.left); var parentWidth = parseFloat(parentElement.style.width); this.container.style.transformOrigin = "-".concat(parentLeft + parentWidth, "px -").concat(parentElement.style.top); this.container.style.left = "".concat(parentLeft + parentWidth, "px"); this.container.appendChild(popup.render()); return this.container; } }]); return PopupAnnotationElement; }(AnnotationElement);
var PopupElement = /*#__PURE__*/function () {
function PopupElement(parameters) { _classCallCheck(this, PopupElement); this.container = parameters.container; this.trigger = parameters.trigger; this.color = parameters.color; this.title = parameters.title; this.modificationDate = parameters.modificationDate; this.contents = parameters.contents; this.hideWrapper = parameters.hideWrapper || false; this.pinned = false; } _createClass(PopupElement, [{ key: "render", value: function render() { var BACKGROUND_ENLIGHT = 0.7; var wrapper = document.createElement("div"); wrapper.className = "popupWrapper"; this.hideElement = this.hideWrapper ? wrapper : this.container; this.hideElement.setAttribute("hidden", true); var popup = document.createElement("div"); popup.className = "popup"; var color = this.color; if (color) { var r = BACKGROUND_ENLIGHT * (255 - color[0]) + color[0]; var g = BACKGROUND_ENLIGHT * (255 - color[1]) + color[1]; var b = BACKGROUND_ENLIGHT * (255 - color[2]) + color[2]; popup.style.backgroundColor = _util.Util.makeCssRgb(r | 0, g | 0, b | 0); } var title = document.createElement("h1"); title.textContent = this.title; popup.appendChild(title); var dateObject = _display_utils.PDFDateString.toDateObject(this.modificationDate); if (dateObject) { var modificationDate = document.createElement("span"); modificationDate.textContent = "{{date}}, {{time}}"; modificationDate.dataset.l10nId = "annotation_date_string"; modificationDate.dataset.l10nArgs = JSON.stringify({ date: dateObject.toLocaleDateString(), time: dateObject.toLocaleTimeString() }); popup.appendChild(modificationDate); } var contents = this._formatContents(this.contents); popup.appendChild(contents); this.trigger.addEventListener("click", this._toggle.bind(this)); this.trigger.addEventListener("mouseover", this._show.bind(this, false)); this.trigger.addEventListener("mouseout", this._hide.bind(this, false)); popup.addEventListener("click", this._hide.bind(this, true)); wrapper.appendChild(popup); return wrapper; } }, { key: "_formatContents", value: function _formatContents(contents) { var p = document.createElement("p"); var lines = contents.split(/(?:\r\n?|\n)/); for (var i = 0, ii = lines.length; i < ii; ++i) { var line = lines[i]; p.appendChild(document.createTextNode(line)); if (i < ii - 1) { p.appendChild(document.createElement("br")); } } return p; } }, { key: "_toggle", value: function _toggle() { if (this.pinned) { this._hide(true); } else { this._show(true); } } }, { key: "_show", value: function _show() { var pin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; if (pin) { this.pinned = true; } if (this.hideElement.hasAttribute("hidden")) { this.hideElement.removeAttribute("hidden"); this.container.style.zIndex += 1; } } }, { key: "_hide", value: function _hide() { var unpin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true; if (unpin) { this.pinned = false; } if (!this.hideElement.hasAttribute("hidden") && !this.pinned) { this.hideElement.setAttribute("hidden", true); this.container.style.zIndex -= 1; } } }]); return PopupElement; }();
var FreeTextAnnotationElement = /*#__PURE__*/function (_AnnotationElement5) {
_inherits(FreeTextAnnotationElement, _AnnotationElement5); var _super10 = _createSuper(FreeTextAnnotationElement); function FreeTextAnnotationElement(parameters) { _classCallCheck(this, FreeTextAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super10.call(this, parameters, isRenderable, true); } _createClass(FreeTextAnnotationElement, [{ key: "render", value: function render() { this.container.className = "freeTextAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } }]); return FreeTextAnnotationElement; }(AnnotationElement);
var LineAnnotationElement = /*#__PURE__*/function (_AnnotationElement6) {
_inherits(LineAnnotationElement, _AnnotationElement6); var _super11 = _createSuper(LineAnnotationElement); function LineAnnotationElement(parameters) { _classCallCheck(this, LineAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super11.call(this, parameters, isRenderable, true); } _createClass(LineAnnotationElement, [{ key: "render", value: function render() { this.container.className = "lineAnnotation"; var data = this.data; var width = data.rect[2] - data.rect[0]; var height = data.rect[3] - data.rect[1]; var svg = this.svgFactory.create(width, height); var line = this.svgFactory.createElement("svg:line"); line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]); line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]); line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]); line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]); line.setAttribute("stroke-width", data.borderStyle.width || 1); line.setAttribute("stroke", "transparent"); svg.appendChild(line); this.container.append(svg); this._createPopup(this.container, line, data); return this.container; } }]); return LineAnnotationElement; }(AnnotationElement);
var SquareAnnotationElement = /*#__PURE__*/function (_AnnotationElement7) {
_inherits(SquareAnnotationElement, _AnnotationElement7); var _super12 = _createSuper(SquareAnnotationElement); function SquareAnnotationElement(parameters) { _classCallCheck(this, SquareAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super12.call(this, parameters, isRenderable, true); } _createClass(SquareAnnotationElement, [{ key: "render", value: function render() { this.container.className = "squareAnnotation"; var data = this.data; var width = data.rect[2] - data.rect[0]; var height = data.rect[3] - data.rect[1]; var svg = this.svgFactory.create(width, height); var borderWidth = data.borderStyle.width; var square = this.svgFactory.createElement("svg:rect"); square.setAttribute("x", borderWidth / 2); square.setAttribute("y", borderWidth / 2); square.setAttribute("width", width - borderWidth); square.setAttribute("height", height - borderWidth); square.setAttribute("stroke-width", borderWidth || 1); square.setAttribute("stroke", "transparent"); square.setAttribute("fill", "none"); svg.appendChild(square); this.container.append(svg); this._createPopup(this.container, square, data); return this.container; } }]); return SquareAnnotationElement; }(AnnotationElement);
var CircleAnnotationElement = /*#__PURE__*/function (_AnnotationElement8) {
_inherits(CircleAnnotationElement, _AnnotationElement8); var _super13 = _createSuper(CircleAnnotationElement); function CircleAnnotationElement(parameters) { _classCallCheck(this, CircleAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super13.call(this, parameters, isRenderable, true); } _createClass(CircleAnnotationElement, [{ key: "render", value: function render() { this.container.className = "circleAnnotation"; var data = this.data; var width = data.rect[2] - data.rect[0]; var height = data.rect[3] - data.rect[1]; var svg = this.svgFactory.create(width, height); var borderWidth = data.borderStyle.width; var circle = this.svgFactory.createElement("svg:ellipse"); circle.setAttribute("cx", width / 2); circle.setAttribute("cy", height / 2); circle.setAttribute("rx", width / 2 - borderWidth / 2); circle.setAttribute("ry", height / 2 - borderWidth / 2); circle.setAttribute("stroke-width", borderWidth || 1); circle.setAttribute("stroke", "transparent"); circle.setAttribute("fill", "none"); svg.appendChild(circle); this.container.append(svg); this._createPopup(this.container, circle, data); return this.container; } }]); return CircleAnnotationElement; }(AnnotationElement);
var PolylineAnnotationElement = /*#__PURE__*/function (_AnnotationElement9) {
_inherits(PolylineAnnotationElement, _AnnotationElement9); var _super14 = _createSuper(PolylineAnnotationElement); function PolylineAnnotationElement(parameters) { var _this3; _classCallCheck(this, PolylineAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); _this3 = _super14.call(this, parameters, isRenderable, true); _this3.containerClassName = "polylineAnnotation"; _this3.svgElementName = "svg:polyline"; return _this3; } _createClass(PolylineAnnotationElement, [{ key: "render", value: function render() { this.container.className = this.containerClassName; var data = this.data; var width = data.rect[2] - data.rect[0]; var height = data.rect[3] - data.rect[1]; var svg = this.svgFactory.create(width, height); var points = []; var _iterator2 = _createForOfIteratorHelper(data.vertices), _step2; try { for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) { var coordinate = _step2.value; var x = coordinate.x - data.rect[0]; var y = data.rect[3] - coordinate.y; points.push(x + "," + y); } } catch (err) { _iterator2.e(err); } finally { _iterator2.f(); } points = points.join(" "); var polyline = this.svgFactory.createElement(this.svgElementName); polyline.setAttribute("points", points); polyline.setAttribute("stroke-width", data.borderStyle.width || 1); polyline.setAttribute("stroke", "transparent"); polyline.setAttribute("fill", "none"); svg.appendChild(polyline); this.container.append(svg); this._createPopup(this.container, polyline, data); return this.container; } }]); return PolylineAnnotationElement; }(AnnotationElement);
var PolygonAnnotationElement = /*#__PURE__*/function (_PolylineAnnotationEl) {
_inherits(PolygonAnnotationElement, _PolylineAnnotationEl); var _super15 = _createSuper(PolygonAnnotationElement); function PolygonAnnotationElement(parameters) { var _this4; _classCallCheck(this, PolygonAnnotationElement); _this4 = _super15.call(this, parameters); _this4.containerClassName = "polygonAnnotation"; _this4.svgElementName = "svg:polygon"; return _this4; } return PolygonAnnotationElement; }(PolylineAnnotationElement);
var CaretAnnotationElement = /*#__PURE__*/function (_AnnotationElement10) {
_inherits(CaretAnnotationElement, _AnnotationElement10); var _super16 = _createSuper(CaretAnnotationElement); function CaretAnnotationElement(parameters) { _classCallCheck(this, CaretAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super16.call(this, parameters, isRenderable, true); } _createClass(CaretAnnotationElement, [{ key: "render", value: function render() { this.container.className = "caretAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } }]); return CaretAnnotationElement; }(AnnotationElement);
var InkAnnotationElement = /*#__PURE__*/function (_AnnotationElement11) {
_inherits(InkAnnotationElement, _AnnotationElement11); var _super17 = _createSuper(InkAnnotationElement); function InkAnnotationElement(parameters) { var _this5; _classCallCheck(this, InkAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); _this5 = _super17.call(this, parameters, isRenderable, true); _this5.containerClassName = "inkAnnotation"; _this5.svgElementName = "svg:polyline"; return _this5; } _createClass(InkAnnotationElement, [{ key: "render", value: function render() { this.container.className = this.containerClassName; var data = this.data; var width = data.rect[2] - data.rect[0]; var height = data.rect[3] - data.rect[1]; var svg = this.svgFactory.create(width, height); var _iterator3 = _createForOfIteratorHelper(data.inkLists), _step3; try { for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) { var inkList = _step3.value; var points = []; var _iterator4 = _createForOfIteratorHelper(inkList), _step4; try { for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) { var coordinate = _step4.value; var x = coordinate.x - data.rect[0]; var y = data.rect[3] - coordinate.y; points.push("".concat(x, ",").concat(y)); } } catch (err) { _iterator4.e(err); } finally { _iterator4.f(); } points = points.join(" "); var polyline = this.svgFactory.createElement(this.svgElementName); polyline.setAttribute("points", points); polyline.setAttribute("stroke-width", data.borderStyle.width || 1); polyline.setAttribute("stroke", "transparent"); polyline.setAttribute("fill", "none"); this._createPopup(this.container, polyline, data); svg.appendChild(polyline); } } catch (err) { _iterator3.e(err); } finally { _iterator3.f(); } this.container.append(svg); return this.container; } }]); return InkAnnotationElement; }(AnnotationElement);
var HighlightAnnotationElement = /*#__PURE__*/function (_AnnotationElement12) {
_inherits(HighlightAnnotationElement, _AnnotationElement12); var _super18 = _createSuper(HighlightAnnotationElement); function HighlightAnnotationElement(parameters) { _classCallCheck(this, HighlightAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super18.call(this, parameters, isRenderable, true); } _createClass(HighlightAnnotationElement, [{ key: "render", value: function render() { this.container.className = "highlightAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } }]); return HighlightAnnotationElement; }(AnnotationElement);
var UnderlineAnnotationElement = /*#__PURE__*/function (_AnnotationElement13) {
_inherits(UnderlineAnnotationElement, _AnnotationElement13); var _super19 = _createSuper(UnderlineAnnotationElement); function UnderlineAnnotationElement(parameters) { _classCallCheck(this, UnderlineAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super19.call(this, parameters, isRenderable, true); } _createClass(UnderlineAnnotationElement, [{ key: "render", value: function render() { this.container.className = "underlineAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } }]); return UnderlineAnnotationElement; }(AnnotationElement);
var SquigglyAnnotationElement = /*#__PURE__*/function (_AnnotationElement14) {
_inherits(SquigglyAnnotationElement, _AnnotationElement14); var _super20 = _createSuper(SquigglyAnnotationElement); function SquigglyAnnotationElement(parameters) { _classCallCheck(this, SquigglyAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super20.call(this, parameters, isRenderable, true); } _createClass(SquigglyAnnotationElement, [{ key: "render", value: function render() { this.container.className = "squigglyAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } }]); return SquigglyAnnotationElement; }(AnnotationElement);
var StrikeOutAnnotationElement = /*#__PURE__*/function (_AnnotationElement15) {
_inherits(StrikeOutAnnotationElement, _AnnotationElement15); var _super21 = _createSuper(StrikeOutAnnotationElement); function StrikeOutAnnotationElement(parameters) { _classCallCheck(this, StrikeOutAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super21.call(this, parameters, isRenderable, true); } _createClass(StrikeOutAnnotationElement, [{ key: "render", value: function render() { this.container.className = "strikeoutAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } }]); return StrikeOutAnnotationElement; }(AnnotationElement);
var StampAnnotationElement = /*#__PURE__*/function (_AnnotationElement16) {
_inherits(StampAnnotationElement, _AnnotationElement16); var _super22 = _createSuper(StampAnnotationElement); function StampAnnotationElement(parameters) { _classCallCheck(this, StampAnnotationElement); var isRenderable = !!(parameters.data.hasPopup || parameters.data.title || parameters.data.contents); return _super22.call(this, parameters, isRenderable, true); } _createClass(StampAnnotationElement, [{ key: "render", value: function render() { this.container.className = "stampAnnotation"; if (!this.data.hasPopup) { this._createPopup(this.container, null, this.data); } return this.container; } }]); return StampAnnotationElement; }(AnnotationElement);
var FileAttachmentAnnotationElement = /*#__PURE__*/function (_AnnotationElement17) {
_inherits(FileAttachmentAnnotationElement, _AnnotationElement17); var _super23 = _createSuper(FileAttachmentAnnotationElement); function FileAttachmentAnnotationElement(parameters) { var _this6; _classCallCheck(this, FileAttachmentAnnotationElement); _this6 = _super23.call(this, parameters, true); var _this6$data$file = _this6.data.file, filename = _this6$data$file.filename, content = _this6$data$file.content; _this6.filename = (0, _display_utils.getFilenameFromUrl)(filename); _this6.content = content; if (_this6.linkService.eventBus) { _this6.linkService.eventBus.dispatch("fileattachmentannotation", { source: _assertThisInitialized(_this6), id: (0, _util.stringToPDFString)(filename), filename: filename, content: content }); } return _this6; } _createClass(FileAttachmentAnnotationElement, [{ key: "render", value: function render() { this.container.className = "fileAttachmentAnnotation"; var trigger = document.createElement("div"); trigger.style.height = this.container.style.height; trigger.style.width = this.container.style.width; trigger.addEventListener("dblclick", this._download.bind(this)); if (!this.data.hasPopup && (this.data.title || this.data.contents)) { this._createPopup(this.container, trigger, this.data); } this.container.appendChild(trigger); return this.container; } }, { key: "_download", value: function _download() { if (!this.downloadManager) { (0, _util.warn)("Download cannot be started due to unavailable download manager"); return; } this.downloadManager.downloadData(this.content, this.filename, ""); } }]); return FileAttachmentAnnotationElement; }(AnnotationElement);
var AnnotationLayer = /*#__PURE__*/function () {
function AnnotationLayer() { _classCallCheck(this, AnnotationLayer); } _createClass(AnnotationLayer, null, [{ key: "render", value: function render(parameters) { var sortedAnnotations = [], popupAnnotations = []; var _iterator5 = _createForOfIteratorHelper(parameters.annotations), _step5; try { for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) { var _data = _step5.value; if (!_data) { continue; } if (_data.annotationType === _util.AnnotationType.POPUP) { popupAnnotations.push(_data); continue; } sortedAnnotations.push(_data); } } catch (err) { _iterator5.e(err); } finally { _iterator5.f(); } if (popupAnnotations.length) { sortedAnnotations.push.apply(sortedAnnotations, popupAnnotations); } for (var _i = 0, _sortedAnnotations = sortedAnnotations; _i < _sortedAnnotations.length; _i++) { var data = _sortedAnnotations[_i]; var element = AnnotationElementFactory.create({ data: data, layer: parameters.div, page: parameters.page, viewport: parameters.viewport, linkService: parameters.linkService, downloadManager: parameters.downloadManager, imageResourcesPath: parameters.imageResourcesPath || "", renderInteractiveForms: parameters.renderInteractiveForms || false, svgFactory: new _display_utils.DOMSVGFactory() }); if (element.isRenderable) { parameters.div.appendChild(element.render()); } } } }, { key: "update", value: function update(parameters) { var _iterator6 = _createForOfIteratorHelper(parameters.annotations), _step6; try { for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) { var data = _step6.value; var element = parameters.div.querySelector("[data-annotation-id=\"".concat(data.id, "\"]")); if (element) { element.style.transform = "matrix(".concat(parameters.viewport.transform.join(","), ")"); } } } catch (err) { _iterator6.e(err); } finally { _iterator6.f(); } parameters.div.removeAttribute("hidden"); } }]); return AnnotationLayer; }(); exports.AnnotationLayer = AnnotationLayer;
/***/ }),
/* 215 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.renderTextLayer = void 0; var _util = __w_pdfjs_require__(5); var renderTextLayer = function renderTextLayerClosure() { var MAX_TEXT_DIVS_TO_RENDER = 100000; var NonWhitespaceRegexp = /\S/; function isAllWhitespace(str) { return !NonWhitespaceRegexp.test(str); } function appendText(task, geom, styles) { var textDiv = document.createElement("span"); var textDivProperties = { angle: 0, canvasWidth: 0, isWhitespace: false, originalTransform: null, paddingBottom: 0, paddingLeft: 0, paddingRight: 0, paddingTop: 0, scale: 1 }; task._textDivs.push(textDiv); if (isAllWhitespace(geom.str)) { textDivProperties.isWhitespace = true; task._textDivProperties.set(textDiv, textDivProperties); return; } var tx = _util.Util.transform(task._viewport.transform, geom.transform); var angle = Math.atan2(tx[1], tx[0]); var style = styles[geom.fontName]; if (style.vertical) { angle += Math.PI / 2; } var fontHeight = Math.sqrt(tx[2] * tx[2] + tx[3] * tx[3]); var fontAscent = fontHeight; if (style.ascent) { fontAscent = style.ascent * fontAscent; } else if (style.descent) { fontAscent = (1 + style.descent) * fontAscent; } var left, top; if (angle === 0) { left = tx[4]; top = tx[5] - fontAscent; } else { left = tx[4] + fontAscent * Math.sin(angle); top = tx[5] - fontAscent * Math.cos(angle); } textDiv.style.left = "".concat(left, "px"); textDiv.style.top = "".concat(top, "px"); textDiv.style.fontSize = "".concat(fontHeight, "px"); textDiv.style.fontFamily = style.fontFamily; textDiv.textContent = geom.str; if (task._fontInspectorEnabled) { textDiv.dataset.fontName = geom.fontName; } if (angle !== 0) { textDivProperties.angle = angle * (180 / Math.PI); } var shouldScaleText = false; if (geom.str.length > 1) { shouldScaleText = true; } else if (geom.transform[0] !== geom.transform[3]) { var absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]); if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) { shouldScaleText = true; } } if (shouldScaleText) { if (style.vertical) { textDivProperties.canvasWidth = geom.height * task._viewport.scale; } else { textDivProperties.canvasWidth = geom.width * task._viewport.scale; } } task._textDivProperties.set(textDiv, textDivProperties); if (task._textContentStream) { task._layoutText(textDiv); } if (task._enhanceTextSelection) { var angleCos = 1, angleSin = 0; if (angle !== 0) { angleCos = Math.cos(angle); angleSin = Math.sin(angle); } var divWidth = (style.vertical ? geom.height : geom.width) * task._viewport.scale; var divHeight = fontHeight; var m, b; if (angle !== 0) { m = [angleCos, angleSin, -angleSin, angleCos, left, top]; b = _util.Util.getAxialAlignedBoundingBox([0, 0, divWidth, divHeight], m); } else { b = [left, top, left + divWidth, top + divHeight]; } task._bounds.push({ left: b[0], top: b[1], right: b[2], bottom: b[3], div: textDiv, size: [divWidth, divHeight], m: m }); } } function render(task) { if (task._canceled) { return; } var textDivs = task._textDivs; var capability = task._capability; var textDivsLength = textDivs.length; if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) { task._renderingDone = true; capability.resolve(); return; } if (!task._textContentStream) { for (var i = 0; i < textDivsLength; i++) { task._layoutText(textDivs[i]); } } task._renderingDone = true; capability.resolve(); } function findPositiveMin(ts, offset, count) { var result = 0; for (var i = 0; i < count; i++) { var t = ts[offset++]; if (t > 0) { result = result ? Math.min(t, result) : t; } } return result; } function expand(task) { var bounds = task._bounds; var viewport = task._viewport; var expanded = expandBounds(viewport.width, viewport.height, bounds); for (var i = 0; i < expanded.length; i++) { var div = bounds[i].div; var divProperties = task._textDivProperties.get(div); if (divProperties.angle === 0) { divProperties.paddingLeft = bounds[i].left - expanded[i].left; divProperties.paddingTop = bounds[i].top - expanded[i].top; divProperties.paddingRight = expanded[i].right - bounds[i].right; divProperties.paddingBottom = expanded[i].bottom - bounds[i].bottom; task._textDivProperties.set(div, divProperties); continue; } var e = expanded[i], b = bounds[i]; var m = b.m, c = m[0], s = m[1]; var points = [[0, 0], [0, b.size[1]], [b.size[0], 0], b.size]; var ts = new Float64Array(64); points.forEach(function (p, j) { var t = _util.Util.applyTransform(p, m); ts[j + 0] = c && (e.left - t[0]) / c; ts[j + 4] = s && (e.top - t[1]) / s; ts[j + 8] = c && (e.right - t[0]) / c; ts[j + 12] = s && (e.bottom - t[1]) / s; ts[j + 16] = s && (e.left - t[0]) / -s; ts[j + 20] = c && (e.top - t[1]) / c; ts[j + 24] = s && (e.right - t[0]) / -s; ts[j + 28] = c && (e.bottom - t[1]) / c; ts[j + 32] = c && (e.left - t[0]) / -c; ts[j + 36] = s && (e.top - t[1]) / -s; ts[j + 40] = c && (e.right - t[0]) / -c; ts[j + 44] = s && (e.bottom - t[1]) / -s; ts[j + 48] = s && (e.left - t[0]) / s; ts[j + 52] = c && (e.top - t[1]) / -c; ts[j + 56] = s && (e.right - t[0]) / s; ts[j + 60] = c && (e.bottom - t[1]) / -c; }); var boxScale = 1 + Math.min(Math.abs(c), Math.abs(s)); divProperties.paddingLeft = findPositiveMin(ts, 32, 16) / boxScale; divProperties.paddingTop = findPositiveMin(ts, 48, 16) / boxScale; divProperties.paddingRight = findPositiveMin(ts, 0, 16) / boxScale; divProperties.paddingBottom = findPositiveMin(ts, 16, 16) / boxScale; task._textDivProperties.set(div, divProperties); } } function expandBounds(width, height, boxes) { var bounds = boxes.map(function (box, i) { return { x1: box.left, y1: box.top, x2: box.right, y2: box.bottom, index: i, x1New: undefined, x2New: undefined }; }); expandBoundsLTR(width, bounds); var expanded = new Array(boxes.length); bounds.forEach(function (b) { var i = b.index; expanded[i] = { left: b.x1New, top: 0, right: b.x2New, bottom: 0 }; }); boxes.map(function (box, i) { var e = expanded[i], b = bounds[i]; b.x1 = box.top; b.y1 = width - e.right; b.x2 = box.bottom; b.y2 = width - e.left; b.index = i; b.x1New = undefined; b.x2New = undefined; }); expandBoundsLTR(height, bounds); bounds.forEach(function (b) { var i = b.index; expanded[i].top = b.x1New; expanded[i].bottom = b.x2New; }); return expanded; } function expandBoundsLTR(width, bounds) { bounds.sort(function (a, b) { return a.x1 - b.x1 || a.index - b.index; }); var fakeBoundary = { x1: -Infinity, y1: -Infinity, x2: 0, y2: Infinity, index: -1, x1New: 0, x2New: 0 }; var horizon = [{ start: -Infinity, end: Infinity, boundary: fakeBoundary }]; bounds.forEach(function (boundary) { var i = 0; while (i < horizon.length && horizon[i].end <= boundary.y1) { i++; } var j = horizon.length - 1; while (j >= 0 && horizon[j].start >= boundary.y2) { j--; } var horizonPart, affectedBoundary; var q, k, maxXNew = -Infinity; for (q = i; q <= j; q++) { horizonPart = horizon[q]; affectedBoundary = horizonPart.boundary; var xNew; if (affectedBoundary.x2 > boundary.x1) { xNew = affectedBoundary.index > boundary.index ? affectedBoundary.x1New : boundary.x1; } else if (affectedBoundary.x2New === undefined) { xNew = (affectedBoundary.x2 + boundary.x1) / 2; } else { xNew = affectedBoundary.x2New; } if (xNew > maxXNew) { maxXNew = xNew; } } boundary.x1New = maxXNew; for (q = i; q <= j; q++) { horizonPart = horizon[q]; affectedBoundary = horizonPart.boundary; if (affectedBoundary.x2New === undefined) { if (affectedBoundary.x2 > boundary.x1) { if (affectedBoundary.index > boundary.index) { affectedBoundary.x2New = affectedBoundary.x2; } } else { affectedBoundary.x2New = maxXNew; } } else if (affectedBoundary.x2New > maxXNew) { affectedBoundary.x2New = Math.max(maxXNew, affectedBoundary.x2); } } var changedHorizon = [], lastBoundary = null; for (q = i; q <= j; q++) { horizonPart = horizon[q]; affectedBoundary = horizonPart.boundary; var useBoundary = affectedBoundary.x2 > boundary.x2 ? affectedBoundary : boundary; if (lastBoundary === useBoundary) { changedHorizon[changedHorizon.length - 1].end = horizonPart.end; } else { changedHorizon.push({ start: horizonPart.start, end: horizonPart.end, boundary: useBoundary }); lastBoundary = useBoundary; } } if (horizon[i].start < boundary.y1) { changedHorizon[0].start = boundary.y1; changedHorizon.unshift({ start: horizon[i].start, end: boundary.y1, boundary: horizon[i].boundary }); } if (boundary.y2 < horizon[j].end) { changedHorizon[changedHorizon.length - 1].end = boundary.y2; changedHorizon.push({ start: boundary.y2, end: horizon[j].end, boundary: horizon[j].boundary }); } for (q = i; q <= j; q++) { horizonPart = horizon[q]; affectedBoundary = horizonPart.boundary; if (affectedBoundary.x2New !== undefined) { continue; } var used = false; for (k = i - 1; !used && k >= 0 && horizon[k].start >= affectedBoundary.y1; k--) { used = horizon[k].boundary === affectedBoundary; } for (k = j + 1; !used && k < horizon.length && horizon[k].end <= affectedBoundary.y2; k++) { used = horizon[k].boundary === affectedBoundary; } for (k = 0; !used && k < changedHorizon.length; k++) { used = changedHorizon[k].boundary === affectedBoundary; } if (!used) { affectedBoundary.x2New = maxXNew; } } Array.prototype.splice.apply(horizon, [i, j - i + 1].concat(changedHorizon)); }); horizon.forEach(function (horizonPart) { var affectedBoundary = horizonPart.boundary; if (affectedBoundary.x2New === undefined) { affectedBoundary.x2New = Math.max(width, affectedBoundary.x2); } }); } function TextLayerRenderTask(_ref) { var _this = this; var textContent = _ref.textContent, textContentStream = _ref.textContentStream, container = _ref.container, viewport = _ref.viewport, textDivs = _ref.textDivs, textContentItemsStr = _ref.textContentItemsStr, enhanceTextSelection = _ref.enhanceTextSelection; this._textContent = textContent; this._textContentStream = textContentStream; this._container = container; this._viewport = viewport; this._textDivs = textDivs || []; this._textContentItemsStr = textContentItemsStr || []; this._enhanceTextSelection = !!enhanceTextSelection; this._fontInspectorEnabled = !!(globalThis.FontInspector && globalThis.FontInspector.enabled); this._reader = null; this._layoutTextLastFontSize = null; this._layoutTextLastFontFamily = null; this._layoutTextCtx = null; this._textDivProperties = new WeakMap(); this._renderingDone = false; this._canceled = false; this._capability = (0, _util.createPromiseCapability)(); this._renderTimer = null; this._bounds = []; this._capability.promise["finally"](function () { if (_this._layoutTextCtx) { _this._layoutTextCtx.canvas.width = 0; _this._layoutTextCtx.canvas.height = 0; _this._layoutTextCtx = null; } })["catch"](function () {}); } TextLayerRenderTask.prototype = { get promise() { return this._capability.promise; }, cancel: function TextLayer_cancel() { this._canceled = true; if (this._reader) { this._reader.cancel(new _util.AbortException("TextLayer task cancelled.")); this._reader = null; } if (this._renderTimer !== null) { clearTimeout(this._renderTimer); this._renderTimer = null; } this._capability.reject(new Error("TextLayer task cancelled.")); }, _processItems: function _processItems(items, styleCache) { for (var i = 0, len = items.length; i < len; i++) { this._textContentItemsStr.push(items[i].str); appendText(this, items[i], styleCache); } }, _layoutText: function _layoutText(textDiv) { var textDivProperties = this._textDivProperties.get(textDiv); if (textDivProperties.isWhitespace) { return; } var transform = ""; if (textDivProperties.canvasWidth !== 0) { var _textDiv$style = textDiv.style, fontSize = _textDiv$style.fontSize, fontFamily = _textDiv$style.fontFamily; if (fontSize !== this._layoutTextLastFontSize || fontFamily !== this._layoutTextLastFontFamily) { this._layoutTextCtx.font = "".concat(fontSize, " ").concat(fontFamily); this._layoutTextLastFontSize = fontSize; this._layoutTextLastFontFamily = fontFamily; } var _this$_layoutTextCtx$ = this._layoutTextCtx.measureText(textDiv.textContent), width = _this$_layoutTextCtx$.width; if (width > 0) { textDivProperties.scale = textDivProperties.canvasWidth / width; transform = "scaleX(".concat(textDivProperties.scale, ")"); } } if (textDivProperties.angle !== 0) { transform = "rotate(".concat(textDivProperties.angle, "deg) ").concat(transform); } if (transform.length > 0) { if (this._enhanceTextSelection) { textDivProperties.originalTransform = transform; } textDiv.style.transform = transform; } this._textDivProperties.set(textDiv, textDivProperties); this._container.appendChild(textDiv); }, _render: function TextLayer_render(timeout) { var _this2 = this; var capability = (0, _util.createPromiseCapability)(); var styleCache = Object.create(null); var canvas = document.createElement("canvas"); canvas.mozOpaque = true; this._layoutTextCtx = canvas.getContext("2d", { alpha: false }); if (this._textContent) { var textItems = this._textContent.items; var textStyles = this._textContent.styles; this._processItems(textItems, textStyles); capability.resolve(); } else if (this._textContentStream) { var pump = function pump() { _this2._reader.read().then(function (_ref2) { var value = _ref2.value, done = _ref2.done; if (done) { capability.resolve(); return; } Object.assign(styleCache, value.styles); _this2._processItems(value.items, styleCache); pump(); }, capability.reject); }; this._reader = this._textContentStream.getReader(); pump(); } else { throw new Error('Neither "textContent" nor "textContentStream"' + " parameters specified."); } capability.promise.then(function () { styleCache = null; if (!timeout) { render(_this2); } else { _this2._renderTimer = setTimeout(function () { render(_this2); _this2._renderTimer = null; }, timeout); } }, this._capability.reject); }, expandTextDivs: function TextLayer_expandTextDivs(expandDivs) { if (!this._enhanceTextSelection || !this._renderingDone) { return; } if (this._bounds !== null) { expand(this); this._bounds = null; } var transformBuf = [], paddingBuf = []; for (var i = 0, ii = this._textDivs.length; i < ii; i++) { var div = this._textDivs[i]; var divProps = this._textDivProperties.get(div); if (divProps.isWhitespace) { continue; } if (expandDivs) { transformBuf.length = 0; paddingBuf.length = 0; if (divProps.originalTransform) { transformBuf.push(divProps.originalTransform); } if (divProps.paddingTop > 0) { paddingBuf.push("".concat(divProps.paddingTop, "px")); transformBuf.push("translateY(".concat(-divProps.paddingTop, "px)")); } else { paddingBuf.push(0); } if (divProps.paddingRight > 0) { paddingBuf.push("".concat(divProps.paddingRight / divProps.scale, "px")); } else { paddingBuf.push(0); } if (divProps.paddingBottom > 0) { paddingBuf.push("".concat(divProps.paddingBottom, "px")); } else { paddingBuf.push(0); } if (divProps.paddingLeft > 0) { paddingBuf.push("".concat(divProps.paddingLeft / divProps.scale, "px")); transformBuf.push("translateX(".concat(-divProps.paddingLeft / divProps.scale, "px)")); } else { paddingBuf.push(0); } div.style.padding = paddingBuf.join(" "); if (transformBuf.length) { div.style.transform = transformBuf.join(" "); } } else { div.style.padding = null; div.style.transform = divProps.originalTransform; } } } }; function renderTextLayer(renderParameters) { var task = new TextLayerRenderTask({ textContent: renderParameters.textContent, textContentStream: renderParameters.textContentStream, container: renderParameters.container, viewport: renderParameters.viewport, textDivs: renderParameters.textDivs, textContentItemsStr: renderParameters.textContentItemsStr, enhanceTextSelection: renderParameters.enhanceTextSelection }); task._render(renderParameters.timeout); return task; } return renderTextLayer; }(); exports.renderTextLayer = renderTextLayer;
/***/ }),
/* 216 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.SVGGraphics = void 0; var _util = __w_pdfjs_require__(5); var _display_utils = __w_pdfjs_require__(1); var _is_node = __w_pdfjs_require__(7); function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); } function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); } function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); } function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var SVGGraphics = function SVGGraphics() { throw new Error("Not implemented: SVGGraphics"); }; exports.SVGGraphics = SVGGraphics; { var opListToTree = function opListToTree(opList) { var opTree = []; var tmp = []; var _iterator = _createForOfIteratorHelper(opList), _step; try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var opListElement = _step.value; if (opListElement.fn === "save") { opTree.push({ fnId: 92, fn: "group", items: [] }); tmp.push(opTree); opTree = opTree[opTree.length - 1].items; continue; } if (opListElement.fn === "restore") { opTree = tmp.pop(); } else { opTree.push(opListElement); } } } catch (err) { _iterator.e(err); } finally { _iterator.f(); } return opTree; }; var pf = function pf(value) { if (Number.isInteger(value)) { return value.toString(); } var s = value.toFixed(10); var i = s.length - 1; if (s[i] !== "0") { return s; } do { i--; } while (s[i] === "0"); return s.substring(0, s[i] === "." ? i : i + 1); }; var pm = function pm(m) { if (m[4] === 0 && m[5] === 0) { if (m[1] === 0 && m[2] === 0) { if (m[0] === 1 && m[3] === 1) { return ""; } return "scale(".concat(pf(m[0]), " ").concat(pf(m[3]), ")"); } if (m[0] === m[3] && m[1] === -m[2]) { var a = Math.acos(m[0]) * 180 / Math.PI; return "rotate(".concat(pf(a), ")"); } } else { if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) { return "translate(".concat(pf(m[4]), " ").concat(pf(m[5]), ")"); } } return "matrix(".concat(pf(m[0]), " ").concat(pf(m[1]), " ").concat(pf(m[2]), " ").concat(pf(m[3]), " ").concat(pf(m[4]), " ") + "".concat(pf(m[5]), ")"); }; var SVG_DEFAULTS = { fontStyle: "normal", fontWeight: "normal", fillColor: "#000000" };
var XML_NS = "http://www.w3.org/XML/1998/namespace";
var XLINK_NS = "http://www.w3.org/1999/xlink";
var LINE_CAP_STYLES = ["butt", "round", "square"]; var LINE_JOIN_STYLES = ["miter", "round", "bevel"]; var convertImgDataToPng = function () { var PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]); var CHUNK_WRAPPER_SIZE = 12; var crcTable = new Int32Array(256); for (var i = 0; i < 256; i++) { var c = i; for (var h = 0; h < 8; h++) { if (c & 1) { c = 0xedb88320 ^ c >> 1 & 0x7fffffff; } else { c = c >> 1 & 0x7fffffff; } } crcTable[i] = c; } function crc32(data, start, end) { var crc = -1; for (var _i = start; _i < end; _i++) { var a = (crc ^ data[_i]) & 0xff; var b = crcTable[a]; crc = crc >>> 8 ^ b; } return crc ^ -1; } function writePngChunk(type, body, data, offset) { var p = offset; var len = body.length; data[p] = len >> 24 & 0xff; data[p + 1] = len >> 16 & 0xff; data[p + 2] = len >> 8 & 0xff; data[p + 3] = len & 0xff; p += 4; data[p] = type.charCodeAt(0) & 0xff; data[p + 1] = type.charCodeAt(1) & 0xff; data[p + 2] = type.charCodeAt(2) & 0xff; data[p + 3] = type.charCodeAt(3) & 0xff; p += 4; data.set(body, p); p += body.length; var crc = crc32(data, offset + 4, p); data[p] = crc >> 24 & 0xff; data[p + 1] = crc >> 16 & 0xff; data[p + 2] = crc >> 8 & 0xff; data[p + 3] = crc & 0xff; } function adler32(data, start, end) { var a = 1; var b = 0; for (var _i2 = start; _i2 < end; ++_i2) { a = (a + (data[_i2] & 0xff)) % 65521; b = (b + a) % 65521; } return b << 16 | a; } function deflateSync(literals) { if (!_is_node.isNodeJS) { return deflateSyncUncompressed(literals); } try { var input; if (parseInt(process.versions.node) >= 8) { input = literals; } else { input = Buffer.from(literals); } var output = require("zlib").deflateSync(input, { level: 9 }); return output instanceof Uint8Array ? output : new Uint8Array(output); } catch (e) { (0, _util.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + e); } return deflateSyncUncompressed(literals); } function deflateSyncUncompressed(literals) { var len = literals.length; var maxBlockLength = 0xffff; var deflateBlocks = Math.ceil(len / maxBlockLength); var idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4); var pi = 0; idat[pi++] = 0x78; idat[pi++] = 0x9c; var pos = 0; while (len > maxBlockLength) { idat[pi++] = 0x00; idat[pi++] = 0xff; idat[pi++] = 0xff; idat[pi++] = 0x00; idat[pi++] = 0x00; idat.set(literals.subarray(pos, pos + maxBlockLength), pi); pi += maxBlockLength; pos += maxBlockLength; len -= maxBlockLength; } idat[pi++] = 0x01; idat[pi++] = len & 0xff; idat[pi++] = len >> 8 & 0xff; idat[pi++] = ~len & 0xffff & 0xff; idat[pi++] = (~len & 0xffff) >> 8 & 0xff; idat.set(literals.subarray(pos), pi); pi += literals.length - pos; var adler = adler32(literals, 0, literals.length); idat[pi++] = adler >> 24 & 0xff; idat[pi++] = adler >> 16 & 0xff; idat[pi++] = adler >> 8 & 0xff; idat[pi++] = adler & 0xff; return idat; } function encode(imgData, kind, forceDataSchema, isMask) { var width = imgData.width; var height = imgData.height; var bitDepth, colorType, lineSize; var bytes = imgData.data; switch (kind) { case _util.ImageKind.GRAYSCALE_1BPP: colorType = 0; bitDepth = 1; lineSize = width + 7 >> 3; break; case _util.ImageKind.RGB_24BPP: colorType = 2; bitDepth = 8; lineSize = width * 3; break; case _util.ImageKind.RGBA_32BPP: colorType = 6; bitDepth = 8; lineSize = width * 4; break; default: throw new Error("invalid format"); } var literals = new Uint8Array((1 + lineSize) * height); var offsetLiterals = 0, offsetBytes = 0; for (var y = 0; y < height; ++y) { literals[offsetLiterals++] = 0; literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals); offsetBytes += lineSize; offsetLiterals += lineSize; } if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) { offsetLiterals = 0; for (var _y = 0; _y < height; _y++) { offsetLiterals++; for (var _i3 = 0; _i3 < lineSize; _i3++) { literals[offsetLiterals++] ^= 0xff; } } }
var ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);
var idat = deflateSync(literals); var pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length; var data = new Uint8Array(pngLength); var offset = 0; data.set(PNG_HEADER, offset); offset += PNG_HEADER.length; writePngChunk("IHDR", ihdr, data, offset); offset += CHUNK_WRAPPER_SIZE + ihdr.length; writePngChunk("IDATA", idat, data, offset); offset += CHUNK_WRAPPER_SIZE + idat.length; writePngChunk("IEND", new Uint8Array(0), data, offset); return (0, _util.createObjectURL)(data, "image/png", forceDataSchema); } return function convertImgDataToPng(imgData, forceDataSchema, isMask) { var kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind; return encode(imgData, kind, forceDataSchema, isMask); }; }();
var SVGExtraState = /*#__PURE__*/function () {
function SVGExtraState() { _classCallCheck(this, SVGExtraState); this.fontSizeScale = 1; this.fontWeight = SVG_DEFAULTS.fontWeight; this.fontSize = 0; this.textMatrix = _util.IDENTITY_MATRIX; this.fontMatrix = _util.FONT_IDENTITY_MATRIX; this.leading = 0; this.textRenderingMode = _util.TextRenderingMode.FILL; this.textMatrixScale = 1; this.x = 0; this.y = 0; this.lineX = 0; this.lineY = 0; this.charSpacing = 0; this.wordSpacing = 0; this.textHScale = 1; this.textRise = 0; this.fillColor = SVG_DEFAULTS.fillColor; this.strokeColor = "#000000"; this.fillAlpha = 1; this.strokeAlpha = 1; this.lineWidth = 1; this.lineJoin = ""; this.lineCap = ""; this.miterLimit = 0; this.dashArray = []; this.dashPhase = 0; this.dependencies = []; this.activeClipUrl = null; this.clipGroup = null; this.maskId = ""; } _createClass(SVGExtraState, [{ key: "clone", value: function clone() { return Object.create(this); } }, { key: "setCurrentPoint", value: function setCurrentPoint(x, y) { this.x = x; this.y = y; } }]); return SVGExtraState; }(); var clipCount = 0; var maskCount = 0; var shadingCount = 0;
exports.SVGGraphics = SVGGraphics = /*#__PURE__*/function () {
function SVGGraphics(commonObjs, objs) { var forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; _classCallCheck(this, SVGGraphics); this.svgFactory = new _display_utils.DOMSVGFactory(); this.current = new SVGExtraState(); this.transformMatrix = _util.IDENTITY_MATRIX; this.transformStack = []; this.extraStack = []; this.commonObjs = commonObjs; this.objs = objs; this.pendingClip = null; this.pendingEOFill = false; this.embedFonts = false; this.embeddedFonts = Object.create(null); this.cssStyle = null; this.forceDataSchema = !!forceDataSchema; this._operatorIdMapping = []; for (var op in _util.OPS) { this._operatorIdMapping[_util.OPS[op]] = op; } } _createClass(SVGGraphics, [{ key: "save", value: function save() { this.transformStack.push(this.transformMatrix); var old = this.current; this.extraStack.push(old); this.current = old.clone(); } }, { key: "restore", value: function restore() { this.transformMatrix = this.transformStack.pop(); this.current = this.extraStack.pop(); this.pendingClip = null; this.tgrp = null; } }, { key: "group", value: function group(items) { this.save(); this.executeOpTree(items); this.restore(); } }, { key: "loadDependencies", value: function loadDependencies(operatorList) { var _this = this; var fnArray = operatorList.fnArray; var argsArray = operatorList.argsArray; for (var i = 0, ii = fnArray.length; i < ii; i++) { if (fnArray[i] !== _util.OPS.dependency) { continue; } var _iterator2 = _createForOfIteratorHelper(argsArray[i]), _step2; try { var _loop = function _loop() { var obj = _step2.value; var objsPool = obj.startsWith("g_") ? _this.commonObjs : _this.objs; var promise = new Promise(function (resolve) { objsPool.get(obj, resolve); }); _this.current.dependencies.push(promise); }; for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) { _loop(); } } catch (err) { _iterator2.e(err); } finally { _iterator2.f(); } } return Promise.all(this.current.dependencies); } }, { key: "transform", value: function transform(a, b, c, d, e, f) { var transformMatrix = [a, b, c, d, e, f]; this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix); this.tgrp = null; } }, { key: "getSVG", value: function getSVG(operatorList, viewport) { var _this2 = this; this.viewport = viewport; var svgElement = this._initialize(viewport); return this.loadDependencies(operatorList).then(function () { _this2.transformMatrix = _util.IDENTITY_MATRIX; _this2.executeOpTree(_this2.convertOpList(operatorList)); return svgElement; }); } }, { key: "convertOpList", value: function convertOpList(operatorList) { var operatorIdMapping = this._operatorIdMapping; var argsArray = operatorList.argsArray; var fnArray = operatorList.fnArray; var opList = []; for (var i = 0, ii = fnArray.length; i < ii; i++) { var fnId = fnArray[i]; opList.push({ fnId: fnId, fn: operatorIdMapping[fnId], args: argsArray[i] }); } return opListToTree(opList); } }, { key: "executeOpTree", value: function executeOpTree(opTree) { var _iterator3 = _createForOfIteratorHelper(opTree), _step3; try { for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) { var opTreeElement = _step3.value; var fn = opTreeElement.fn; var fnId = opTreeElement.fnId; var args = opTreeElement.args; switch (fnId | 0) { case _util.OPS.beginText: this.beginText(); break; case _util.OPS.dependency: break; case _util.OPS.setLeading: this.setLeading(args); break; case _util.OPS.setLeadingMoveText: this.setLeadingMoveText(args[0], args[1]); break; case _util.OPS.setFont: this.setFont(args); break; case _util.OPS.showText: this.showText(args[0]); break; case _util.OPS.showSpacedText: this.showText(args[0]); break; case _util.OPS.endText: this.endText(); break; case _util.OPS.moveText: this.moveText(args[0], args[1]); break; case _util.OPS.setCharSpacing: this.setCharSpacing(args[0]); break; case _util.OPS.setWordSpacing: this.setWordSpacing(args[0]); break; case _util.OPS.setHScale: this.setHScale(args[0]); break; case _util.OPS.setTextMatrix: this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]); break; case _util.OPS.setTextRise: this.setTextRise(args[0]); break; case _util.OPS.setTextRenderingMode: this.setTextRenderingMode(args[0]); break; case _util.OPS.setLineWidth: this.setLineWidth(args[0]); break; case _util.OPS.setLineJoin: this.setLineJoin(args[0]); break; case _util.OPS.setLineCap: this.setLineCap(args[0]); break; case _util.OPS.setMiterLimit: this.setMiterLimit(args[0]); break; case _util.OPS.setFillRGBColor: this.setFillRGBColor(args[0], args[1], args[2]); break; case _util.OPS.setStrokeRGBColor: this.setStrokeRGBColor(args[0], args[1], args[2]); break; case _util.OPS.setStrokeColorN: this.setStrokeColorN(args); break; case _util.OPS.setFillColorN: this.setFillColorN(args); break; case _util.OPS.shadingFill: this.shadingFill(args[0]); break; case _util.OPS.setDash: this.setDash(args[0], args[1]); break; case _util.OPS.setRenderingIntent: this.setRenderingIntent(args[0]); break; case _util.OPS.setFlatness: this.setFlatness(args[0]); break; case _util.OPS.setGState: this.setGState(args[0]); break; case _util.OPS.fill: this.fill(); break; case _util.OPS.eoFill: this.eoFill(); break; case _util.OPS.stroke: this.stroke(); break; case _util.OPS.fillStroke: this.fillStroke(); break; case _util.OPS.eoFillStroke: this.eoFillStroke(); break; case _util.OPS.clip: this.clip("nonzero"); break; case _util.OPS.eoClip: this.clip("evenodd"); break; case _util.OPS.paintSolidColorImageMask: this.paintSolidColorImageMask(); break; case _util.OPS.paintImageXObject: this.paintImageXObject(args[0]); break; case _util.OPS.paintInlineImageXObject: this.paintInlineImageXObject(args[0]); break; case _util.OPS.paintImageMaskXObject: this.paintImageMaskXObject(args[0]); break; case _util.OPS.paintFormXObjectBegin: this.paintFormXObjectBegin(args[0], args[1]); break; case _util.OPS.paintFormXObjectEnd: this.paintFormXObjectEnd(); break; case _util.OPS.closePath: this.closePath(); break; case _util.OPS.closeStroke: this.closeStroke(); break; case _util.OPS.closeFillStroke: this.closeFillStroke(); break; case _util.OPS.closeEOFillStroke: this.closeEOFillStroke(); break; case _util.OPS.nextLine: this.nextLine(); break; case _util.OPS.transform: this.transform(args[0], args[1], args[2], args[3], args[4], args[5]); break; case _util.OPS.constructPath: this.constructPath(args[0], args[1]); break; case _util.OPS.endPath: this.endPath(); break; case 92: this.group(opTreeElement.items); break; default: (0, _util.warn)("Unimplemented operator ".concat(fn)); break; } } } catch (err) { _iterator3.e(err); } finally { _iterator3.f(); } } }, { key: "setWordSpacing", value: function setWordSpacing(wordSpacing) { this.current.wordSpacing = wordSpacing; } }, { key: "setCharSpacing", value: function setCharSpacing(charSpacing) { this.current.charSpacing = charSpacing; } }, { key: "nextLine", value: function nextLine() { this.moveText(0, this.current.leading); } }, { key: "setTextMatrix", value: function setTextMatrix(a, b, c, d, e, f) { var current = this.current; current.textMatrix = current.lineMatrix = [a, b, c, d, e, f]; current.textMatrixScale = Math.sqrt(a * a + b * b); current.x = current.lineX = 0; current.y = current.lineY = 0; current.xcoords = []; current.ycoords = []; current.tspan = this.svgFactory.createElement("svg:tspan"); current.tspan.setAttributeNS(null, "font-family", current.fontFamily); current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px")); current.tspan.setAttributeNS(null, "y", pf(-current.y)); current.txtElement = this.svgFactory.createElement("svg:text"); current.txtElement.appendChild(current.tspan); } }, { key: "beginText", value: function beginText() { var current = this.current; current.x = current.lineX = 0; current.y = current.lineY = 0; current.textMatrix = _util.IDENTITY_MATRIX; current.lineMatrix = _util.IDENTITY_MATRIX; current.textMatrixScale = 1; current.tspan = this.svgFactory.createElement("svg:tspan"); current.txtElement = this.svgFactory.createElement("svg:text"); current.txtgrp = this.svgFactory.createElement("svg:g"); current.xcoords = []; current.ycoords = []; } }, { key: "moveText", value: function moveText(x, y) { var current = this.current; current.x = current.lineX += x; current.y = current.lineY += y; current.xcoords = []; current.ycoords = []; current.tspan = this.svgFactory.createElement("svg:tspan"); current.tspan.setAttributeNS(null, "font-family", current.fontFamily); current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px")); current.tspan.setAttributeNS(null, "y", pf(-current.y)); } }, { key: "showText", value: function showText(glyphs) { var current = this.current; var font = current.font; var fontSize = current.fontSize; if (fontSize === 0) { return; } var fontSizeScale = current.fontSizeScale; var charSpacing = current.charSpacing; var wordSpacing = current.wordSpacing; var fontDirection = current.fontDirection; var textHScale = current.textHScale * fontDirection; var vertical = font.vertical; var spacingDir = vertical ? 1 : -1; var defaultVMetrics = font.defaultVMetrics; var widthAdvanceScale = fontSize * current.fontMatrix[0]; var x = 0; var _iterator4 = _createForOfIteratorHelper(glyphs), _step4; try { for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) { var glyph = _step4.value; if (glyph === null) { x += fontDirection * wordSpacing; continue; } else if ((0, _util.isNum)(glyph)) { x += spacingDir * glyph * fontSize / 1000; continue; } var spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing; var character = glyph.fontChar; var scaledX = void 0, scaledY = void 0; var width = glyph.width; if (vertical) { var vx = void 0; var vmetric = glyph.vmetric || defaultVMetrics; vx = glyph.vmetric ? vmetric[1] : width * 0.5; vx = -vx * widthAdvanceScale; var vy = vmetric[2] * widthAdvanceScale; width = vmetric ? -vmetric[0] : width; scaledX = vx / fontSizeScale; scaledY = (x + vy) / fontSizeScale; } else { scaledX = x / fontSizeScale; scaledY = 0; } if (glyph.isInFont || font.missingFile) { current.xcoords.push(current.x + scaledX); if (vertical) { current.ycoords.push(-current.y + scaledY); } current.tspan.textContent += character; } else {} var charWidth = void 0; if (vertical) { charWidth = width * widthAdvanceScale - spacing * fontDirection; } else { charWidth = width * widthAdvanceScale + spacing * fontDirection; } x += charWidth; } } catch (err) { _iterator4.e(err); } finally { _iterator4.f(); } current.tspan.setAttributeNS(null, "x", current.xcoords.map(pf).join(" ")); if (vertical) { current.tspan.setAttributeNS(null, "y", current.ycoords.map(pf).join(" ")); } else { current.tspan.setAttributeNS(null, "y", pf(-current.y)); } if (vertical) { current.y -= x; } else { current.x += x * textHScale; } current.tspan.setAttributeNS(null, "font-family", current.fontFamily); current.tspan.setAttributeNS(null, "font-size", "".concat(pf(current.fontSize), "px")); if (current.fontStyle !== SVG_DEFAULTS.fontStyle) { current.tspan.setAttributeNS(null, "font-style", current.fontStyle); } if (current.fontWeight !== SVG_DEFAULTS.fontWeight) { current.tspan.setAttributeNS(null, "font-weight", current.fontWeight); } var fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK; if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { if (current.fillColor !== SVG_DEFAULTS.fillColor) { current.tspan.setAttributeNS(null, "fill", current.fillColor); } if (current.fillAlpha < 1) { current.tspan.setAttributeNS(null, "fill-opacity", current.fillAlpha); } } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) { current.tspan.setAttributeNS(null, "fill", "transparent"); } else { current.tspan.setAttributeNS(null, "fill", "none"); } if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) { var lineWidthScale = 1 / (current.textMatrixScale || 1); this._setStrokeAttributes(current.tspan, lineWidthScale); } var textMatrix = current.textMatrix; if (current.textRise !== 0) { textMatrix = textMatrix.slice(); textMatrix[5] += current.textRise; } current.txtElement.setAttributeNS(null, "transform", "".concat(pm(textMatrix), " scale(").concat(pf(textHScale), ", -1)")); current.txtElement.setAttributeNS(XML_NS, "xml:space", "preserve"); current.txtElement.appendChild(current.tspan); current.txtgrp.appendChild(current.txtElement); this._ensureTransformGroup().appendChild(current.txtElement); } }, { key: "setLeadingMoveText", value: function setLeadingMoveText(x, y) { this.setLeading(-y); this.moveText(x, y); } }, { key: "addFontStyle", value: function addFontStyle(fontObj) { if (!fontObj.data) { throw new Error("addFontStyle: No font data available, " + 'ensure that the "fontExtraProperties" API parameter is set.'); } if (!this.cssStyle) { this.cssStyle = this.svgFactory.createElement("svg:style"); this.cssStyle.setAttributeNS(null, "type", "text/css"); this.defs.appendChild(this.cssStyle); } var url = (0, _util.createObjectURL)(fontObj.data, fontObj.mimetype, this.forceDataSchema); this.cssStyle.textContent += "@font-face { font-family: \"".concat(fontObj.loadedName, "\";") + " src: url(".concat(url, "); }\n"); } }, { key: "setFont", value: function setFont(details) { var current = this.current; var fontObj = this.commonObjs.get(details[0]); var size = details[1]; current.font = fontObj; if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) { this.addFontStyle(fontObj); this.embeddedFonts[fontObj.loadedName] = fontObj; } current.fontMatrix = fontObj.fontMatrix ? fontObj.fontMatrix : _util.FONT_IDENTITY_MATRIX; var bold = "normal"; if (fontObj.black) { bold = "900"; } else if (fontObj.bold) { bold = "bold"; } var italic = fontObj.italic ? "italic" : "normal"; if (size < 0) { size = -size; current.fontDirection = -1; } else { current.fontDirection = 1; } current.fontSize = size; current.fontFamily = fontObj.loadedName; current.fontWeight = bold; current.fontStyle = italic; current.tspan = this.svgFactory.createElement("svg:tspan"); current.tspan.setAttributeNS(null, "y", pf(-current.y)); current.xcoords = []; current.ycoords = []; } }, { key: "endText", value: function endText() { var current = this.current; if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement && current.txtElement.hasChildNodes()) { current.element = current.txtElement; this.clip("nonzero"); this.endPath(); } } }, { key: "setLineWidth", value: function setLineWidth(width) { if (width > 0) { this.current.lineWidth = width; } } }, { key: "setLineCap", value: function setLineCap(style) { this.current.lineCap = LINE_CAP_STYLES[style]; } }, { key: "setLineJoin", value: function setLineJoin(style) { this.current.lineJoin = LINE_JOIN_STYLES[style]; } }, { key: "setMiterLimit", value: function setMiterLimit(limit) { this.current.miterLimit = limit; } }, { key: "setStrokeAlpha", value: function setStrokeAlpha(strokeAlpha) { this.current.strokeAlpha = strokeAlpha; } }, { key: "setStrokeRGBColor", value: function setStrokeRGBColor(r, g, b) { this.current.strokeColor = _util.Util.makeCssRgb(r, g, b); } }, { key: "setFillAlpha", value: function setFillAlpha(fillAlpha) { this.current.fillAlpha = fillAlpha; } }, { key: "setFillRGBColor", value: function setFillRGBColor(r, g, b) { this.current.fillColor = _util.Util.makeCssRgb(r, g, b); this.current.tspan = this.svgFactory.createElement("svg:tspan"); this.current.xcoords = []; this.current.ycoords = []; } }, { key: "setStrokeColorN", value: function setStrokeColorN(args) { this.current.strokeColor = this._makeColorN_Pattern(args); } }, { key: "setFillColorN", value: function setFillColorN(args) { this.current.fillColor = this._makeColorN_Pattern(args); } }, { key: "shadingFill", value: function shadingFill(args) { var width = this.viewport.width; var height = this.viewport.height; var inv = _util.Util.inverseTransform(this.transformMatrix); var bl = _util.Util.applyTransform([0, 0], inv); var br = _util.Util.applyTransform([0, height], inv); var ul = _util.Util.applyTransform([width, 0], inv); var ur = _util.Util.applyTransform([width, height], inv); var x0 = Math.min(bl[0], br[0], ul[0], ur[0]); var y0 = Math.min(bl[1], br[1], ul[1], ur[1]); var x1 = Math.max(bl[0], br[0], ul[0], ur[0]); var y1 = Math.max(bl[1], br[1], ul[1], ur[1]); var rect = this.svgFactory.createElement("svg:rect"); rect.setAttributeNS(null, "x", x0); rect.setAttributeNS(null, "y", y0); rect.setAttributeNS(null, "width", x1 - x0); rect.setAttributeNS(null, "height", y1 - y0); rect.setAttributeNS(null, "fill", this._makeShadingPattern(args)); if (this.current.fillAlpha < 1) { rect.setAttributeNS(null, "fill-opacity", this.current.fillAlpha); } this._ensureTransformGroup().appendChild(rect); } }, { key: "_makeColorN_Pattern", value: function _makeColorN_Pattern(args) { if (args[0] === "TilingPattern") { return this._makeTilingPattern(args); } return this._makeShadingPattern(args); } }, { key: "_makeTilingPattern", value: function _makeTilingPattern(args) { var color = args[1]; var operatorList = args[2]; var matrix = args[3] || _util.IDENTITY_MATRIX; var _args$ = _slicedToArray(args[4], 4), x0 = _args$[0], y0 = _args$[1], x1 = _args$[2], y1 = _args$[3]; var xstep = args[5]; var ystep = args[6]; var paintType = args[7]; var tilingId = "shading".concat(shadingCount++); var _Util$applyTransform = _util.Util.applyTransform([x0, y0], matrix), _Util$applyTransform2 = _slicedToArray(_Util$applyTransform, 2), tx0 = _Util$applyTransform2[0], ty0 = _Util$applyTransform2[1]; var _Util$applyTransform3 = _util.Util.applyTransform([x1, y1], matrix), _Util$applyTransform4 = _slicedToArray(_Util$applyTransform3, 2), tx1 = _Util$applyTransform4[0], ty1 = _Util$applyTransform4[1]; var _Util$singularValueDe = _util.Util.singularValueDecompose2dScale(matrix), _Util$singularValueDe2 = _slicedToArray(_Util$singularValueDe, 2), xscale = _Util$singularValueDe2[0], yscale = _Util$singularValueDe2[1]; var txstep = xstep * xscale; var tystep = ystep * yscale; var tiling = this.svgFactory.createElement("svg:pattern"); tiling.setAttributeNS(null, "id", tilingId); tiling.setAttributeNS(null, "patternUnits", "userSpaceOnUse"); tiling.setAttributeNS(null, "width", txstep); tiling.setAttributeNS(null, "height", tystep); tiling.setAttributeNS(null, "x", "".concat(tx0)); tiling.setAttributeNS(null, "y", "".concat(ty0)); var svg = this.svg; var transformMatrix = this.transformMatrix; var fillColor = this.current.fillColor; var strokeColor = this.current.strokeColor; var bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0); this.svg = bbox; this.transformMatrix = matrix; if (paintType === 2) { var cssColor = _util.Util.makeCssRgb.apply(_util.Util, _toConsumableArray(color)); this.current.fillColor = cssColor; this.current.strokeColor = cssColor; } this.executeOpTree(this.convertOpList(operatorList)); this.svg = svg; this.transformMatrix = transformMatrix; this.current.fillColor = fillColor; this.current.strokeColor = strokeColor; tiling.appendChild(bbox.childNodes[0]); this.defs.appendChild(tiling); return "url(#".concat(tilingId, ")"); } }, { key: "_makeShadingPattern", value: function _makeShadingPattern(args) { switch (args[0]) { case "RadialAxial": var shadingId = "shading".concat(shadingCount++); var colorStops = args[3]; var gradient; switch (args[1]) { case "axial": var point0 = args[4]; var point1 = args[5]; gradient = this.svgFactory.createElement("svg:linearGradient"); gradient.setAttributeNS(null, "id", shadingId); gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"); gradient.setAttributeNS(null, "x1", point0[0]); gradient.setAttributeNS(null, "y1", point0[1]); gradient.setAttributeNS(null, "x2", point1[0]); gradient.setAttributeNS(null, "y2", point1[1]); break; case "radial": var focalPoint = args[4]; var circlePoint = args[5]; var focalRadius = args[6]; var circleRadius = args[7]; gradient = this.svgFactory.createElement("svg:radialGradient"); gradient.setAttributeNS(null, "id", shadingId); gradient.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"); gradient.setAttributeNS(null, "cx", circlePoint[0]); gradient.setAttributeNS(null, "cy", circlePoint[1]); gradient.setAttributeNS(null, "r", circleRadius); gradient.setAttributeNS(null, "fx", focalPoint[0]); gradient.setAttributeNS(null, "fy", focalPoint[1]); gradient.setAttributeNS(null, "fr", focalRadius); break; default: throw new Error("Unknown RadialAxial type: ".concat(args[1])); } var _iterator5 = _createForOfIteratorHelper(colorStops), _step5; try { for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) { var colorStop = _step5.value; var stop = this.svgFactory.createElement("svg:stop"); stop.setAttributeNS(null, "offset", colorStop[0]); stop.setAttributeNS(null, "stop-color", colorStop[1]); gradient.appendChild(stop); } } catch (err) { _iterator5.e(err); } finally { _iterator5.f(); } this.defs.appendChild(gradient); return "url(#".concat(shadingId, ")"); case "Mesh": (0, _util.warn)("Unimplemented pattern Mesh"); return null; case "Dummy": return "hotpink"; default: throw new Error("Unknown IR type: ".concat(args[0])); } } }, { key: "setDash", value: function setDash(dashArray, dashPhase) { this.current.dashArray = dashArray; this.current.dashPhase = dashPhase; } }, { key: "constructPath", value: function constructPath(ops, args) { var current = this.current; var x = current.x, y = current.y; var d = []; var j = 0; var _iterator6 = _createForOfIteratorHelper(ops), _step6; try { for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) { var op = _step6.value; switch (op | 0) { case _util.OPS.rectangle: x = args[j++]; y = args[j++]; var width = args[j++]; var height = args[j++]; var xw = x + width; var yh = y + height; d.push("M", pf(x), pf(y), "L", pf(xw), pf(y), "L", pf(xw), pf(yh), "L", pf(x), pf(yh), "Z"); break; case _util.OPS.moveTo: x = args[j++]; y = args[j++]; d.push("M", pf(x), pf(y)); break; case _util.OPS.lineTo: x = args[j++]; y = args[j++]; d.push("L", pf(x), pf(y)); break; case _util.OPS.curveTo: x = args[j + 4]; y = args[j + 5]; d.push("C", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y)); j += 6; break; case _util.OPS.curveTo2: d.push("C", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3])); x = args[j + 2]; y = args[j + 3]; j += 4; break; case _util.OPS.curveTo3: x = args[j + 2]; y = args[j + 3]; d.push("C", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y)); j += 4; break; case _util.OPS.closePath: d.push("Z"); break; } } } catch (err) { _iterator6.e(err); } finally { _iterator6.f(); } d = d.join(" "); if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) { d = current.path.getAttributeNS(null, "d") + d; } else { current.path = this.svgFactory.createElement("svg:path"); this._ensureTransformGroup().appendChild(current.path); } current.path.setAttributeNS(null, "d", d); current.path.setAttributeNS(null, "fill", "none"); current.element = current.path; current.setCurrentPoint(x, y); } }, { key: "endPath", value: function endPath() { var current = this.current; current.path = null; if (!this.pendingClip) { return; } if (!current.element) { this.pendingClip = null; return; } var clipId = "clippath".concat(clipCount++); var clipPath = this.svgFactory.createElement("svg:clipPath"); clipPath.setAttributeNS(null, "id", clipId); clipPath.setAttributeNS(null, "transform", pm(this.transformMatrix)); var clipElement = current.element.cloneNode(true); if (this.pendingClip === "evenodd") { clipElement.setAttributeNS(null, "clip-rule", "evenodd"); } else { clipElement.setAttributeNS(null, "clip-rule", "nonzero"); } this.pendingClip = null; clipPath.appendChild(clipElement); this.defs.appendChild(clipPath); if (current.activeClipUrl) { current.clipGroup = null; this.extraStack.forEach(function (prev) { prev.clipGroup = null; }); clipPath.setAttributeNS(null, "clip-path", current.activeClipUrl); } current.activeClipUrl = "url(#".concat(clipId, ")"); this.tgrp = null; } }, { key: "clip", value: function clip(type) { this.pendingClip = type; } }, { key: "closePath", value: function closePath() { var current = this.current; if (current.path) { var d = "".concat(current.path.getAttributeNS(null, "d"), "Z"); current.path.setAttributeNS(null, "d", d); } } }, { key: "setLeading", value: function setLeading(leading) { this.current.leading = -leading; } }, { key: "setTextRise", value: function setTextRise(textRise) { this.current.textRise = textRise; } }, { key: "setTextRenderingMode", value: function setTextRenderingMode(textRenderingMode) { this.current.textRenderingMode = textRenderingMode; } }, { key: "setHScale", value: function setHScale(scale) { this.current.textHScale = scale / 100; } }, { key: "setRenderingIntent", value: function setRenderingIntent(intent) {} }, { key: "setFlatness", value: function setFlatness(flatness) {} }, { key: "setGState", value: function setGState(states) { var _iterator7 = _createForOfIteratorHelper(states), _step7; try { for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) { var _step7$value = _slicedToArray(_step7.value, 2), key = _step7$value[0], value = _step7$value[1]; switch (key) { case "LW": this.setLineWidth(value); break; case "LC": this.setLineCap(value); break; case "LJ": this.setLineJoin(value); break; case "ML": this.setMiterLimit(value); break; case "D": this.setDash(value[0], value[1]); break; case "RI": this.setRenderingIntent(value); break; case "FL": this.setFlatness(value); break; case "Font": this.setFont(value); break; case "CA": this.setStrokeAlpha(value); break; case "ca": this.setFillAlpha(value); break; default: (0, _util.warn)("Unimplemented graphic state operator ".concat(key)); break; } } } catch (err) { _iterator7.e(err); } finally { _iterator7.f(); } } }, { key: "fill", value: function fill() { var current = this.current; if (current.element) { current.element.setAttributeNS(null, "fill", current.fillColor); current.element.setAttributeNS(null, "fill-opacity", current.fillAlpha); this.endPath(); } } }, { key: "stroke", value: function stroke() { var current = this.current; if (current.element) { this._setStrokeAttributes(current.element); current.element.setAttributeNS(null, "fill", "none"); this.endPath(); } } }, { key: "_setStrokeAttributes", value: function _setStrokeAttributes(element) { var lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1; var current = this.current; var dashArray = current.dashArray; if (lineWidthScale !== 1 && dashArray.length > 0) { dashArray = dashArray.map(function (value) { return lineWidthScale * value; }); } element.setAttributeNS(null, "stroke", current.strokeColor); element.setAttributeNS(null, "stroke-opacity", current.strokeAlpha); element.setAttributeNS(null, "stroke-miterlimit", pf(current.miterLimit)); element.setAttributeNS(null, "stroke-linecap", current.lineCap); element.setAttributeNS(null, "stroke-linejoin", current.lineJoin); element.setAttributeNS(null, "stroke-width", pf(lineWidthScale * current.lineWidth) + "px"); element.setAttributeNS(null, "stroke-dasharray", dashArray.map(pf).join(" ")); element.setAttributeNS(null, "stroke-dashoffset", pf(lineWidthScale * current.dashPhase) + "px"); } }, { key: "eoFill", value: function eoFill() { if (this.current.element) { this.current.element.setAttributeNS(null, "fill-rule", "evenodd"); } this.fill(); } }, { key: "fillStroke", value: function fillStroke() { this.stroke(); this.fill(); } }, { key: "eoFillStroke", value: function eoFillStroke() { if (this.current.element) { this.current.element.setAttributeNS(null, "fill-rule", "evenodd"); } this.fillStroke(); } }, { key: "closeStroke", value: function closeStroke() { this.closePath(); this.stroke(); } }, { key: "closeFillStroke", value: function closeFillStroke() { this.closePath(); this.fillStroke(); } }, { key: "closeEOFillStroke", value: function closeEOFillStroke() { this.closePath(); this.eoFillStroke(); } }, { key: "paintSolidColorImageMask", value: function paintSolidColorImageMask() { var rect = this.svgFactory.createElement("svg:rect"); rect.setAttributeNS(null, "x", "0"); rect.setAttributeNS(null, "y", "0"); rect.setAttributeNS(null, "width", "1px"); rect.setAttributeNS(null, "height", "1px"); rect.setAttributeNS(null, "fill", this.current.fillColor); this._ensureTransformGroup().appendChild(rect); } }, { key: "paintImageXObject", value: function paintImageXObject(objId) { var imgData = this.objs.get(objId); if (!imgData) { (0, _util.warn)("Dependent image with object ID ".concat(objId, " is not ready yet")); return; } this.paintInlineImageXObject(imgData); } }, { key: "paintInlineImageXObject", value: function paintInlineImageXObject(imgData, mask) { var width = imgData.width; var height = imgData.height; var imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask); var cliprect = this.svgFactory.createElement("svg:rect"); cliprect.setAttributeNS(null, "x", "0"); cliprect.setAttributeNS(null, "y", "0"); cliprect.setAttributeNS(null, "width", pf(width)); cliprect.setAttributeNS(null, "height", pf(height)); this.current.element = cliprect; this.clip("nonzero"); var imgEl = this.svgFactory.createElement("svg:image"); imgEl.setAttributeNS(XLINK_NS, "xlink:href", imgSrc); imgEl.setAttributeNS(null, "x", "0"); imgEl.setAttributeNS(null, "y", pf(-height)); imgEl.setAttributeNS(null, "width", pf(width) + "px"); imgEl.setAttributeNS(null, "height", pf(height) + "px"); imgEl.setAttributeNS(null, "transform", "scale(".concat(pf(1 / width), " ").concat(pf(-1 / height), ")")); if (mask) { mask.appendChild(imgEl); } else { this._ensureTransformGroup().appendChild(imgEl); } } }, { key: "paintImageMaskXObject", value: function paintImageMaskXObject(imgData) { var current = this.current; var width = imgData.width; var height = imgData.height; var fillColor = current.fillColor; current.maskId = "mask".concat(maskCount++); var mask = this.svgFactory.createElement("svg:mask"); mask.setAttributeNS(null, "id", current.maskId); var rect = this.svgFactory.createElement("svg:rect"); rect.setAttributeNS(null, "x", "0"); rect.setAttributeNS(null, "y", "0"); rect.setAttributeNS(null, "width", pf(width)); rect.setAttributeNS(null, "height", pf(height)); rect.setAttributeNS(null, "fill", fillColor); rect.setAttributeNS(null, "mask", "url(#".concat(current.maskId, ")")); this.defs.appendChild(mask); this._ensureTransformGroup().appendChild(rect); this.paintInlineImageXObject(imgData, mask); } }, { key: "paintFormXObjectBegin", value: function paintFormXObjectBegin(matrix, bbox) { if (Array.isArray(matrix) && matrix.length === 6) { this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]); } if (bbox) { var width = bbox[2] - bbox[0]; var height = bbox[3] - bbox[1]; var cliprect = this.svgFactory.createElement("svg:rect"); cliprect.setAttributeNS(null, "x", bbox[0]); cliprect.setAttributeNS(null, "y", bbox[1]); cliprect.setAttributeNS(null, "width", pf(width)); cliprect.setAttributeNS(null, "height", pf(height)); this.current.element = cliprect; this.clip("nonzero"); this.endPath(); } } }, { key: "paintFormXObjectEnd", value: function paintFormXObjectEnd() {} }, { key: "_initialize", value: function _initialize(viewport) { var svg = this.svgFactory.create(viewport.width, viewport.height); var definitions = this.svgFactory.createElement("svg:defs"); svg.appendChild(definitions); this.defs = definitions; var rootGroup = this.svgFactory.createElement("svg:g"); rootGroup.setAttributeNS(null, "transform", pm(viewport.transform)); svg.appendChild(rootGroup); this.svg = rootGroup; return svg; } }, { key: "_ensureClipGroup", value: function _ensureClipGroup() { if (!this.current.clipGroup) { var clipGroup = this.svgFactory.createElement("svg:g"); clipGroup.setAttributeNS(null, "clip-path", this.current.activeClipUrl); this.svg.appendChild(clipGroup); this.current.clipGroup = clipGroup; } return this.current.clipGroup; } }, { key: "_ensureTransformGroup", value: function _ensureTransformGroup() { if (!this.tgrp) { this.tgrp = this.svgFactory.createElement("svg:g"); this.tgrp.setAttributeNS(null, "transform", pm(this.transformMatrix)); if (this.current.activeClipUrl) { this._ensureClipGroup().appendChild(this.tgrp); } else { this.svg.appendChild(this.tgrp); } } return this.tgrp; } }]); return SVGGraphics; }(); }
/***/ }),
/* 217 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFNodeStream = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2)); var _util = __w_pdfjs_require__(5); var _network_utils = __w_pdfjs_require__(218); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); } function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
; var fs = require("fs"); var http = require("http"); var https = require("https"); var url = require("url");
var fileUriRegex = /^file:\/\/\/[a-zA-Z]:\//;
function parseUrl(sourceUrl) { var parsedUrl = url.parse(sourceUrl); if (parsedUrl.protocol === "file:" || parsedUrl.host) { return parsedUrl; } if (/^[a-z]:[/\\]/i.test(sourceUrl)) {
return url.parse("file:///".concat(sourceUrl));
} if (!parsedUrl.host) { parsedUrl.protocol = "file:"; } return parsedUrl; }
var PDFNodeStream = /*#__PURE__*/function () {
function PDFNodeStream(source) { _classCallCheck(this, PDFNodeStream); this.source = source; this.url = parseUrl(source.url); this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:"; this.isFsUrl = this.url.protocol === "file:"; this.httpHeaders = this.isHttp && source.httpHeaders || {}; this._fullRequestReader = null; this._rangeRequestReaders = []; } _createClass(PDFNodeStream, [{ key: "getFullReader", value: function getFullReader() { (0, _util.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."); this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this); return this._fullRequestReader; } }, { key: "getRangeReader", value: function getRangeReader(start, end) { if (end <= this._progressiveDataLength) { return null; } var rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end); this._rangeRequestReaders.push(rangeReader); return rangeReader; } }, { key: "cancelAllRequests", value: function cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } var readers = this._rangeRequestReaders.slice(0); readers.forEach(function (reader) { reader.cancel(reason); }); } }, { key: "_progressiveDataLength", get: function get() { return this._fullRequestReader ? this._fullRequestReader._loaded : 0; } }]); return PDFNodeStream; }(); exports.PDFNodeStream = PDFNodeStream;
var BaseFullReader = /*#__PURE__*/function () {
function BaseFullReader(stream) { _classCallCheck(this, BaseFullReader); this._url = stream.url; this._done = false; this._storedError = null; this.onProgress = null; var source = stream.source; this._contentLength = source.length; this._loaded = 0; this._filename = null; this._disableRange = source.disableRange || false; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize && !this._disableRange) { this._disableRange = true; } this._isStreamingSupported = !source.disableStream; this._isRangeSupported = !source.disableRange; this._readableStream = null; this._readCapability = (0, _util.createPromiseCapability)(); this._headersCapability = (0, _util.createPromiseCapability)(); } _createClass(BaseFullReader, [{ key: "read", value: function () {
var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
var chunk, buffer; return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: _context.next = 2; return this._readCapability.promise; case 2: if (!this._done) { _context.next = 4; break; } return _context.abrupt("return", { value: undefined, done: true }); case 4: if (!this._storedError) { _context.next = 6; break; } throw this._storedError; case 6: chunk = this._readableStream.read(); if (!(chunk === null)) { _context.next = 10; break; } this._readCapability = (0, _util.createPromiseCapability)(); return _context.abrupt("return", this.read()); case 10: this._loaded += chunk.length; if (this.onProgress) { this.onProgress({ loaded: this._loaded, total: this._contentLength }); } buffer = new Uint8Array(chunk).buffer; return _context.abrupt("return", { value: buffer, done: false }); case 14: case "end": return _context.stop(); } } }, _callee, this); })); function read() { return _read.apply(this, arguments); } return read; }() }, { key: "cancel", value: function cancel(reason) { if (!this._readableStream) { this._error(reason); return; } this._readableStream.destroy(reason); } }, { key: "_error", value: function _error(reason) { this._storedError = reason; this._readCapability.resolve(); } }, { key: "_setReadableStream", value: function _setReadableStream(readableStream) { var _this = this; this._readableStream = readableStream; readableStream.on("readable", function () { _this._readCapability.resolve(); }); readableStream.on("end", function () { readableStream.destroy(); _this._done = true; _this._readCapability.resolve(); }); readableStream.on("error", function (reason) { _this._error(reason); }); if (!this._isStreamingSupported && this._isRangeSupported) { this._error(new _util.AbortException("streaming is disabled")); } if (this._storedError) { this._readableStream.destroy(this._storedError); } } }, { key: "headersReady", get: function get() { return this._headersCapability.promise; } }, { key: "filename", get: function get() { return this._filename; } }, { key: "contentLength", get: function get() { return this._contentLength; } }, { key: "isRangeSupported", get: function get() { return this._isRangeSupported; } }, { key: "isStreamingSupported", get: function get() { return this._isStreamingSupported; } }]); return BaseFullReader; }();
var BaseRangeReader = /*#__PURE__*/function () {
function BaseRangeReader(stream) { _classCallCheck(this, BaseRangeReader); this._url = stream.url; this._done = false; this._storedError = null; this.onProgress = null; this._loaded = 0; this._readableStream = null; this._readCapability = (0, _util.createPromiseCapability)(); var source = stream.source; this._isStreamingSupported = !source.disableStream; } _createClass(BaseRangeReader, [{ key: "read", value: function () {
var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
var chunk, buffer; return _regenerator["default"].wrap(function _callee2$(_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0: _context2.next = 2; return this._readCapability.promise; case 2: if (!this._done) { _context2.next = 4; break; } return _context2.abrupt("return", { value: undefined, done: true }); case 4: if (!this._storedError) { _context2.next = 6; break; } throw this._storedError; case 6: chunk = this._readableStream.read(); if (!(chunk === null)) { _context2.next = 10; break; } this._readCapability = (0, _util.createPromiseCapability)(); return _context2.abrupt("return", this.read()); case 10: this._loaded += chunk.length; if (this.onProgress) { this.onProgress({ loaded: this._loaded }); } buffer = new Uint8Array(chunk).buffer; return _context2.abrupt("return", { value: buffer, done: false }); case 14: case "end": return _context2.stop(); } } }, _callee2, this); })); function read() { return _read2.apply(this, arguments); } return read; }() }, { key: "cancel", value: function cancel(reason) { if (!this._readableStream) { this._error(reason); return; } this._readableStream.destroy(reason); } }, { key: "_error", value: function _error(reason) { this._storedError = reason; this._readCapability.resolve(); } }, { key: "_setReadableStream", value: function _setReadableStream(readableStream) { var _this2 = this; this._readableStream = readableStream; readableStream.on("readable", function () { _this2._readCapability.resolve(); }); readableStream.on("end", function () { readableStream.destroy(); _this2._done = true; _this2._readCapability.resolve(); }); readableStream.on("error", function (reason) { _this2._error(reason); }); if (this._storedError) { this._readableStream.destroy(this._storedError); } } }, { key: "isStreamingSupported", get: function get() { return this._isStreamingSupported; } }]); return BaseRangeReader; }(); function createRequestOptions(parsedUrl, headers) { return { protocol: parsedUrl.protocol, auth: parsedUrl.auth, host: parsedUrl.hostname, port: parsedUrl.port, path: parsedUrl.path, method: "GET", headers: headers }; }
var PDFNodeStreamFullReader = /*#__PURE__*/function (_BaseFullReader) {
_inherits(PDFNodeStreamFullReader, _BaseFullReader); var _super = _createSuper(PDFNodeStreamFullReader); function PDFNodeStreamFullReader(stream) { var _this3; _classCallCheck(this, PDFNodeStreamFullReader); _this3 = _super.call(this, stream); var handleResponse = function handleResponse(response) { if (response.statusCode === 404) { var error = new _util.MissingPDFException("Missing PDF \"".concat(_this3._url, "\".")); _this3._storedError = error; _this3._headersCapability.reject(error); return; } _this3._headersCapability.resolve(); _this3._setReadableStream(response); var getResponseHeader = function getResponseHeader(name) { return _this3._readableStream.headers[name.toLowerCase()]; }; var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader: getResponseHeader, isHttp: stream.isHttp, rangeChunkSize: _this3._rangeChunkSize, disableRange: _this3._disableRange }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength; _this3._isRangeSupported = allowRangeRequests; _this3._contentLength = suggestedLength || _this3._contentLength; _this3._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); }; _this3._request = null; if (_this3._url.protocol === "http:") { _this3._request = http.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse); } else { _this3._request = https.request(createRequestOptions(_this3._url, stream.httpHeaders), handleResponse); } _this3._request.on("error", function (reason) { _this3._storedError = reason; _this3._headersCapability.reject(reason); }); _this3._request.end(); return _this3; } return PDFNodeStreamFullReader; }(BaseFullReader);
var PDFNodeStreamRangeReader = /*#__PURE__*/function (_BaseRangeReader) {
_inherits(PDFNodeStreamRangeReader, _BaseRangeReader); var _super2 = _createSuper(PDFNodeStreamRangeReader); function PDFNodeStreamRangeReader(stream, start, end) { var _this4; _classCallCheck(this, PDFNodeStreamRangeReader); _this4 = _super2.call(this, stream); _this4._httpHeaders = {}; for (var property in stream.httpHeaders) { var value = stream.httpHeaders[property]; if (typeof value === "undefined") { continue; } _this4._httpHeaders[property] = value; } _this4._httpHeaders.Range = "bytes=".concat(start, "-").concat(end - 1); var handleResponse = function handleResponse(response) { if (response.statusCode === 404) { var error = new _util.MissingPDFException("Missing PDF \"".concat(_this4._url, "\".")); _this4._storedError = error; return; } _this4._setReadableStream(response); }; _this4._request = null; if (_this4._url.protocol === "http:") { _this4._request = http.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse); } else { _this4._request = https.request(createRequestOptions(_this4._url, _this4._httpHeaders), handleResponse); } _this4._request.on("error", function (reason) { _this4._storedError = reason; }); _this4._request.end(); return _this4; } return PDFNodeStreamRangeReader; }(BaseRangeReader);
var PDFNodeStreamFsFullReader = /*#__PURE__*/function (_BaseFullReader2) {
_inherits(PDFNodeStreamFsFullReader, _BaseFullReader2); var _super3 = _createSuper(PDFNodeStreamFsFullReader); function PDFNodeStreamFsFullReader(stream) { var _this5; _classCallCheck(this, PDFNodeStreamFsFullReader); _this5 = _super3.call(this, stream); var path = decodeURIComponent(_this5._url.path); if (fileUriRegex.test(_this5._url.href)) {
path = path.replace(/^\//, "");
} fs.lstat(path, function (error, stat) { if (error) { if (error.code === "ENOENT") { error = new _util.MissingPDFException("Missing PDF \"".concat(path, "\".")); } _this5._storedError = error; _this5._headersCapability.reject(error); return; } _this5._contentLength = stat.size; _this5._setReadableStream(fs.createReadStream(path)); _this5._headersCapability.resolve(); }); return _this5; } return PDFNodeStreamFsFullReader; }(BaseFullReader);
var PDFNodeStreamFsRangeReader = /*#__PURE__*/function (_BaseRangeReader2) {
_inherits(PDFNodeStreamFsRangeReader, _BaseRangeReader2); var _super4 = _createSuper(PDFNodeStreamFsRangeReader); function PDFNodeStreamFsRangeReader(stream, start, end) { var _this6; _classCallCheck(this, PDFNodeStreamFsRangeReader); _this6 = _super4.call(this, stream); var path = decodeURIComponent(_this6._url.path); if (fileUriRegex.test(_this6._url.href)) {
path = path.replace(/^\//, "");
} _this6._setReadableStream(fs.createReadStream(path, { start: start, end: end - 1 })); return _this6; } return PDFNodeStreamFsRangeReader; }(BaseRangeReader);
/***/ }),
/* 218 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.createResponseStatusError = createResponseStatusError; exports.extractFilenameFromHeader = extractFilenameFromHeader; exports.validateRangeRequestCapabilities = validateRangeRequestCapabilities; exports.validateResponseStatus = validateResponseStatus; var _util = __w_pdfjs_require__(5); var _content_disposition = __w_pdfjs_require__(219); function validateRangeRequestCapabilities(_ref) { var getResponseHeader = _ref.getResponseHeader, isHttp = _ref.isHttp, rangeChunkSize = _ref.rangeChunkSize, disableRange = _ref.disableRange; (0, _util.assert)(rangeChunkSize > 0, "Range chunk size must be larger than zero"); var returnValues = { allowRangeRequests: false, suggestedLength: undefined }; var length = parseInt(getResponseHeader("Content-Length"), 10); if (!Number.isInteger(length)) { return returnValues; } returnValues.suggestedLength = length; if (length <= 2 * rangeChunkSize) { return returnValues; } if (disableRange || !isHttp) { return returnValues; } if (getResponseHeader("Accept-Ranges") !== "bytes") { return returnValues; } var contentEncoding = getResponseHeader("Content-Encoding") || "identity"; if (contentEncoding !== "identity") { return returnValues; } returnValues.allowRangeRequests = true; return returnValues; } function extractFilenameFromHeader(getResponseHeader) { var contentDisposition = getResponseHeader("Content-Disposition"); if (contentDisposition) { var filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition); if (filename.includes("%")) { try { filename = decodeURIComponent(filename); } catch (ex) {} } if (/\.pdf$/i.test(filename)) { return filename; } } return null; } function createResponseStatusError(status, url) { if (status === 404 || status === 0 && url.startsWith("file:")) { return new _util.MissingPDFException('Missing PDF "' + url + '".'); } return new _util.UnexpectedResponseException("Unexpected server response (" + status + ') while retrieving PDF "' + url + '".', status); } function validateResponseStatus(status) { return status === 200 || status === 206; }
/***/ }),
/* 219 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader; function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } function getFilenameFromContentDispositionHeader(contentDisposition) { var needsEncodingFixup = true; var tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition); if (tmp) { tmp = tmp[1]; var filename = rfc2616unquote(tmp); filename = unescape(filename); filename = rfc5987decode(filename); filename = rfc2047decode(filename); return fixupEncoding(filename); } tmp = rfc2231getparam(contentDisposition); if (tmp) { var _filename = rfc2047decode(tmp); return fixupEncoding(_filename); } tmp = toParamRegExp("filename", "i").exec(contentDisposition); if (tmp) { tmp = tmp[1]; var _filename2 = rfc2616unquote(tmp); _filename2 = rfc2047decode(_filename2); return fixupEncoding(_filename2); } function toParamRegExp(attributePattern, flags) { return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags); } function textdecode(encoding, value) { if (encoding) { if (!/^[\x00-\xFF]+$/.test(value)) { return value; } try { var decoder = new TextDecoder(encoding, { fatal: true }); var bytes = Array.from(value, function (ch) { return ch.charCodeAt(0) & 0xff; }); value = decoder.decode(new Uint8Array(bytes)); needsEncodingFixup = false; } catch (e) { if (/^utf-?8$/i.test(encoding)) { try { value = decodeURIComponent(escape(value)); needsEncodingFixup = false; } catch (err) {} } } } return value; } function fixupEncoding(value) { if (needsEncodingFixup && /[\x80-\xff]/.test(value)) { value = textdecode("utf-8", value); if (needsEncodingFixup) { value = textdecode("iso-8859-1", value); } } return value; } function rfc2231getparam(contentDispositionStr) { var matches = []; var match; var iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig"); while ((match = iter.exec(contentDispositionStr)) !== null) { var _match = match, _match2 = _slicedToArray(_match, 4), n = _match2[1], quot = _match2[2], part = _match2[3]; n = parseInt(n, 10); if (n in matches) { if (n === 0) { break; } continue; } matches[n] = [quot, part]; } var parts = []; for (var _n2 = 0; _n2 < matches.length; ++_n2) { if (!(_n2 in matches)) { break; } var _matches$_n = _slicedToArray(matches[_n2], 2), _quot = _matches$_n[0], _part = _matches$_n[1]; _part = rfc2616unquote(_part); if (_quot) { _part = unescape(_part); if (_n2 === 0) { _part = rfc5987decode(_part); } } parts.push(_part); } return parts.join(""); } function rfc2616unquote(value) { if (value.startsWith('"')) { var parts = value.slice(1).split('\\"'); for (var i = 0; i < parts.length; ++i) { var quotindex = parts[i].indexOf('"'); if (quotindex !== -1) { parts[i] = parts[i].slice(0, quotindex); parts.length = i + 1; } parts[i] = parts[i].replace(/\\(.)/g, "$1"); } value = parts.join('"'); } return value; } function rfc5987decode(extvalue) { var encodingend = extvalue.indexOf("'"); if (encodingend === -1) { return extvalue; } var encoding = extvalue.slice(0, encodingend); var langvalue = extvalue.slice(encodingend + 1); var value = langvalue.replace(/^[^']*'/, ""); return textdecode(encoding, value); } function rfc2047decode(value) { if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) { return value; } return value.replace(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) { if (encoding === "q" || encoding === "Q") { text = text.replace(/_/g, " "); text = text.replace(/=([0-9a-fA-F]{2})/g, function (match, hex) { return String.fromCharCode(parseInt(hex, 16)); }); return textdecode(charset, text); } try { text = atob(text); } catch (e) {} return textdecode(charset, text); }); } return ""; }
/***/ }),
/* 220 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFNetworkStream = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2)); var _util = __w_pdfjs_require__(5); var _network_utils = __w_pdfjs_require__(218); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
; var OK_RESPONSE = 200; var PARTIAL_CONTENT_RESPONSE = 206; function getArrayBuffer(xhr) { var data = xhr.response; if (typeof data !== "string") { return data; } var array = (0, _util.stringToBytes)(data); return array.buffer; }
var NetworkManager = /*#__PURE__*/function () {
function NetworkManager(url, args) { _classCallCheck(this, NetworkManager); this.url = url; args = args || {}; this.isHttp = /^https?:/i.test(url); this.httpHeaders = this.isHttp && args.httpHeaders || {}; this.withCredentials = args.withCredentials || false; this.getXhr = args.getXhr || function NetworkManager_getXhr() { return new XMLHttpRequest(); }; this.currXhrId = 0; this.pendingRequests = Object.create(null); } _createClass(NetworkManager, [{ key: "requestRange", value: function requestRange(begin, end, listeners) { var args = { begin: begin, end: end }; for (var prop in listeners) { args[prop] = listeners[prop]; } return this.request(args); } }, { key: "requestFull", value: function requestFull(listeners) { return this.request(listeners); } }, { key: "request", value: function request(args) { var xhr = this.getXhr(); var xhrId = this.currXhrId++; var pendingRequest = this.pendingRequests[xhrId] = { xhr: xhr }; xhr.open("GET", this.url); xhr.withCredentials = this.withCredentials; for (var property in this.httpHeaders) { var value = this.httpHeaders[property]; if (typeof value === "undefined") { continue; } xhr.setRequestHeader(property, value); } if (this.isHttp && "begin" in args && "end" in args) { xhr.setRequestHeader("Range", "bytes=".concat(args.begin, "-").concat(args.end - 1)); pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE; } else { pendingRequest.expectedStatus = OK_RESPONSE; } xhr.responseType = "arraybuffer"; if (args.onError) { xhr.onerror = function (evt) { args.onError(xhr.status); }; } xhr.onreadystatechange = this.onStateChange.bind(this, xhrId); xhr.onprogress = this.onProgress.bind(this, xhrId); pendingRequest.onHeadersReceived = args.onHeadersReceived; pendingRequest.onDone = args.onDone; pendingRequest.onError = args.onError; pendingRequest.onProgress = args.onProgress; xhr.send(null); return xhrId; } }, { key: "onProgress", value: function onProgress(xhrId, evt) { var pendingRequest = this.pendingRequests[xhrId]; if (!pendingRequest) { return; } if (pendingRequest.onProgress) { pendingRequest.onProgress(evt); } } }, { key: "onStateChange", value: function onStateChange(xhrId, evt) { var pendingRequest = this.pendingRequests[xhrId]; if (!pendingRequest) { return; } var xhr = pendingRequest.xhr; if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) { pendingRequest.onHeadersReceived(); delete pendingRequest.onHeadersReceived; } if (xhr.readyState !== 4) { return; } if (!(xhrId in this.pendingRequests)) { return; } delete this.pendingRequests[xhrId]; if (xhr.status === 0 && this.isHttp) { if (pendingRequest.onError) { pendingRequest.onError(xhr.status); } return; } var xhrStatus = xhr.status || OK_RESPONSE; var ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE; if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) { if (pendingRequest.onError) { pendingRequest.onError(xhr.status); } return; } var chunk = getArrayBuffer(xhr); if (xhrStatus === PARTIAL_CONTENT_RESPONSE) { var rangeHeader = xhr.getResponseHeader("Content-Range"); var matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader); pendingRequest.onDone({ begin: parseInt(matches[1], 10), chunk: chunk }); } else if (chunk) { pendingRequest.onDone({ begin: 0, chunk: chunk }); } else if (pendingRequest.onError) { pendingRequest.onError(xhr.status); } } }, { key: "hasPendingRequests", value: function hasPendingRequests() { for (var xhrId in this.pendingRequests) { return true; } return false; } }, { key: "getRequestXhr", value: function getRequestXhr(xhrId) { return this.pendingRequests[xhrId].xhr; } }, { key: "isPendingRequest", value: function isPendingRequest(xhrId) { return xhrId in this.pendingRequests; } }, { key: "abortAllRequests", value: function abortAllRequests() { for (var xhrId in this.pendingRequests) { this.abortRequest(xhrId | 0); } } }, { key: "abortRequest", value: function abortRequest(xhrId) { var xhr = this.pendingRequests[xhrId].xhr; delete this.pendingRequests[xhrId]; xhr.abort(); } }]); return NetworkManager; }();
var PDFNetworkStream = /*#__PURE__*/function () {
function PDFNetworkStream(source) { _classCallCheck(this, PDFNetworkStream); this._source = source; this._manager = new NetworkManager(source.url, { httpHeaders: source.httpHeaders, withCredentials: source.withCredentials }); this._rangeChunkSize = source.rangeChunkSize; this._fullRequestReader = null; this._rangeRequestReaders = []; } _createClass(PDFNetworkStream, [{ key: "_onRangeRequestReaderClosed", value: function _onRangeRequestReaderClosed(reader) { var i = this._rangeRequestReaders.indexOf(reader); if (i >= 0) { this._rangeRequestReaders.splice(i, 1); } } }, { key: "getFullReader", value: function getFullReader() { (0, _util.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."); this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source); return this._fullRequestReader; } }, { key: "getRangeReader", value: function getRangeReader(begin, end) { var reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end); reader.onClosed = this._onRangeRequestReaderClosed.bind(this); this._rangeRequestReaders.push(reader); return reader; } }, { key: "cancelAllRequests", value: function cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } var readers = this._rangeRequestReaders.slice(0); readers.forEach(function (reader) { reader.cancel(reason); }); } }]); return PDFNetworkStream; }(); exports.PDFNetworkStream = PDFNetworkStream;
var PDFNetworkStreamFullRequestReader = /*#__PURE__*/function () {
function PDFNetworkStreamFullRequestReader(manager, source) { _classCallCheck(this, PDFNetworkStreamFullRequestReader); this._manager = manager; var args = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = source.url; this._fullRequestId = manager.requestFull(args); this._headersReceivedCapability = (0, _util.createPromiseCapability)(); this._disableRange = source.disableRange || false; this._contentLength = source.length; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize && !this._disableRange) { this._disableRange = true; } this._isStreamingSupported = false; this._isRangeSupported = false; this._cachedChunks = []; this._requests = []; this._done = false; this._storedError = undefined; this._filename = null; this.onProgress = null; } _createClass(PDFNetworkStreamFullRequestReader, [{ key: "_onHeadersReceived", value: function _onHeadersReceived() { var fullRequestXhrId = this._fullRequestId; var fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId); var getResponseHeader = function getResponseHeader(name) { return fullRequestXhr.getResponseHeader(name); }; var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader: getResponseHeader, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength; if (allowRangeRequests) { this._isRangeSupported = true; } this._contentLength = suggestedLength || this._contentLength; this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); if (this._isRangeSupported) { this._manager.abortRequest(fullRequestXhrId); } this._headersReceivedCapability.resolve(); } }, { key: "_onDone", value: function _onDone(args) { if (args) { if (this._requests.length > 0) { var requestCapability = this._requests.shift(); requestCapability.resolve({ value: args.chunk, done: false }); } else { this._cachedChunks.push(args.chunk); } } this._done = true; if (this._cachedChunks.length > 0) { return; } this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; } }, { key: "_onError", value: function _onError(status) { var url = this._url; var exception = (0, _network_utils.createResponseStatusError)(status, url); this._storedError = exception; this._headersReceivedCapability.reject(exception); this._requests.forEach(function (requestCapability) { requestCapability.reject(exception); }); this._requests = []; this._cachedChunks = []; } }, { key: "_onProgress", value: function _onProgress(data) { if (this.onProgress) { this.onProgress({ loaded: data.loaded, total: data.lengthComputable ? data.total : this._contentLength }); } } }, { key: "read", value: function () {
var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
var chunk, requestCapability; return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: if (!this._storedError) { _context.next = 2; break; } throw this._storedError; case 2: if (!(this._cachedChunks.length > 0)) { _context.next = 5; break; } chunk = this._cachedChunks.shift(); return _context.abrupt("return", { value: chunk, done: false }); case 5: if (!this._done) { _context.next = 7; break; } return _context.abrupt("return", { value: undefined, done: true }); case 7: requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return _context.abrupt("return", requestCapability.promise); case 10: case "end": return _context.stop(); } } }, _callee, this); })); function read() { return _read.apply(this, arguments); } return read; }() }, { key: "cancel", value: function cancel(reason) { this._done = true; this._headersReceivedCapability.reject(reason); this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; if (this._manager.isPendingRequest(this._fullRequestId)) { this._manager.abortRequest(this._fullRequestId); } this._fullRequestReader = null; } }, { key: "filename", get: function get() { return this._filename; } }, { key: "isRangeSupported", get: function get() { return this._isRangeSupported; } }, { key: "isStreamingSupported", get: function get() { return this._isStreamingSupported; } }, { key: "contentLength", get: function get() { return this._contentLength; } }, { key: "headersReady", get: function get() { return this._headersReceivedCapability.promise; } }]); return PDFNetworkStreamFullRequestReader; }();
var PDFNetworkStreamRangeRequestReader = /*#__PURE__*/function () {
function PDFNetworkStreamRangeRequestReader(manager, begin, end) { _classCallCheck(this, PDFNetworkStreamRangeRequestReader); this._manager = manager; var args = { onDone: this._onDone.bind(this), onProgress: this._onProgress.bind(this) }; this._requestId = manager.requestRange(begin, end, args); this._requests = []; this._queuedChunk = null; this._done = false; this.onProgress = null; this.onClosed = null; } _createClass(PDFNetworkStreamRangeRequestReader, [{ key: "_close", value: function _close() { if (this.onClosed) { this.onClosed(this); } } }, { key: "_onDone", value: function _onDone(data) { var chunk = data.chunk; if (this._requests.length > 0) { var requestCapability = this._requests.shift(); requestCapability.resolve({ value: chunk, done: false }); } else { this._queuedChunk = chunk; } this._done = true; this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; this._close(); } }, { key: "_onProgress", value: function _onProgress(evt) { if (!this.isStreamingSupported && this.onProgress) { this.onProgress({ loaded: evt.loaded }); } } }, { key: "read", value: function () {
var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
var chunk, requestCapability; return _regenerator["default"].wrap(function _callee2$(_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0: if (!(this._queuedChunk !== null)) { _context2.next = 4; break; } chunk = this._queuedChunk; this._queuedChunk = null; return _context2.abrupt("return", { value: chunk, done: false }); case 4: if (!this._done) { _context2.next = 6; break; } return _context2.abrupt("return", { value: undefined, done: true }); case 6: requestCapability = (0, _util.createPromiseCapability)(); this._requests.push(requestCapability); return _context2.abrupt("return", requestCapability.promise); case 9: case "end": return _context2.stop(); } } }, _callee2, this); })); function read() { return _read2.apply(this, arguments); } return read; }() }, { key: "cancel", value: function cancel(reason) { this._done = true; this._requests.forEach(function (requestCapability) { requestCapability.resolve({ value: undefined, done: true }); }); this._requests = []; if (this._manager.isPendingRequest(this._requestId)) { this._manager.abortRequest(this._requestId); } this._close(); } }, { key: "isStreamingSupported", get: function get() { return false; } }]); return PDFNetworkStreamRangeRequestReader; }();
/***/ }),
/* 221 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFFetchStream = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(2)); var _util = __w_pdfjs_require__(5); var _network_utils = __w_pdfjs_require__(218); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
; function createFetchOptions(headers, withCredentials, abortController) { return { method: "GET", headers: headers, signal: abortController && abortController.signal, mode: "cors", credentials: withCredentials ? "include" : "same-origin", redirect: "follow" }; } function createHeaders(httpHeaders) { var headers = new Headers(); for (var property in httpHeaders) { var value = httpHeaders[property]; if (typeof value === "undefined") { continue; } headers.append(property, value); } return headers; }
var PDFFetchStream = /*#__PURE__*/function () {
function PDFFetchStream(source) { _classCallCheck(this, PDFFetchStream); this.source = source; this.isHttp = /^https?:/i.test(source.url); this.httpHeaders = this.isHttp && source.httpHeaders || {}; this._fullRequestReader = null; this._rangeRequestReaders = []; } _createClass(PDFFetchStream, [{ key: "getFullReader", value: function getFullReader() { (0, _util.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."); this._fullRequestReader = new PDFFetchStreamReader(this); return this._fullRequestReader; } }, { key: "getRangeReader", value: function getRangeReader(begin, end) { if (end <= this._progressiveDataLength) { return null; } var reader = new PDFFetchStreamRangeReader(this, begin, end); this._rangeRequestReaders.push(reader); return reader; } }, { key: "cancelAllRequests", value: function cancelAllRequests(reason) { if (this._fullRequestReader) { this._fullRequestReader.cancel(reason); } var readers = this._rangeRequestReaders.slice(0); readers.forEach(function (reader) { reader.cancel(reason); }); } }, { key: "_progressiveDataLength", get: function get() { return this._fullRequestReader ? this._fullRequestReader._loaded : 0; } }]); return PDFFetchStream; }(); exports.PDFFetchStream = PDFFetchStream;
var PDFFetchStreamReader = /*#__PURE__*/function () {
function PDFFetchStreamReader(stream) { var _this = this; _classCallCheck(this, PDFFetchStreamReader); this._stream = stream; this._reader = null; this._loaded = 0; this._filename = null; var source = stream.source; this._withCredentials = source.withCredentials || false; this._contentLength = source.length; this._headersCapability = (0, _util.createPromiseCapability)(); this._disableRange = source.disableRange || false; this._rangeChunkSize = source.rangeChunkSize; if (!this._rangeChunkSize && !this._disableRange) { this._disableRange = true; } if (typeof AbortController !== "undefined") { this._abortController = new AbortController(); } this._isStreamingSupported = !source.disableStream; this._isRangeSupported = !source.disableRange; this._headers = createHeaders(this._stream.httpHeaders); var url = source.url; fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) { if (!(0, _network_utils.validateResponseStatus)(response.status)) { throw (0, _network_utils.createResponseStatusError)(response.status, url); } _this._reader = response.body.getReader(); _this._headersCapability.resolve(); var getResponseHeader = function getResponseHeader(name) { return response.headers.get(name); }; var _validateRangeRequest = (0, _network_utils.validateRangeRequestCapabilities)({ getResponseHeader: getResponseHeader, isHttp: _this._stream.isHttp, rangeChunkSize: _this._rangeChunkSize, disableRange: _this._disableRange }), allowRangeRequests = _validateRangeRequest.allowRangeRequests, suggestedLength = _validateRangeRequest.suggestedLength; _this._isRangeSupported = allowRangeRequests; _this._contentLength = suggestedLength || _this._contentLength; _this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader); if (!_this._isStreamingSupported && _this._isRangeSupported) { _this.cancel(new _util.AbortException("Streaming is disabled.")); } })["catch"](this._headersCapability.reject); this.onProgress = null; } _createClass(PDFFetchStreamReader, [{ key: "read", value: function () {
var _read = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
var _yield$this$_reader$r, value, done, buffer; return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: _context.next = 2; return this._headersCapability.promise; case 2: _context.next = 4; return this._reader.read(); case 4: _yield$this$_reader$r = _context.sent; value = _yield$this$_reader$r.value; done = _yield$this$_reader$r.done; if (!done) { _context.next = 9; break; } return _context.abrupt("return", { value: value, done: done }); case 9: this._loaded += value.byteLength; if (this.onProgress) { this.onProgress({ loaded: this._loaded, total: this._contentLength }); } buffer = new Uint8Array(value).buffer; return _context.abrupt("return", { value: buffer, done: false }); case 13: case "end": return _context.stop(); } } }, _callee, this); })); function read() { return _read.apply(this, arguments); } return read; }() }, { key: "cancel", value: function cancel(reason) { if (this._reader) { this._reader.cancel(reason); } if (this._abortController) { this._abortController.abort(); } } }, { key: "headersReady", get: function get() { return this._headersCapability.promise; } }, { key: "filename", get: function get() { return this._filename; } }, { key: "contentLength", get: function get() { return this._contentLength; } }, { key: "isRangeSupported", get: function get() { return this._isRangeSupported; } }, { key: "isStreamingSupported", get: function get() { return this._isStreamingSupported; } }]); return PDFFetchStreamReader; }();
var PDFFetchStreamRangeReader = /*#__PURE__*/function () {
function PDFFetchStreamRangeReader(stream, begin, end) { var _this2 = this; _classCallCheck(this, PDFFetchStreamRangeReader); this._stream = stream; this._reader = null; this._loaded = 0; var source = stream.source; this._withCredentials = source.withCredentials || false; this._readCapability = (0, _util.createPromiseCapability)(); this._isStreamingSupported = !source.disableStream; if (typeof AbortController !== "undefined") { this._abortController = new AbortController(); } this._headers = createHeaders(this._stream.httpHeaders); this._headers.append("Range", "bytes=".concat(begin, "-").concat(end - 1)); var url = source.url; fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(function (response) { if (!(0, _network_utils.validateResponseStatus)(response.status)) { throw (0, _network_utils.createResponseStatusError)(response.status, url); } _this2._readCapability.resolve(); _this2._reader = response.body.getReader(); }); this.onProgress = null; } _createClass(PDFFetchStreamRangeReader, [{ key: "read", value: function () {
var _read2 = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
var _yield$this$_reader$r2, value, done, buffer; return _regenerator["default"].wrap(function _callee2$(_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0: _context2.next = 2; return this._readCapability.promise; case 2: _context2.next = 4; return this._reader.read(); case 4: _yield$this$_reader$r2 = _context2.sent; value = _yield$this$_reader$r2.value; done = _yield$this$_reader$r2.done; if (!done) { _context2.next = 9; break; } return _context2.abrupt("return", { value: value, done: done }); case 9: this._loaded += value.byteLength; if (this.onProgress) { this.onProgress({ loaded: this._loaded }); } buffer = new Uint8Array(value).buffer; return _context2.abrupt("return", { value: buffer, done: false }); case 13: case "end": return _context2.stop(); } } }, _callee2, this); })); function read() { return _read2.apply(this, arguments); } return read; }() }, { key: "cancel", value: function cancel(reason) { if (this._reader) { this._reader.cancel(reason); } if (this._abortController) { this._abortController.abort(); } } }, { key: "isStreamingSupported", get: function get() { return this._isStreamingSupported; } }]); return PDFFetchStreamRangeReader; }();
/***/ })
/******/ ]);
});
//# sourceMappingURL=pdf.js.map
/**
* @licstart The following is the entire license notice for the * Javascript code in this page * * Copyright 2020 Mozilla Foundation * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at *
* http://www.apache.org/licenses/LICENSE-2.0
* * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. * * @licend The above is the entire license notice for the * Javascript code in this page */ (function webpackUniversalModuleDefinition(root, factory) { if(typeof exports === 'object' && typeof module === 'object') module.exports = factory(); else if(typeof define === 'function' && define.amd) define("pdfjs-dist/web/pdf_viewer", [], factory); else if(typeof exports === 'object') exports["pdfjs-dist/web/pdf_viewer"] = factory(); else root["pdfjs-dist/web/pdf_viewer"] = root.pdfjsViewer = factory(); })(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __w_pdfjs_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__w_pdfjs_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__w_pdfjs_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__w_pdfjs_require__.d = function(exports, name, getter) {
/******/ 		if(!__w_pdfjs_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__w_pdfjs_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__w_pdfjs_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __w_pdfjs_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__w_pdfjs_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __w_pdfjs_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__w_pdfjs_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__w_pdfjs_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__w_pdfjs_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__w_pdfjs_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __w_pdfjs_require__(__w_pdfjs_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); Object.defineProperty(exports, "AnnotationLayerBuilder", { enumerable: true, get: function get() { return _annotation_layer_builder.AnnotationLayerBuilder; } }); Object.defineProperty(exports, "DefaultAnnotationLayerFactory", { enumerable: true, get: function get() { return _annotation_layer_builder.DefaultAnnotationLayerFactory; } }); Object.defineProperty(exports, "DefaultTextLayerFactory", { enumerable: true, get: function get() { return _text_layer_builder.DefaultTextLayerFactory; } }); Object.defineProperty(exports, "TextLayerBuilder", { enumerable: true, get: function get() { return _text_layer_builder.TextLayerBuilder; } }); Object.defineProperty(exports, "EventBus", { enumerable: true, get: function get() { return _ui_utils.EventBus; } }); Object.defineProperty(exports, "NullL10n", { enumerable: true, get: function get() { return _ui_utils.NullL10n; } }); Object.defineProperty(exports, "ProgressBar", { enumerable: true, get: function get() { return _ui_utils.ProgressBar; } }); Object.defineProperty(exports, "PDFLinkService", { enumerable: true, get: function get() { return _pdf_link_service.PDFLinkService; } }); Object.defineProperty(exports, "SimpleLinkService", { enumerable: true, get: function get() { return _pdf_link_service.SimpleLinkService; } }); Object.defineProperty(exports, "DownloadManager", { enumerable: true, get: function get() { return _download_manager.DownloadManager; } }); Object.defineProperty(exports, "GenericL10n", { enumerable: true, get: function get() { return _genericl10n.GenericL10n; } }); Object.defineProperty(exports, "PDFFindController", { enumerable: true, get: function get() { return _pdf_find_controller.PDFFindController; } }); Object.defineProperty(exports, "PDFHistory", { enumerable: true, get: function get() { return _pdf_history.PDFHistory; } }); Object.defineProperty(exports, "PDFPageView", { enumerable: true, get: function get() { return _pdf_page_view.PDFPageView; } }); Object.defineProperty(exports, "PDFSinglePageViewer", { enumerable: true, get: function get() { return _pdf_single_page_viewer.PDFSinglePageViewer; } }); Object.defineProperty(exports, "PDFViewer", { enumerable: true, get: function get() { return _pdf_viewer.PDFViewer; } }); var _annotation_layer_builder = __w_pdfjs_require__(1); var _text_layer_builder = __w_pdfjs_require__(8); var _ui_utils = __w_pdfjs_require__(3); var _pdf_link_service = __w_pdfjs_require__(7); var _download_manager = __w_pdfjs_require__(9); var _genericl10n = __w_pdfjs_require__(11); var _pdf_find_controller = __w_pdfjs_require__(13); var _pdf_history = __w_pdfjs_require__(15); var _pdf_page_view = __w_pdfjs_require__(16); var _pdf_single_page_viewer = __w_pdfjs_require__(18); var _pdf_viewer = __w_pdfjs_require__(20); var pdfjsVersion = '2.5.207'; var pdfjsBuild = '0974d6052';
/***/ }),
/* 1 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.DefaultAnnotationLayerFactory = exports.AnnotationLayerBuilder = void 0; var _pdfjsLib = __w_pdfjs_require__(2); var _ui_utils = __w_pdfjs_require__(3); var _pdf_link_service = __w_pdfjs_require__(7); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var AnnotationLayerBuilder = /*#__PURE__*/function () {
function AnnotationLayerBuilder(_ref) { var pageDiv = _ref.pageDiv, pdfPage = _ref.pdfPage, linkService = _ref.linkService, downloadManager = _ref.downloadManager, _ref$imageResourcesPa = _ref.imageResourcesPath, imageResourcesPath = _ref$imageResourcesPa === void 0 ? "" : _ref$imageResourcesPa, _ref$renderInteractiv = _ref.renderInteractiveForms, renderInteractiveForms = _ref$renderInteractiv === void 0 ? false : _ref$renderInteractiv, _ref$l10n = _ref.l10n, l10n = _ref$l10n === void 0 ? _ui_utils.NullL10n : _ref$l10n; _classCallCheck(this, AnnotationLayerBuilder); this.pageDiv = pageDiv; this.pdfPage = pdfPage; this.linkService = linkService; this.downloadManager = downloadManager; this.imageResourcesPath = imageResourcesPath; this.renderInteractiveForms = renderInteractiveForms; this.l10n = l10n; this.div = null; this._cancelled = false; } _createClass(AnnotationLayerBuilder, [{ key: "render", value: function render(viewport) { var _this = this; var intent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "display"; this.pdfPage.getAnnotations({ intent: intent }).then(function (annotations) { if (_this._cancelled) { return; } var parameters = { viewport: viewport.clone({ dontFlip: true }), div: _this.div, annotations: annotations, page: _this.pdfPage, imageResourcesPath: _this.imageResourcesPath, renderInteractiveForms: _this.renderInteractiveForms, linkService: _this.linkService, downloadManager: _this.downloadManager }; if (_this.div) { _pdfjsLib.AnnotationLayer.update(parameters); } else { if (annotations.length === 0) { return; } _this.div = document.createElement("div"); _this.div.className = "annotationLayer"; _this.pageDiv.appendChild(_this.div); parameters.div = _this.div; _pdfjsLib.AnnotationLayer.render(parameters); _this.l10n.translate(_this.div); } }); } }, { key: "cancel", value: function cancel() { this._cancelled = true; } }, { key: "hide", value: function hide() { if (!this.div) { return; } this.div.setAttribute("hidden", "true"); } }]); return AnnotationLayerBuilder; }(); exports.AnnotationLayerBuilder = AnnotationLayerBuilder;
var DefaultAnnotationLayerFactory = /*#__PURE__*/function () {
function DefaultAnnotationLayerFactory() { _classCallCheck(this, DefaultAnnotationLayerFactory); } _createClass(DefaultAnnotationLayerFactory, [{ key: "createAnnotationLayerBuilder", value: function createAnnotationLayerBuilder(pageDiv, pdfPage) { var imageResourcesPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ""; var renderInteractiveForms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; var l10n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _ui_utils.NullL10n; return new AnnotationLayerBuilder({ pageDiv: pageDiv, pdfPage: pdfPage, imageResourcesPath: imageResourcesPath, renderInteractiveForms: renderInteractiveForms, linkService: new _pdf_link_service.SimpleLinkService(), l10n: l10n }); } }]); return DefaultAnnotationLayerFactory; }(); exports.DefaultAnnotationLayerFactory = DefaultAnnotationLayerFactory;
/***/ }),
/* 2 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; var pdfjsLib; if (typeof window !== "undefined" && window["pdfjs-dist/build/pdf"]) { pdfjsLib = window["pdfjs-dist/build/pdf"]; } else { pdfjsLib = require("../build/pdf.js"); } module.exports = pdfjsLib;
/***/ }),
/* 3 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.isValidRotation = isValidRotation; exports.isValidScrollMode = isValidScrollMode; exports.isValidSpreadMode = isValidSpreadMode; exports.isPortraitOrientation = isPortraitOrientation; exports.clamp = clamp; exports.getPDFFileNameFromURL = getPDFFileNameFromURL; exports.noContextMenuHandler = noContextMenuHandler; exports.parseQueryString = parseQueryString; exports.backtrackBeforeAllVisibleElements = backtrackBeforeAllVisibleElements; exports.getVisibleElements = getVisibleElements; exports.roundToDivide = roundToDivide; exports.getPageSizeInches = getPageSizeInches; exports.approximateFraction = approximateFraction; exports.getOutputScale = getOutputScale; exports.scrollIntoView = scrollIntoView; exports.watchScroll = watchScroll; exports.binarySearchFirstItem = binarySearchFirstItem; exports.normalizeWheelEventDelta = normalizeWheelEventDelta; exports.waitOnEventOrTimeout = waitOnEventOrTimeout; exports.moveToEndOfArray = moveToEndOfArray;
exports.WaitOnType = exports.animationStarted = exports.ProgressBar = exports.EventBus = exports.NullL10n = exports.SpreadMode = exports.ScrollMode = exports.TextLayerMode = exports.RendererType = exports.PresentationModeState = exports.VERTICAL_PADDING = exports.SCROLLBAR_PADDING = exports.MAX_AUTO_SCALE = exports.UNKNOWN_SCALE = exports.MAX_SCALE = exports.MIN_SCALE = exports.DEFAULT_SCALE = exports.DEFAULT_SCALE_VALUE = exports.CSS_UNITS = exports.AutoPrintRegExp = void 0;
var _regenerator = _interopRequireDefault(__w_pdfjs_require__(4)); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
var CSS_UNITS = 96.0 / 72.0; exports.CSS_UNITS = CSS_UNITS; var DEFAULT_SCALE_VALUE = "auto"; exports.DEFAULT_SCALE_VALUE = DEFAULT_SCALE_VALUE; var DEFAULT_SCALE = 1.0; exports.DEFAULT_SCALE = DEFAULT_SCALE; var MIN_SCALE = 0.1; exports.MIN_SCALE = MIN_SCALE; var MAX_SCALE = 10.0; exports.MAX_SCALE = MAX_SCALE; var UNKNOWN_SCALE = 0; exports.UNKNOWN_SCALE = UNKNOWN_SCALE; var MAX_AUTO_SCALE = 1.25; exports.MAX_AUTO_SCALE = MAX_AUTO_SCALE; var SCROLLBAR_PADDING = 40; exports.SCROLLBAR_PADDING = SCROLLBAR_PADDING; var VERTICAL_PADDING = 5; exports.VERTICAL_PADDING = VERTICAL_PADDING; var PresentationModeState = { UNKNOWN: 0, NORMAL: 1, CHANGING: 2, FULLSCREEN: 3 }; exports.PresentationModeState = PresentationModeState; var RendererType = { CANVAS: "canvas", SVG: "svg" }; exports.RendererType = RendererType; var TextLayerMode = { DISABLE: 0, ENABLE: 1, ENABLE_ENHANCE: 2 }; exports.TextLayerMode = TextLayerMode; var ScrollMode = { UNKNOWN: -1, VERTICAL: 0, HORIZONTAL: 1, WRAPPED: 2 }; exports.ScrollMode = ScrollMode; var SpreadMode = { UNKNOWN: -1, NONE: 0, ODD: 1, EVEN: 2 }; exports.SpreadMode = SpreadMode; var AutoPrintRegExp = /\bprint\s*\(/; exports.AutoPrintRegExp = AutoPrintRegExp; function formatL10nValue(text, args) { if (!args) { return text; } return text.replace(/\{\{\s*(\w+)\s*\}\}/g, function (all, name) { return name in args ? args[name] : "{{" + name + "}}"; }); } var NullL10n = { getLanguage: function getLanguage() {
return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: return _context.abrupt("return", "en-us"); case 1: case "end": return _context.stop(); } } }, _callee); }))(); }, getDirection: function getDirection() {
return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
return _regenerator["default"].wrap(function _callee2$(_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0: return _context2.abrupt("return", "ltr"); case 1: case "end": return _context2.stop(); } } }, _callee2); }))(); }, get: function get(property, args, fallback) {
return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
return _regenerator["default"].wrap(function _callee3$(_context3) { while (1) { switch (_context3.prev = _context3.next) { case 0: return _context3.abrupt("return", formatL10nValue(fallback, args)); case 1: case "end": return _context3.stop(); } } }, _callee3); }))(); }, translate: function translate(element) {
return _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
return _regenerator["default"].wrap(function _callee4$(_context4) { while (1) { switch (_context4.prev = _context4.next) { case 0: case "end": return _context4.stop(); } } }, _callee4); }))(); } }; exports.NullL10n = NullL10n; function getOutputScale(ctx) { var devicePixelRatio = window.devicePixelRatio || 1; var backingStoreRatio = ctx.webkitBackingStorePixelRatio || ctx.mozBackingStorePixelRatio || ctx.msBackingStorePixelRatio || ctx.oBackingStorePixelRatio || ctx.backingStorePixelRatio || 1; var pixelRatio = devicePixelRatio / backingStoreRatio; return { sx: pixelRatio, sy: pixelRatio, scaled: pixelRatio !== 1 }; } function scrollIntoView(element, spot) { var skipOverflowHiddenElements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; var parent = element.offsetParent; if (!parent) { console.error("offsetParent is not set -- cannot scroll"); return; } var offsetY = element.offsetTop + element.clientTop; var offsetX = element.offsetLeft + element.clientLeft; while (parent.clientHeight === parent.scrollHeight && parent.clientWidth === parent.scrollWidth || skipOverflowHiddenElements && getComputedStyle(parent).overflow === "hidden") { if (parent.dataset._scaleY) { offsetY /= parent.dataset._scaleY; offsetX /= parent.dataset._scaleX; } offsetY += parent.offsetTop; offsetX += parent.offsetLeft; parent = parent.offsetParent; if (!parent) { return; } } if (spot) { if (spot.top !== undefined) { offsetY += spot.top; } if (spot.left !== undefined) { offsetX += spot.left; parent.scrollLeft = offsetX; } } parent.scrollTop = offsetY; } function watchScroll(viewAreaElement, callback) { var debounceScroll = function debounceScroll(evt) { if (rAF) { return; } rAF = window.requestAnimationFrame(function viewAreaElementScrolled() { rAF = null; var currentX = viewAreaElement.scrollLeft; var lastX = state.lastX; if (currentX !== lastX) { state.right = currentX > lastX; } state.lastX = currentX; var currentY = viewAreaElement.scrollTop; var lastY = state.lastY; if (currentY !== lastY) { state.down = currentY > lastY; } state.lastY = currentY; callback(state); }); }; var state = { right: true, down: true, lastX: viewAreaElement.scrollLeft, lastY: viewAreaElement.scrollTop, _eventHandler: debounceScroll }; var rAF = null; viewAreaElement.addEventListener("scroll", debounceScroll, true); return state; } function parseQueryString(query) { var parts = query.split("&"); var params = Object.create(null); for (var i = 0, ii = parts.length; i < ii; ++i) { var param = parts[i].split("="); var key = param[0].toLowerCase(); var value = param.length > 1 ? param[1] : null; params[decodeURIComponent(key)] = decodeURIComponent(value); } return params; } function binarySearchFirstItem(items, condition) { var minIndex = 0; var maxIndex = items.length - 1; if (maxIndex < 0 || !condition(items[maxIndex])) { return items.length; } if (condition(items[minIndex])) { return minIndex; } while (minIndex < maxIndex) { var currentIndex = minIndex + maxIndex >> 1; var currentItem = items[currentIndex]; if (condition(currentItem)) { maxIndex = currentIndex; } else { minIndex = currentIndex + 1; } } return minIndex; } function approximateFraction(x) { if (Math.floor(x) === x) { return [x, 1]; } var xinv = 1 / x; var limit = 8; if (xinv > limit) { return [1, limit]; } else if (Math.floor(xinv) === xinv) { return [1, xinv]; } var x_ = x > 1 ? xinv : x; var a = 0, b = 1, c = 1, d = 1; while (true) { var p = a + c, q = b + d; if (q > limit) { break; } if (x_ <= p / q) { c = p; d = q; } else { a = p; b = q; } } var result; if (x_ - a / b < c / d - x_) { result = x_ === x ? [a, b] : [b, a]; } else { result = x_ === x ? [c, d] : [d, c]; } return result; } function roundToDivide(x, div) { var r = x % div; return r === 0 ? x : Math.round(x - r + div); } function getPageSizeInches(_ref) { var view = _ref.view, userUnit = _ref.userUnit, rotate = _ref.rotate; var _view = _slicedToArray(view, 4), x1 = _view[0], y1 = _view[1], x2 = _view[2], y2 = _view[3]; var changeOrientation = rotate % 180 !== 0; var width = (x2 - x1) / 72 * userUnit; var height = (y2 - y1) / 72 * userUnit; return { width: changeOrientation ? height : width, height: changeOrientation ? width : height }; } function backtrackBeforeAllVisibleElements(index, views, top) { if (index < 2) { return index; } var elt = views[index].div; var pageTop = elt.offsetTop + elt.clientTop; if (pageTop >= top) { elt = views[index - 1].div; pageTop = elt.offsetTop + elt.clientTop; } for (var i = index - 2; i >= 0; --i) { elt = views[i].div; if (elt.offsetTop + elt.clientTop + elt.clientHeight <= pageTop) { break; } index = i; } return index; } function getVisibleElements(scrollEl, views) { var sortByVisibility = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; var horizontal = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; var top = scrollEl.scrollTop, bottom = top + scrollEl.clientHeight; var left = scrollEl.scrollLeft, right = left + scrollEl.clientWidth; function isElementBottomAfterViewTop(view) { var element = view.div; var elementBottom = element.offsetTop + element.clientTop + element.clientHeight; return elementBottom > top; } function isElementRightAfterViewLeft(view) { var element = view.div; var elementRight = element.offsetLeft + element.clientLeft + element.clientWidth; return elementRight > left; } var visible = [], numViews = views.length; var firstVisibleElementInd = numViews === 0 ? 0 : binarySearchFirstItem(views, horizontal ? isElementRightAfterViewLeft : isElementBottomAfterViewTop); if (firstVisibleElementInd > 0 && firstVisibleElementInd < numViews && !horizontal) { firstVisibleElementInd = backtrackBeforeAllVisibleElements(firstVisibleElementInd, views, top); } var lastEdge = horizontal ? right : -1; for (var i = firstVisibleElementInd; i < numViews; i++) { var view = views[i], element = view.div; var currentWidth = element.offsetLeft + element.clientLeft; var currentHeight = element.offsetTop + element.clientTop; var viewWidth = element.clientWidth, viewHeight = element.clientHeight; var viewRight = currentWidth + viewWidth; var viewBottom = currentHeight + viewHeight; if (lastEdge === -1) { if (viewBottom >= bottom) { lastEdge = viewBottom; } } else if ((horizontal ? currentWidth : currentHeight) > lastEdge) { break; } if (viewBottom <= top || currentHeight >= bottom || viewRight <= left || currentWidth >= right) { continue; } var hiddenHeight = Math.max(0, top - currentHeight) + Math.max(0, viewBottom - bottom); var hiddenWidth = Math.max(0, left - currentWidth) + Math.max(0, viewRight - right); var percent = (viewHeight - hiddenHeight) * (viewWidth - hiddenWidth) * 100 / viewHeight / viewWidth | 0; visible.push({ id: view.id, x: currentWidth, y: currentHeight, view: view, percent: percent }); } var first = visible[0], last = visible[visible.length - 1]; if (sortByVisibility) { visible.sort(function (a, b) { var pc = a.percent - b.percent; if (Math.abs(pc) > 0.001) { return -pc; } return a.id - b.id; }); } return { first: first, last: last, views: visible }; } function noContextMenuHandler(evt) { evt.preventDefault(); } function isDataSchema(url) { var i = 0; var ii = url.length; while (i < ii && url[i].trim() === "") { i++; } return url.substring(i, i + 5).toLowerCase() === "data:"; } function getPDFFileNameFromURL(url) { var defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "document.pdf"; if (typeof url !== "string") { return defaultFilename; } if (isDataSchema(url)) { console.warn("getPDFFileNameFromURL: " + 'ignoring "data:" URL for performance reasons.'); return defaultFilename; } var reURI = /^(?:(?:[^:]+:)?\/\/[^\/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/; var reFilename = /[^\/?#=]+\.pdf\b(?!.*\.pdf\b)/i; var splitURI = reURI.exec(url); var suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]); if (suggestedFilename) { suggestedFilename = suggestedFilename[0]; if (suggestedFilename.includes("%")) { try { suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0]; } catch (ex) {} } } return suggestedFilename || defaultFilename; } function normalizeWheelEventDelta(evt) { var delta = Math.sqrt(evt.deltaX * evt.deltaX + evt.deltaY * evt.deltaY); var angle = Math.atan2(evt.deltaY, evt.deltaX); if (-0.25 * Math.PI < angle && angle < 0.75 * Math.PI) { delta = -delta; } var MOUSE_DOM_DELTA_PIXEL_MODE = 0; var MOUSE_DOM_DELTA_LINE_MODE = 1; var MOUSE_PIXELS_PER_LINE = 30; var MOUSE_LINES_PER_PAGE = 30; if (evt.deltaMode === MOUSE_DOM_DELTA_PIXEL_MODE) { delta /= MOUSE_PIXELS_PER_LINE * MOUSE_LINES_PER_PAGE; } else if (evt.deltaMode === MOUSE_DOM_DELTA_LINE_MODE) { delta /= MOUSE_LINES_PER_PAGE; } return delta; } function isValidRotation(angle) { return Number.isInteger(angle) && angle % 90 === 0; } function isValidScrollMode(mode) { return Number.isInteger(mode) && Object.values(ScrollMode).includes(mode) && mode !== ScrollMode.UNKNOWN; } function isValidSpreadMode(mode) { return Number.isInteger(mode) && Object.values(SpreadMode).includes(mode) && mode !== SpreadMode.UNKNOWN; } function isPortraitOrientation(size) { return size.width <= size.height; } var WaitOnType = { EVENT: "event", TIMEOUT: "timeout" }; exports.WaitOnType = WaitOnType; function waitOnEventOrTimeout(_ref2) { var target = _ref2.target, name = _ref2.name, _ref2$delay = _ref2.delay, delay = _ref2$delay === void 0 ? 0 : _ref2$delay; return new Promise(function (resolve, reject) { if (_typeof(target) !== "object" || !(name && typeof name === "string") || !(Number.isInteger(delay) && delay >= 0)) { throw new Error("waitOnEventOrTimeout - invalid parameters."); } function handler(type) { if (target instanceof EventBus) { target._off(name, eventHandler); } else { target.removeEventListener(name, eventHandler); } if (timeout) { clearTimeout(timeout); } resolve(type); } var eventHandler = handler.bind(null, WaitOnType.EVENT); if (target instanceof EventBus) { target._on(name, eventHandler); } else { target.addEventListener(name, eventHandler); } var timeoutHandler = handler.bind(null, WaitOnType.TIMEOUT); var timeout = setTimeout(timeoutHandler, delay); }); } var animationStarted = new Promise(function (resolve) { window.requestAnimationFrame(resolve); }); exports.animationStarted = animationStarted; function dispatchDOMEvent(eventName) { var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; throw new Error("Not implemented: dispatchDOMEvent"); }
var EventBus = /*#__PURE__*/function () {
function EventBus(options) { _classCallCheck(this, EventBus); this._listeners = Object.create(null); } _createClass(EventBus, [{ key: "on", value: function on(eventName, listener) { this._on(eventName, listener, { external: true }); } }, { key: "off", value: function off(eventName, listener) { this._off(eventName, listener, { external: true }); } }, { key: "dispatch", value: function dispatch(eventName) { var eventListeners = this._listeners[eventName]; if (!eventListeners || eventListeners.length === 0) { return; } var args = Array.prototype.slice.call(arguments, 1); var externalListeners; eventListeners.slice(0).forEach(function (_ref3) { var listener = _ref3.listener, external = _ref3.external; if (external) { if (!externalListeners) { externalListeners = []; } externalListeners.push(listener); return; } listener.apply(null, args); }); if (externalListeners) { externalListeners.forEach(function (listener) { listener.apply(null, args); }); externalListeners = null; } } }, { key: "_on", value: function _on(eventName, listener) { var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null; var eventListeners = this._listeners[eventName]; if (!eventListeners) { this._listeners[eventName] = eventListeners = []; } eventListeners.push({ listener: listener, external: (options && options.external) === true }); } }, { key: "_off", value: function _off(eventName, listener) { var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null; var eventListeners = this._listeners[eventName]; if (!eventListeners) { return; } for (var i = 0, ii = eventListeners.length; i < ii; i++) { if (eventListeners[i].listener === listener) { eventListeners.splice(i, 1); return; } } } }]); return EventBus; }(); exports.EventBus = EventBus; function clamp(v, min, max) { return Math.min(Math.max(v, min), max); }
var ProgressBar = /*#__PURE__*/function () {
function ProgressBar(id) { var _ref4 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}, height = _ref4.height, width = _ref4.width, units = _ref4.units; _classCallCheck(this, ProgressBar); this.visible = true; this.div = document.querySelector(id + " .progress"); this.bar = this.div.parentNode; this.height = height || 100; this.width = width || 100; this.units = units || "%"; this.div.style.height = this.height + this.units; this.percent = 0; } _createClass(ProgressBar, [{ key: "_updateBar", value: function _updateBar() { if (this._indeterminate) { this.div.classList.add("indeterminate"); this.div.style.width = this.width + this.units; return; } this.div.classList.remove("indeterminate"); var progressSize = this.width * this._percent / 100; this.div.style.width = progressSize + this.units; } }, { key: "setWidth", value: function setWidth(viewer) { if (!viewer) { return; } var container = viewer.parentNode; var scrollbarWidth = container.offsetWidth - viewer.offsetWidth; if (scrollbarWidth > 0) { this.bar.style.width = "calc(100% - ".concat(scrollbarWidth, "px)"); } } }, { key: "hide", value: function hide() { if (!this.visible) { return; } this.visible = false; this.bar.classList.add("hidden"); document.body.classList.remove("loadingInProgress"); } }, { key: "show", value: function show() { if (this.visible) { return; } this.visible = true; document.body.classList.add("loadingInProgress"); this.bar.classList.remove("hidden"); } }, { key: "percent", get: function get() { return this._percent; }, set: function set(val) { this._indeterminate = isNaN(val); this._percent = clamp(val, 0, 100); this._updateBar(); } }]); return ProgressBar; }(); exports.ProgressBar = ProgressBar; function moveToEndOfArray(arr, condition) { var moved = [], len = arr.length; var write = 0; for (var read = 0; read < len; ++read) { if (condition(arr[read])) { moved.push(arr[read]); } else { arr[write] = arr[read]; ++write; } } for (var _read = 0; write < len; ++_read, ++write) { arr[write] = moved[_read]; } }
/***/ }),
/* 4 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; module.exports = __w_pdfjs_require__(5);
/***/ }),
/* 5 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict";
/* WEBPACK VAR INJECTION */(function(module) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
var runtime = function (exports) { "use strict"; var Op = Object.prototype; var hasOwn = Op.hasOwnProperty; var undefined; var $Symbol = typeof Symbol === "function" ? Symbol : {}; var iteratorSymbol = $Symbol.iterator || "@@iterator"; var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator"; var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); return obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); var context = new Context(tryLocsList || []); generator._invoke = makeInvokeMethod(innerFn, self, context); return generator; } exports.wrap = wrap; function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } var GenStateSuspendedStart = "suspendedStart"; var GenStateSuspendedYield = "suspendedYield"; var GenStateExecuting = "executing"; var GenStateCompleted = "completed"; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; IteratorPrototype[iteratorSymbol] = function () { return this; }; var getProto = Object.getPrototypeOf; var NativeIteratorPrototype = getProto && getProto(getProto(values([]))); if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) { IteratorPrototype = NativeIteratorPrototype; } var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype; GeneratorFunctionPrototype.constructor = GeneratorFunction; GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } exports.isGeneratorFunction = function (genFun) { var ctor = typeof genFun === "function" && genFun.constructor; return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false; }; exports.mark = function (genFun) { if (Object.setPrototypeOf) { Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); } else { genFun.__proto__ = GeneratorFunctionPrototype; define(genFun, toStringTagSymbol, "GeneratorFunction"); } genFun.prototype = Object.create(Gp); return genFun; }; exports.awrap = function (arg) { return { __await: arg }; }; function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (record.type === "throw") { reject(record.arg); } else { var result = record.arg; var value = result.value; if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) { return PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }); } return PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped; resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } } var previousPromise; function enqueue(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } this._invoke = enqueue; } defineIteratorMethods(AsyncIterator.prototype); AsyncIterator.prototype[asyncIteratorSymbol] = function () { return this; }; exports.AsyncIterator = AsyncIterator; exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { if (PromiseImpl === void 0) PromiseImpl = Promise; var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }; function makeInvokeMethod(innerFn, self, context) { var state = GenStateSuspendedStart; return function invoke(method, arg) { if (state === GenStateExecuting) { throw new Error("Generator is already running"); } if (state === GenStateCompleted) { if (method === "throw") { throw arg; } return doneResult(); } context.method = method; context.arg = arg; while (true) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (context.method === "next") { context.sent = context._sent = context.arg; } else if (context.method === "throw") { if (state === GenStateSuspendedStart) { state = GenStateCompleted; throw context.arg; } context.dispatchException(context.arg); } else if (context.method === "return") { context.abrupt("return", context.arg); } state = GenStateExecuting; var record = tryCatch(innerFn, self, context); if (record.type === "normal") { state = context.done ? GenStateCompleted : GenStateSuspendedYield; if (record.arg === ContinueSentinel) { continue; } return { value: record.arg, done: context.done }; } else if (record.type === "throw") { state = GenStateCompleted; context.method = "throw"; context.arg = record.arg; } } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (method === undefined) { context.delegate = null; if (context.method === "throw") { if (delegate.iterator["return"]) { context.method = "return"; context.arg = undefined; maybeInvokeDelegate(delegate, context); if (context.method === "throw") { return ContinueSentinel; } } context.method = "throw"; context.arg = new TypeError("The iterator does not provide a 'throw' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if (record.type === "throw") { context.method = "throw"; context.arg = record.arg; context.delegate = null; return ContinueSentinel; } var info = record.arg; if (!info) { context.method = "throw"; context.arg = new TypeError("iterator result is not an object"); context.delegate = null; return ContinueSentinel; } if (info.done) { context[delegate.resultName] = info.value; context.next = delegate.nextLoc; if (context.method !== "return") { context.method = "next"; context.arg = undefined; } } else { return info; } context.delegate = null; return ContinueSentinel; } defineIteratorMethods(Gp); define(Gp, toStringTagSymbol, "Generator"); Gp[iteratorSymbol] = function () { return this; }; Gp.toString = function () { return "[object Generator]"; }; function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; if (1 in locs) { entry.catchLoc = locs[1]; } if (2 in locs) { entry.finallyLoc = locs[2]; entry.afterLoc = locs[3]; } this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal"; delete record.arg; entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }]; tryLocsList.forEach(pushTryEntry, this); this.reset(true); } exports.keys = function (object) { var keys = []; for (var key in object) { keys.push(key); } keys.reverse(); return function next() { while (keys.length) { var key = keys.pop(); if (key in object) { next.value = key; next.done = false; return next; } } next.done = true; return next; }; }; function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) { return iteratorMethod.call(iterable); } if (typeof iterable.next === "function") { return iterable; } if (!isNaN(iterable.length)) { var i = -1, next = function next() { while (++i < iterable.length) { if (hasOwn.call(iterable, i)) { next.value = iterable[i]; next.done = false; return next; } } next.value = undefined; next.done = true; return next; }; return next.next = next; } } return { next: doneResult }; } exports.values = values; function doneResult() { return { value: undefined, done: true }; } Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { this.prev = 0; this.next = 0; this.sent = this._sent = undefined; this.done = false; this.delegate = null; this.method = "next"; this.arg = undefined; this.tryEntries.forEach(resetTryEntry); if (!skipTempReset) { for (var name in this) { if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) { this[name] = undefined; } } } }, stop: function stop() { this.done = true; var rootEntry = this.tryEntries[0]; var rootRecord = rootEntry.completion; if (rootRecord.type === "throw") { throw rootRecord.arg; } return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) { throw exception; } var context = this; function handle(loc, caught) { record.type = "throw"; record.arg = exception; context.next = loc; if (caught) { context.method = "next"; context.arg = undefined; } return !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; var record = entry.completion; if (entry.tryLoc === "root") { return handle("end"); } if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"); var hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) { return handle(entry.catchLoc, true); } else if (this.prev < entry.finallyLoc) { return handle(entry.finallyLoc); } } else if (hasCatch) { if (this.prev < entry.catchLoc) { return handle(entry.catchLoc, true); } } else if (hasFinally) { if (this.prev < entry.finallyLoc) { return handle(entry.finallyLoc); } } else { throw new Error("try statement without catch or finally"); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) { finallyEntry = null; } var record = finallyEntry ? finallyEntry.completion : {}; record.type = type; record.arg = arg; if (finallyEntry) { this.method = "next"; this.next = finallyEntry.finallyLoc; return ContinueSentinel; } return this.complete(record); }, complete: function complete(record, afterLoc) { if (record.type === "throw") { throw record.arg; } if (record.type === "break" || record.type === "continue") { this.next = record.arg; } else if (record.type === "return") { this.rval = this.arg = record.arg; this.method = "return"; this.next = "end"; } else if (record.type === "normal" && afterLoc) { this.next = afterLoc; } return ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) { this.complete(entry.completion, entry.afterLoc); resetTryEntry(entry); return ContinueSentinel; } } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (record.type === "throw") { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }; if (this.method === "next") { this.arg = undefined; } return ContinueSentinel; } }; return exports; }(( false ? undefined : _typeof(module)) === "object" ? module.exports : {}); try { regeneratorRuntime = runtime; } catch (accidentalStrictMode) { Function("r", "regeneratorRuntime = r")(runtime); }
/* WEBPACK VAR INJECTION */}.call(this, __w_pdfjs_require__(6)(module)))
/***/ }),
/* 6 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; module.exports = function (module) { if (!module.webpackPolyfill) { module.deprecate = function () {}; module.paths = []; if (!module.children) module.children = []; Object.defineProperty(module, "loaded", { enumerable: true, get: function get() { return module.l; } }); Object.defineProperty(module, "id", { enumerable: true, get: function get() { return module.i; } }); module.webpackPolyfill = 1; } return module; };
/***/ }),
/* 7 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.SimpleLinkService = exports.PDFLinkService = void 0; var _ui_utils = __w_pdfjs_require__(3);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var PDFLinkService = /*#__PURE__*/function () {
function PDFLinkService() { var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}, eventBus = _ref.eventBus, _ref$externalLinkTarg = _ref.externalLinkTarget, externalLinkTarget = _ref$externalLinkTarg === void 0 ? null : _ref$externalLinkTarg, _ref$externalLinkRel = _ref.externalLinkRel, externalLinkRel = _ref$externalLinkRel === void 0 ? null : _ref$externalLinkRel, _ref$externalLinkEnab = _ref.externalLinkEnabled, externalLinkEnabled = _ref$externalLinkEnab === void 0 ? true : _ref$externalLinkEnab, _ref$ignoreDestinatio = _ref.ignoreDestinationZoom, ignoreDestinationZoom = _ref$ignoreDestinatio === void 0 ? false : _ref$ignoreDestinatio; _classCallCheck(this, PDFLinkService); this.eventBus = eventBus; this.externalLinkTarget = externalLinkTarget; this.externalLinkRel = externalLinkRel; this.externalLinkEnabled = externalLinkEnabled; this._ignoreDestinationZoom = ignoreDestinationZoom; this.baseUrl = null; this.pdfDocument = null; this.pdfViewer = null; this.pdfHistory = null; this._pagesRefCache = null; } _createClass(PDFLinkService, [{ key: "setDocument", value: function setDocument(pdfDocument) { var baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null; this.baseUrl = baseUrl; this.pdfDocument = pdfDocument; this._pagesRefCache = Object.create(null); } }, { key: "setViewer", value: function setViewer(pdfViewer) { this.pdfViewer = pdfViewer; } }, { key: "setHistory", value: function setHistory(pdfHistory) { this.pdfHistory = pdfHistory; } }, { key: "navigateTo", value: function navigateTo(dest) { var _this = this; var goToDestination = function goToDestination(_ref2) { var namedDest = _ref2.namedDest, explicitDest = _ref2.explicitDest; var destRef = explicitDest[0]; var pageNumber; if (destRef instanceof Object) { pageNumber = _this._cachedPageNumber(destRef); if (pageNumber === null) { _this.pdfDocument.getPageIndex(destRef).then(function (pageIndex) { _this.cachePageRef(pageIndex + 1, destRef); goToDestination({ namedDest: namedDest, explicitDest: explicitDest }); })["catch"](function () { console.error("PDFLinkService.navigateTo: \"".concat(destRef, "\" is not ") + "a valid page reference, for dest=\"".concat(dest, "\".")); }); return; } } else if (Number.isInteger(destRef)) { pageNumber = destRef + 1; } else { console.error("PDFLinkService.navigateTo: \"".concat(destRef, "\" is not ") + "a valid destination reference, for dest=\"".concat(dest, "\".")); return; } if (!pageNumber || pageNumber < 1 || pageNumber > _this.pagesCount) { console.error("PDFLinkService.navigateTo: \"".concat(pageNumber, "\" is not ") + "a valid page number, for dest=\"".concat(dest, "\".")); return; } if (_this.pdfHistory) { _this.pdfHistory.pushCurrentPosition(); _this.pdfHistory.push({ namedDest: namedDest, explicitDest: explicitDest, pageNumber: pageNumber }); } _this.pdfViewer.scrollPageIntoView({ pageNumber: pageNumber, destArray: explicitDest, ignoreDestinationZoom: _this._ignoreDestinationZoom }); }; new Promise(function (resolve, reject) { if (typeof dest === "string") { _this.pdfDocument.getDestination(dest).then(function (destArray) { resolve({ namedDest: dest, explicitDest: destArray }); }); return; } resolve({ namedDest: "", explicitDest: dest }); }).then(function (data) { if (!Array.isArray(data.explicitDest)) { console.error("PDFLinkService.navigateTo: \"".concat(data.explicitDest, "\" is") + " not a valid destination array, for dest=\"".concat(dest, "\".")); return; } goToDestination(data); }); } }, { key: "getDestinationHash", value: function getDestinationHash(dest) { if (typeof dest === "string") { return this.getAnchorUrl("#" + escape(dest)); } if (Array.isArray(dest)) { var str = JSON.stringify(dest); return this.getAnchorUrl("#" + escape(str)); } return this.getAnchorUrl(""); } }, { key: "getAnchorUrl", value: function getAnchorUrl(anchor) { return (this.baseUrl || "") + anchor; } }, { key: "setHash", value: function setHash(hash) { var pageNumber, dest; if (hash.includes("=")) { var params = (0, _ui_utils.parseQueryString)(hash); if ("search" in params) { this.eventBus.dispatch("findfromurlhash", { source: this, query: params.search.replace(/"/g, ""), phraseSearch: params.phrase === "true" }); } if ("page" in params) { pageNumber = params.page | 0 || 1; } if ("zoom" in params) { var zoomArgs = params.zoom.split(","); var zoomArg = zoomArgs[0]; var zoomArgNumber = parseFloat(zoomArg); if (!zoomArg.includes("Fit")) { dest = [null, { name: "XYZ" }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null, zoomArgs.length > 2 ? zoomArgs[2] | 0 : null, zoomArgNumber ? zoomArgNumber / 100 : zoomArg]; } else { if (zoomArg === "Fit" || zoomArg === "FitB") { dest = [null, { name: zoomArg }]; } else if (zoomArg === "FitH" || zoomArg === "FitBH" || zoomArg === "FitV" || zoomArg === "FitBV") { dest = [null, { name: zoomArg }, zoomArgs.length > 1 ? zoomArgs[1] | 0 : null]; } else if (zoomArg === "FitR") { if (zoomArgs.length !== 5) { console.error('PDFLinkService.setHash: Not enough parameters for "FitR".'); } else { dest = [null, { name: zoomArg }, zoomArgs[1] | 0, zoomArgs[2] | 0, zoomArgs[3] | 0, zoomArgs[4] | 0]; } } else { console.error("PDFLinkService.setHash: \"".concat(zoomArg, "\" is not ") + "a valid zoom value."); } } } if (dest) { this.pdfViewer.scrollPageIntoView({ pageNumber: pageNumber || this.page, destArray: dest, allowNegativeOffset: true }); } else if (pageNumber) { this.page = pageNumber; } if ("pagemode" in params) { this.eventBus.dispatch("pagemode", { source: this, mode: params.pagemode }); } if ("nameddest" in params) { this.navigateTo(params.nameddest); } } else { dest = unescape(hash); try { dest = JSON.parse(dest); if (!Array.isArray(dest)) { dest = dest.toString(); } } catch (ex) {} if (typeof dest === "string" || isValidExplicitDestination(dest)) { this.navigateTo(dest); return; } console.error("PDFLinkService.setHash: \"".concat(unescape(hash), "\" is not ") + "a valid destination."); } } }, { key: "executeNamedAction", value: function executeNamedAction(action) { switch (action) { case "GoBack": if (this.pdfHistory) { this.pdfHistory.back(); } break; case "GoForward": if (this.pdfHistory) { this.pdfHistory.forward(); } break; case "NextPage": if (this.page < this.pagesCount) { this.page++; } break; case "PrevPage": if (this.page > 1) { this.page--; } break; case "LastPage": this.page = this.pagesCount; break; case "FirstPage": this.page = 1; break; default: break; } this.eventBus.dispatch("namedaction", { source: this, action: action }); } }, { key: "cachePageRef", value: function cachePageRef(pageNum, pageRef) { if (!pageRef) { return; } var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen); this._pagesRefCache[refStr] = pageNum; } }, { key: "_cachedPageNumber", value: function _cachedPageNumber(pageRef) { var refStr = pageRef.gen === 0 ? "".concat(pageRef.num, "R") : "".concat(pageRef.num, "R").concat(pageRef.gen); return this._pagesRefCache && this._pagesRefCache[refStr] || null; } }, { key: "isPageVisible", value: function isPageVisible(pageNumber) { return this.pdfViewer.isPageVisible(pageNumber); } }, { key: "pagesCount", get: function get() { return this.pdfDocument ? this.pdfDocument.numPages : 0; } }, { key: "page", get: function get() { return this.pdfViewer.currentPageNumber; }, set: function set(value) { this.pdfViewer.currentPageNumber = value; } }, { key: "rotation", get: function get() { return this.pdfViewer.pagesRotation; }, set: function set(value) { this.pdfViewer.pagesRotation = value; } }]); return PDFLinkService; }(); exports.PDFLinkService = PDFLinkService; function isValidExplicitDestination(dest) { if (!Array.isArray(dest)) { return false; } var destLength = dest.length; if (destLength < 2) { return false; } var page = dest[0]; if (!(_typeof(page) === "object" && Number.isInteger(page.num) && Number.isInteger(page.gen)) && !(Number.isInteger(page) && page >= 0)) { return false; } var zoom = dest[1]; if (!(_typeof(zoom) === "object" && typeof zoom.name === "string")) { return false; } var allowNull = true; switch (zoom.name) { case "XYZ": if (destLength !== 5) { return false; } break; case "Fit": case "FitB": return destLength === 2; case "FitH": case "FitBH": case "FitV": case "FitBV": if (destLength !== 3) { return false; } break; case "FitR": if (destLength !== 6) { return false; } allowNull = false; break; default: return false; } for (var i = 2; i < destLength; i++) { var param = dest[i]; if (!(typeof param === "number" || allowNull && param === null)) { return false; } } return true; }
var SimpleLinkService = /*#__PURE__*/function () {
function SimpleLinkService() { _classCallCheck(this, SimpleLinkService); this.externalLinkTarget = null; this.externalLinkRel = null; this.externalLinkEnabled = true; this._ignoreDestinationZoom = false; } _createClass(SimpleLinkService, [{ key: "navigateTo", value: function navigateTo(dest) {} }, { key: "getDestinationHash", value: function getDestinationHash(dest) { return "#"; } }, { key: "getAnchorUrl", value: function getAnchorUrl(hash) { return "#"; } }, { key: "setHash", value: function setHash(hash) {} }, { key: "executeNamedAction", value: function executeNamedAction(action) {} }, { key: "cachePageRef", value: function cachePageRef(pageNum, pageRef) {} }, { key: "isPageVisible", value: function isPageVisible(pageNumber) { return true; } }, { key: "pagesCount", get: function get() { return 0; } }, { key: "page", get: function get() { return 0; }, set: function set(value) {} }, { key: "rotation", get: function get() { return 0; }, set: function set(value) {} }]); return SimpleLinkService; }(); exports.SimpleLinkService = SimpleLinkService;
/***/ }),
/* 8 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.DefaultTextLayerFactory = exports.TextLayerBuilder = void 0; var _pdfjsLib = __w_pdfjs_require__(2); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var EXPAND_DIVS_TIMEOUT = 300;
var TextLayerBuilder = /*#__PURE__*/function () {
function TextLayerBuilder(_ref) { var textLayerDiv = _ref.textLayerDiv, eventBus = _ref.eventBus, pageIndex = _ref.pageIndex, viewport = _ref.viewport, _ref$findController = _ref.findController, findController = _ref$findController === void 0 ? null : _ref$findController, _ref$enhanceTextSelec = _ref.enhanceTextSelection, enhanceTextSelection = _ref$enhanceTextSelec === void 0 ? false : _ref$enhanceTextSelec; _classCallCheck(this, TextLayerBuilder); this.textLayerDiv = textLayerDiv; this.eventBus = eventBus; this.textContent = null; this.textContentItemsStr = []; this.textContentStream = null; this.renderingDone = false; this.pageIdx = pageIndex; this.pageNumber = this.pageIdx + 1; this.matches = []; this.viewport = viewport; this.textDivs = []; this.findController = findController; this.textLayerRenderTask = null; this.enhanceTextSelection = enhanceTextSelection; this._onUpdateTextLayerMatches = null; this._bindMouse(); } _createClass(TextLayerBuilder, [{ key: "_finishRendering", value: function _finishRendering() { this.renderingDone = true; if (!this.enhanceTextSelection) { var endOfContent = document.createElement("div"); endOfContent.className = "endOfContent"; this.textLayerDiv.appendChild(endOfContent); } this.eventBus.dispatch("textlayerrendered", { source: this, pageNumber: this.pageNumber, numTextDivs: this.textDivs.length }); } }, { key: "render", value: function render() { var _this = this; var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0; if (!(this.textContent || this.textContentStream) || this.renderingDone) { return; } this.cancel(); this.textDivs = []; var textLayerFrag = document.createDocumentFragment(); this.textLayerRenderTask = (0, _pdfjsLib.renderTextLayer)({ textContent: this.textContent, textContentStream: this.textContentStream, container: textLayerFrag, viewport: this.viewport, textDivs: this.textDivs, textContentItemsStr: this.textContentItemsStr, timeout: timeout, enhanceTextSelection: this.enhanceTextSelection }); this.textLayerRenderTask.promise.then(function () { _this.textLayerDiv.appendChild(textLayerFrag); _this._finishRendering(); _this._updateMatches(); }, function (reason) {}); if (!this._onUpdateTextLayerMatches) { this._onUpdateTextLayerMatches = function (evt) { if (evt.pageIndex === _this.pageIdx || evt.pageIndex === -1) { _this._updateMatches(); } }; this.eventBus._on("updatetextlayermatches", this._onUpdateTextLayerMatches); } } }, { key: "cancel", value: function cancel() { if (this.textLayerRenderTask) { this.textLayerRenderTask.cancel(); this.textLayerRenderTask = null; } if (this._onUpdateTextLayerMatches) { this.eventBus._off("updatetextlayermatches", this._onUpdateTextLayerMatches); this._onUpdateTextLayerMatches = null; } } }, { key: "setTextContentStream", value: function setTextContentStream(readableStream) { this.cancel(); this.textContentStream = readableStream; } }, { key: "setTextContent", value: function setTextContent(textContent) { this.cancel(); this.textContent = textContent; } }, { key: "_convertMatches", value: function _convertMatches(matches, matchesLength) { if (!matches) { return []; } var findController = this.findController, textContentItemsStr = this.textContentItemsStr; var i = 0, iIndex = 0; var end = textContentItemsStr.length - 1; var queryLen = findController.state.query.length; var result = []; for (var m = 0, mm = matches.length; m < mm; m++) { var matchIdx = matches[m]; while (i !== end && matchIdx >= iIndex + textContentItemsStr[i].length) { iIndex += textContentItemsStr[i].length; i++; } if (i === textContentItemsStr.length) { console.error("Could not find a matching mapping"); } var match = { begin: { divIdx: i, offset: matchIdx - iIndex } }; if (matchesLength) { matchIdx += matchesLength[m]; } else { matchIdx += queryLen; } while (i !== end && matchIdx > iIndex + textContentItemsStr[i].length) { iIndex += textContentItemsStr[i].length; i++; } match.end = { divIdx: i, offset: matchIdx - iIndex }; result.push(match); } return result; } }, { key: "_renderMatches", value: function _renderMatches(matches) { if (matches.length === 0) { return; } var findController = this.findController, pageIdx = this.pageIdx, textContentItemsStr = this.textContentItemsStr, textDivs = this.textDivs; var isSelectedPage = pageIdx === findController.selected.pageIdx; var selectedMatchIdx = findController.selected.matchIdx; var highlightAll = findController.state.highlightAll; var prevEnd = null; var infinity = { divIdx: -1, offset: undefined }; function beginText(begin, className) { var divIdx = begin.divIdx; textDivs[divIdx].textContent = ""; appendTextToDiv(divIdx, 0, begin.offset, className); } function appendTextToDiv(divIdx, fromOffset, toOffset, className) { var div = textDivs[divIdx]; var content = textContentItemsStr[divIdx].substring(fromOffset, toOffset); var node = document.createTextNode(content); if (className) { var span = document.createElement("span"); span.className = className; span.appendChild(node); div.appendChild(span); return; } div.appendChild(node); } var i0 = selectedMatchIdx, i1 = i0 + 1; if (highlightAll) { i0 = 0; i1 = matches.length; } else if (!isSelectedPage) { return; } for (var i = i0; i < i1; i++) { var match = matches[i]; var begin = match.begin; var end = match.end; var isSelected = isSelectedPage && i === selectedMatchIdx; var highlightSuffix = isSelected ? " selected" : ""; if (isSelected) { findController.scrollMatchIntoView({ element: textDivs[begin.divIdx], pageIndex: pageIdx, matchIndex: selectedMatchIdx }); } if (!prevEnd || begin.divIdx !== prevEnd.divIdx) { if (prevEnd !== null) { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset); } beginText(begin); } else { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, begin.offset); } if (begin.divIdx === end.divIdx) { appendTextToDiv(begin.divIdx, begin.offset, end.offset, "highlight" + highlightSuffix); } else { appendTextToDiv(begin.divIdx, begin.offset, infinity.offset, "highlight begin" + highlightSuffix); for (var n0 = begin.divIdx + 1, n1 = end.divIdx; n0 < n1; n0++) { textDivs[n0].className = "highlight middle" + highlightSuffix; } beginText(end, "highlight end" + highlightSuffix); } prevEnd = end; } if (prevEnd) { appendTextToDiv(prevEnd.divIdx, prevEnd.offset, infinity.offset); } } }, { key: "_updateMatches", value: function _updateMatches() { if (!this.renderingDone) { return; } var findController = this.findController, matches = this.matches, pageIdx = this.pageIdx, textContentItemsStr = this.textContentItemsStr, textDivs = this.textDivs; var clearedUntilDivIdx = -1; for (var i = 0, ii = matches.length; i < ii; i++) { var match = matches[i]; var begin = Math.max(clearedUntilDivIdx, match.begin.divIdx); for (var n = begin, end = match.end.divIdx; n <= end; n++) { var div = textDivs[n]; div.textContent = textContentItemsStr[n]; div.className = ""; } clearedUntilDivIdx = match.end.divIdx + 1; } if (!findController || !findController.highlightMatches) { return; } var pageMatches = findController.pageMatches[pageIdx] || null; var pageMatchesLength = findController.pageMatchesLength[pageIdx] || null; this.matches = this._convertMatches(pageMatches, pageMatchesLength); this._renderMatches(this.matches); } }, { key: "_bindMouse", value: function _bindMouse() { var _this2 = this; var div = this.textLayerDiv; var expandDivsTimer = null; div.addEventListener("mousedown", function (evt) { if (_this2.enhanceTextSelection && _this2.textLayerRenderTask) { _this2.textLayerRenderTask.expandTextDivs(true); if (expandDivsTimer) { clearTimeout(expandDivsTimer); expandDivsTimer = null; } return; } var end = div.querySelector(".endOfContent"); if (!end) { return; } var adjustTop = evt.target !== div; adjustTop = adjustTop && window.getComputedStyle(end).getPropertyValue("-moz-user-select") !== "none"; if (adjustTop) { var divBounds = div.getBoundingClientRect(); var r = Math.max(0, (evt.pageY - divBounds.top) / divBounds.height); end.style.top = (r * 100).toFixed(2) + "%"; } end.classList.add("active"); }); div.addEventListener("mouseup", function () { if (_this2.enhanceTextSelection && _this2.textLayerRenderTask) { expandDivsTimer = setTimeout(function () { if (_this2.textLayerRenderTask) { _this2.textLayerRenderTask.expandTextDivs(false); } expandDivsTimer = null; }, EXPAND_DIVS_TIMEOUT); return; } var end = div.querySelector(".endOfContent"); if (!end) { return; } end.style.top = ""; end.classList.remove("active"); }); } }]); return TextLayerBuilder; }(); exports.TextLayerBuilder = TextLayerBuilder;
var DefaultTextLayerFactory = /*#__PURE__*/function () {
function DefaultTextLayerFactory() { _classCallCheck(this, DefaultTextLayerFactory); } _createClass(DefaultTextLayerFactory, [{ key: "createTextLayerBuilder", value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) { var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; var eventBus = arguments.length > 4 ? arguments[4] : undefined; return new TextLayerBuilder({ textLayerDiv: textLayerDiv, pageIndex: pageIndex, viewport: viewport, enhanceTextSelection: enhanceTextSelection, eventBus: eventBus }); } }]); return DefaultTextLayerFactory; }(); exports.DefaultTextLayerFactory = DefaultTextLayerFactory;
/***/ }),
/* 9 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.DownloadManager = void 0; var _pdfjsLib = __w_pdfjs_require__(2); var _viewer_compatibility = __w_pdfjs_require__(10); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
; var DISABLE_CREATE_OBJECT_URL = _viewer_compatibility.viewerCompatibilityParams.disableCreateObjectURL || false; function _download(blobUrl, filename) { var a = document.createElement("a"); if (!a.click) { throw new Error('DownloadManager: "a.click()" is not supported.'); } a.href = blobUrl; a.target = "_parent"; if ("download" in a) { a.download = filename; } (document.body || document.documentElement).appendChild(a); a.click(); a.remove(); }
var DownloadManager = /*#__PURE__*/function () {
function DownloadManager(_ref) { var _ref$disableCreateObj = _ref.disableCreateObjectURL, disableCreateObjectURL = _ref$disableCreateObj === void 0 ? DISABLE_CREATE_OBJECT_URL : _ref$disableCreateObj; _classCallCheck(this, DownloadManager); this.disableCreateObjectURL = disableCreateObjectURL; } _createClass(DownloadManager, [{ key: "downloadUrl", value: function downloadUrl(url, filename) {
if (!(0, _pdfjsLib.createValidAbsoluteUrl)(url, "http://example.com")) {
return; } _download(url + "#pdfjs.action=download", filename); } }, { key: "downloadData", value: function downloadData(data, filename, contentType) { if (navigator.msSaveBlob) { navigator.msSaveBlob(new Blob([data], { type: contentType }), filename); return; } var blobUrl = (0, _pdfjsLib.createObjectURL)(data, contentType, this.disableCreateObjectURL); _download(blobUrl, filename); } }, { key: "download", value: function download(blob, url, filename) { if (navigator.msSaveBlob) { if (!navigator.msSaveBlob(blob, filename)) { this.downloadUrl(url, filename); } return; } if (this.disableCreateObjectURL) { this.downloadUrl(url, filename); return; } var blobUrl = URL.createObjectURL(blob); _download(blobUrl, filename); } }]); return DownloadManager; }(); exports.DownloadManager = DownloadManager;
/***/ }),
/* 10 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.viewerCompatibilityParams = void 0; var compatibilityParams = Object.create(null); { var userAgent = typeof navigator !== "undefined" && navigator.userAgent || ""; var platform = typeof navigator !== "undefined" && navigator.platform || ""; var maxTouchPoints = typeof navigator !== "undefined" && navigator.maxTouchPoints || 1; var isAndroid = /Android/.test(userAgent); var isIE = /Trident/.test(userAgent); var isIOS = /\b(iPad|iPhone|iPod)(?=;)/.test(userAgent) || platform === "MacIntel" && maxTouchPoints > 1; var isIOSChrome = /CriOS/.test(userAgent); (function checkOnBlobSupport() { if (isIE || isIOSChrome) { compatibilityParams.disableCreateObjectURL = true; } })(); (function checkCanvasSizeLimitation() { if (isIOS || isAndroid) { compatibilityParams.maxCanvasPixels = 5242880; } })(); } var viewerCompatibilityParams = Object.freeze(compatibilityParams); exports.viewerCompatibilityParams = viewerCompatibilityParams;
/***/ }),
/* 11 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.GenericL10n = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(4)); __w_pdfjs_require__(12); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var webL10n = document.webL10n;
var GenericL10n = /*#__PURE__*/function () {
function GenericL10n(lang) { _classCallCheck(this, GenericL10n); this._lang = lang; this._ready = new Promise(function (resolve, reject) { webL10n.setLanguage(lang, function () { resolve(webL10n); }); }); } _createClass(GenericL10n, [{ key: "getLanguage", value: function () {
var _getLanguage = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
var l10n; return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: _context.next = 2; return this._ready; case 2: l10n = _context.sent; return _context.abrupt("return", l10n.getLanguage()); case 4: case "end": return _context.stop(); } } }, _callee, this); })); function getLanguage() { return _getLanguage.apply(this, arguments); } return getLanguage; }() }, { key: "getDirection", value: function () {
var _getDirection = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
var l10n; return _regenerator["default"].wrap(function _callee2$(_context2) { while (1) { switch (_context2.prev = _context2.next) { case 0: _context2.next = 2; return this._ready; case 2: l10n = _context2.sent; return _context2.abrupt("return", l10n.getDirection()); case 4: case "end": return _context2.stop(); } } }, _callee2, this); })); function getDirection() { return _getDirection.apply(this, arguments); } return getDirection; }() }, { key: "get", value: function () {
var _get = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee3(property, args, fallback) {
var l10n; return _regenerator["default"].wrap(function _callee3$(_context3) { while (1) { switch (_context3.prev = _context3.next) { case 0: _context3.next = 2; return this._ready; case 2: l10n = _context3.sent; return _context3.abrupt("return", l10n.get(property, args, fallback)); case 4: case "end": return _context3.stop(); } } }, _callee3, this); })); function get(_x, _x2, _x3) { return _get.apply(this, arguments); } return get; }() }, { key: "translate", value: function () {
var _translate = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee4(element) {
var l10n; return _regenerator["default"].wrap(function _callee4$(_context4) { while (1) { switch (_context4.prev = _context4.next) { case 0: _context4.next = 2; return this._ready; case 2: l10n = _context4.sent; return _context4.abrupt("return", l10n.translate(element)); case 4: case "end": return _context4.stop(); } } }, _callee4, this); })); function translate(_x4) { return _translate.apply(this, arguments); } return translate; }() }]); return GenericL10n; }(); exports.GenericL10n = GenericL10n;
/***/ }),
/* 12 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; document.webL10n = function (window, document, undefined) { var gL10nData = {}; var gTextData = ''; var gTextProp = 'textContent'; var gLanguage = ''; var gMacros = {}; var gReadyState = 'loading'; var gAsyncResourceLoading = true; function getL10nResourceLinks() { return document.querySelectorAll('link[type="application/l10n"]'); } function getL10nDictionary() { var script = document.querySelector('script[type="application/l10n"]'); return script ? JSON.parse(script.innerHTML) : null; } function getTranslatableChildren(element) { return element ? element.querySelectorAll('*[data-l10n-id]') : []; } function getL10nAttributes(element) { if (!element) return {}; var l10nId = element.getAttribute('data-l10n-id'); var l10nArgs = element.getAttribute('data-l10n-args'); var args = {}; if (l10nArgs) { try { args = JSON.parse(l10nArgs); } catch (e) { console.warn('could not parse arguments for #' + l10nId); } } return { id: l10nId, args: args }; } function xhrLoadText(url, onSuccess, onFailure) { onSuccess = onSuccess || function _onSuccess(data) {}; onFailure = onFailure || function _onFailure() {}; var xhr = new XMLHttpRequest(); xhr.open('GET', url, gAsyncResourceLoading); if (xhr.overrideMimeType) { xhr.overrideMimeType('text/plain; charset=utf-8'); } xhr.onreadystatechange = function () { if (xhr.readyState == 4) { if (xhr.status == 200 || xhr.status === 0) { onSuccess(xhr.responseText); } else { onFailure(); } } }; xhr.onerror = onFailure; xhr.ontimeout = onFailure; try { xhr.send(null); } catch (e) { onFailure(); } } function parseResource(href, lang, successCallback, failureCallback) { var baseURL = href.replace(/[^\/]*$/, '') || './'; function evalString(text) { if (text.lastIndexOf('\\') < 0) return text;
return text.replace(/\\\\/g, '\\').replace(/\\n/g, '\n').replace(/\\r/g, '\r').replace(/\\t/g, '\t').replace(/\\b/g, '\b').replace(/\\f/g, '\f').replace(/\\{/g, '{').replace(/\\}/g, '}').replace(/\\"/g, '"').replace(/\\'/g, "'");
} function parseProperties(text, parsedPropertiesCallback) { var dictionary = {}; var reBlank = /^\s*|\s*$/; var reComment = /^\s*#|^\s*$/; var reSection = /^\s*\[(.*)\]\s*$/; var reImport = /^\s*@import\s+url\((.*)\)\s*$/i; var reSplit = /^([^=\s]*)\s*=\s*(.+)$/; function parseRawLines(rawText, extendedSyntax, parsedRawLinesCallback) { var entries = rawText.replace(reBlank, '').split(/[\r\n]+/); var currentLang = '*'; var genericLang = lang.split('-', 1)[0]; var skipLang = false; var match = ''; function nextEntry() { while (true) { if (!entries.length) { parsedRawLinesCallback(); return; } var line = entries.shift(); if (reComment.test(line)) continue; if (extendedSyntax) { match = reSection.exec(line); if (match) { currentLang = match[1].toLowerCase(); skipLang = currentLang !== '*' && currentLang !== lang && currentLang !== genericLang; continue; } else if (skipLang) { continue; } match = reImport.exec(line); if (match) { loadImport(baseURL + match[1], nextEntry); return; } } var tmp = line.match(reSplit); if (tmp && tmp.length == 3) { dictionary[tmp[1]] = evalString(tmp[2]); } } } nextEntry(); } function loadImport(url, callback) { xhrLoadText(url, function (content) { parseRawLines(content, false, callback); }, function () { console.warn(url + ' not found.'); callback(); }); } parseRawLines(text, true, function () { parsedPropertiesCallback(dictionary); }); } xhrLoadText(href, function (response) { gTextData += response; parseProperties(response, function (data) { for (var key in data) { var id, prop, index = key.lastIndexOf('.'); if (index > 0) { id = key.substring(0, index); prop = key.substring(index + 1); } else { id = key; prop = gTextProp; } if (!gL10nData[id]) { gL10nData[id] = {}; } gL10nData[id][prop] = data[key]; } if (successCallback) { successCallback(); } }); }, failureCallback); } function loadLocale(lang, callback) { if (lang) { lang = lang.toLowerCase(); } callback = callback || function _callback() {}; clear(); gLanguage = lang; var langLinks = getL10nResourceLinks(); var langCount = langLinks.length; if (langCount === 0) { var dict = getL10nDictionary(); if (dict && dict.locales && dict.default_locale) { console.log('using the embedded JSON directory, early way out'); gL10nData = dict.locales[lang]; if (!gL10nData) { var defaultLocale = dict.default_locale.toLowerCase(); for (var anyCaseLang in dict.locales) { anyCaseLang = anyCaseLang.toLowerCase(); if (anyCaseLang === lang) { gL10nData = dict.locales[lang]; break; } else if (anyCaseLang === defaultLocale) { gL10nData = dict.locales[defaultLocale]; } } } callback(); } else { console.log('no resource to load, early way out'); } gReadyState = 'complete'; return; } var onResourceLoaded = null; var gResourceCount = 0; onResourceLoaded = function onResourceLoaded() { gResourceCount++; if (gResourceCount >= langCount) { callback(); gReadyState = 'complete'; } }; function L10nResourceLink(link) { var href = link.href; this.load = function (lang, callback) { parseResource(href, lang, callback, function () { console.warn(href + ' not found.'); console.warn('"' + lang + '" resource not found'); gLanguage = ''; callback(); }); }; } for (var i = 0; i < langCount; i++) { var resource = new L10nResourceLink(langLinks[i]); resource.load(lang, onResourceLoaded); } } function clear() { gL10nData = {}; gTextData = ''; gLanguage = ''; } function getPluralRules(lang) { var locales2rules = { 'af': 3, 'ak': 4, 'am': 4, 'ar': 1, 'asa': 3, 'az': 0, 'be': 11, 'bem': 3, 'bez': 3, 'bg': 3, 'bh': 4, 'bm': 0, 'bn': 3, 'bo': 0, 'br': 20, 'brx': 3, 'bs': 11, 'ca': 3, 'cgg': 3, 'chr': 3, 'cs': 12, 'cy': 17, 'da': 3, 'de': 3, 'dv': 3, 'dz': 0, 'ee': 3, 'el': 3, 'en': 3, 'eo': 3, 'es': 3, 'et': 3, 'eu': 3, 'fa': 0, 'ff': 5, 'fi': 3, 'fil': 4, 'fo': 3, 'fr': 5, 'fur': 3, 'fy': 3, 'ga': 8, 'gd': 24, 'gl': 3, 'gsw': 3, 'gu': 3, 'guw': 4, 'gv': 23, 'ha': 3, 'haw': 3, 'he': 2, 'hi': 4, 'hr': 11, 'hu': 0, 'id': 0, 'ig': 0, 'ii': 0, 'is': 3, 'it': 3, 'iu': 7, 'ja': 0, 'jmc': 3, 'jv': 0, 'ka': 0, 'kab': 5, 'kaj': 3, 'kcg': 3, 'kde': 0, 'kea': 0, 'kk': 3, 'kl': 3, 'km': 0, 'kn': 0, 'ko': 0, 'ksb': 3, 'ksh': 21, 'ku': 3, 'kw': 7, 'lag': 18, 'lb': 3, 'lg': 3, 'ln': 4, 'lo': 0, 'lt': 10, 'lv': 6, 'mas': 3, 'mg': 4, 'mk': 16, 'ml': 3, 'mn': 3, 'mo': 9, 'mr': 3, 'ms': 0, 'mt': 15, 'my': 0, 'nah': 3, 'naq': 7, 'nb': 3, 'nd': 3, 'ne': 3, 'nl': 3, 'nn': 3, 'no': 3, 'nr': 3, 'nso': 4, 'ny': 3, 'nyn': 3, 'om': 3, 'or': 3, 'pa': 3, 'pap': 3, 'pl': 13, 'ps': 3, 'pt': 3, 'rm': 3, 'ro': 9, 'rof': 3, 'ru': 11, 'rwk': 3, 'sah': 0, 'saq': 3, 'se': 7, 'seh': 3, 'ses': 0, 'sg': 0, 'sh': 11, 'shi': 19, 'sk': 12, 'sl': 14, 'sma': 7, 'smi': 7, 'smj': 7, 'smn': 7, 'sms': 7, 'sn': 3, 'so': 3, 'sq': 3, 'sr': 11, 'ss': 3, 'ssy': 3, 'st': 3, 'sv': 3, 'sw': 3, 'syr': 3, 'ta': 3, 'te': 3, 'teo': 3, 'th': 0, 'ti': 4, 'tig': 3, 'tk': 3, 'tl': 4, 'tn': 3, 'to': 0, 'tr': 0, 'ts': 3, 'tzm': 22, 'uk': 11, 'ur': 3, 've': 3, 'vi': 0, 'vun': 3, 'wa': 4, 'wae': 3, 'wo': 0, 'xh': 3, 'xog': 3, 'yo': 0, 'zh': 0, 'zu': 3 }; function isIn(n, list) { return list.indexOf(n) !== -1; } function isBetween(n, start, end) { return start <= n && n <= end; } var pluralRules = { '0': function _(n) { return 'other'; }, '1': function _(n) { if (isBetween(n % 100, 3, 10)) return 'few'; if (n === 0) return 'zero'; if (isBetween(n % 100, 11, 99)) return 'many'; if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '2': function _(n) { if (n !== 0 && n % 10 === 0) return 'many'; if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '3': function _(n) { if (n == 1) return 'one'; return 'other'; }, '4': function _(n) { if (isBetween(n, 0, 1)) return 'one'; return 'other'; }, '5': function _(n) { if (isBetween(n, 0, 2) && n != 2) return 'one'; return 'other'; }, '6': function _(n) { if (n === 0) return 'zero'; if (n % 10 == 1 && n % 100 != 11) return 'one'; return 'other'; }, '7': function _(n) { if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '8': function _(n) { if (isBetween(n, 3, 6)) return 'few'; if (isBetween(n, 7, 10)) return 'many'; if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '9': function _(n) { if (n === 0 || n != 1 && isBetween(n % 100, 1, 19)) return 'few'; if (n == 1) return 'one'; return 'other'; }, '10': function _(n) { if (isBetween(n % 10, 2, 9) && !isBetween(n % 100, 11, 19)) return 'few'; if (n % 10 == 1 && !isBetween(n % 100, 11, 19)) return 'one'; return 'other'; }, '11': function _(n) { if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few'; if (n % 10 === 0 || isBetween(n % 10, 5, 9) || isBetween(n % 100, 11, 14)) return 'many'; if (n % 10 == 1 && n % 100 != 11) return 'one'; return 'other'; }, '12': function _(n) { if (isBetween(n, 2, 4)) return 'few'; if (n == 1) return 'one'; return 'other'; }, '13': function _(n) { if (isBetween(n % 10, 2, 4) && !isBetween(n % 100, 12, 14)) return 'few'; if (n != 1 && isBetween(n % 10, 0, 1) || isBetween(n % 10, 5, 9) || isBetween(n % 100, 12, 14)) return 'many'; if (n == 1) return 'one'; return 'other'; }, '14': function _(n) { if (isBetween(n % 100, 3, 4)) return 'few'; if (n % 100 == 2) return 'two'; if (n % 100 == 1) return 'one'; return 'other'; }, '15': function _(n) { if (n === 0 || isBetween(n % 100, 2, 10)) return 'few'; if (isBetween(n % 100, 11, 19)) return 'many'; if (n == 1) return 'one'; return 'other'; }, '16': function _(n) { if (n % 10 == 1 && n != 11) return 'one'; return 'other'; }, '17': function _(n) { if (n == 3) return 'few'; if (n === 0) return 'zero'; if (n == 6) return 'many'; if (n == 2) return 'two'; if (n == 1) return 'one'; return 'other'; }, '18': function _(n) { if (n === 0) return 'zero'; if (isBetween(n, 0, 2) && n !== 0 && n != 2) return 'one'; return 'other'; }, '19': function _(n) { if (isBetween(n, 2, 10)) return 'few'; if (isBetween(n, 0, 1)) return 'one'; return 'other'; }, '20': function _(n) { if ((isBetween(n % 10, 3, 4) || n % 10 == 9) && !(isBetween(n % 100, 10, 19) || isBetween(n % 100, 70, 79) || isBetween(n % 100, 90, 99))) return 'few'; if (n % 1000000 === 0 && n !== 0) return 'many'; if (n % 10 == 2 && !isIn(n % 100, [12, 72, 92])) return 'two'; if (n % 10 == 1 && !isIn(n % 100, [11, 71, 91])) return 'one'; return 'other'; }, '21': function _(n) { if (n === 0) return 'zero'; if (n == 1) return 'one'; return 'other'; }, '22': function _(n) { if (isBetween(n, 0, 1) || isBetween(n, 11, 99)) return 'one'; return 'other'; }, '23': function _(n) { if (isBetween(n % 10, 1, 2) || n % 20 === 0) return 'one'; return 'other'; }, '24': function _(n) { if (isBetween(n, 3, 10) || isBetween(n, 13, 19)) return 'few'; if (isIn(n, [2, 12])) return 'two'; if (isIn(n, [1, 11])) return 'one'; return 'other'; } }; var index = locales2rules[lang.replace(/-.*$/, '')]; if (!(index in pluralRules)) { console.warn('plural form unknown for [' + lang + ']'); return function () { return 'other'; }; } return pluralRules[index]; } gMacros.plural = function (str, param, key, prop) { var n = parseFloat(param); if (isNaN(n)) return str; if (prop != gTextProp) return str; if (!gMacros._pluralRules) { gMacros._pluralRules = getPluralRules(gLanguage); } var index = '[' + gMacros._pluralRules(n) + ']'; if (n === 0 && key + '[zero]' in gL10nData) { str = gL10nData[key + '[zero]'][prop]; } else if (n == 1 && key + '[one]' in gL10nData) { str = gL10nData[key + '[one]'][prop]; } else if (n == 2 && key + '[two]' in gL10nData) { str = gL10nData[key + '[two]'][prop]; } else if (key + index in gL10nData) { str = gL10nData[key + index][prop]; } else if (key + '[other]' in gL10nData) { str = gL10nData[key + '[other]'][prop]; } return str; }; function getL10nData(key, args, fallback) { var data = gL10nData[key]; if (!data) { console.warn('#' + key + ' is undefined.'); if (!fallback) { return null; } data = fallback; } var rv = {}; for (var prop in data) { var str = data[prop]; str = substIndexes(str, args, key, prop); str = substArguments(str, args, key); rv[prop] = str; } return rv; } function substIndexes(str, args, key, prop) { var reIndex = /\{\[\s*([a-zA-Z]+)\(([a-zA-Z]+)\)\s*\]\}/; var reMatch = reIndex.exec(str); if (!reMatch || !reMatch.length) return str; var macroName = reMatch[1]; var paramName = reMatch[2]; var param; if (args && paramName in args) { param = args[paramName]; } else if (paramName in gL10nData) { param = gL10nData[paramName]; } if (macroName in gMacros) { var macro = gMacros[macroName]; str = macro(str, param, key, prop); } return str; } function substArguments(str, args, key) { var reArgs = /\{\{\s*(.+?)\s*\}\}/g; return str.replace(reArgs, function (matched_text, arg) { if (args && arg in args) { return args[arg]; } if (arg in gL10nData) { return gL10nData[arg]; } console.log('argument {{' + arg + '}} for #' + key + ' is undefined.'); return matched_text; }); } function translateElement(element) { var l10n = getL10nAttributes(element); if (!l10n.id) return; var data = getL10nData(l10n.id, l10n.args); if (!data) { console.warn('#' + l10n.id + ' is undefined.'); return; } if (data[gTextProp]) { if (getChildElementCount(element) === 0) { element[gTextProp] = data[gTextProp]; } else { var children = element.childNodes; var found = false; for (var i = 0, l = children.length; i < l; i++) { if (children[i].nodeType === 3 && /\S/.test(children[i].nodeValue)) { if (found) { children[i].nodeValue = ''; } else { children[i].nodeValue = data[gTextProp]; found = true; } } } if (!found) { var textNode = document.createTextNode(data[gTextProp]); element.insertBefore(textNode, element.firstChild); } } delete data[gTextProp]; } for (var k in data) { element[k] = data[k]; } } function getChildElementCount(element) { if (element.children) { return element.children.length; } if (typeof element.childElementCount !== 'undefined') { return element.childElementCount; } var count = 0; for (var i = 0; i < element.childNodes.length; i++) { count += element.nodeType === 1 ? 1 : 0; } return count; } function translateFragment(element) { element = element || document.documentElement; var children = getTranslatableChildren(element); var elementCount = children.length; for (var i = 0; i < elementCount; i++) { translateElement(children[i]); } translateElement(element); } return { get: function get(key, args, fallbackString) { var index = key.lastIndexOf('.'); var prop = gTextProp; if (index > 0) { prop = key.substring(index + 1); key = key.substring(0, index); } var fallback; if (fallbackString) { fallback = {}; fallback[prop] = fallbackString; } var data = getL10nData(key, args, fallback); if (data && prop in data) { return data[prop]; } return '{{' + key + '}}'; }, getData: function getData() { return gL10nData; }, getText: function getText() { return gTextData; }, getLanguage: function getLanguage() { return gLanguage; }, setLanguage: function setLanguage(lang, callback) { loadLocale(lang, function () { if (callback) callback(); }); }, getDirection: function getDirection() { var rtlList = ['ar', 'he', 'fa', 'ps', 'ur']; var shortCode = gLanguage.split('-', 1)[0]; return rtlList.indexOf(shortCode) >= 0 ? 'rtl' : 'ltr'; }, translate: translateFragment, getReadyState: function getReadyState() { return gReadyState; }, ready: function ready(callback) { if (!callback) { return; } else if (gReadyState == 'complete' || gReadyState == 'interactive') { window.setTimeout(function () { callback(); }); } else if (document.addEventListener) { document.addEventListener('localized', function once() { document.removeEventListener('localized', once); callback(); }); } } }; }(window, document);
/***/ }),
/* 13 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFFindController = exports.FindState = void 0; var _pdfjsLib = __w_pdfjs_require__(2); var _pdf_find_utils = __w_pdfjs_require__(14); var _ui_utils = __w_pdfjs_require__(3); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var FindState = { FOUND: 0, NOT_FOUND: 1, WRAPPED: 2, PENDING: 3 }; exports.FindState = FindState; var FIND_TIMEOUT = 250; var MATCH_SCROLL_OFFSET_TOP = -50; var MATCH_SCROLL_OFFSET_LEFT = -400; var CHARACTERS_TO_NORMALIZE = { "\u2018": "'", "\u2019": "'", "\u201A": "'", "\u201B": "'", "\u201C": '"', "\u201D": '"', "\u201E": '"', "\u201F": '"', "\xBC": "1/4", "\xBD": "1/2", "\xBE": "3/4" }; var normalizationRegex = null; function normalize(text) { if (!normalizationRegex) { var replace = Object.keys(CHARACTERS_TO_NORMALIZE).join(""); normalizationRegex = new RegExp("[".concat(replace, "]"), "g"); } return text.replace(normalizationRegex, function (ch) { return CHARACTERS_TO_NORMALIZE[ch]; }); }
var PDFFindController = /*#__PURE__*/function () {
function PDFFindController(_ref) { var linkService = _ref.linkService, eventBus = _ref.eventBus; _classCallCheck(this, PDFFindController); this._linkService = linkService; this._eventBus = eventBus; this._reset(); eventBus._on("findbarclose", this._onFindBarClose.bind(this)); } _createClass(PDFFindController, [{ key: "setDocument", value: function setDocument(pdfDocument) { if (this._pdfDocument) { this._reset(); } if (!pdfDocument) { return; } this._pdfDocument = pdfDocument; this._firstPageCapability.resolve(); } }, { key: "executeCommand", value: function executeCommand(cmd, state) { var _this = this; if (!state) { return; } var pdfDocument = this._pdfDocument; if (this._state === null || this._shouldDirtyMatch(cmd, state)) { this._dirtyMatch = true; } this._state = state; if (cmd !== "findhighlightallchange") { this._updateUIState(FindState.PENDING); } this._firstPageCapability.promise.then(function () { if (!_this._pdfDocument || pdfDocument && _this._pdfDocument !== pdfDocument) { return; } _this._extractText(); var findbarClosed = !_this._highlightMatches; var pendingTimeout = !!_this._findTimeout; if (_this._findTimeout) { clearTimeout(_this._findTimeout); _this._findTimeout = null; } if (cmd === "find") { _this._findTimeout = setTimeout(function () { _this._nextMatch(); _this._findTimeout = null; }, FIND_TIMEOUT); } else if (_this._dirtyMatch) { _this._nextMatch(); } else if (cmd === "findagain") { _this._nextMatch(); if (findbarClosed && _this._state.highlightAll) { _this._updateAllPages(); } } else if (cmd === "findhighlightallchange") { if (pendingTimeout) { _this._nextMatch(); } else { _this._highlightMatches = true; } _this._updateAllPages(); } else { _this._nextMatch(); } }); } }, { key: "scrollMatchIntoView", value: function scrollMatchIntoView(_ref2) { var _ref2$element = _ref2.element, element = _ref2$element === void 0 ? null : _ref2$element, _ref2$pageIndex = _ref2.pageIndex, pageIndex = _ref2$pageIndex === void 0 ? -1 : _ref2$pageIndex, _ref2$matchIndex = _ref2.matchIndex, matchIndex = _ref2$matchIndex === void 0 ? -1 : _ref2$matchIndex; if (!this._scrollMatches || !element) { return; } else if (matchIndex === -1 || matchIndex !== this._selected.matchIdx) { return; } else if (pageIndex === -1 || pageIndex !== this._selected.pageIdx) { return; } this._scrollMatches = false; var spot = { top: MATCH_SCROLL_OFFSET_TOP, left: MATCH_SCROLL_OFFSET_LEFT }; (0, _ui_utils.scrollIntoView)(element, spot, true); } }, { key: "_reset", value: function _reset() { this._highlightMatches = false; this._scrollMatches = false; this._pdfDocument = null; this._pageMatches = []; this._pageMatchesLength = []; this._state = null; this._selected = { pageIdx: -1, matchIdx: -1 }; this._offset = { pageIdx: null, matchIdx: null, wrapped: false }; this._extractTextPromises = []; this._pageContents = []; this._matchesCountTotal = 0; this._pagesToSearch = null; this._pendingFindMatches = Object.create(null); this._resumePageIdx = null; this._dirtyMatch = false; clearTimeout(this._findTimeout); this._findTimeout = null; this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)(); } }, { key: "_shouldDirtyMatch", value: function _shouldDirtyMatch(cmd, state) { if (state.query !== this._state.query) { return true; } switch (cmd) { case "findagain": var pageNumber = this._selected.pageIdx + 1; var linkService = this._linkService; if (pageNumber >= 1 && pageNumber <= linkService.pagesCount && pageNumber !== linkService.page && !linkService.isPageVisible(pageNumber)) { return true; } return false; case "findhighlightallchange": return false; } return true; } }, { key: "_prepareMatches", value: function _prepareMatches(matchesWithLength, matches, matchesLength) { function isSubTerm(currentIndex) { var currentElem = matchesWithLength[currentIndex]; var nextElem = matchesWithLength[currentIndex + 1]; if (currentIndex < matchesWithLength.length - 1 && currentElem.match === nextElem.match) { currentElem.skipped = true; return true; } for (var i = currentIndex - 1; i >= 0; i--) { var prevElem = matchesWithLength[i]; if (prevElem.skipped) { continue; } if (prevElem.match + prevElem.matchLength < currentElem.match) { break; } if (prevElem.match + prevElem.matchLength >= currentElem.match + currentElem.matchLength) { currentElem.skipped = true; return true; } } return false; } matchesWithLength.sort(function (a, b) { return a.match === b.match ? a.matchLength - b.matchLength : a.match - b.match; }); for (var i = 0, len = matchesWithLength.length; i < len; i++) { if (isSubTerm(i)) { continue; } matches.push(matchesWithLength[i].match); matchesLength.push(matchesWithLength[i].matchLength); } } }, { key: "_isEntireWord", value: function _isEntireWord(content, startIdx, length) { if (startIdx > 0) { var first = content.charCodeAt(startIdx); var limit = content.charCodeAt(startIdx - 1); if ((0, _pdf_find_utils.getCharacterType)(first) === (0, _pdf_find_utils.getCharacterType)(limit)) { return false; } } var endIdx = startIdx + length - 1; if (endIdx < content.length - 1) { var last = content.charCodeAt(endIdx); var _limit = content.charCodeAt(endIdx + 1); if ((0, _pdf_find_utils.getCharacterType)(last) === (0, _pdf_find_utils.getCharacterType)(_limit)) { return false; } } return true; } }, { key: "_calculatePhraseMatch", value: function _calculatePhraseMatch(query, pageIndex, pageContent, entireWord) { var matches = []; var queryLen = query.length; var matchIdx = -queryLen; while (true) { matchIdx = pageContent.indexOf(query, matchIdx + queryLen); if (matchIdx === -1) { break; } if (entireWord && !this._isEntireWord(pageContent, matchIdx, queryLen)) { continue; } matches.push(matchIdx); } this._pageMatches[pageIndex] = matches; } }, { key: "_calculateWordMatch", value: function _calculateWordMatch(query, pageIndex, pageContent, entireWord) { var matchesWithLength = []; var queryArray = query.match(/\S+/g); for (var i = 0, len = queryArray.length; i < len; i++) { var subquery = queryArray[i]; var subqueryLen = subquery.length; var matchIdx = -subqueryLen; while (true) { matchIdx = pageContent.indexOf(subquery, matchIdx + subqueryLen); if (matchIdx === -1) { break; } if (entireWord && !this._isEntireWord(pageContent, matchIdx, subqueryLen)) { continue; } matchesWithLength.push({ match: matchIdx, matchLength: subqueryLen, skipped: false }); } } this._pageMatchesLength[pageIndex] = []; this._pageMatches[pageIndex] = []; this._prepareMatches(matchesWithLength, this._pageMatches[pageIndex], this._pageMatchesLength[pageIndex]); } }, { key: "_calculateMatch", value: function _calculateMatch(pageIndex) { var pageContent = this._pageContents[pageIndex]; var query = this._query; var _this$_state = this._state, caseSensitive = _this$_state.caseSensitive, entireWord = _this$_state.entireWord, phraseSearch = _this$_state.phraseSearch; if (query.length === 0) { return; } if (!caseSensitive) { pageContent = pageContent.toLowerCase(); query = query.toLowerCase(); } if (phraseSearch) { this._calculatePhraseMatch(query, pageIndex, pageContent, entireWord); } else { this._calculateWordMatch(query, pageIndex, pageContent, entireWord); } if (this._state.highlightAll) { this._updatePage(pageIndex); } if (this._resumePageIdx === pageIndex) { this._resumePageIdx = null; this._nextPageMatch(); } var pageMatchesCount = this._pageMatches[pageIndex].length; if (pageMatchesCount > 0) { this._matchesCountTotal += pageMatchesCount; this._updateUIResultsCount(); } } }, { key: "_extractText", value: function _extractText() { var _this2 = this; if (this._extractTextPromises.length > 0) { return; } var promise = Promise.resolve(); var _loop = function _loop(i, ii) { var extractTextCapability = (0, _pdfjsLib.createPromiseCapability)(); _this2._extractTextPromises[i] = extractTextCapability.promise; promise = promise.then(function () { return _this2._pdfDocument.getPage(i + 1).then(function (pdfPage) { return pdfPage.getTextContent({ normalizeWhitespace: true }); }).then(function (textContent) { var textItems = textContent.items; var strBuf = []; for (var j = 0, jj = textItems.length; j < jj; j++) { strBuf.push(textItems[j].str); } _this2._pageContents[i] = normalize(strBuf.join("")); extractTextCapability.resolve(i); }, function (reason) { console.error("Unable to get text content for page ".concat(i + 1), reason); _this2._pageContents[i] = ""; extractTextCapability.resolve(i); }); }); }; for (var i = 0, ii = this._linkService.pagesCount; i < ii; i++) { _loop(i, ii); } } }, { key: "_updatePage", value: function _updatePage(index) { if (this._scrollMatches && this._selected.pageIdx === index) { this._linkService.page = index + 1; } this._eventBus.dispatch("updatetextlayermatches", { source: this, pageIndex: index }); } }, { key: "_updateAllPages", value: function _updateAllPages() { this._eventBus.dispatch("updatetextlayermatches", { source: this, pageIndex: -1 }); } }, { key: "_nextMatch", value: function _nextMatch() { var _this3 = this; var previous = this._state.findPrevious; var currentPageIndex = this._linkService.page - 1; var numPages = this._linkService.pagesCount; this._highlightMatches = true; if (this._dirtyMatch) { this._dirtyMatch = false; this._selected.pageIdx = this._selected.matchIdx = -1; this._offset.pageIdx = currentPageIndex; this._offset.matchIdx = null; this._offset.wrapped = false; this._resumePageIdx = null; this._pageMatches.length = 0; this._pageMatchesLength.length = 0; this._matchesCountTotal = 0; this._updateAllPages(); for (var i = 0; i < numPages; i++) { if (this._pendingFindMatches[i] === true) { continue; } this._pendingFindMatches[i] = true; this._extractTextPromises[i].then(function (pageIdx) { delete _this3._pendingFindMatches[pageIdx]; _this3._calculateMatch(pageIdx); }); } } if (this._query === "") { this._updateUIState(FindState.FOUND); return; } if (this._resumePageIdx) { return; } var offset = this._offset; this._pagesToSearch = numPages; if (offset.matchIdx !== null) { var numPageMatches = this._pageMatches[offset.pageIdx].length; if (!previous && offset.matchIdx + 1 < numPageMatches || previous && offset.matchIdx > 0) { offset.matchIdx = previous ? offset.matchIdx - 1 : offset.matchIdx + 1; this._updateMatch(true); return; } this._advanceOffsetPage(previous); } this._nextPageMatch(); } }, { key: "_matchesReady", value: function _matchesReady(matches) { var offset = this._offset; var numMatches = matches.length; var previous = this._state.findPrevious; if (numMatches) { offset.matchIdx = previous ? numMatches - 1 : 0; this._updateMatch(true); return true; } this._advanceOffsetPage(previous); if (offset.wrapped) { offset.matchIdx = null; if (this._pagesToSearch < 0) { this._updateMatch(false); return true; } } return false; } }, { key: "_nextPageMatch", value: function _nextPageMatch() { if (this._resumePageIdx !== null) { console.error("There can only be one pending page."); } var matches = null; do { var pageIdx = this._offset.pageIdx; matches = this._pageMatches[pageIdx]; if (!matches) { this._resumePageIdx = pageIdx; break; } } while (!this._matchesReady(matches)); } }, { key: "_advanceOffsetPage", value: function _advanceOffsetPage(previous) { var offset = this._offset; var numPages = this._linkService.pagesCount; offset.pageIdx = previous ? offset.pageIdx - 1 : offset.pageIdx + 1; offset.matchIdx = null; this._pagesToSearch--; if (offset.pageIdx >= numPages || offset.pageIdx < 0) { offset.pageIdx = previous ? numPages - 1 : 0; offset.wrapped = true; } } }, { key: "_updateMatch", value: function _updateMatch() { var found = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; var state = FindState.NOT_FOUND; var wrapped = this._offset.wrapped; this._offset.wrapped = false; if (found) { var previousPage = this._selected.pageIdx; this._selected.pageIdx = this._offset.pageIdx; this._selected.matchIdx = this._offset.matchIdx; state = wrapped ? FindState.WRAPPED : FindState.FOUND; if (previousPage !== -1 && previousPage !== this._selected.pageIdx) { this._updatePage(previousPage); } } this._updateUIState(state, this._state.findPrevious); if (this._selected.pageIdx !== -1) { this._scrollMatches = true; this._updatePage(this._selected.pageIdx); } } }, { key: "_onFindBarClose", value: function _onFindBarClose(evt) { var _this4 = this; var pdfDocument = this._pdfDocument; this._firstPageCapability.promise.then(function () { if (!_this4._pdfDocument || pdfDocument && _this4._pdfDocument !== pdfDocument) { return; } if (_this4._findTimeout) { clearTimeout(_this4._findTimeout); _this4._findTimeout = null; } if (_this4._resumePageIdx) { _this4._resumePageIdx = null; _this4._dirtyMatch = true; } _this4._updateUIState(FindState.FOUND); _this4._highlightMatches = false; _this4._updateAllPages(); }); } }, { key: "_requestMatchesCount", value: function _requestMatchesCount() { var _this$_selected = this._selected, pageIdx = _this$_selected.pageIdx, matchIdx = _this$_selected.matchIdx; var current = 0, total = this._matchesCountTotal; if (matchIdx !== -1) { for (var i = 0; i < pageIdx; i++) { current += this._pageMatches[i] && this._pageMatches[i].length || 0; } current += matchIdx + 1; } if (current < 1 || current > total) { current = total = 0; } return { current: current, total: total }; } }, { key: "_updateUIResultsCount", value: function _updateUIResultsCount() { this._eventBus.dispatch("updatefindmatchescount", { source: this, matchesCount: this._requestMatchesCount() }); } }, { key: "_updateUIState", value: function _updateUIState(state, previous) { this._eventBus.dispatch("updatefindcontrolstate", { source: this, state: state, previous: previous, matchesCount: this._requestMatchesCount() }); } }, { key: "highlightMatches", get: function get() { return this._highlightMatches; } }, { key: "pageMatches", get: function get() { return this._pageMatches; } }, { key: "pageMatchesLength", get: function get() { return this._pageMatchesLength; } }, { key: "selected", get: function get() { return this._selected; } }, { key: "state", get: function get() { return this._state; } }, { key: "_query", get: function get() { if (this._state.query !== this._rawQuery) { this._rawQuery = this._state.query; this._normalizedQuery = normalize(this._state.query); } return this._normalizedQuery; } }]); return PDFFindController; }(); exports.PDFFindController = PDFFindController;
/***/ }),
/* 14 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.getCharacterType = getCharacterType; exports.CharacterType = void 0; var CharacterType = { SPACE: 0, ALPHA_LETTER: 1, PUNCT: 2, HAN_LETTER: 3, KATAKANA_LETTER: 4, HIRAGANA_LETTER: 5, HALFWIDTH_KATAKANA_LETTER: 6, THAI_LETTER: 7 }; exports.CharacterType = CharacterType; function isAlphabeticalScript(charCode) { return charCode < 0x2e80; } function isAscii(charCode) { return (charCode & 0xff80) === 0; } function isAsciiAlpha(charCode) { return charCode >= 0x61 && charCode <= 0x7a || charCode >= 0x41 && charCode <= 0x5a; } function isAsciiDigit(charCode) { return charCode >= 0x30 && charCode <= 0x39; } function isAsciiSpace(charCode) { return charCode === 0x20 || charCode === 0x09 || charCode === 0x0d || charCode === 0x0a; } function isHan(charCode) { return charCode >= 0x3400 && charCode <= 0x9fff || charCode >= 0xf900 && charCode <= 0xfaff; } function isKatakana(charCode) { return charCode >= 0x30a0 && charCode <= 0x30ff; } function isHiragana(charCode) { return charCode >= 0x3040 && charCode <= 0x309f; } function isHalfwidthKatakana(charCode) { return charCode >= 0xff60 && charCode <= 0xff9f; } function isThai(charCode) { return (charCode & 0xff80) === 0x0e00; } function getCharacterType(charCode) { if (isAlphabeticalScript(charCode)) { if (isAscii(charCode)) { if (isAsciiSpace(charCode)) { return CharacterType.SPACE; } else if (isAsciiAlpha(charCode) || isAsciiDigit(charCode) || charCode === 0x5f) { return CharacterType.ALPHA_LETTER; } return CharacterType.PUNCT; } else if (isThai(charCode)) { return CharacterType.THAI_LETTER; } else if (charCode === 0xa0) { return CharacterType.SPACE; } return CharacterType.ALPHA_LETTER; } if (isHan(charCode)) { return CharacterType.HAN_LETTER; } else if (isKatakana(charCode)) { return CharacterType.KATAKANA_LETTER; } else if (isHiragana(charCode)) { return CharacterType.HIRAGANA_LETTER; } else if (isHalfwidthKatakana(charCode)) { return CharacterType.HALFWIDTH_KATAKANA_LETTER; } return CharacterType.ALPHA_LETTER; }
/***/ }),
/* 15 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.isDestHashesEqual = isDestHashesEqual; exports.isDestArraysEqual = isDestArraysEqual; exports.PDFHistory = void 0; var _ui_utils = __w_pdfjs_require__(3);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); } function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var HASH_CHANGE_TIMEOUT = 1000; var POSITION_UPDATED_THRESHOLD = 50; var UPDATE_VIEWAREA_TIMEOUT = 1000; function getCurrentHash() { return document.location.hash; }
var PDFHistory = /*#__PURE__*/function () {
function PDFHistory(_ref) { var _this = this; var linkService = _ref.linkService, eventBus = _ref.eventBus; _classCallCheck(this, PDFHistory); this.linkService = linkService; this.eventBus = eventBus; this._initialized = false; this._fingerprint = ""; this.reset(); this._boundEvents = null; this._isViewerInPresentationMode = false; this.eventBus._on("presentationmodechanged", function (evt) { _this._isViewerInPresentationMode = evt.active || evt.switchInProgress; }); this.eventBus._on("pagesinit", function () { _this._isPagesLoaded = false; var onPagesLoaded = function onPagesLoaded(evt) { _this.eventBus._off("pagesloaded", onPagesLoaded); _this._isPagesLoaded = !!evt.pagesCount; }; _this.eventBus._on("pagesloaded", onPagesLoaded); }); } _createClass(PDFHistory, [{ key: "initialize", value: function initialize(_ref2) { var fingerprint = _ref2.fingerprint, _ref2$resetHistory = _ref2.resetHistory, resetHistory = _ref2$resetHistory === void 0 ? false : _ref2$resetHistory, _ref2$updateUrl = _ref2.updateUrl, updateUrl = _ref2$updateUrl === void 0 ? false : _ref2$updateUrl; if (!fingerprint || typeof fingerprint !== "string") { console.error('PDFHistory.initialize: The "fingerprint" must be a non-empty string.'); return; } if (this._initialized) { this.reset(); } var reInitialized = this._fingerprint !== "" && this._fingerprint !== fingerprint; this._fingerprint = fingerprint; this._updateUrl = updateUrl === true; this._initialized = true; this._bindEvents(); var state = window.history.state; this._popStateInProgress = false; this._blockHashChange = 0; this._currentHash = getCurrentHash(); this._numPositionUpdates = 0; this._uid = this._maxUid = 0; this._destination = null; this._position = null; if (!this._isValidState(state, true) || resetHistory) { var _this$_parseCurrentHa = this._parseCurrentHash(true), hash = _this$_parseCurrentHa.hash, page = _this$_parseCurrentHa.page, rotation = _this$_parseCurrentHa.rotation; if (!hash || reInitialized || resetHistory) { this._pushOrReplaceState(null, true); return; } this._pushOrReplaceState({ hash: hash, page: page, rotation: rotation }, true); return; } var destination = state.destination; this._updateInternalState(destination, state.uid, true); if (this._uid > this._maxUid) { this._maxUid = this._uid; } if (destination.rotation !== undefined) { this._initialRotation = destination.rotation; } if (destination.dest) { this._initialBookmark = JSON.stringify(destination.dest); this._destination.page = null; } else if (destination.hash) { this._initialBookmark = destination.hash; } else if (destination.page) { this._initialBookmark = "page=".concat(destination.page); } } }, { key: "reset", value: function reset() { if (this._initialized) { this._pageHide(); this._initialized = false; this._unbindEvents(); } if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } this._initialBookmark = null; this._initialRotation = null; } }, { key: "push", value: function push(_ref3) { var _this2 = this; var _ref3$namedDest = _ref3.namedDest, namedDest = _ref3$namedDest === void 0 ? null : _ref3$namedDest, explicitDest = _ref3.explicitDest, pageNumber = _ref3.pageNumber; if (!this._initialized) { return; } if (namedDest && typeof namedDest !== "string") { console.error("PDFHistory.push: " + "\"".concat(namedDest, "\" is not a valid namedDest parameter.")); return; } else if (!Array.isArray(explicitDest)) { console.error("PDFHistory.push: " + "\"".concat(explicitDest, "\" is not a valid explicitDest parameter.")); return; } else if (!(Number.isInteger(pageNumber) && pageNumber > 0 && pageNumber <= this.linkService.pagesCount)) { if (pageNumber !== null || this._destination) { console.error("PDFHistory.push: " + "\"".concat(pageNumber, "\" is not a valid pageNumber parameter.")); return; } } var hash = namedDest || JSON.stringify(explicitDest); if (!hash) { return; } var forceReplace = false; if (this._destination && (isDestHashesEqual(this._destination.hash, hash) || isDestArraysEqual(this._destination.dest, explicitDest))) { if (this._destination.page) { return; } forceReplace = true; } if (this._popStateInProgress && !forceReplace) { return; } this._pushOrReplaceState({ dest: explicitDest, hash: hash, page: pageNumber, rotation: this.linkService.rotation }, forceReplace); if (!this._popStateInProgress) { this._popStateInProgress = true; Promise.resolve().then(function () { _this2._popStateInProgress = false; }); } } }, { key: "pushCurrentPosition", value: function pushCurrentPosition() { if (!this._initialized || this._popStateInProgress) { return; } this._tryPushCurrentPosition(); } }, { key: "back", value: function back() { if (!this._initialized || this._popStateInProgress) { return; } var state = window.history.state; if (this._isValidState(state) && state.uid > 0) { window.history.back(); } } }, { key: "forward", value: function forward() { if (!this._initialized || this._popStateInProgress) { return; } var state = window.history.state; if (this._isValidState(state) && state.uid < this._maxUid) { window.history.forward(); } } }, { key: "_pushOrReplaceState", value: function _pushOrReplaceState(destination) { var forceReplace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; var shouldReplace = forceReplace || !this._destination; var newState = { fingerprint: this._fingerprint, uid: shouldReplace ? this._uid : this._uid + 1, destination: destination }; this._updateInternalState(destination, newState.uid); var newUrl; if (this._updateUrl && destination && destination.hash) { var baseUrl = document.location.href.split("#")[0];
if (!baseUrl.startsWith("file://")) {
newUrl = "".concat(baseUrl, "#").concat(destination.hash); } } if (shouldReplace) { window.history.replaceState(newState, "", newUrl); } else { this._maxUid = this._uid; window.history.pushState(newState, "", newUrl); } } }, { key: "_tryPushCurrentPosition", value: function _tryPushCurrentPosition() { var temporary = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; if (!this._position) { return; } var position = this._position; if (temporary) { position = Object.assign(Object.create(null), this._position); position.temporary = true; } if (!this._destination) { this._pushOrReplaceState(position); return; } if (this._destination.temporary) { this._pushOrReplaceState(position, true); return; } if (this._destination.hash === position.hash) { return; } if (!this._destination.page && (POSITION_UPDATED_THRESHOLD <= 0 || this._numPositionUpdates <= POSITION_UPDATED_THRESHOLD)) { return; } var forceReplace = false; if (this._destination.page >= position.first && this._destination.page <= position.page) { if (this._destination.dest || !this._destination.first) { return; } forceReplace = true; } this._pushOrReplaceState(position, forceReplace); } }, { key: "_isValidState", value: function _isValidState(state) { var checkReload = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; if (!state) { return false; } if (state.fingerprint !== this._fingerprint) { if (checkReload) { if (typeof state.fingerprint !== "string" || state.fingerprint.length !== this._fingerprint.length) { return false; } var _performance$getEntri = performance.getEntriesByType("navigation"), _performance$getEntri2 = _slicedToArray(_performance$getEntri, 1), perfEntry = _performance$getEntri2[0]; if (!perfEntry || perfEntry.type !== "reload") { return false; } } else { return false; } } if (!Number.isInteger(state.uid) || state.uid < 0) { return false; } if (state.destination === null || _typeof(state.destination) !== "object") { return false; } return true; } }, { key: "_updateInternalState", value: function _updateInternalState(destination, uid) { var removeTemporary = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } if (removeTemporary && destination && destination.temporary) { delete destination.temporary; } this._destination = destination; this._uid = uid; this._numPositionUpdates = 0; } }, { key: "_parseCurrentHash", value: function _parseCurrentHash() { var checkNameddest = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; var hash = unescape(getCurrentHash()).substring(1); var params = (0, _ui_utils.parseQueryString)(hash); var nameddest = params.nameddest || ""; var page = params.page | 0; if (!(Number.isInteger(page) && page > 0 && page <= this.linkService.pagesCount) || checkNameddest && nameddest.length > 0) { page = null; } return { hash: hash, page: page, rotation: this.linkService.rotation }; } }, { key: "_updateViewarea", value: function _updateViewarea(_ref4) { var _this3 = this; var location = _ref4.location; if (this._updateViewareaTimeout) { clearTimeout(this._updateViewareaTimeout); this._updateViewareaTimeout = null; } this._position = { hash: this._isViewerInPresentationMode ? "page=".concat(location.pageNumber) : location.pdfOpenParams.substring(1), page: this.linkService.page, first: location.pageNumber, rotation: location.rotation }; if (this._popStateInProgress) { return; } if (POSITION_UPDATED_THRESHOLD > 0 && this._isPagesLoaded && this._destination && !this._destination.page) { this._numPositionUpdates++; } if (UPDATE_VIEWAREA_TIMEOUT > 0) { this._updateViewareaTimeout = setTimeout(function () { if (!_this3._popStateInProgress) { _this3._tryPushCurrentPosition(true); } _this3._updateViewareaTimeout = null; }, UPDATE_VIEWAREA_TIMEOUT); } } }, { key: "_popState", value: function _popState(_ref5) { var _this4 = this; var state = _ref5.state; var newHash = getCurrentHash(), hashChanged = this._currentHash !== newHash; this._currentHash = newHash; if (!state) { this._uid++; var _this$_parseCurrentHa2 = this._parseCurrentHash(), hash = _this$_parseCurrentHa2.hash, page = _this$_parseCurrentHa2.page, rotation = _this$_parseCurrentHa2.rotation; this._pushOrReplaceState({ hash: hash, page: page, rotation: rotation }, true); return; } if (!this._isValidState(state)) { return; } this._popStateInProgress = true; if (hashChanged) { this._blockHashChange++; (0, _ui_utils.waitOnEventOrTimeout)({ target: window, name: "hashchange", delay: HASH_CHANGE_TIMEOUT }).then(function () { _this4._blockHashChange--; }); } var destination = state.destination; this._updateInternalState(destination, state.uid, true); if (this._uid > this._maxUid) { this._maxUid = this._uid; } if ((0, _ui_utils.isValidRotation)(destination.rotation)) { this.linkService.rotation = destination.rotation; } if (destination.dest) { this.linkService.navigateTo(destination.dest); } else if (destination.hash) { this.linkService.setHash(destination.hash); } else if (destination.page) { this.linkService.page = destination.page; } Promise.resolve().then(function () { _this4._popStateInProgress = false; }); } }, { key: "_pageHide", value: function _pageHide() { if (!this._destination || this._destination.temporary) { this._tryPushCurrentPosition(); } } }, { key: "_bindEvents", value: function _bindEvents() { if (this._boundEvents) { return; } this._boundEvents = { updateViewarea: this._updateViewarea.bind(this), popState: this._popState.bind(this), pageHide: this._pageHide.bind(this) }; this.eventBus._on("updateviewarea", this._boundEvents.updateViewarea); window.addEventListener("popstate", this._boundEvents.popState); window.addEventListener("pagehide", this._boundEvents.pageHide); } }, { key: "_unbindEvents", value: function _unbindEvents() { if (!this._boundEvents) { return; } this.eventBus._off("updateviewarea", this._boundEvents.updateViewarea); window.removeEventListener("popstate", this._boundEvents.popState); window.removeEventListener("pagehide", this._boundEvents.pageHide); this._boundEvents = null; } }, { key: "popStateInProgress", get: function get() { return this._initialized && (this._popStateInProgress || this._blockHashChange > 0); } }, { key: "initialBookmark", get: function get() { return this._initialized ? this._initialBookmark : null; } }, { key: "initialRotation", get: function get() { return this._initialized ? this._initialRotation : null; } }]); return PDFHistory; }(); exports.PDFHistory = PDFHistory; function isDestHashesEqual(destHash, pushHash) { if (typeof destHash !== "string" || typeof pushHash !== "string") { return false; } if (destHash === pushHash) { return true; } var _parseQueryString = (0, _ui_utils.parseQueryString)(destHash), nameddest = _parseQueryString.nameddest; if (nameddest === pushHash) { return true; } return false; } function isDestArraysEqual(firstDest, secondDest) { function isEntryEqual(first, second) { if (_typeof(first) !== _typeof(second)) { return false; } if (Array.isArray(first) || Array.isArray(second)) { return false; } if (first !== null && _typeof(first) === "object" && second !== null) { if (Object.keys(first).length !== Object.keys(second).length) { return false; } for (var key in first) { if (!isEntryEqual(first[key], second[key])) { return false; } } return true; } return first === second || Number.isNaN(first) && Number.isNaN(second); } if (!(Array.isArray(firstDest) && Array.isArray(secondDest))) { return false; } if (firstDest.length !== secondDest.length) { return false; } for (var i = 0, ii = firstDest.length; i < ii; i++) { if (!isEntryEqual(firstDest[i], secondDest[i])) { return false; } } return true; }
/***/ }),
/* 16 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFPageView = void 0; var _regenerator = _interopRequireDefault(__w_pdfjs_require__(4)); var _ui_utils = __w_pdfjs_require__(3); var _pdfjsLib = __w_pdfjs_require__(2); var _pdf_rendering_queue = __w_pdfjs_require__(17); var _viewer_compatibility = __w_pdfjs_require__(10); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var MAX_CANVAS_PIXELS = _viewer_compatibility.viewerCompatibilityParams.maxCanvasPixels || 16777216;
var PDFPageView = /*#__PURE__*/function () {
function PDFPageView(options) { _classCallCheck(this, PDFPageView); var container = options.container; var defaultViewport = options.defaultViewport; this.id = options.id; this.renderingId = "page" + this.id; this.pdfPage = null; this.pageLabel = null; this.rotation = 0; this.scale = options.scale || _ui_utils.DEFAULT_SCALE; this.viewport = defaultViewport; this.pdfPageRotate = defaultViewport.rotation; this.hasRestrictedScaling = false; this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE; this.imageResourcesPath = options.imageResourcesPath || ""; this.renderInteractiveForms = options.renderInteractiveForms || false; this.useOnlyCssZoom = options.useOnlyCssZoom || false; this.maxCanvasPixels = options.maxCanvasPixels || MAX_CANVAS_PIXELS; this.eventBus = options.eventBus; this.renderingQueue = options.renderingQueue; this.textLayerFactory = options.textLayerFactory; this.annotationLayerFactory = options.annotationLayerFactory; this.renderer = options.renderer || _ui_utils.RendererType.CANVAS; this.enableWebGL = options.enableWebGL || false; this.l10n = options.l10n || _ui_utils.NullL10n; this.paintTask = null; this.paintedViewportMap = new WeakMap(); this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL; this.resume = null; this.error = null; this.annotationLayer = null; this.textLayer = null; this.zoomLayer = null; var div = document.createElement("div"); div.className = "page"; div.style.width = Math.floor(this.viewport.width) + "px"; div.style.height = Math.floor(this.viewport.height) + "px"; div.setAttribute("data-page-number", this.id); this.div = div; container.appendChild(div); } _createClass(PDFPageView, [{ key: "setPdfPage", value: function setPdfPage(pdfPage) { this.pdfPage = pdfPage; this.pdfPageRotate = pdfPage.rotate; var totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = pdfPage.getViewport({ scale: this.scale * _ui_utils.CSS_UNITS, rotation: totalRotation }); this.stats = pdfPage.stats; this.reset(); } }, { key: "destroy", value: function destroy() { this.reset(); if (this.pdfPage) { this.pdfPage.cleanup(); } } }, { key: "_resetZoomLayer", value: function _resetZoomLayer() { var removeFromDOM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; if (!this.zoomLayer) { return; } var zoomLayerCanvas = this.zoomLayer.firstChild; this.paintedViewportMap["delete"](zoomLayerCanvas); zoomLayerCanvas.width = 0; zoomLayerCanvas.height = 0; if (removeFromDOM) { this.zoomLayer.remove(); } this.zoomLayer = null; } }, { key: "reset", value: function reset() { var keepZoomLayer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; var keepAnnotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; this.cancelRendering(keepAnnotations); this.renderingState = _pdf_rendering_queue.RenderingStates.INITIAL; var div = this.div; div.style.width = Math.floor(this.viewport.width) + "px"; div.style.height = Math.floor(this.viewport.height) + "px"; var childNodes = div.childNodes; var currentZoomLayerNode = keepZoomLayer && this.zoomLayer || null; var currentAnnotationNode = keepAnnotations && this.annotationLayer && this.annotationLayer.div || null; for (var i = childNodes.length - 1; i >= 0; i--) { var node = childNodes[i]; if (currentZoomLayerNode === node || currentAnnotationNode === node) { continue; } div.removeChild(node); } div.removeAttribute("data-loaded"); if (currentAnnotationNode) { this.annotationLayer.hide(); } else if (this.annotationLayer) { this.annotationLayer.cancel(); this.annotationLayer = null; } if (!currentZoomLayerNode) { if (this.canvas) { this.paintedViewportMap["delete"](this.canvas); this.canvas.width = 0; this.canvas.height = 0; delete this.canvas; } this._resetZoomLayer(); } if (this.svg) { this.paintedViewportMap["delete"](this.svg); delete this.svg; } this.loadingIconDiv = document.createElement("div"); this.loadingIconDiv.className = "loadingIcon"; div.appendChild(this.loadingIconDiv); } }, { key: "update", value: function update(scale, rotation) { this.scale = scale || this.scale; if (typeof rotation !== "undefined") { this.rotation = rotation; } var totalRotation = (this.rotation + this.pdfPageRotate) % 360; this.viewport = this.viewport.clone({ scale: this.scale * _ui_utils.CSS_UNITS, rotation: totalRotation }); if (this.svg) { this.cssTransform(this.svg, true); this.eventBus.dispatch("pagerendered", { source: this, pageNumber: this.id, cssTransform: true, timestamp: performance.now() }); return; } var isScalingRestricted = false; if (this.canvas && this.maxCanvasPixels > 0) { var outputScale = this.outputScale; if ((Math.floor(this.viewport.width) * outputScale.sx | 0) * (Math.floor(this.viewport.height) * outputScale.sy | 0) > this.maxCanvasPixels) { isScalingRestricted = true; } } if (this.canvas) { if (this.useOnlyCssZoom || this.hasRestrictedScaling && isScalingRestricted) { this.cssTransform(this.canvas, true); this.eventBus.dispatch("pagerendered", { source: this, pageNumber: this.id, cssTransform: true, timestamp: performance.now() }); return; } if (!this.zoomLayer && !this.canvas.hasAttribute("hidden")) { this.zoomLayer = this.canvas.parentNode; this.zoomLayer.style.position = "absolute"; } } if (this.zoomLayer) { this.cssTransform(this.zoomLayer.firstChild); } this.reset(true, true); } }, { key: "cancelRendering", value: function cancelRendering() { var keepAnnotations = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false; if (this.paintTask) { this.paintTask.cancel(); this.paintTask = null; } this.resume = null; if (this.textLayer) { this.textLayer.cancel(); this.textLayer = null; } if (!keepAnnotations && this.annotationLayer) { this.annotationLayer.cancel(); this.annotationLayer = null; } } }, { key: "cssTransform", value: function cssTransform(target) { var redrawAnnotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; var width = this.viewport.width; var height = this.viewport.height; var div = this.div; target.style.width = target.parentNode.style.width = div.style.width = Math.floor(width) + "px"; target.style.height = target.parentNode.style.height = div.style.height = Math.floor(height) + "px"; var relativeRotation = this.viewport.rotation - this.paintedViewportMap.get(target).rotation; var absRotation = Math.abs(relativeRotation); var scaleX = 1, scaleY = 1; if (absRotation === 90 || absRotation === 270) { scaleX = height / width; scaleY = width / height; } var cssTransform = "rotate(" + relativeRotation + "deg) " + "scale(" + scaleX + "," + scaleY + ")"; target.style.transform = cssTransform; if (this.textLayer) { var textLayerViewport = this.textLayer.viewport; var textRelativeRotation = this.viewport.rotation - textLayerViewport.rotation; var textAbsRotation = Math.abs(textRelativeRotation); var scale = width / textLayerViewport.width; if (textAbsRotation === 90 || textAbsRotation === 270) { scale = width / textLayerViewport.height; } var textLayerDiv = this.textLayer.textLayerDiv; var transX, transY; switch (textAbsRotation) { case 0: transX = transY = 0; break; case 90: transX = 0; transY = "-" + textLayerDiv.style.height; break; case 180: transX = "-" + textLayerDiv.style.width; transY = "-" + textLayerDiv.style.height; break; case 270: transX = "-" + textLayerDiv.style.width; transY = 0; break; default: console.error("Bad rotation value."); break; } textLayerDiv.style.transform = "rotate(" + textAbsRotation + "deg) " + "scale(" + scale + ", " + scale + ") " + "translate(" + transX + ", " + transY + ")"; textLayerDiv.style.transformOrigin = "0% 0%"; } if (redrawAnnotations && this.annotationLayer) { this.annotationLayer.render(this.viewport, "display"); } } }, { key: "getPagePoint", value: function getPagePoint(x, y) { return this.viewport.convertToPdfPoint(x, y); } }, { key: "draw", value: function draw() { var _this = this; if (this.renderingState !== _pdf_rendering_queue.RenderingStates.INITIAL) { console.error("Must be in new state before drawing"); this.reset(); } var div = this.div, pdfPage = this.pdfPage; if (!pdfPage) { this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED; if (this.loadingIconDiv) { div.removeChild(this.loadingIconDiv); delete this.loadingIconDiv; } return Promise.reject(new Error("pdfPage is not loaded")); } this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING; var canvasWrapper = document.createElement("div"); canvasWrapper.style.width = div.style.width; canvasWrapper.style.height = div.style.height; canvasWrapper.classList.add("canvasWrapper"); if (this.annotationLayer && this.annotationLayer.div) { div.insertBefore(canvasWrapper, this.annotationLayer.div); } else { div.appendChild(canvasWrapper); } var textLayer = null; if (this.textLayerMode !== _ui_utils.TextLayerMode.DISABLE && this.textLayerFactory) { var textLayerDiv = document.createElement("div"); textLayerDiv.className = "textLayer"; textLayerDiv.style.width = canvasWrapper.style.width; textLayerDiv.style.height = canvasWrapper.style.height; if (this.annotationLayer && this.annotationLayer.div) { div.insertBefore(textLayerDiv, this.annotationLayer.div); } else { div.appendChild(textLayerDiv); } textLayer = this.textLayerFactory.createTextLayerBuilder(textLayerDiv, this.id - 1, this.viewport, this.textLayerMode === _ui_utils.TextLayerMode.ENABLE_ENHANCE, this.eventBus); } this.textLayer = textLayer; var renderContinueCallback = null; if (this.renderingQueue) { renderContinueCallback = function renderContinueCallback(cont) { if (!_this.renderingQueue.isHighestPriority(_this)) { _this.renderingState = _pdf_rendering_queue.RenderingStates.PAUSED; _this.resume = function () { _this.renderingState = _pdf_rendering_queue.RenderingStates.RUNNING; cont(); }; return; } cont(); }; }
var finishPaintTask = /*#__PURE__*/function () {
var _ref = _asyncToGenerator( /*#__PURE__*/_regenerator["default"].mark(function _callee(error) {
return _regenerator["default"].wrap(function _callee$(_context) { while (1) { switch (_context.prev = _context.next) { case 0: if (paintTask === _this.paintTask) { _this.paintTask = null; } if (!(error instanceof _pdfjsLib.RenderingCancelledException)) { _context.next = 4; break; } _this.error = null; return _context.abrupt("return"); case 4: _this.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED; if (_this.loadingIconDiv) { div.removeChild(_this.loadingIconDiv); delete _this.loadingIconDiv; } _this._resetZoomLayer(true); _this.error = error; _this.stats = pdfPage.stats; _this.eventBus.dispatch("pagerendered", { source: _this, pageNumber: _this.id, cssTransform: false, timestamp: performance.now() }); if (!error) { _context.next = 12; break; } throw error; case 12: case "end": return _context.stop(); } } }, _callee); })); return function finishPaintTask(_x) { return _ref.apply(this, arguments); }; }(); var paintTask = this.renderer === _ui_utils.RendererType.SVG ? this.paintOnSvg(canvasWrapper) : this.paintOnCanvas(canvasWrapper); paintTask.onRenderContinue = renderContinueCallback; this.paintTask = paintTask; var resultPromise = paintTask.promise.then(function () { return finishPaintTask(null).then(function () { if (textLayer) { var readableStream = pdfPage.streamTextContent({ normalizeWhitespace: true }); textLayer.setTextContentStream(readableStream); textLayer.render(); } }); }, function (reason) { return finishPaintTask(reason); }); if (this.annotationLayerFactory) { if (!this.annotationLayer) { this.annotationLayer = this.annotationLayerFactory.createAnnotationLayerBuilder(div, pdfPage, this.imageResourcesPath, this.renderInteractiveForms, this.l10n); } this.annotationLayer.render(this.viewport, "display"); } div.setAttribute("data-loaded", true); this.eventBus.dispatch("pagerender", { source: this, pageNumber: this.id }); return resultPromise; } }, { key: "paintOnCanvas", value: function paintOnCanvas(canvasWrapper) { var renderCapability = (0, _pdfjsLib.createPromiseCapability)(); var result = { promise: renderCapability.promise, onRenderContinue: function onRenderContinue(cont) { cont(); }, cancel: function cancel() { renderTask.cancel(); } }; var viewport = this.viewport; var canvas = document.createElement("canvas"); this.l10n.get("page_canvas", { page: this.id }, "Page {{page}}").then(function (msg) { canvas.setAttribute("aria-label", msg); }); canvas.setAttribute("hidden", "hidden"); var isCanvasHidden = true; var showCanvas = function showCanvas() { if (isCanvasHidden) { canvas.removeAttribute("hidden"); isCanvasHidden = false; } }; canvasWrapper.appendChild(canvas); this.canvas = canvas; canvas.mozOpaque = true; var ctx = canvas.getContext("2d", { alpha: false }); var outputScale = (0, _ui_utils.getOutputScale)(ctx); this.outputScale = outputScale; if (this.useOnlyCssZoom) { var actualSizeViewport = viewport.clone({ scale: _ui_utils.CSS_UNITS }); outputScale.sx *= actualSizeViewport.width / viewport.width; outputScale.sy *= actualSizeViewport.height / viewport.height; outputScale.scaled = true; } if (this.maxCanvasPixels > 0) { var pixelsInViewport = viewport.width * viewport.height; var maxScale = Math.sqrt(this.maxCanvasPixels / pixelsInViewport); if (outputScale.sx > maxScale || outputScale.sy > maxScale) { outputScale.sx = maxScale; outputScale.sy = maxScale; outputScale.scaled = true; this.hasRestrictedScaling = true; } else { this.hasRestrictedScaling = false; } } var sfx = (0, _ui_utils.approximateFraction)(outputScale.sx); var sfy = (0, _ui_utils.approximateFraction)(outputScale.sy); canvas.width = (0, _ui_utils.roundToDivide)(viewport.width * outputScale.sx, sfx[0]); canvas.height = (0, _ui_utils.roundToDivide)(viewport.height * outputScale.sy, sfy[0]); canvas.style.width = (0, _ui_utils.roundToDivide)(viewport.width, sfx[1]) + "px"; canvas.style.height = (0, _ui_utils.roundToDivide)(viewport.height, sfy[1]) + "px"; this.paintedViewportMap.set(canvas, viewport); var transform = !outputScale.scaled ? null : [outputScale.sx, 0, 0, outputScale.sy, 0, 0]; var renderContext = { canvasContext: ctx, transform: transform, viewport: this.viewport, enableWebGL: this.enableWebGL, renderInteractiveForms: this.renderInteractiveForms }; var renderTask = this.pdfPage.render(renderContext); renderTask.onContinue = function (cont) { showCanvas(); if (result.onRenderContinue) { result.onRenderContinue(cont); } else { cont(); } }; renderTask.promise.then(function () { showCanvas(); renderCapability.resolve(undefined); }, function (error) { showCanvas(); renderCapability.reject(error); }); return result; } }, { key: "paintOnSvg", value: function paintOnSvg(wrapper) { var _this2 = this; var cancelled = false; var ensureNotCancelled = function ensureNotCancelled() { if (cancelled) { throw new _pdfjsLib.RenderingCancelledException("Rendering cancelled, page ".concat(_this2.id), "svg"); } }; var pdfPage = this.pdfPage; var actualSizeViewport = this.viewport.clone({ scale: _ui_utils.CSS_UNITS }); var promise = pdfPage.getOperatorList().then(function (opList) { ensureNotCancelled(); var svgGfx = new _pdfjsLib.SVGGraphics(pdfPage.commonObjs, pdfPage.objs); return svgGfx.getSVG(opList, actualSizeViewport).then(function (svg) { ensureNotCancelled(); _this2.svg = svg; _this2.paintedViewportMap.set(svg, actualSizeViewport); svg.style.width = wrapper.style.width; svg.style.height = wrapper.style.height; _this2.renderingState = _pdf_rendering_queue.RenderingStates.FINISHED; wrapper.appendChild(svg); }); }); return { promise: promise, onRenderContinue: function onRenderContinue(cont) { cont(); }, cancel: function cancel() { cancelled = true; } }; } }, { key: "setPageLabel", value: function setPageLabel(label) { this.pageLabel = typeof label === "string" ? label : null; if (this.pageLabel !== null) { this.div.setAttribute("data-page-label", this.pageLabel); } else { this.div.removeAttribute("data-page-label"); } } }, { key: "width", get: function get() { return this.viewport.width; } }, { key: "height", get: function get() { return this.viewport.height; } }]); return PDFPageView; }(); exports.PDFPageView = PDFPageView;
/***/ }),
/* 17 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFRenderingQueue = exports.RenderingStates = void 0; function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var CLEANUP_TIMEOUT = 30000; var RenderingStates = { INITIAL: 0, RUNNING: 1, PAUSED: 2, FINISHED: 3 }; exports.RenderingStates = RenderingStates;
var PDFRenderingQueue = /*#__PURE__*/function () {
function PDFRenderingQueue() { _classCallCheck(this, PDFRenderingQueue); this.pdfViewer = null; this.pdfThumbnailViewer = null; this.onIdle = null; this.highestPriorityPage = null; this.idleTimeout = null; this.printing = false; this.isThumbnailViewEnabled = false; } _createClass(PDFRenderingQueue, [{ key: "setViewer", value: function setViewer(pdfViewer) { this.pdfViewer = pdfViewer; } }, { key: "setThumbnailViewer", value: function setThumbnailViewer(pdfThumbnailViewer) { this.pdfThumbnailViewer = pdfThumbnailViewer; } }, { key: "isHighestPriority", value: function isHighestPriority(view) { return this.highestPriorityPage === view.renderingId; } }, { key: "renderHighestPriority", value: function renderHighestPriority(currentlyVisiblePages) { if (this.idleTimeout) { clearTimeout(this.idleTimeout); this.idleTimeout = null; } if (this.pdfViewer.forceRendering(currentlyVisiblePages)) { return; } if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) { if (this.pdfThumbnailViewer.forceRendering()) { return; } } if (this.printing) { return; } if (this.onIdle) { this.idleTimeout = setTimeout(this.onIdle.bind(this), CLEANUP_TIMEOUT); } } }, { key: "getHighestPriority", value: function getHighestPriority(visible, views, scrolledDown) { var visibleViews = visible.views; var numVisible = visibleViews.length; if (numVisible === 0) { return null; } for (var i = 0; i < numVisible; ++i) { var view = visibleViews[i].view; if (!this.isViewFinished(view)) { return view; } } if (scrolledDown) { var nextPageIndex = visible.last.id; if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) { return views[nextPageIndex]; } } else { var previousPageIndex = visible.first.id - 2; if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) { return views[previousPageIndex]; } } return null; } }, { key: "isViewFinished", value: function isViewFinished(view) { return view.renderingState === RenderingStates.FINISHED; } }, { key: "renderView", value: function renderView(view) { var _this = this; switch (view.renderingState) { case RenderingStates.FINISHED: return false; case RenderingStates.PAUSED: this.highestPriorityPage = view.renderingId; view.resume(); break; case RenderingStates.RUNNING: this.highestPriorityPage = view.renderingId; break; case RenderingStates.INITIAL: this.highestPriorityPage = view.renderingId; view.draw()["finally"](function () { _this.renderHighestPriority(); })["catch"](function (reason) { console.error("renderView: \"".concat(reason, "\"")); }); break; } return true; } }]); return PDFRenderingQueue; }(); exports.PDFRenderingQueue = PDFRenderingQueue;
/***/ }),
/* 18 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFSinglePageViewer = void 0; var _base_viewer = __w_pdfjs_require__(19); var _pdfjsLib = __w_pdfjs_require__(2);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); } function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var PDFSinglePageViewer = /*#__PURE__*/function (_BaseViewer) {
_inherits(PDFSinglePageViewer, _BaseViewer); var _super = _createSuper(PDFSinglePageViewer); function PDFSinglePageViewer(options) { var _this; _classCallCheck(this, PDFSinglePageViewer); _this = _super.call(this, options); _this.eventBus._on("pagesinit", function (evt) { _this._ensurePageViewVisible(); }); return _this; } _createClass(PDFSinglePageViewer, [{ key: "_resetView", value: function _resetView() { _get(_getPrototypeOf(PDFSinglePageViewer.prototype), "_resetView", this).call(this); this._previousPageNumber = 1; this._shadowViewer = document.createDocumentFragment(); this._updateScrollDown = null; } }, { key: "_ensurePageViewVisible", value: function _ensurePageViewVisible() { var pageView = this._pages[this._currentPageNumber - 1]; var previousPageView = this._pages[this._previousPageNumber - 1]; var viewerNodes = this.viewer.childNodes; switch (viewerNodes.length) { case 0: this.viewer.appendChild(pageView.div); break; case 1: if (viewerNodes[0] !== previousPageView.div) { throw new Error("_ensurePageViewVisible: Unexpected previously visible page."); } if (pageView === previousPageView) { break; } this._shadowViewer.appendChild(previousPageView.div); this.viewer.appendChild(pageView.div); this.container.scrollTop = 0; break; default: throw new Error("_ensurePageViewVisible: Only one page should be visible at a time."); } this._previousPageNumber = this._currentPageNumber; } }, { key: "_scrollUpdate", value: function _scrollUpdate() { if (this._updateScrollDown) { this._updateScrollDown(); } _get(_getPrototypeOf(PDFSinglePageViewer.prototype), "_scrollUpdate", this).call(this); } }, { key: "_scrollIntoView", value: function _scrollIntoView(_ref) { var _this2 = this; var pageDiv = _ref.pageDiv, _ref$pageSpot = _ref.pageSpot, pageSpot = _ref$pageSpot === void 0 ? null : _ref$pageSpot, _ref$pageNumber = _ref.pageNumber, pageNumber = _ref$pageNumber === void 0 ? null : _ref$pageNumber; if (pageNumber) { this._setCurrentPageNumber(pageNumber); } var scrolledDown = this._currentPageNumber >= this._previousPageNumber; this._ensurePageViewVisible(); this.update(); _get(_getPrototypeOf(PDFSinglePageViewer.prototype), "_scrollIntoView", this).call(this, { pageDiv: pageDiv, pageSpot: pageSpot, pageNumber: pageNumber }); this._updateScrollDown = function () { _this2.scroll.down = scrolledDown; _this2._updateScrollDown = null; }; } }, { key: "_getVisiblePages", value: function _getVisiblePages() { return this._getCurrentVisiblePage(); } }, { key: "_updateHelper", value: function _updateHelper(visiblePages) {} }, { key: "_updateScrollMode", value: function _updateScrollMode() {} }, { key: "_updateSpreadMode", value: function _updateSpreadMode() {} }, { key: "_viewerElement", get: function get() { return (0, _pdfjsLib.shadow)(this, "_viewerElement", this._shadowViewer); } }, { key: "_isScrollModeHorizontal", get: function get() { return (0, _pdfjsLib.shadow)(this, "_isScrollModeHorizontal", false); } }]); return PDFSinglePageViewer; }(_base_viewer.BaseViewer); exports.PDFSinglePageViewer = PDFSinglePageViewer;
/***/ }),
/* 19 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.BaseViewer = void 0; var _ui_utils = __w_pdfjs_require__(3); var _pdf_rendering_queue = __w_pdfjs_require__(17); var _annotation_layer_builder = __w_pdfjs_require__(1); var _pdfjsLib = __w_pdfjs_require__(2); var _pdf_page_view = __w_pdfjs_require__(16); var _pdf_link_service = __w_pdfjs_require__(7); var _text_layer_builder = __w_pdfjs_require__(8); function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
var DEFAULT_CACHE_SIZE = 10; function PDFPageViewBuffer(size) { var data = []; this.push = function (view) { var i = data.indexOf(view); if (i >= 0) { data.splice(i, 1); } data.push(view); if (data.length > size) { data.shift().destroy(); } }; this.resize = function (newSize, pagesToKeep) { size = newSize; if (pagesToKeep) { var pageIdsToKeep = new Set(); for (var i = 0, iMax = pagesToKeep.length; i < iMax; ++i) { pageIdsToKeep.add(pagesToKeep[i].id); } (0, _ui_utils.moveToEndOfArray)(data, function (page) { return pageIdsToKeep.has(page.id); }); } while (data.length > size) { data.shift().destroy(); } }; } function isSameScale(oldScale, newScale) { if (newScale === oldScale) { return true; } if (Math.abs(newScale - oldScale) < 1e-15) { return true; } return false; }
var BaseViewer = /*#__PURE__*/function () {
function BaseViewer(options) { var _this = this; _classCallCheck(this, BaseViewer); if (this.constructor === BaseViewer) { throw new Error("Cannot initialize BaseViewer."); } this._name = this.constructor.name; this.container = options.container; this.viewer = options.viewer || options.container.firstElementChild; this.eventBus = options.eventBus; this.linkService = options.linkService || new _pdf_link_service.SimpleLinkService(); this.downloadManager = options.downloadManager || null; this.findController = options.findController || null; this.removePageBorders = options.removePageBorders || false; this.textLayerMode = Number.isInteger(options.textLayerMode) ? options.textLayerMode : _ui_utils.TextLayerMode.ENABLE; this.imageResourcesPath = options.imageResourcesPath || ""; this.renderInteractiveForms = options.renderInteractiveForms || false; this.enablePrintAutoRotate = options.enablePrintAutoRotate || false; this.renderer = options.renderer || _ui_utils.RendererType.CANVAS; this.enableWebGL = options.enableWebGL || false; this.useOnlyCssZoom = options.useOnlyCssZoom || false; this.maxCanvasPixels = options.maxCanvasPixels; this.l10n = options.l10n || _ui_utils.NullL10n; this.defaultRenderingQueue = !options.renderingQueue; if (this.defaultRenderingQueue) { this.renderingQueue = new _pdf_rendering_queue.PDFRenderingQueue(); this.renderingQueue.setViewer(this); } else { this.renderingQueue = options.renderingQueue; } this.scroll = (0, _ui_utils.watchScroll)(this.container, this._scrollUpdate.bind(this)); this.presentationModeState = _ui_utils.PresentationModeState.UNKNOWN; this._onBeforeDraw = this._onAfterDraw = null; this._resetView(); if (this.removePageBorders) { this.viewer.classList.add("removePageBorders"); } Promise.resolve().then(function () { _this.eventBus.dispatch("baseviewerinit", { source: _this }); }); } _createClass(BaseViewer, [{ key: "getPageView", value: function getPageView(index) { return this._pages[index]; } }, { key: "_setCurrentPageNumber", value: function _setCurrentPageNumber(val) { var resetCurrentPageView = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; if (this._currentPageNumber === val) { if (resetCurrentPageView) { this._resetCurrentPageView(); } return true; } if (!(0 < val && val <= this.pagesCount)) { return false; } this._currentPageNumber = val; this.eventBus.dispatch("pagechanging", { source: this, pageNumber: val, pageLabel: this._pageLabels && this._pageLabels[val - 1] }); if (resetCurrentPageView) { this._resetCurrentPageView(); } return true; } }, { key: "_onePageRenderedOrForceFetch", value: function _onePageRenderedOrForceFetch() { if (!this.container.offsetParent || this._getVisiblePages().views.length === 0) { return Promise.resolve(); } return this._onePageRenderedCapability.promise; } }, { key: "setDocument", value: function setDocument(pdfDocument) { var _this2 = this; if (this.pdfDocument) { this._cancelRendering(); this._resetView(); if (this.findController) { this.findController.setDocument(null); } } this.pdfDocument = pdfDocument; if (!pdfDocument) { return; } var pagesCount = pdfDocument.numPages; var firstPagePromise = pdfDocument.getPage(1); this._pagesCapability.promise.then(function () { _this2.eventBus.dispatch("pagesloaded", { source: _this2, pagesCount: pagesCount }); }); this._onBeforeDraw = function (evt) { var pageView = _this2._pages[evt.pageNumber - 1]; if (!pageView) { return; } _this2._buffer.push(pageView); }; this.eventBus._on("pagerender", this._onBeforeDraw); this._onAfterDraw = function (evt) { if (evt.cssTransform || _this2._onePageRenderedCapability.settled) { return; } _this2._onePageRenderedCapability.resolve(); _this2.eventBus._off("pagerendered", _this2._onAfterDraw); _this2._onAfterDraw = null; }; this.eventBus._on("pagerendered", this._onAfterDraw); firstPagePromise.then(function (firstPdfPage) { _this2._firstPageCapability.resolve(firstPdfPage); var scale = _this2.currentScale; var viewport = firstPdfPage.getViewport({ scale: scale * _ui_utils.CSS_UNITS }); var textLayerFactory = _this2.textLayerMode !== _ui_utils.TextLayerMode.DISABLE ? _this2 : null; for (var pageNum = 1; pageNum <= pagesCount; ++pageNum) { var pageView = new _pdf_page_view.PDFPageView({ container: _this2._viewerElement, eventBus: _this2.eventBus, id: pageNum, scale: scale, defaultViewport: viewport.clone(), renderingQueue: _this2.renderingQueue, textLayerFactory: textLayerFactory, textLayerMode: _this2.textLayerMode, annotationLayerFactory: _this2, imageResourcesPath: _this2.imageResourcesPath, renderInteractiveForms: _this2.renderInteractiveForms, renderer: _this2.renderer, enableWebGL: _this2.enableWebGL, useOnlyCssZoom: _this2.useOnlyCssZoom, maxCanvasPixels: _this2.maxCanvasPixels, l10n: _this2.l10n }); _this2._pages.push(pageView); } var firstPageView = _this2._pages[0]; if (firstPageView) { firstPageView.setPdfPage(firstPdfPage); _this2.linkService.cachePageRef(1, firstPdfPage.ref); } if (_this2._spreadMode !== _ui_utils.SpreadMode.NONE) { _this2._updateSpreadMode(); } _this2._onePageRenderedOrForceFetch().then(function () { if (_this2.findController) { _this2.findController.setDocument(pdfDocument); } if (pdfDocument.loadingParams.disableAutoFetch || pagesCount > 7500) { _this2._pagesCapability.resolve(); return; } var getPagesLeft = pagesCount - 1; if (getPagesLeft <= 0) { _this2._pagesCapability.resolve(); return; } var _loop = function _loop(_pageNum) { pdfDocument.getPage(_pageNum).then(function (pdfPage) { var pageView = _this2._pages[_pageNum - 1]; if (!pageView.pdfPage) { pageView.setPdfPage(pdfPage); } _this2.linkService.cachePageRef(_pageNum, pdfPage.ref); if (--getPagesLeft === 0) { _this2._pagesCapability.resolve(); } }, function (reason) { console.error("Unable to get page ".concat(_pageNum, " to initialize viewer"), reason); if (--getPagesLeft === 0) { _this2._pagesCapability.resolve(); } }); }; for (var _pageNum = 2; _pageNum <= pagesCount; ++_pageNum) { _loop(_pageNum); } }); _this2.eventBus.dispatch("pagesinit", { source: _this2 }); if (_this2.defaultRenderingQueue) { _this2.update(); } })["catch"](function (reason) { console.error("Unable to initialize viewer", reason); }); } }, { key: "setPageLabels", value: function setPageLabels(labels) { if (!this.pdfDocument) { return; } if (!labels) { this._pageLabels = null; } else if (!(Array.isArray(labels) && this.pdfDocument.numPages === labels.length)) { this._pageLabels = null; console.error("".concat(this._name, ".setPageLabels: Invalid page labels.")); } else { this._pageLabels = labels; } for (var i = 0, ii = this._pages.length; i < ii; i++) { var pageView = this._pages[i]; var label = this._pageLabels && this._pageLabels[i]; pageView.setPageLabel(label); } } }, { key: "_resetView", value: function _resetView() { this._pages = []; this._currentPageNumber = 1; this._currentScale = _ui_utils.UNKNOWN_SCALE; this._currentScaleValue = null; this._pageLabels = null; this._buffer = new PDFPageViewBuffer(DEFAULT_CACHE_SIZE); this._location = null; this._pagesRotation = 0; this._pagesRequests = new WeakMap(); this._firstPageCapability = (0, _pdfjsLib.createPromiseCapability)(); this._onePageRenderedCapability = (0, _pdfjsLib.createPromiseCapability)(); this._pagesCapability = (0, _pdfjsLib.createPromiseCapability)(); this._scrollMode = _ui_utils.ScrollMode.VERTICAL; this._spreadMode = _ui_utils.SpreadMode.NONE; if (this._onBeforeDraw) { this.eventBus._off("pagerender", this._onBeforeDraw); this._onBeforeDraw = null; } if (this._onAfterDraw) { this.eventBus._off("pagerendered", this._onAfterDraw); this._onAfterDraw = null; } this.viewer.textContent = ""; this._updateScrollMode(); } }, { key: "_scrollUpdate", value: function _scrollUpdate() { if (this.pagesCount === 0) { return; } this.update(); } }, { key: "_scrollIntoView", value: function _scrollIntoView(_ref) { var pageDiv = _ref.pageDiv, _ref$pageSpot = _ref.pageSpot, pageSpot = _ref$pageSpot === void 0 ? null : _ref$pageSpot, _ref$pageNumber = _ref.pageNumber, pageNumber = _ref$pageNumber === void 0 ? null : _ref$pageNumber; (0, _ui_utils.scrollIntoView)(pageDiv, pageSpot); } }, { key: "_setScaleUpdatePages", value: function _setScaleUpdatePages(newScale, newValue) { var noScroll = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false; var preset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; this._currentScaleValue = newValue.toString(); if (isSameScale(this._currentScale, newScale)) { if (preset) { this.eventBus.dispatch("scalechanging", { source: this, scale: newScale, presetValue: newValue }); } return; } for (var i = 0, ii = this._pages.length; i < ii; i++) { this._pages[i].update(newScale); } this._currentScale = newScale; if (!noScroll) { var page = this._currentPageNumber, dest; if (this._location && !(this.isInPresentationMode || this.isChangingPresentationMode)) { page = this._location.pageNumber; dest = [null, { name: "XYZ" }, this._location.left, this._location.top, null]; } this.scrollPageIntoView({ pageNumber: page, destArray: dest, allowNegativeOffset: true }); } this.eventBus.dispatch("scalechanging", { source: this, scale: newScale, presetValue: preset ? newValue : undefined }); if (this.defaultRenderingQueue) { this.update(); } } }, { key: "_setScale", value: function _setScale(value) { var noScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false; var scale = parseFloat(value); if (scale > 0) { this._setScaleUpdatePages(scale, value, noScroll, false); } else { var currentPage = this._pages[this._currentPageNumber - 1]; if (!currentPage) { return; } var noPadding = this.isInPresentationMode || this.removePageBorders; var hPadding = noPadding ? 0 : _ui_utils.SCROLLBAR_PADDING; var vPadding = noPadding ? 0 : _ui_utils.VERTICAL_PADDING; if (!noPadding && this._isScrollModeHorizontal) { var _ref2 = [vPadding, hPadding]; hPadding = _ref2[0]; vPadding = _ref2[1]; } var pageWidthScale = (this.container.clientWidth - hPadding) / currentPage.width * currentPage.scale; var pageHeightScale = (this.container.clientHeight - vPadding) / currentPage.height * currentPage.scale; switch (value) { case "page-actual": scale = 1; break; case "page-width": scale = pageWidthScale; break; case "page-height": scale = pageHeightScale; break; case "page-fit": scale = Math.min(pageWidthScale, pageHeightScale); break; case "auto": var horizontalScale = (0, _ui_utils.isPortraitOrientation)(currentPage) ? pageWidthScale : Math.min(pageHeightScale, pageWidthScale); scale = Math.min(_ui_utils.MAX_AUTO_SCALE, horizontalScale); break; default: console.error("".concat(this._name, "._setScale: \"").concat(value, "\" is an unknown zoom value.")); return; } this._setScaleUpdatePages(scale, value, noScroll, true); } } }, { key: "_resetCurrentPageView", value: function _resetCurrentPageView() { if (this.isInPresentationMode) { this._setScale(this._currentScaleValue, true); } var pageView = this._pages[this._currentPageNumber - 1]; this._scrollIntoView({ pageDiv: pageView.div }); } }, { key: "scrollPageIntoView", value: function scrollPageIntoView(_ref3) { var pageNumber = _ref3.pageNumber, _ref3$destArray = _ref3.destArray, destArray = _ref3$destArray === void 0 ? null : _ref3$destArray, _ref3$allowNegativeOf = _ref3.allowNegativeOffset, allowNegativeOffset = _ref3$allowNegativeOf === void 0 ? false : _ref3$allowNegativeOf, _ref3$ignoreDestinati = _ref3.ignoreDestinationZoom, ignoreDestinationZoom = _ref3$ignoreDestinati === void 0 ? false : _ref3$ignoreDestinati; if (!this.pdfDocument) { return; } var pageView = Number.isInteger(pageNumber) && this._pages[pageNumber - 1]; if (!pageView) { console.error("".concat(this._name, ".scrollPageIntoView: ") + "\"".concat(pageNumber, "\" is not a valid pageNumber parameter.")); return; } if (this.isInPresentationMode || !destArray) { this._setCurrentPageNumber(pageNumber, true); return; } var x = 0, y = 0; var width = 0, height = 0, widthScale, heightScale; var changeOrientation = pageView.rotation % 180 !== 0; var pageWidth = (changeOrientation ? pageView.height : pageView.width) / pageView.scale / _ui_utils.CSS_UNITS; var pageHeight = (changeOrientation ? pageView.width : pageView.height) / pageView.scale / _ui_utils.CSS_UNITS; var scale = 0; switch (destArray[1].name) { case "XYZ": x = destArray[2]; y = destArray[3]; scale = destArray[4]; x = x !== null ? x : 0; y = y !== null ? y : pageHeight; break; case "Fit": case "FitB": scale = "page-fit"; break; case "FitH": case "FitBH": y = destArray[2]; scale = "page-width"; if (y === null && this._location) { x = this._location.left; y = this._location.top; } break; case "FitV": case "FitBV": x = destArray[2]; width = pageWidth; height = pageHeight; scale = "page-height"; break; case "FitR": x = destArray[2]; y = destArray[3]; width = destArray[4] - x; height = destArray[5] - y; var hPadding = this.removePageBorders ? 0 : _ui_utils.SCROLLBAR_PADDING; var vPadding = this.removePageBorders ? 0 : _ui_utils.VERTICAL_PADDING; widthScale = (this.container.clientWidth - hPadding) / width / _ui_utils.CSS_UNITS; heightScale = (this.container.clientHeight - vPadding) / height / _ui_utils.CSS_UNITS; scale = Math.min(Math.abs(widthScale), Math.abs(heightScale)); break; default: console.error("".concat(this._name, ".scrollPageIntoView: ") + "\"".concat(destArray[1].name, "\" is not a valid destination type.")); return; } if (!ignoreDestinationZoom) { if (scale && scale !== this._currentScale) { this.currentScaleValue = scale; } else if (this._currentScale === _ui_utils.UNKNOWN_SCALE) { this.currentScaleValue = _ui_utils.DEFAULT_SCALE_VALUE; } } if (scale === "page-fit" && !destArray[4]) { this._scrollIntoView({ pageDiv: pageView.div, pageNumber: pageNumber }); return; } var boundingRect = [pageView.viewport.convertToViewportPoint(x, y), pageView.viewport.convertToViewportPoint(x + width, y + height)]; var left = Math.min(boundingRect[0][0], boundingRect[1][0]); var top = Math.min(boundingRect[0][1], boundingRect[1][1]); if (!allowNegativeOffset) { left = Math.max(left, 0); top = Math.max(top, 0); } this._scrollIntoView({ pageDiv: pageView.div, pageSpot: { left: left, top: top }, pageNumber: pageNumber }); } }, { key: "_updateLocation", value: function _updateLocation(firstPage) { var currentScale = this._currentScale; var currentScaleValue = this._currentScaleValue; var normalizedScaleValue = parseFloat(currentScaleValue) === currentScale ? Math.round(currentScale * 10000) / 100 : currentScaleValue; var pageNumber = firstPage.id; var pdfOpenParams = "#page=" + pageNumber; pdfOpenParams += "&zoom=" + normalizedScaleValue; var currentPageView = this._pages[pageNumber - 1]; var container = this.container; var topLeft = currentPageView.getPagePoint(container.scrollLeft - firstPage.x, container.scrollTop - firstPage.y); var intLeft = Math.round(topLeft[0]); var intTop = Math.round(topLeft[1]); pdfOpenParams += "," + intLeft + "," + intTop; this._location = { pageNumber: pageNumber, scale: normalizedScaleValue, top: intTop, left: intLeft, rotation: this._pagesRotation, pdfOpenParams: pdfOpenParams }; } }, { key: "_updateHelper", value: function _updateHelper(visiblePages) { throw new Error("Not implemented: _updateHelper"); } }, { key: "update", value: function update() { var visible = this._getVisiblePages(); var visiblePages = visible.views, numVisiblePages = visiblePages.length; if (numVisiblePages === 0) { return; } var newCacheSize = Math.max(DEFAULT_CACHE_SIZE, 2 * numVisiblePages + 1); this._buffer.resize(newCacheSize, visiblePages); this.renderingQueue.renderHighestPriority(visible); this._updateHelper(visiblePages); this._updateLocation(visible.first); this.eventBus.dispatch("updateviewarea", { source: this, location: this._location }); } }, { key: "containsElement", value: function containsElement(element) { return this.container.contains(element); } }, { key: "focus", value: function focus() { this.container.focus(); } }, { key: "_getCurrentVisiblePage", value: function _getCurrentVisiblePage() { if (!this.pagesCount) { return { views: [] }; } var pageView = this._pages[this._currentPageNumber - 1]; var element = pageView.div; var view = { id: pageView.id, x: element.offsetLeft + element.clientLeft, y: element.offsetTop + element.clientTop, view: pageView }; return { first: view, last: view, views: [view] }; } }, { key: "_getVisiblePages", value: function _getVisiblePages() { return (0, _ui_utils.getVisibleElements)(this.container, this._pages, true, this._isScrollModeHorizontal); } }, { key: "isPageVisible", value: function isPageVisible(pageNumber) { if (!this.pdfDocument) { return false; } if (pageNumber < 1 || pageNumber > this.pagesCount) { console.error("".concat(this._name, ".isPageVisible: \"").concat(pageNumber, "\" is out of bounds.")); return false; } return this._getVisiblePages().views.some(function (view) { return view.id === pageNumber; }); } }, { key: "cleanup", value: function cleanup() { for (var i = 0, ii = this._pages.length; i < ii; i++) { if (this._pages[i] && this._pages[i].renderingState !== _pdf_rendering_queue.RenderingStates.FINISHED) { this._pages[i].reset(); } } } }, { key: "_cancelRendering", value: function _cancelRendering() { for (var i = 0, ii = this._pages.length; i < ii; i++) { if (this._pages[i]) { this._pages[i].cancelRendering(); } } } }, { key: "_ensurePdfPageLoaded", value: function _ensurePdfPageLoaded(pageView) { var _this3 = this; if (pageView.pdfPage) { return Promise.resolve(pageView.pdfPage); } if (this._pagesRequests.has(pageView)) { return this._pagesRequests.get(pageView); } var promise = this.pdfDocument.getPage(pageView.id).then(function (pdfPage) { if (!pageView.pdfPage) { pageView.setPdfPage(pdfPage); } _this3._pagesRequests["delete"](pageView); return pdfPage; })["catch"](function (reason) { console.error("Unable to get page for page view", reason); _this3._pagesRequests["delete"](pageView); }); this._pagesRequests.set(pageView, promise); return promise; } }, { key: "forceRendering", value: function forceRendering(currentlyVisiblePages) { var _this4 = this; var visiblePages = currentlyVisiblePages || this._getVisiblePages(); var scrollAhead = this._isScrollModeHorizontal ? this.scroll.right : this.scroll.down; var pageView = this.renderingQueue.getHighestPriority(visiblePages, this._pages, scrollAhead); if (pageView) { this._ensurePdfPageLoaded(pageView).then(function () { _this4.renderingQueue.renderView(pageView); }); return true; } return false; } }, { key: "createTextLayerBuilder", value: function createTextLayerBuilder(textLayerDiv, pageIndex, viewport) { var enhanceTextSelection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; var eventBus = arguments.length > 4 ? arguments[4] : undefined; return new _text_layer_builder.TextLayerBuilder({ textLayerDiv: textLayerDiv, eventBus: eventBus, pageIndex: pageIndex, viewport: viewport, findController: this.isInPresentationMode ? null : this.findController, enhanceTextSelection: this.isInPresentationMode ? false : enhanceTextSelection }); } }, { key: "createAnnotationLayerBuilder", value: function createAnnotationLayerBuilder(pageDiv, pdfPage) { var imageResourcesPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ""; var renderInteractiveForms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false; var l10n = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _ui_utils.NullL10n; return new _annotation_layer_builder.AnnotationLayerBuilder({ pageDiv: pageDiv, pdfPage: pdfPage, imageResourcesPath: imageResourcesPath, renderInteractiveForms: renderInteractiveForms, linkService: this.linkService, downloadManager: this.downloadManager, l10n: l10n }); } }, { key: "getPagesOverview", value: function getPagesOverview() { var pagesOverview = this._pages.map(function (pageView) { var viewport = pageView.pdfPage.getViewport({ scale: 1 }); return { width: viewport.width, height: viewport.height, rotation: viewport.rotation }; }); if (!this.enablePrintAutoRotate) { return pagesOverview; } var isFirstPagePortrait = (0, _ui_utils.isPortraitOrientation)(pagesOverview[0]); return pagesOverview.map(function (size) { if (isFirstPagePortrait === (0, _ui_utils.isPortraitOrientation)(size)) { return size; } return { width: size.height, height: size.width, rotation: (size.rotation + 90) % 360 }; }); } }, { key: "_updateScrollMode", value: function _updateScrollMode() { var pageNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null; var scrollMode = this._scrollMode, viewer = this.viewer; viewer.classList.toggle("scrollHorizontal", scrollMode === _ui_utils.ScrollMode.HORIZONTAL); viewer.classList.toggle("scrollWrapped", scrollMode === _ui_utils.ScrollMode.WRAPPED); if (!this.pdfDocument || !pageNumber) { return; } if (this._currentScaleValue && isNaN(this._currentScaleValue)) { this._setScale(this._currentScaleValue, true); } this._setCurrentPageNumber(pageNumber, true); this.update(); } }, { key: "_updateSpreadMode", value: function _updateSpreadMode() { var pageNumber = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null; if (!this.pdfDocument) { return; } var viewer = this.viewer, pages = this._pages; viewer.textContent = ""; if (this._spreadMode === _ui_utils.SpreadMode.NONE) { for (var i = 0, iMax = pages.length; i < iMax; ++i) { viewer.appendChild(pages[i].div); } } else { var parity = this._spreadMode - 1; var spread = null; for (var _i = 0, _iMax = pages.length; _i < _iMax; ++_i) { if (spread === null) { spread = document.createElement("div"); spread.className = "spread"; viewer.appendChild(spread); } else if (_i % 2 === parity) { spread = spread.cloneNode(false); viewer.appendChild(spread); } spread.appendChild(pages[_i].div); } } if (!pageNumber) { return; } this._setCurrentPageNumber(pageNumber, true); this.update(); } }, { key: "pagesCount", get: function get() { return this._pages.length; } }, { key: "pageViewsReady", get: function get() { if (!this._pagesCapability.settled) { return false; } return this._pages.every(function (pageView) { return pageView && pageView.pdfPage; }); } }, { key: "currentPageNumber", get: function get() { return this._currentPageNumber; }, set: function set(val) { if (!Number.isInteger(val)) { throw new Error("Invalid page number."); } if (!this.pdfDocument) { return; } if (!this._setCurrentPageNumber(val, true)) { console.error("".concat(this._name, ".currentPageNumber: \"").concat(val, "\" is not a valid page.")); } } }, { key: "currentPageLabel", get: function get() { return this._pageLabels && this._pageLabels[this._currentPageNumber - 1]; }, set: function set(val) { if (!this.pdfDocument) { return; } var page = val | 0; if (this._pageLabels) { var i = this._pageLabels.indexOf(val); if (i >= 0) { page = i + 1; } } if (!this._setCurrentPageNumber(page, true)) { console.error("".concat(this._name, ".currentPageLabel: \"").concat(val, "\" is not a valid page.")); } } }, { key: "currentScale", get: function get() { return this._currentScale !== _ui_utils.UNKNOWN_SCALE ? this._currentScale : _ui_utils.DEFAULT_SCALE; }, set: function set(val) { if (isNaN(val)) { throw new Error("Invalid numeric scale."); } if (!this.pdfDocument) { return; } this._setScale(val, false); } }, { key: "currentScaleValue", get: function get() { return this._currentScaleValue; }, set: function set(val) { if (!this.pdfDocument) { return; } this._setScale(val, false); } }, { key: "pagesRotation", get: function get() { return this._pagesRotation; }, set: function set(rotation) { if (!(0, _ui_utils.isValidRotation)(rotation)) { throw new Error("Invalid pages rotation angle."); } if (!this.pdfDocument) { return; } if (this._pagesRotation === rotation) { return; } this._pagesRotation = rotation; var pageNumber = this._currentPageNumber; for (var i = 0, ii = this._pages.length; i < ii; i++) { var pageView = this._pages[i]; pageView.update(pageView.scale, rotation); } if (this._currentScaleValue) { this._setScale(this._currentScaleValue, true); } this.eventBus.dispatch("rotationchanging", { source: this, pagesRotation: rotation, pageNumber: pageNumber }); if (this.defaultRenderingQueue) { this.update(); } } }, { key: "firstPagePromise", get: function get() { return this.pdfDocument ? this._firstPageCapability.promise : null; } }, { key: "onePageRendered", get: function get() { return this.pdfDocument ? this._onePageRenderedCapability.promise : null; } }, { key: "pagesPromise", get: function get() { return this.pdfDocument ? this._pagesCapability.promise : null; } }, { key: "_viewerElement", get: function get() { throw new Error("Not implemented: _viewerElement"); } }, { key: "_isScrollModeHorizontal", get: function get() { return this.isInPresentationMode ? false : this._scrollMode === _ui_utils.ScrollMode.HORIZONTAL; } }, { key: "isInPresentationMode", get: function get() { return this.presentationModeState === _ui_utils.PresentationModeState.FULLSCREEN; } }, { key: "isChangingPresentationMode", get: function get() { return this.presentationModeState === _ui_utils.PresentationModeState.CHANGING; } }, { key: "isHorizontalScrollbarEnabled", get: function get() { return this.isInPresentationMode ? false : this.container.scrollWidth > this.container.clientWidth; } }, { key: "isVerticalScrollbarEnabled", get: function get() { return this.isInPresentationMode ? false : this.container.scrollHeight > this.container.clientHeight; } }, { key: "hasEqualPageSizes", get: function get() { var firstPageView = this._pages[0]; for (var i = 1, ii = this._pages.length; i < ii; ++i) { var pageView = this._pages[i]; if (pageView.width !== firstPageView.width || pageView.height !== firstPageView.height) { return false; } } return true; } }, { key: "scrollMode", get: function get() { return this._scrollMode; }, set: function set(mode) { if (this._scrollMode === mode) { return; } if (!(0, _ui_utils.isValidScrollMode)(mode)) { throw new Error("Invalid scroll mode: ".concat(mode)); } this._scrollMode = mode; this.eventBus.dispatch("scrollmodechanged", { source: this, mode: mode }); this._updateScrollMode(this._currentPageNumber); } }, { key: "spreadMode", get: function get() { return this._spreadMode; }, set: function set(mode) { if (this._spreadMode === mode) { return; } if (!(0, _ui_utils.isValidSpreadMode)(mode)) { throw new Error("Invalid spread mode: ".concat(mode)); } this._spreadMode = mode; this.eventBus.dispatch("spreadmodechanged", { source: this, mode: mode }); this._updateSpreadMode(this._currentPageNumber); } }]); return BaseViewer; }(); exports.BaseViewer = BaseViewer;
/***/ }),
/* 20 */
/***/ (function(module, exports, __w_pdfjs_require__) {
"use strict"; Object.defineProperty(exports, "__esModule", { value: true }); exports.PDFViewer = void 0; var _base_viewer = __w_pdfjs_require__(19); var _pdfjsLib = __w_pdfjs_require__(2);
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; } function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); } function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
var PDFViewer = /*#__PURE__*/function (_BaseViewer) {
_inherits(PDFViewer, _BaseViewer); var _super = _createSuper(PDFViewer); function PDFViewer() { _classCallCheck(this, PDFViewer); return _super.apply(this, arguments); } _createClass(PDFViewer, [{ key: "_scrollIntoView", value: function _scrollIntoView(_ref) { var pageDiv = _ref.pageDiv, _ref$pageSpot = _ref.pageSpot, pageSpot = _ref$pageSpot === void 0 ? null : _ref$pageSpot, _ref$pageNumber = _ref.pageNumber, pageNumber = _ref$pageNumber === void 0 ? null : _ref$pageNumber; if (!pageSpot && !this.isInPresentationMode) { var left = pageDiv.offsetLeft + pageDiv.clientLeft; var right = left + pageDiv.clientWidth; var _this$container = this.container, scrollLeft = _this$container.scrollLeft, clientWidth = _this$container.clientWidth; if (this._isScrollModeHorizontal || left < scrollLeft || right > scrollLeft + clientWidth) { pageSpot = { left: 0, top: 0 }; } } _get(_getPrototypeOf(PDFViewer.prototype), "_scrollIntoView", this).call(this, { pageDiv: pageDiv, pageSpot: pageSpot, pageNumber: pageNumber }); } }, { key: "_getVisiblePages", value: function _getVisiblePages() { if (this.isInPresentationMode) { return this._getCurrentVisiblePage(); } return _get(_getPrototypeOf(PDFViewer.prototype), "_getVisiblePages", this).call(this); } }, { key: "_updateHelper", value: function _updateHelper(visiblePages) { if (this.isInPresentationMode) { return; } var currentId = this._currentPageNumber; var stillFullyVisible = false; var _iterator = _createForOfIteratorHelper(visiblePages), _step; try { for (_iterator.s(); !(_step = _iterator.n()).done;) { var page = _step.value; if (page.percent < 100) { break; } if (page.id === currentId) { stillFullyVisible = true; break; } } } catch (err) { _iterator.e(err); } finally { _iterator.f(); } if (!stillFullyVisible) { currentId = visiblePages[0].id; } this._setCurrentPageNumber(currentId); } }, { key: "_viewerElement", get: function get() { return (0, _pdfjsLib.shadow)(this, "_viewerElement", this.viewer); } }]); return PDFViewer; }(_base_viewer.BaseViewer); exports.PDFViewer = PDFViewer;
/***/ })
/******/ ]);
});
//# sourceMappingURL=pdf_viewer.js.map
"use strict"; var pdfViewer=null; var pdfColor=null; $(function() { if(!$("#viewerContainer").length) return; var width=$(window).width(); $(window).on("resize",function() { if(width==$(window).width()) return; width=$(window).width(); pdfViewer.currentScaleValue="page-width"; }); $("body").on("pdfjs",function() { var color=$("#viewerContainer").attr("data-color"); pdfColor=[parseInt(color.substr(0,2),16),parseInt(color.substr(2,2),16),parseInt(color.substr(4,2),16)]; if(pdfViewer==null) { pdfjsLib.GlobalWorkerOptions.workerSrc="pdfjs/pdf.worker.min.js"; var file=$("#viewerContainer").attr("data-file"); pdfjsLib.getDocument(file).promise.then(function(pdfDocument) { var container=document.getElementById("viewerContainer"); var eventBus=new pdfjsViewer.EventBus(); pdfViewer=new pdfjsViewer.PDFViewer({ container:container, eventBus:eventBus, }); var fn1=function() { pdfViewer.currentScaleValue="page-width"; }; var fn2=function() { $("a",container).each(function() { $(this).attr("target","_blank"); }); }; eventBus.on("pagesinit",fn1); eventBus.on("textlayerrendered",fn2); pdfViewer.removePageBorders=true; pdfViewer.setDocument(pdfDocument); },function(message,exception) { console.log(message); console.log(exception); }); } else {
pdfViewer.currentScaleValue=pdfViewer.currentScale*2; // TRUC PER FORZAR EL REDIBUIXAT DEL PDF
pdfViewer.currentScaleValue="page-width"; } }).trigger("pdfjs"); });